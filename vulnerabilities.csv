Package Name,Severity,Installed Version,Fixed Version,Description,CVE ID,Source
apt,LOW,2.2.4,,It was found that apt-key in apt all versions do not correctly validate gpg keys with the master keyring leading to a potential man-in-the-middle attack.,CVE-2011-3374,tykio/gromit & tykio/tyk-plugin-compiler
apt-transport-https,LOW,2.2.4,,It was found that apt-key in apt all versions do not correctly validate gpg keys with the master keyring leading to a potential man-in-the-middle attack.,CVE-2011-3374,tykio/tyk-plugin-compiler
bash,HIGH,5.1-2+deb11u1,,A flaw was found in the bash package where a heap-buffer overflow can occur in valid parameter_transform. This issue may lead to memory problems.,CVE-2022-3715,tykio/tyk-plugin-compiler
bash,LOW,5.1-2+deb11u1,,null,TEMP-0841856-B18BAF,tykio/gromit & tykio/tyk-plugin-compiler
binutils,LOW,2.35.2-2,,The C++ symbol demangler routine in cplus-dem.c in libiberty as distributed in GNU Binutils 2.29 allows remote attackers to cause a denial of service (excessive memory allocation and application crash) via a crafted file as demonstrated by a call from the Binary File Descriptor (BFD) library (aka libbfd).,CVE-2017-13716,tykio/tyk-plugin-compiler
binutils,LOW,2.35.2-2,,The demangle_template function in cplus-dem.c in GNU libiberty as distributed in GNU Binutils 2.31.1 contains an integer overflow vulnerability (for Create an array for saving the template argument values) that can trigger a heap-based buffer overflow as demonstrated by nm.,CVE-2018-20673,tykio/tyk-plugin-compiler
binutils,LOW,2.35.2-2,,A heap-based buffer over-read exists in the function d_expression_1 in cp-demangle.c in GNU libiberty as distributed in GNU Binutils 2.31.1. A crafted input can cause segmentation faults leading to denial-of-service as demonstrated by c++filt.,CVE-2018-20712,tykio/tyk-plugin-compiler
binutils,LOW,2.35.2-2,,An issue was discovered in cplus-dem.c in GNU libiberty as distributed in GNU Binutils 2.30. Stack Exhaustion occurs in the C++ demangling functions provided by libiberty and there are recursive stack frames: demangle_template_value_parm demangle_integral_value and demangle_expression.,CVE-2018-9996,tykio/tyk-plugin-compiler
binutils,LOW,2.35.2-2,,GNU binutils gold gold v1.11-v1.16 (GNU binutils v2.21-v2.31.1) is affected by: Improper Input Validation Signed/Unsigned Comparison Out-of-bounds Read. The impact is: Denial of service. The component is: gold/fileread.cc:497 elfcpp/elfcpp_file.h:644. The attack vector is: An ELF file with an invalid e_shoff header field must be opened.,CVE-2019-1010204,tykio/tyk-plugin-compiler
binutils,LOW,2.35.2-2,,An issue was discovered in binutils libbfd.c 2.36 relating to the auxiliary symbol data allows attackers to read or write to system memory or cause a denial of service.,CVE-2020-19726,tykio/tyk-plugin-compiler
binutils,LOW,2.35.2-2,,An issue was discovered in the Binary File Descriptor (BFD) library (aka libbfd) as distributed in GNU Binutils 2.35.1. A heap-based buffer over-read can occur in bfd_getl_signed_32 in libbfd.c because sh_entsize is not validated in _bfd_elf_slurp_secondary_reloc_section in elf.c.,CVE-2020-35448,tykio/tyk-plugin-compiler
binutils,LOW,2.35.2-2,,There is an open race window when writing output in the following utilities in GNU binutils version 2.35 and earlier:ar objcopy strip ranlib. When these utilities are run as a privileged user (presumably as part of a script updating binaries across different users) an unprivileged user can trick these utilities into getting ownership of arbitrary files through a symlink.,CVE-2021-20197,tykio/tyk-plugin-compiler
binutils,LOW,2.35.2-2,,A flaw was found in GNU Binutils 2.35.1 where there is a heap-based buffer overflow in _bfd_elf_slurp_secondary_reloc_section in elf.c due to the number of symbols not calculated correctly. The highest threat from this vulnerability is to system availability.,CVE-2021-20284,tykio/tyk-plugin-compiler
binutils,LOW,2.35.2-2,,An issue was discovered in GNU libiberty as distributed in GNU Binutils 2.36. It is a stack-overflow issue in demangle_type in rust-demangle.c.,CVE-2021-32256,tykio/tyk-plugin-compiler
binutils,LOW,2.35.2-2,,A flaw was discovered in GNU libiberty within demangle_path() in rust-demangle.c as distributed in GNU Binutils version 2.36. A crafted symbol can cause stack memory to be exhausted leading to a crash.,CVE-2021-3530,tykio/tyk-plugin-compiler
binutils,LOW,2.35.2-2,,An out of bounds flaw was found in GNU binutils objdump utility version 2.36. An attacker could use this flaw and pass a large section to avr_elf32_load_records_from_section() probably resulting in a crash or in some cases memory corruption. The highest threat from this vulnerability is to integrity as well as system availability.,CVE-2021-3549,tykio/tyk-plugin-compiler
binutils,LOW,2.35.2-2,,Heap/stack buffer overflow in the dlang_lname function in d-demangle.c in libiberty allows attackers to potentially cause a denial of service (segmentation fault and crash) via a crafted mangled symbol.,CVE-2021-3826,tykio/tyk-plugin-compiler
binutils,LOW,2.35.2-2,,stab_xcoff_builtin_type in stabs.c in GNU Binutils through 2.37 allows attackers to cause a denial of service (heap-based buffer overflow) or possibly have unspecified other impact as demonstrated by an out-of-bounds write. NOTE: this issue exists because of an incorrect fix for CVE-2018-12699.,CVE-2021-45078,tykio/tyk-plugin-compiler
binutils,LOW,2.35.2-2,,Heap-based Buffer Overflow in function bfd_getl32 in Binutils objdump 3.37.,CVE-2021-46174,tykio/tyk-plugin-compiler
binutils,LOW,2.35.2-2,,GCC v12.0 was discovered to contain an uncontrolled recursion via the component libiberty/rust-demangle.c. This vulnerability allows attackers to cause a Denial of Service (DoS) by consuming excessive CPU and memory resources.,CVE-2021-46195,tykio/tyk-plugin-compiler
binutils,LOW,2.35.2-2,,An issue was discovered in Binutils readelf 2.38.50 reachable assertion failure in function display_debug_names allows attackers to cause a denial of service.,CVE-2022-35205,tykio/tyk-plugin-compiler
binutils,LOW,2.35.2-2,,Null pointer dereference vulnerability in Binutils readelf 2.38.50 via function read_and_display_attr_value in file dwarf.c.,CVE-2022-35206,tykio/tyk-plugin-compiler
binutils,LOW,2.35.2-2,,In GNU Binutils before 2.40 there is a heap-buffer-overflow in the error function bfd_getl32 when called from the strip_main function in strip-new via a crafted file.,CVE-2022-38533,tykio/tyk-plugin-compiler
binutils,LOW,2.35.2-2,,An illegal memory access flaw was found in the binutils package. Parsing an ELF file containing corrupt symbol version information may result in a denial of service. This issue is the result of an incomplete fix for CVE-2020-16599.,CVE-2022-4285,tykio/tyk-plugin-compiler
binutils,LOW,2.35.2-2,,Heap buffer overflow vulnerability in binutils readelf before 2.40 via function find_section_in_set in file readelf.c.,CVE-2022-44840,tykio/tyk-plugin-compiler
binutils,LOW,2.35.2-2,,Heap buffer overflow vulnerability in binutils readelf before 2.40 via function display_debug_section in file readelf.c.,CVE-2022-45703,tykio/tyk-plugin-compiler
binutils,LOW,2.35.2-2,,An issue was discovered function stab_demangle_v3_arg in stabs.c in Binutils 2.34 thru 2.38 allows attackers to cause a denial of service due to memory leaks.,CVE-2022-47007,tykio/tyk-plugin-compiler
binutils,LOW,2.35.2-2,,An issue was discovered function make_tempdir and make_tempname in bucomm.c in Binutils 2.34 thru 2.38 allows attackers to cause a denial of service due to memory leaks.,CVE-2022-47008,tykio/tyk-plugin-compiler
binutils,LOW,2.35.2-2,,An issue was discovered function pr_function_type in prdbg.c in Binutils 2.34 thru 2.38 allows attackers to cause a denial of service due to memory leaks.,CVE-2022-47010,tykio/tyk-plugin-compiler
binutils,LOW,2.35.2-2,,An issue was discovered function parse_stab_struct_fields in stabs.c in Binutils 2.34 thru 2.38 allows attackers to cause a denial of service due to memory leaks.,CVE-2022-47011,tykio/tyk-plugin-compiler
binutils,LOW,2.35.2-2,,An issue was discovered in Binutils addr2line before 2.39.3 function parse_module contains multiple out of bound reads which may cause a denial of service or other unspecified impacts.,CVE-2022-47673,tykio/tyk-plugin-compiler
binutils,LOW,2.35.2-2,,An issue was discovered Binutils objdump before 2.39.3 allows attackers to cause a denial of service or other unspecified impacts via function bfd_mach_o_get_synthetic_symtab in match-o.c.,CVE-2022-47695,tykio/tyk-plugin-compiler
binutils,LOW,2.35.2-2,,An issue was discovered Binutils objdump before 2.39.3 allows attackers to cause a denial of service or other unspecified impacts via function compare_symbols.,CVE-2022-47696,tykio/tyk-plugin-compiler
binutils,LOW,2.35.2-2,,GNU Binutils before 2.40 was discovered to contain an excessive memory consumption vulnerability via the function load_separate_debug_files at dwarf2.c. The attacker could supply a crafted ELF file and cause a DNS attack.,CVE-2022-48063,tykio/tyk-plugin-compiler
binutils,LOW,2.35.2-2,,GNU Binutils before 2.40 was discovered to contain an excessive memory consumption vulnerability via the function bfd_dwarf2_find_nearest_line_with_alt at dwarf2.c. The attacker could supply a crafted ELF file and cause a DNS attack.,CVE-2022-48064,tykio/tyk-plugin-compiler
binutils,LOW,2.35.2-2,,GNU Binutils before 2.40 was discovered to contain a memory leak vulnerability var the function find_abstract_instance in dwarf2.c.,CVE-2022-48065,tykio/tyk-plugin-compiler
binutils,LOW,2.35.2-2,,Heap based buffer overflow in binutils-gdb/bfd/libbfd.c in bfd_getl64.,CVE-2023-1579,tykio/tyk-plugin-compiler
binutils,LOW,2.35.2-2,,A potential heap based buffer overflow was found in _bfd_elf_slurp_version_tables() in bfd/elf.c. This may lead to loss of availability.,CVE-2023-1972,tykio/tyk-plugin-compiler
binutils,LOW,2.35.2-2,,An out-of-bounds read flaw was found in the parse_module function in bfd/vms-alpha.c in Binutils.,CVE-2023-25584,tykio/tyk-plugin-compiler
binutils,LOW,2.35.2-2,,A flaw was found in Binutils. The use of an uninitialized field in the struct module *module may lead to application crash and local denial of service.,CVE-2023-25585,tykio/tyk-plugin-compiler
binutils,LOW,2.35.2-2,,A flaw was found in Binutils. A logic fail in the bfd_init_section_decompress_status function may lead to the use of an uninitialized variable that can cause a crash and local denial of service.,CVE-2023-25586,tykio/tyk-plugin-compiler
binutils,LOW,2.35.2-2,,A flaw was found in Binutils. The field `the_bfd` of `asymbol`struct is uninitialized in the `bfd_mach_o_get_synthetic_symtab` function which may lead to an application crash and local denial of service.,CVE-2023-25588,tykio/tyk-plugin-compiler
binutils,LOW,2.35.2-2,,GNU objdump 2.43 is vulnerable to Buffer Overflow in the BFD (Binary File Descriptor) library's handling of tekhex format files.,CVE-2024-53589,tykio/tyk-plugin-compiler
binutils,LOW,2.35.2-2,,https://www.gnu.org/software/binutils/ nm >=2.43 is affected by: Incorrect Access Control. The type of exploitation is: local. The component is: `nm --without-symbol-version` function.,CVE-2024-57360,tykio/tyk-plugin-compiler
binutils,LOW,2.35.2-2,,A vulnerability which was classified as problematic was found in GNU Binutils up to 2.43. This affects the function disassemble_bytes of the file binutils/objdump.c. The manipulation of the argument buf leads to stack-based buffer overflow. It is possible to initiate the attack remotely. The complexity of an attack is rather high. The exploitability is told to be difficult. The exploit has been disclosed to the public and may be used. Upgrading to version 2.44 is able to address this issue. The identifier of the patch is baac6c221e9d69335bf41366a1c7d87d8ab2f893. It is recommended to upgrade the affected component.,CVE-2025-0840,tykio/tyk-plugin-compiler
binutils,LOW,2.35.2-2,,A vulnerability has been found in GNU Binutils 2.43 and classified as problematic. Affected by this vulnerability is the function __sanitizer::internal_strlen of the file binutils/nm.c of the component nm. The manipulation of the argument const leads to buffer overflow. The attack can be launched remotely. The complexity of an attack is rather high. The exploitation appears to be difficult. The exploit has been disclosed to the public and may be used.,CVE-2025-1147,tykio/tyk-plugin-compiler
binutils,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43 and classified as problematic. Affected by this issue is the function link_order_scan of the file ld/ldelfgen.c of the component ld. The manipulation leads to memory leak. The attack may be launched remotely. The complexity of an attack is rather high. The exploitation is known to be difficult. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue. The code maintainer explains: I'm not going to commit some of the leak fixes I've been working on to the 2.44 branch due to concern that would destabilise ld. All of the reported leaks in this bugzilla have been fixed on binutils master.,CVE-2025-1148,tykio/tyk-plugin-compiler
binutils,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43. It has been classified as problematic. This affects the function xstrdup of the file libiberty/xmalloc.c of the component ld. The manipulation leads to memory leak. It is possible to initiate the attack remotely. The complexity of an attack is rather high. The exploitability is told to be difficult. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue. The code maintainer explains: I'm not going to commit some of the leak fixes I've been working on to the 2.44 branch due to concern that would destabilise ld. All of the reported leaks in this bugzilla have been fixed on binutils master.,CVE-2025-1149,tykio/tyk-plugin-compiler
binutils,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43. It has been declared as problematic. This vulnerability affects the function bfd_malloc of the file libbfd.c of the component ld. The manipulation leads to memory leak. The attack can be initiated remotely. The complexity of an attack is rather high. The exploitation appears to be difficult. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue. The code maintainer explains: I'm not going to commit some of the leak fixes I've been working on to the 2.44 branch due to concern that would destabilise ld. All of the reported leaks in this bugzilla have been fixed on binutils master.,CVE-2025-1150,tykio/tyk-plugin-compiler
binutils,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43. It has been rated as problematic. This issue affects the function xmemdup of the file xmemdup.c of the component ld. The manipulation leads to memory leak. The attack may be initiated remotely. The complexity of an attack is rather high. The exploitation is known to be difficult. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue. The code maintainer explains: I'm not going to commit some of the leak fixes I've been working on to the 2.44 branch due to concern that would destabilise ld. All of the reported leaks in this bugzilla have been fixed on binutils master.,CVE-2025-1151,tykio/tyk-plugin-compiler
binutils,LOW,2.35.2-2,,A vulnerability classified as problematic has been found in GNU Binutils 2.43. Affected is the function xstrdup of the file xstrdup.c of the component ld. The manipulation leads to memory leak. It is possible to launch the attack remotely. The complexity of an attack is rather high. The exploitability is told to be difficult. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue. The code maintainer explains: I'm not going to commit some of the leak fixes I've been working on to the 2.44 branch due to concern that would destabilise ld. All of the reported leaks in this bugzilla have been fixed on binutils master.,CVE-2025-1152,tykio/tyk-plugin-compiler
binutils,LOW,2.35.2-2,,A vulnerability classified as problematic was found in GNU Binutils 2.43/2.44. Affected by this vulnerability is the function bfd_set_format of the file format.c. The manipulation leads to memory corruption. The attack can be launched remotely. The complexity of an attack is rather high. The exploitation appears to be difficult. Upgrading to version 2.45 is able to address this issue. The identifier of the patch is 8d97c1a53f3dc9fd8e1ccdb039b8a33d50133150. It is recommended to upgrade the affected component.,CVE-2025-1153,tykio/tyk-plugin-compiler
binutils,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43 and classified as critical. This issue affects the function _bfd_elf_gc_mark_rsec of the file elflink.c of the component ld. The manipulation leads to heap-based buffer overflow. The attack may be initiated remotely. The complexity of an attack is rather high. The exploitation is known to be difficult. The exploit has been disclosed to the public and may be used. The patch is named f9978defb6fab0bd8583942d97c112b0932ac814. It is recommended to apply a patch to fix this issue.,CVE-2025-1176,tykio/tyk-plugin-compiler
binutils,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43. It has been declared as problematic. Affected by this vulnerability is the function bfd_putl64 of the file libbfd.c of the component ld. The manipulation leads to memory corruption. The attack can be launched remotely. The complexity of an attack is rather high. The exploitation appears to be difficult. The exploit has been disclosed to the public and may be used. The identifier of the patch is 75086e9de1707281172cc77f178e7949a4414ed0. It is recommended to apply a patch to fix this issue.,CVE-2025-1178,tykio/tyk-plugin-compiler
binutils,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43. It has been rated as critical. Affected by this issue is the function bfd_putl64 of the file bfd/libbfd.c of the component ld. The manipulation leads to memory corruption. The attack may be launched remotely. The complexity of an attack is rather high. The exploitation is known to be difficult. The exploit has been disclosed to the public and may be used. Upgrading to version 2.44 is able to address this issue. It is recommended to upgrade the affected component. The code maintainer explains that [t]his bug has been fixed at some point between the 2.43 and 2.44 releases.,CVE-2025-1179,tykio/tyk-plugin-compiler
binutils,LOW,2.35.2-2,,A vulnerability classified as problematic has been found in GNU Binutils 2.43. This affects the function _bfd_elf_write_section_eh_frame of the file bfd/elf-eh-frame.c of the component ld. The manipulation leads to memory corruption. It is possible to initiate the attack remotely. The complexity of an attack is rather high. The exploitability is told to be difficult. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue.,CVE-2025-1180,tykio/tyk-plugin-compiler
binutils,LOW,2.35.2-2,,A vulnerability classified as critical was found in GNU Binutils 2.43. This vulnerability affects the function _bfd_elf_gc_mark_rsec of the file bfd/elflink.c of the component ld. The manipulation leads to memory corruption. The attack can be initiated remotely. The complexity of an attack is rather high. The exploitation appears to be difficult. The exploit has been disclosed to the public and may be used. The name of the patch is 931494c9a89558acb36a03a340c01726545eef24. It is recommended to apply a patch to fix this issue.,CVE-2025-1181,tykio/tyk-plugin-compiler
binutils,LOW,2.35.2-2,,A vulnerability which was classified as critical was found in GNU Binutils 2.43. Affected is the function bfd_elf_reloc_symbol_deleted_p of the file bfd/elflink.c of the component ld. The manipulation leads to memory corruption. It is possible to launch the attack remotely. The complexity of an attack is rather high. The exploitability is told to be difficult. The exploit has been disclosed to the public and may be used. The patch is identified as b425859021d17adf62f06fb904797cf8642986ad. It is recommended to apply a patch to fix this issue.,CVE-2025-1182,tykio/tyk-plugin-compiler
binutils,LOW,2.35.2-2,,A vulnerability has been found in GNU Binutils 2.43/2.44 and classified as problematic. Affected by this vulnerability is the function display_info of the file binutils/bucomm.c of the component objdump. The manipulation leads to memory leak. An attack has to be approached locally. The exploit has been disclosed to the public and may be used. The patch is named ba6ad3a18cb26b79e0e3b84c39f707535bbc344d. It is recommended to apply a patch to fix this issue.,CVE-2025-3198,tykio/tyk-plugin-compiler
binutils-aarch64-linux-gnu,LOW,2.35.2-2,,The C++ symbol demangler routine in cplus-dem.c in libiberty as distributed in GNU Binutils 2.29 allows remote attackers to cause a denial of service (excessive memory allocation and application crash) via a crafted file as demonstrated by a call from the Binary File Descriptor (BFD) library (aka libbfd).,CVE-2017-13716,tykio/tyk-plugin-compiler
binutils-aarch64-linux-gnu,LOW,2.35.2-2,,The demangle_template function in cplus-dem.c in GNU libiberty as distributed in GNU Binutils 2.31.1 contains an integer overflow vulnerability (for Create an array for saving the template argument values) that can trigger a heap-based buffer overflow as demonstrated by nm.,CVE-2018-20673,tykio/tyk-plugin-compiler
binutils-aarch64-linux-gnu,LOW,2.35.2-2,,A heap-based buffer over-read exists in the function d_expression_1 in cp-demangle.c in GNU libiberty as distributed in GNU Binutils 2.31.1. A crafted input can cause segmentation faults leading to denial-of-service as demonstrated by c++filt.,CVE-2018-20712,tykio/tyk-plugin-compiler
binutils-aarch64-linux-gnu,LOW,2.35.2-2,,An issue was discovered in cplus-dem.c in GNU libiberty as distributed in GNU Binutils 2.30. Stack Exhaustion occurs in the C++ demangling functions provided by libiberty and there are recursive stack frames: demangle_template_value_parm demangle_integral_value and demangle_expression.,CVE-2018-9996,tykio/tyk-plugin-compiler
binutils-aarch64-linux-gnu,LOW,2.35.2-2,,GNU binutils gold gold v1.11-v1.16 (GNU binutils v2.21-v2.31.1) is affected by: Improper Input Validation Signed/Unsigned Comparison Out-of-bounds Read. The impact is: Denial of service. The component is: gold/fileread.cc:497 elfcpp/elfcpp_file.h:644. The attack vector is: An ELF file with an invalid e_shoff header field must be opened.,CVE-2019-1010204,tykio/tyk-plugin-compiler
binutils-aarch64-linux-gnu,LOW,2.35.2-2,,An issue was discovered in binutils libbfd.c 2.36 relating to the auxiliary symbol data allows attackers to read or write to system memory or cause a denial of service.,CVE-2020-19726,tykio/tyk-plugin-compiler
binutils-aarch64-linux-gnu,LOW,2.35.2-2,,An issue was discovered in the Binary File Descriptor (BFD) library (aka libbfd) as distributed in GNU Binutils 2.35.1. A heap-based buffer over-read can occur in bfd_getl_signed_32 in libbfd.c because sh_entsize is not validated in _bfd_elf_slurp_secondary_reloc_section in elf.c.,CVE-2020-35448,tykio/tyk-plugin-compiler
binutils-aarch64-linux-gnu,LOW,2.35.2-2,,There is an open race window when writing output in the following utilities in GNU binutils version 2.35 and earlier:ar objcopy strip ranlib. When these utilities are run as a privileged user (presumably as part of a script updating binaries across different users) an unprivileged user can trick these utilities into getting ownership of arbitrary files through a symlink.,CVE-2021-20197,tykio/tyk-plugin-compiler
binutils-aarch64-linux-gnu,LOW,2.35.2-2,,A flaw was found in GNU Binutils 2.35.1 where there is a heap-based buffer overflow in _bfd_elf_slurp_secondary_reloc_section in elf.c due to the number of symbols not calculated correctly. The highest threat from this vulnerability is to system availability.,CVE-2021-20284,tykio/tyk-plugin-compiler
binutils-aarch64-linux-gnu,LOW,2.35.2-2,,An issue was discovered in GNU libiberty as distributed in GNU Binutils 2.36. It is a stack-overflow issue in demangle_type in rust-demangle.c.,CVE-2021-32256,tykio/tyk-plugin-compiler
binutils-aarch64-linux-gnu,LOW,2.35.2-2,,A flaw was discovered in GNU libiberty within demangle_path() in rust-demangle.c as distributed in GNU Binutils version 2.36. A crafted symbol can cause stack memory to be exhausted leading to a crash.,CVE-2021-3530,tykio/tyk-plugin-compiler
binutils-aarch64-linux-gnu,LOW,2.35.2-2,,An out of bounds flaw was found in GNU binutils objdump utility version 2.36. An attacker could use this flaw and pass a large section to avr_elf32_load_records_from_section() probably resulting in a crash or in some cases memory corruption. The highest threat from this vulnerability is to integrity as well as system availability.,CVE-2021-3549,tykio/tyk-plugin-compiler
binutils-aarch64-linux-gnu,LOW,2.35.2-2,,Heap/stack buffer overflow in the dlang_lname function in d-demangle.c in libiberty allows attackers to potentially cause a denial of service (segmentation fault and crash) via a crafted mangled symbol.,CVE-2021-3826,tykio/tyk-plugin-compiler
binutils-aarch64-linux-gnu,LOW,2.35.2-2,,stab_xcoff_builtin_type in stabs.c in GNU Binutils through 2.37 allows attackers to cause a denial of service (heap-based buffer overflow) or possibly have unspecified other impact as demonstrated by an out-of-bounds write. NOTE: this issue exists because of an incorrect fix for CVE-2018-12699.,CVE-2021-45078,tykio/tyk-plugin-compiler
binutils-aarch64-linux-gnu,LOW,2.35.2-2,,Heap-based Buffer Overflow in function bfd_getl32 in Binutils objdump 3.37.,CVE-2021-46174,tykio/tyk-plugin-compiler
binutils-aarch64-linux-gnu,LOW,2.35.2-2,,GCC v12.0 was discovered to contain an uncontrolled recursion via the component libiberty/rust-demangle.c. This vulnerability allows attackers to cause a Denial of Service (DoS) by consuming excessive CPU and memory resources.,CVE-2021-46195,tykio/tyk-plugin-compiler
binutils-aarch64-linux-gnu,LOW,2.35.2-2,,An issue was discovered in Binutils readelf 2.38.50 reachable assertion failure in function display_debug_names allows attackers to cause a denial of service.,CVE-2022-35205,tykio/tyk-plugin-compiler
binutils-aarch64-linux-gnu,LOW,2.35.2-2,,Null pointer dereference vulnerability in Binutils readelf 2.38.50 via function read_and_display_attr_value in file dwarf.c.,CVE-2022-35206,tykio/tyk-plugin-compiler
binutils-aarch64-linux-gnu,LOW,2.35.2-2,,In GNU Binutils before 2.40 there is a heap-buffer-overflow in the error function bfd_getl32 when called from the strip_main function in strip-new via a crafted file.,CVE-2022-38533,tykio/tyk-plugin-compiler
binutils-aarch64-linux-gnu,LOW,2.35.2-2,,An illegal memory access flaw was found in the binutils package. Parsing an ELF file containing corrupt symbol version information may result in a denial of service. This issue is the result of an incomplete fix for CVE-2020-16599.,CVE-2022-4285,tykio/tyk-plugin-compiler
binutils-aarch64-linux-gnu,LOW,2.35.2-2,,Heap buffer overflow vulnerability in binutils readelf before 2.40 via function find_section_in_set in file readelf.c.,CVE-2022-44840,tykio/tyk-plugin-compiler
binutils-aarch64-linux-gnu,LOW,2.35.2-2,,Heap buffer overflow vulnerability in binutils readelf before 2.40 via function display_debug_section in file readelf.c.,CVE-2022-45703,tykio/tyk-plugin-compiler
binutils-aarch64-linux-gnu,LOW,2.35.2-2,,An issue was discovered function stab_demangle_v3_arg in stabs.c in Binutils 2.34 thru 2.38 allows attackers to cause a denial of service due to memory leaks.,CVE-2022-47007,tykio/tyk-plugin-compiler
binutils-aarch64-linux-gnu,LOW,2.35.2-2,,An issue was discovered function make_tempdir and make_tempname in bucomm.c in Binutils 2.34 thru 2.38 allows attackers to cause a denial of service due to memory leaks.,CVE-2022-47008,tykio/tyk-plugin-compiler
binutils-aarch64-linux-gnu,LOW,2.35.2-2,,An issue was discovered function pr_function_type in prdbg.c in Binutils 2.34 thru 2.38 allows attackers to cause a denial of service due to memory leaks.,CVE-2022-47010,tykio/tyk-plugin-compiler
binutils-aarch64-linux-gnu,LOW,2.35.2-2,,An issue was discovered function parse_stab_struct_fields in stabs.c in Binutils 2.34 thru 2.38 allows attackers to cause a denial of service due to memory leaks.,CVE-2022-47011,tykio/tyk-plugin-compiler
binutils-aarch64-linux-gnu,LOW,2.35.2-2,,An issue was discovered in Binutils addr2line before 2.39.3 function parse_module contains multiple out of bound reads which may cause a denial of service or other unspecified impacts.,CVE-2022-47673,tykio/tyk-plugin-compiler
binutils-aarch64-linux-gnu,LOW,2.35.2-2,,An issue was discovered Binutils objdump before 2.39.3 allows attackers to cause a denial of service or other unspecified impacts via function bfd_mach_o_get_synthetic_symtab in match-o.c.,CVE-2022-47695,tykio/tyk-plugin-compiler
binutils-aarch64-linux-gnu,LOW,2.35.2-2,,An issue was discovered Binutils objdump before 2.39.3 allows attackers to cause a denial of service or other unspecified impacts via function compare_symbols.,CVE-2022-47696,tykio/tyk-plugin-compiler
binutils-aarch64-linux-gnu,LOW,2.35.2-2,,GNU Binutils before 2.40 was discovered to contain an excessive memory consumption vulnerability via the function load_separate_debug_files at dwarf2.c. The attacker could supply a crafted ELF file and cause a DNS attack.,CVE-2022-48063,tykio/tyk-plugin-compiler
binutils-aarch64-linux-gnu,LOW,2.35.2-2,,GNU Binutils before 2.40 was discovered to contain an excessive memory consumption vulnerability via the function bfd_dwarf2_find_nearest_line_with_alt at dwarf2.c. The attacker could supply a crafted ELF file and cause a DNS attack.,CVE-2022-48064,tykio/tyk-plugin-compiler
binutils-aarch64-linux-gnu,LOW,2.35.2-2,,GNU Binutils before 2.40 was discovered to contain a memory leak vulnerability var the function find_abstract_instance in dwarf2.c.,CVE-2022-48065,tykio/tyk-plugin-compiler
binutils-aarch64-linux-gnu,LOW,2.35.2-2,,Heap based buffer overflow in binutils-gdb/bfd/libbfd.c in bfd_getl64.,CVE-2023-1579,tykio/tyk-plugin-compiler
binutils-aarch64-linux-gnu,LOW,2.35.2-2,,A potential heap based buffer overflow was found in _bfd_elf_slurp_version_tables() in bfd/elf.c. This may lead to loss of availability.,CVE-2023-1972,tykio/tyk-plugin-compiler
binutils-aarch64-linux-gnu,LOW,2.35.2-2,,An out-of-bounds read flaw was found in the parse_module function in bfd/vms-alpha.c in Binutils.,CVE-2023-25584,tykio/tyk-plugin-compiler
binutils-aarch64-linux-gnu,LOW,2.35.2-2,,A flaw was found in Binutils. The use of an uninitialized field in the struct module *module may lead to application crash and local denial of service.,CVE-2023-25585,tykio/tyk-plugin-compiler
binutils-aarch64-linux-gnu,LOW,2.35.2-2,,A flaw was found in Binutils. A logic fail in the bfd_init_section_decompress_status function may lead to the use of an uninitialized variable that can cause a crash and local denial of service.,CVE-2023-25586,tykio/tyk-plugin-compiler
binutils-aarch64-linux-gnu,LOW,2.35.2-2,,A flaw was found in Binutils. The field `the_bfd` of `asymbol`struct is uninitialized in the `bfd_mach_o_get_synthetic_symtab` function which may lead to an application crash and local denial of service.,CVE-2023-25588,tykio/tyk-plugin-compiler
binutils-aarch64-linux-gnu,LOW,2.35.2-2,,GNU objdump 2.43 is vulnerable to Buffer Overflow in the BFD (Binary File Descriptor) library's handling of tekhex format files.,CVE-2024-53589,tykio/tyk-plugin-compiler
binutils-aarch64-linux-gnu,LOW,2.35.2-2,,https://www.gnu.org/software/binutils/ nm >=2.43 is affected by: Incorrect Access Control. The type of exploitation is: local. The component is: `nm --without-symbol-version` function.,CVE-2024-57360,tykio/tyk-plugin-compiler
binutils-aarch64-linux-gnu,LOW,2.35.2-2,,A vulnerability which was classified as problematic was found in GNU Binutils up to 2.43. This affects the function disassemble_bytes of the file binutils/objdump.c. The manipulation of the argument buf leads to stack-based buffer overflow. It is possible to initiate the attack remotely. The complexity of an attack is rather high. The exploitability is told to be difficult. The exploit has been disclosed to the public and may be used. Upgrading to version 2.44 is able to address this issue. The identifier of the patch is baac6c221e9d69335bf41366a1c7d87d8ab2f893. It is recommended to upgrade the affected component.,CVE-2025-0840,tykio/tyk-plugin-compiler
binutils-aarch64-linux-gnu,LOW,2.35.2-2,,A vulnerability has been found in GNU Binutils 2.43 and classified as problematic. Affected by this vulnerability is the function __sanitizer::internal_strlen of the file binutils/nm.c of the component nm. The manipulation of the argument const leads to buffer overflow. The attack can be launched remotely. The complexity of an attack is rather high. The exploitation appears to be difficult. The exploit has been disclosed to the public and may be used.,CVE-2025-1147,tykio/tyk-plugin-compiler
binutils-aarch64-linux-gnu,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43 and classified as problematic. Affected by this issue is the function link_order_scan of the file ld/ldelfgen.c of the component ld. The manipulation leads to memory leak. The attack may be launched remotely. The complexity of an attack is rather high. The exploitation is known to be difficult. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue. The code maintainer explains: I'm not going to commit some of the leak fixes I've been working on to the 2.44 branch due to concern that would destabilise ld. All of the reported leaks in this bugzilla have been fixed on binutils master.,CVE-2025-1148,tykio/tyk-plugin-compiler
binutils-aarch64-linux-gnu,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43. It has been classified as problematic. This affects the function xstrdup of the file libiberty/xmalloc.c of the component ld. The manipulation leads to memory leak. It is possible to initiate the attack remotely. The complexity of an attack is rather high. The exploitability is told to be difficult. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue. The code maintainer explains: I'm not going to commit some of the leak fixes I've been working on to the 2.44 branch due to concern that would destabilise ld. All of the reported leaks in this bugzilla have been fixed on binutils master.,CVE-2025-1149,tykio/tyk-plugin-compiler
binutils-aarch64-linux-gnu,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43. It has been declared as problematic. This vulnerability affects the function bfd_malloc of the file libbfd.c of the component ld. The manipulation leads to memory leak. The attack can be initiated remotely. The complexity of an attack is rather high. The exploitation appears to be difficult. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue. The code maintainer explains: I'm not going to commit some of the leak fixes I've been working on to the 2.44 branch due to concern that would destabilise ld. All of the reported leaks in this bugzilla have been fixed on binutils master.,CVE-2025-1150,tykio/tyk-plugin-compiler
binutils-aarch64-linux-gnu,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43. It has been rated as problematic. This issue affects the function xmemdup of the file xmemdup.c of the component ld. The manipulation leads to memory leak. The attack may be initiated remotely. The complexity of an attack is rather high. The exploitation is known to be difficult. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue. The code maintainer explains: I'm not going to commit some of the leak fixes I've been working on to the 2.44 branch due to concern that would destabilise ld. All of the reported leaks in this bugzilla have been fixed on binutils master.,CVE-2025-1151,tykio/tyk-plugin-compiler
binutils-aarch64-linux-gnu,LOW,2.35.2-2,,A vulnerability classified as problematic has been found in GNU Binutils 2.43. Affected is the function xstrdup of the file xstrdup.c of the component ld. The manipulation leads to memory leak. It is possible to launch the attack remotely. The complexity of an attack is rather high. The exploitability is told to be difficult. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue. The code maintainer explains: I'm not going to commit some of the leak fixes I've been working on to the 2.44 branch due to concern that would destabilise ld. All of the reported leaks in this bugzilla have been fixed on binutils master.,CVE-2025-1152,tykio/tyk-plugin-compiler
binutils-aarch64-linux-gnu,LOW,2.35.2-2,,A vulnerability classified as problematic was found in GNU Binutils 2.43/2.44. Affected by this vulnerability is the function bfd_set_format of the file format.c. The manipulation leads to memory corruption. The attack can be launched remotely. The complexity of an attack is rather high. The exploitation appears to be difficult. Upgrading to version 2.45 is able to address this issue. The identifier of the patch is 8d97c1a53f3dc9fd8e1ccdb039b8a33d50133150. It is recommended to upgrade the affected component.,CVE-2025-1153,tykio/tyk-plugin-compiler
binutils-aarch64-linux-gnu,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43 and classified as critical. This issue affects the function _bfd_elf_gc_mark_rsec of the file elflink.c of the component ld. The manipulation leads to heap-based buffer overflow. The attack may be initiated remotely. The complexity of an attack is rather high. The exploitation is known to be difficult. The exploit has been disclosed to the public and may be used. The patch is named f9978defb6fab0bd8583942d97c112b0932ac814. It is recommended to apply a patch to fix this issue.,CVE-2025-1176,tykio/tyk-plugin-compiler
binutils-aarch64-linux-gnu,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43. It has been declared as problematic. Affected by this vulnerability is the function bfd_putl64 of the file libbfd.c of the component ld. The manipulation leads to memory corruption. The attack can be launched remotely. The complexity of an attack is rather high. The exploitation appears to be difficult. The exploit has been disclosed to the public and may be used. The identifier of the patch is 75086e9de1707281172cc77f178e7949a4414ed0. It is recommended to apply a patch to fix this issue.,CVE-2025-1178,tykio/tyk-plugin-compiler
binutils-aarch64-linux-gnu,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43. It has been rated as critical. Affected by this issue is the function bfd_putl64 of the file bfd/libbfd.c of the component ld. The manipulation leads to memory corruption. The attack may be launched remotely. The complexity of an attack is rather high. The exploitation is known to be difficult. The exploit has been disclosed to the public and may be used. Upgrading to version 2.44 is able to address this issue. It is recommended to upgrade the affected component. The code maintainer explains that [t]his bug has been fixed at some point between the 2.43 and 2.44 releases.,CVE-2025-1179,tykio/tyk-plugin-compiler
binutils-aarch64-linux-gnu,LOW,2.35.2-2,,A vulnerability classified as problematic has been found in GNU Binutils 2.43. This affects the function _bfd_elf_write_section_eh_frame of the file bfd/elf-eh-frame.c of the component ld. The manipulation leads to memory corruption. It is possible to initiate the attack remotely. The complexity of an attack is rather high. The exploitability is told to be difficult. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue.,CVE-2025-1180,tykio/tyk-plugin-compiler
binutils-aarch64-linux-gnu,LOW,2.35.2-2,,A vulnerability classified as critical was found in GNU Binutils 2.43. This vulnerability affects the function _bfd_elf_gc_mark_rsec of the file bfd/elflink.c of the component ld. The manipulation leads to memory corruption. The attack can be initiated remotely. The complexity of an attack is rather high. The exploitation appears to be difficult. The exploit has been disclosed to the public and may be used. The name of the patch is 931494c9a89558acb36a03a340c01726545eef24. It is recommended to apply a patch to fix this issue.,CVE-2025-1181,tykio/tyk-plugin-compiler
binutils-aarch64-linux-gnu,LOW,2.35.2-2,,A vulnerability which was classified as critical was found in GNU Binutils 2.43. Affected is the function bfd_elf_reloc_symbol_deleted_p of the file bfd/elflink.c of the component ld. The manipulation leads to memory corruption. It is possible to launch the attack remotely. The complexity of an attack is rather high. The exploitability is told to be difficult. The exploit has been disclosed to the public and may be used. The patch is identified as b425859021d17adf62f06fb904797cf8642986ad. It is recommended to apply a patch to fix this issue.,CVE-2025-1182,tykio/tyk-plugin-compiler
binutils-aarch64-linux-gnu,LOW,2.35.2-2,,A vulnerability has been found in GNU Binutils 2.43/2.44 and classified as problematic. Affected by this vulnerability is the function display_info of the file binutils/bucomm.c of the component objdump. The manipulation leads to memory leak. An attack has to be approached locally. The exploit has been disclosed to the public and may be used. The patch is named ba6ad3a18cb26b79e0e3b84c39f707535bbc344d. It is recommended to apply a patch to fix this issue.,CVE-2025-3198,tykio/tyk-plugin-compiler
binutils-common,LOW,2.35.2-2,,The C++ symbol demangler routine in cplus-dem.c in libiberty as distributed in GNU Binutils 2.29 allows remote attackers to cause a denial of service (excessive memory allocation and application crash) via a crafted file as demonstrated by a call from the Binary File Descriptor (BFD) library (aka libbfd).,CVE-2017-13716,tykio/tyk-plugin-compiler
binutils-common,LOW,2.35.2-2,,The demangle_template function in cplus-dem.c in GNU libiberty as distributed in GNU Binutils 2.31.1 contains an integer overflow vulnerability (for Create an array for saving the template argument values) that can trigger a heap-based buffer overflow as demonstrated by nm.,CVE-2018-20673,tykio/tyk-plugin-compiler
binutils-common,LOW,2.35.2-2,,A heap-based buffer over-read exists in the function d_expression_1 in cp-demangle.c in GNU libiberty as distributed in GNU Binutils 2.31.1. A crafted input can cause segmentation faults leading to denial-of-service as demonstrated by c++filt.,CVE-2018-20712,tykio/tyk-plugin-compiler
binutils-common,LOW,2.35.2-2,,An issue was discovered in cplus-dem.c in GNU libiberty as distributed in GNU Binutils 2.30. Stack Exhaustion occurs in the C++ demangling functions provided by libiberty and there are recursive stack frames: demangle_template_value_parm demangle_integral_value and demangle_expression.,CVE-2018-9996,tykio/tyk-plugin-compiler
binutils-common,LOW,2.35.2-2,,GNU binutils gold gold v1.11-v1.16 (GNU binutils v2.21-v2.31.1) is affected by: Improper Input Validation Signed/Unsigned Comparison Out-of-bounds Read. The impact is: Denial of service. The component is: gold/fileread.cc:497 elfcpp/elfcpp_file.h:644. The attack vector is: An ELF file with an invalid e_shoff header field must be opened.,CVE-2019-1010204,tykio/tyk-plugin-compiler
binutils-common,LOW,2.35.2-2,,An issue was discovered in binutils libbfd.c 2.36 relating to the auxiliary symbol data allows attackers to read or write to system memory or cause a denial of service.,CVE-2020-19726,tykio/tyk-plugin-compiler
binutils-common,LOW,2.35.2-2,,An issue was discovered in the Binary File Descriptor (BFD) library (aka libbfd) as distributed in GNU Binutils 2.35.1. A heap-based buffer over-read can occur in bfd_getl_signed_32 in libbfd.c because sh_entsize is not validated in _bfd_elf_slurp_secondary_reloc_section in elf.c.,CVE-2020-35448,tykio/tyk-plugin-compiler
binutils-common,LOW,2.35.2-2,,There is an open race window when writing output in the following utilities in GNU binutils version 2.35 and earlier:ar objcopy strip ranlib. When these utilities are run as a privileged user (presumably as part of a script updating binaries across different users) an unprivileged user can trick these utilities into getting ownership of arbitrary files through a symlink.,CVE-2021-20197,tykio/tyk-plugin-compiler
binutils-common,LOW,2.35.2-2,,A flaw was found in GNU Binutils 2.35.1 where there is a heap-based buffer overflow in _bfd_elf_slurp_secondary_reloc_section in elf.c due to the number of symbols not calculated correctly. The highest threat from this vulnerability is to system availability.,CVE-2021-20284,tykio/tyk-plugin-compiler
binutils-common,LOW,2.35.2-2,,An issue was discovered in GNU libiberty as distributed in GNU Binutils 2.36. It is a stack-overflow issue in demangle_type in rust-demangle.c.,CVE-2021-32256,tykio/tyk-plugin-compiler
binutils-common,LOW,2.35.2-2,,A flaw was discovered in GNU libiberty within demangle_path() in rust-demangle.c as distributed in GNU Binutils version 2.36. A crafted symbol can cause stack memory to be exhausted leading to a crash.,CVE-2021-3530,tykio/tyk-plugin-compiler
binutils-common,LOW,2.35.2-2,,An out of bounds flaw was found in GNU binutils objdump utility version 2.36. An attacker could use this flaw and pass a large section to avr_elf32_load_records_from_section() probably resulting in a crash or in some cases memory corruption. The highest threat from this vulnerability is to integrity as well as system availability.,CVE-2021-3549,tykio/tyk-plugin-compiler
binutils-common,LOW,2.35.2-2,,Heap/stack buffer overflow in the dlang_lname function in d-demangle.c in libiberty allows attackers to potentially cause a denial of service (segmentation fault and crash) via a crafted mangled symbol.,CVE-2021-3826,tykio/tyk-plugin-compiler
binutils-common,LOW,2.35.2-2,,stab_xcoff_builtin_type in stabs.c in GNU Binutils through 2.37 allows attackers to cause a denial of service (heap-based buffer overflow) or possibly have unspecified other impact as demonstrated by an out-of-bounds write. NOTE: this issue exists because of an incorrect fix for CVE-2018-12699.,CVE-2021-45078,tykio/tyk-plugin-compiler
binutils-common,LOW,2.35.2-2,,Heap-based Buffer Overflow in function bfd_getl32 in Binutils objdump 3.37.,CVE-2021-46174,tykio/tyk-plugin-compiler
binutils-common,LOW,2.35.2-2,,GCC v12.0 was discovered to contain an uncontrolled recursion via the component libiberty/rust-demangle.c. This vulnerability allows attackers to cause a Denial of Service (DoS) by consuming excessive CPU and memory resources.,CVE-2021-46195,tykio/tyk-plugin-compiler
binutils-common,LOW,2.35.2-2,,An issue was discovered in Binutils readelf 2.38.50 reachable assertion failure in function display_debug_names allows attackers to cause a denial of service.,CVE-2022-35205,tykio/tyk-plugin-compiler
binutils-common,LOW,2.35.2-2,,Null pointer dereference vulnerability in Binutils readelf 2.38.50 via function read_and_display_attr_value in file dwarf.c.,CVE-2022-35206,tykio/tyk-plugin-compiler
binutils-common,LOW,2.35.2-2,,In GNU Binutils before 2.40 there is a heap-buffer-overflow in the error function bfd_getl32 when called from the strip_main function in strip-new via a crafted file.,CVE-2022-38533,tykio/tyk-plugin-compiler
binutils-common,LOW,2.35.2-2,,An illegal memory access flaw was found in the binutils package. Parsing an ELF file containing corrupt symbol version information may result in a denial of service. This issue is the result of an incomplete fix for CVE-2020-16599.,CVE-2022-4285,tykio/tyk-plugin-compiler
binutils-common,LOW,2.35.2-2,,Heap buffer overflow vulnerability in binutils readelf before 2.40 via function find_section_in_set in file readelf.c.,CVE-2022-44840,tykio/tyk-plugin-compiler
binutils-common,LOW,2.35.2-2,,Heap buffer overflow vulnerability in binutils readelf before 2.40 via function display_debug_section in file readelf.c.,CVE-2022-45703,tykio/tyk-plugin-compiler
binutils-common,LOW,2.35.2-2,,An issue was discovered function stab_demangle_v3_arg in stabs.c in Binutils 2.34 thru 2.38 allows attackers to cause a denial of service due to memory leaks.,CVE-2022-47007,tykio/tyk-plugin-compiler
binutils-common,LOW,2.35.2-2,,An issue was discovered function make_tempdir and make_tempname in bucomm.c in Binutils 2.34 thru 2.38 allows attackers to cause a denial of service due to memory leaks.,CVE-2022-47008,tykio/tyk-plugin-compiler
binutils-common,LOW,2.35.2-2,,An issue was discovered function pr_function_type in prdbg.c in Binutils 2.34 thru 2.38 allows attackers to cause a denial of service due to memory leaks.,CVE-2022-47010,tykio/tyk-plugin-compiler
binutils-common,LOW,2.35.2-2,,An issue was discovered function parse_stab_struct_fields in stabs.c in Binutils 2.34 thru 2.38 allows attackers to cause a denial of service due to memory leaks.,CVE-2022-47011,tykio/tyk-plugin-compiler
binutils-common,LOW,2.35.2-2,,An issue was discovered in Binutils addr2line before 2.39.3 function parse_module contains multiple out of bound reads which may cause a denial of service or other unspecified impacts.,CVE-2022-47673,tykio/tyk-plugin-compiler
binutils-common,LOW,2.35.2-2,,An issue was discovered Binutils objdump before 2.39.3 allows attackers to cause a denial of service or other unspecified impacts via function bfd_mach_o_get_synthetic_symtab in match-o.c.,CVE-2022-47695,tykio/tyk-plugin-compiler
binutils-common,LOW,2.35.2-2,,An issue was discovered Binutils objdump before 2.39.3 allows attackers to cause a denial of service or other unspecified impacts via function compare_symbols.,CVE-2022-47696,tykio/tyk-plugin-compiler
binutils-common,LOW,2.35.2-2,,GNU Binutils before 2.40 was discovered to contain an excessive memory consumption vulnerability via the function load_separate_debug_files at dwarf2.c. The attacker could supply a crafted ELF file and cause a DNS attack.,CVE-2022-48063,tykio/tyk-plugin-compiler
binutils-common,LOW,2.35.2-2,,GNU Binutils before 2.40 was discovered to contain an excessive memory consumption vulnerability via the function bfd_dwarf2_find_nearest_line_with_alt at dwarf2.c. The attacker could supply a crafted ELF file and cause a DNS attack.,CVE-2022-48064,tykio/tyk-plugin-compiler
binutils-common,LOW,2.35.2-2,,GNU Binutils before 2.40 was discovered to contain a memory leak vulnerability var the function find_abstract_instance in dwarf2.c.,CVE-2022-48065,tykio/tyk-plugin-compiler
binutils-common,LOW,2.35.2-2,,Heap based buffer overflow in binutils-gdb/bfd/libbfd.c in bfd_getl64.,CVE-2023-1579,tykio/tyk-plugin-compiler
binutils-common,LOW,2.35.2-2,,A potential heap based buffer overflow was found in _bfd_elf_slurp_version_tables() in bfd/elf.c. This may lead to loss of availability.,CVE-2023-1972,tykio/tyk-plugin-compiler
binutils-common,LOW,2.35.2-2,,An out-of-bounds read flaw was found in the parse_module function in bfd/vms-alpha.c in Binutils.,CVE-2023-25584,tykio/tyk-plugin-compiler
binutils-common,LOW,2.35.2-2,,A flaw was found in Binutils. The use of an uninitialized field in the struct module *module may lead to application crash and local denial of service.,CVE-2023-25585,tykio/tyk-plugin-compiler
binutils-common,LOW,2.35.2-2,,A flaw was found in Binutils. A logic fail in the bfd_init_section_decompress_status function may lead to the use of an uninitialized variable that can cause a crash and local denial of service.,CVE-2023-25586,tykio/tyk-plugin-compiler
binutils-common,LOW,2.35.2-2,,A flaw was found in Binutils. The field `the_bfd` of `asymbol`struct is uninitialized in the `bfd_mach_o_get_synthetic_symtab` function which may lead to an application crash and local denial of service.,CVE-2023-25588,tykio/tyk-plugin-compiler
binutils-common,LOW,2.35.2-2,,GNU objdump 2.43 is vulnerable to Buffer Overflow in the BFD (Binary File Descriptor) library's handling of tekhex format files.,CVE-2024-53589,tykio/tyk-plugin-compiler
binutils-common,LOW,2.35.2-2,,https://www.gnu.org/software/binutils/ nm >=2.43 is affected by: Incorrect Access Control. The type of exploitation is: local. The component is: `nm --without-symbol-version` function.,CVE-2024-57360,tykio/tyk-plugin-compiler
binutils-common,LOW,2.35.2-2,,A vulnerability which was classified as problematic was found in GNU Binutils up to 2.43. This affects the function disassemble_bytes of the file binutils/objdump.c. The manipulation of the argument buf leads to stack-based buffer overflow. It is possible to initiate the attack remotely. The complexity of an attack is rather high. The exploitability is told to be difficult. The exploit has been disclosed to the public and may be used. Upgrading to version 2.44 is able to address this issue. The identifier of the patch is baac6c221e9d69335bf41366a1c7d87d8ab2f893. It is recommended to upgrade the affected component.,CVE-2025-0840,tykio/tyk-plugin-compiler
binutils-common,LOW,2.35.2-2,,A vulnerability has been found in GNU Binutils 2.43 and classified as problematic. Affected by this vulnerability is the function __sanitizer::internal_strlen of the file binutils/nm.c of the component nm. The manipulation of the argument const leads to buffer overflow. The attack can be launched remotely. The complexity of an attack is rather high. The exploitation appears to be difficult. The exploit has been disclosed to the public and may be used.,CVE-2025-1147,tykio/tyk-plugin-compiler
binutils-common,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43 and classified as problematic. Affected by this issue is the function link_order_scan of the file ld/ldelfgen.c of the component ld. The manipulation leads to memory leak. The attack may be launched remotely. The complexity of an attack is rather high. The exploitation is known to be difficult. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue. The code maintainer explains: I'm not going to commit some of the leak fixes I've been working on to the 2.44 branch due to concern that would destabilise ld. All of the reported leaks in this bugzilla have been fixed on binutils master.,CVE-2025-1148,tykio/tyk-plugin-compiler
binutils-common,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43. It has been classified as problematic. This affects the function xstrdup of the file libiberty/xmalloc.c of the component ld. The manipulation leads to memory leak. It is possible to initiate the attack remotely. The complexity of an attack is rather high. The exploitability is told to be difficult. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue. The code maintainer explains: I'm not going to commit some of the leak fixes I've been working on to the 2.44 branch due to concern that would destabilise ld. All of the reported leaks in this bugzilla have been fixed on binutils master.,CVE-2025-1149,tykio/tyk-plugin-compiler
binutils-common,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43. It has been declared as problematic. This vulnerability affects the function bfd_malloc of the file libbfd.c of the component ld. The manipulation leads to memory leak. The attack can be initiated remotely. The complexity of an attack is rather high. The exploitation appears to be difficult. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue. The code maintainer explains: I'm not going to commit some of the leak fixes I've been working on to the 2.44 branch due to concern that would destabilise ld. All of the reported leaks in this bugzilla have been fixed on binutils master.,CVE-2025-1150,tykio/tyk-plugin-compiler
binutils-common,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43. It has been rated as problematic. This issue affects the function xmemdup of the file xmemdup.c of the component ld. The manipulation leads to memory leak. The attack may be initiated remotely. The complexity of an attack is rather high. The exploitation is known to be difficult. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue. The code maintainer explains: I'm not going to commit some of the leak fixes I've been working on to the 2.44 branch due to concern that would destabilise ld. All of the reported leaks in this bugzilla have been fixed on binutils master.,CVE-2025-1151,tykio/tyk-plugin-compiler
binutils-common,LOW,2.35.2-2,,A vulnerability classified as problematic has been found in GNU Binutils 2.43. Affected is the function xstrdup of the file xstrdup.c of the component ld. The manipulation leads to memory leak. It is possible to launch the attack remotely. The complexity of an attack is rather high. The exploitability is told to be difficult. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue. The code maintainer explains: I'm not going to commit some of the leak fixes I've been working on to the 2.44 branch due to concern that would destabilise ld. All of the reported leaks in this bugzilla have been fixed on binutils master.,CVE-2025-1152,tykio/tyk-plugin-compiler
binutils-common,LOW,2.35.2-2,,A vulnerability classified as problematic was found in GNU Binutils 2.43/2.44. Affected by this vulnerability is the function bfd_set_format of the file format.c. The manipulation leads to memory corruption. The attack can be launched remotely. The complexity of an attack is rather high. The exploitation appears to be difficult. Upgrading to version 2.45 is able to address this issue. The identifier of the patch is 8d97c1a53f3dc9fd8e1ccdb039b8a33d50133150. It is recommended to upgrade the affected component.,CVE-2025-1153,tykio/tyk-plugin-compiler
binutils-common,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43 and classified as critical. This issue affects the function _bfd_elf_gc_mark_rsec of the file elflink.c of the component ld. The manipulation leads to heap-based buffer overflow. The attack may be initiated remotely. The complexity of an attack is rather high. The exploitation is known to be difficult. The exploit has been disclosed to the public and may be used. The patch is named f9978defb6fab0bd8583942d97c112b0932ac814. It is recommended to apply a patch to fix this issue.,CVE-2025-1176,tykio/tyk-plugin-compiler
binutils-common,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43. It has been declared as problematic. Affected by this vulnerability is the function bfd_putl64 of the file libbfd.c of the component ld. The manipulation leads to memory corruption. The attack can be launched remotely. The complexity of an attack is rather high. The exploitation appears to be difficult. The exploit has been disclosed to the public and may be used. The identifier of the patch is 75086e9de1707281172cc77f178e7949a4414ed0. It is recommended to apply a patch to fix this issue.,CVE-2025-1178,tykio/tyk-plugin-compiler
binutils-common,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43. It has been rated as critical. Affected by this issue is the function bfd_putl64 of the file bfd/libbfd.c of the component ld. The manipulation leads to memory corruption. The attack may be launched remotely. The complexity of an attack is rather high. The exploitation is known to be difficult. The exploit has been disclosed to the public and may be used. Upgrading to version 2.44 is able to address this issue. It is recommended to upgrade the affected component. The code maintainer explains that [t]his bug has been fixed at some point between the 2.43 and 2.44 releases.,CVE-2025-1179,tykio/tyk-plugin-compiler
binutils-common,LOW,2.35.2-2,,A vulnerability classified as problematic has been found in GNU Binutils 2.43. This affects the function _bfd_elf_write_section_eh_frame of the file bfd/elf-eh-frame.c of the component ld. The manipulation leads to memory corruption. It is possible to initiate the attack remotely. The complexity of an attack is rather high. The exploitability is told to be difficult. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue.,CVE-2025-1180,tykio/tyk-plugin-compiler
binutils-common,LOW,2.35.2-2,,A vulnerability classified as critical was found in GNU Binutils 2.43. This vulnerability affects the function _bfd_elf_gc_mark_rsec of the file bfd/elflink.c of the component ld. The manipulation leads to memory corruption. The attack can be initiated remotely. The complexity of an attack is rather high. The exploitation appears to be difficult. The exploit has been disclosed to the public and may be used. The name of the patch is 931494c9a89558acb36a03a340c01726545eef24. It is recommended to apply a patch to fix this issue.,CVE-2025-1181,tykio/tyk-plugin-compiler
binutils-common,LOW,2.35.2-2,,A vulnerability which was classified as critical was found in GNU Binutils 2.43. Affected is the function bfd_elf_reloc_symbol_deleted_p of the file bfd/elflink.c of the component ld. The manipulation leads to memory corruption. It is possible to launch the attack remotely. The complexity of an attack is rather high. The exploitability is told to be difficult. The exploit has been disclosed to the public and may be used. The patch is identified as b425859021d17adf62f06fb904797cf8642986ad. It is recommended to apply a patch to fix this issue.,CVE-2025-1182,tykio/tyk-plugin-compiler
binutils-common,LOW,2.35.2-2,,A vulnerability has been found in GNU Binutils 2.43/2.44 and classified as problematic. Affected by this vulnerability is the function display_info of the file binutils/bucomm.c of the component objdump. The manipulation leads to memory leak. An attack has to be approached locally. The exploit has been disclosed to the public and may be used. The patch is named ba6ad3a18cb26b79e0e3b84c39f707535bbc344d. It is recommended to apply a patch to fix this issue.,CVE-2025-3198,tykio/tyk-plugin-compiler
binutils-dev,LOW,2.35.2-2,,The C++ symbol demangler routine in cplus-dem.c in libiberty as distributed in GNU Binutils 2.29 allows remote attackers to cause a denial of service (excessive memory allocation and application crash) via a crafted file as demonstrated by a call from the Binary File Descriptor (BFD) library (aka libbfd).,CVE-2017-13716,tykio/tyk-plugin-compiler
binutils-dev,LOW,2.35.2-2,,The demangle_template function in cplus-dem.c in GNU libiberty as distributed in GNU Binutils 2.31.1 contains an integer overflow vulnerability (for Create an array for saving the template argument values) that can trigger a heap-based buffer overflow as demonstrated by nm.,CVE-2018-20673,tykio/tyk-plugin-compiler
binutils-dev,LOW,2.35.2-2,,A heap-based buffer over-read exists in the function d_expression_1 in cp-demangle.c in GNU libiberty as distributed in GNU Binutils 2.31.1. A crafted input can cause segmentation faults leading to denial-of-service as demonstrated by c++filt.,CVE-2018-20712,tykio/tyk-plugin-compiler
binutils-dev,LOW,2.35.2-2,,An issue was discovered in cplus-dem.c in GNU libiberty as distributed in GNU Binutils 2.30. Stack Exhaustion occurs in the C++ demangling functions provided by libiberty and there are recursive stack frames: demangle_template_value_parm demangle_integral_value and demangle_expression.,CVE-2018-9996,tykio/tyk-plugin-compiler
binutils-dev,LOW,2.35.2-2,,GNU binutils gold gold v1.11-v1.16 (GNU binutils v2.21-v2.31.1) is affected by: Improper Input Validation Signed/Unsigned Comparison Out-of-bounds Read. The impact is: Denial of service. The component is: gold/fileread.cc:497 elfcpp/elfcpp_file.h:644. The attack vector is: An ELF file with an invalid e_shoff header field must be opened.,CVE-2019-1010204,tykio/tyk-plugin-compiler
binutils-dev,LOW,2.35.2-2,,An issue was discovered in binutils libbfd.c 2.36 relating to the auxiliary symbol data allows attackers to read or write to system memory or cause a denial of service.,CVE-2020-19726,tykio/tyk-plugin-compiler
binutils-dev,LOW,2.35.2-2,,An issue was discovered in the Binary File Descriptor (BFD) library (aka libbfd) as distributed in GNU Binutils 2.35.1. A heap-based buffer over-read can occur in bfd_getl_signed_32 in libbfd.c because sh_entsize is not validated in _bfd_elf_slurp_secondary_reloc_section in elf.c.,CVE-2020-35448,tykio/tyk-plugin-compiler
binutils-dev,LOW,2.35.2-2,,There is an open race window when writing output in the following utilities in GNU binutils version 2.35 and earlier:ar objcopy strip ranlib. When these utilities are run as a privileged user (presumably as part of a script updating binaries across different users) an unprivileged user can trick these utilities into getting ownership of arbitrary files through a symlink.,CVE-2021-20197,tykio/tyk-plugin-compiler
binutils-dev,LOW,2.35.2-2,,A flaw was found in GNU Binutils 2.35.1 where there is a heap-based buffer overflow in _bfd_elf_slurp_secondary_reloc_section in elf.c due to the number of symbols not calculated correctly. The highest threat from this vulnerability is to system availability.,CVE-2021-20284,tykio/tyk-plugin-compiler
binutils-dev,LOW,2.35.2-2,,An issue was discovered in GNU libiberty as distributed in GNU Binutils 2.36. It is a stack-overflow issue in demangle_type in rust-demangle.c.,CVE-2021-32256,tykio/tyk-plugin-compiler
binutils-dev,LOW,2.35.2-2,,A flaw was discovered in GNU libiberty within demangle_path() in rust-demangle.c as distributed in GNU Binutils version 2.36. A crafted symbol can cause stack memory to be exhausted leading to a crash.,CVE-2021-3530,tykio/tyk-plugin-compiler
binutils-dev,LOW,2.35.2-2,,An out of bounds flaw was found in GNU binutils objdump utility version 2.36. An attacker could use this flaw and pass a large section to avr_elf32_load_records_from_section() probably resulting in a crash or in some cases memory corruption. The highest threat from this vulnerability is to integrity as well as system availability.,CVE-2021-3549,tykio/tyk-plugin-compiler
binutils-dev,LOW,2.35.2-2,,Heap/stack buffer overflow in the dlang_lname function in d-demangle.c in libiberty allows attackers to potentially cause a denial of service (segmentation fault and crash) via a crafted mangled symbol.,CVE-2021-3826,tykio/tyk-plugin-compiler
binutils-dev,LOW,2.35.2-2,,stab_xcoff_builtin_type in stabs.c in GNU Binutils through 2.37 allows attackers to cause a denial of service (heap-based buffer overflow) or possibly have unspecified other impact as demonstrated by an out-of-bounds write. NOTE: this issue exists because of an incorrect fix for CVE-2018-12699.,CVE-2021-45078,tykio/tyk-plugin-compiler
binutils-dev,LOW,2.35.2-2,,Heap-based Buffer Overflow in function bfd_getl32 in Binutils objdump 3.37.,CVE-2021-46174,tykio/tyk-plugin-compiler
binutils-dev,LOW,2.35.2-2,,GCC v12.0 was discovered to contain an uncontrolled recursion via the component libiberty/rust-demangle.c. This vulnerability allows attackers to cause a Denial of Service (DoS) by consuming excessive CPU and memory resources.,CVE-2021-46195,tykio/tyk-plugin-compiler
binutils-dev,LOW,2.35.2-2,,An issue was discovered in Binutils readelf 2.38.50 reachable assertion failure in function display_debug_names allows attackers to cause a denial of service.,CVE-2022-35205,tykio/tyk-plugin-compiler
binutils-dev,LOW,2.35.2-2,,Null pointer dereference vulnerability in Binutils readelf 2.38.50 via function read_and_display_attr_value in file dwarf.c.,CVE-2022-35206,tykio/tyk-plugin-compiler
binutils-dev,LOW,2.35.2-2,,In GNU Binutils before 2.40 there is a heap-buffer-overflow in the error function bfd_getl32 when called from the strip_main function in strip-new via a crafted file.,CVE-2022-38533,tykio/tyk-plugin-compiler
binutils-dev,LOW,2.35.2-2,,An illegal memory access flaw was found in the binutils package. Parsing an ELF file containing corrupt symbol version information may result in a denial of service. This issue is the result of an incomplete fix for CVE-2020-16599.,CVE-2022-4285,tykio/tyk-plugin-compiler
binutils-dev,LOW,2.35.2-2,,Heap buffer overflow vulnerability in binutils readelf before 2.40 via function find_section_in_set in file readelf.c.,CVE-2022-44840,tykio/tyk-plugin-compiler
binutils-dev,LOW,2.35.2-2,,Heap buffer overflow vulnerability in binutils readelf before 2.40 via function display_debug_section in file readelf.c.,CVE-2022-45703,tykio/tyk-plugin-compiler
binutils-dev,LOW,2.35.2-2,,An issue was discovered function stab_demangle_v3_arg in stabs.c in Binutils 2.34 thru 2.38 allows attackers to cause a denial of service due to memory leaks.,CVE-2022-47007,tykio/tyk-plugin-compiler
binutils-dev,LOW,2.35.2-2,,An issue was discovered function make_tempdir and make_tempname in bucomm.c in Binutils 2.34 thru 2.38 allows attackers to cause a denial of service due to memory leaks.,CVE-2022-47008,tykio/tyk-plugin-compiler
binutils-dev,LOW,2.35.2-2,,An issue was discovered function pr_function_type in prdbg.c in Binutils 2.34 thru 2.38 allows attackers to cause a denial of service due to memory leaks.,CVE-2022-47010,tykio/tyk-plugin-compiler
binutils-dev,LOW,2.35.2-2,,An issue was discovered function parse_stab_struct_fields in stabs.c in Binutils 2.34 thru 2.38 allows attackers to cause a denial of service due to memory leaks.,CVE-2022-47011,tykio/tyk-plugin-compiler
binutils-dev,LOW,2.35.2-2,,An issue was discovered in Binutils addr2line before 2.39.3 function parse_module contains multiple out of bound reads which may cause a denial of service or other unspecified impacts.,CVE-2022-47673,tykio/tyk-plugin-compiler
binutils-dev,LOW,2.35.2-2,,An issue was discovered Binutils objdump before 2.39.3 allows attackers to cause a denial of service or other unspecified impacts via function bfd_mach_o_get_synthetic_symtab in match-o.c.,CVE-2022-47695,tykio/tyk-plugin-compiler
binutils-dev,LOW,2.35.2-2,,An issue was discovered Binutils objdump before 2.39.3 allows attackers to cause a denial of service or other unspecified impacts via function compare_symbols.,CVE-2022-47696,tykio/tyk-plugin-compiler
binutils-dev,LOW,2.35.2-2,,GNU Binutils before 2.40 was discovered to contain an excessive memory consumption vulnerability via the function load_separate_debug_files at dwarf2.c. The attacker could supply a crafted ELF file and cause a DNS attack.,CVE-2022-48063,tykio/tyk-plugin-compiler
binutils-dev,LOW,2.35.2-2,,GNU Binutils before 2.40 was discovered to contain an excessive memory consumption vulnerability via the function bfd_dwarf2_find_nearest_line_with_alt at dwarf2.c. The attacker could supply a crafted ELF file and cause a DNS attack.,CVE-2022-48064,tykio/tyk-plugin-compiler
binutils-dev,LOW,2.35.2-2,,GNU Binutils before 2.40 was discovered to contain a memory leak vulnerability var the function find_abstract_instance in dwarf2.c.,CVE-2022-48065,tykio/tyk-plugin-compiler
binutils-dev,LOW,2.35.2-2,,Heap based buffer overflow in binutils-gdb/bfd/libbfd.c in bfd_getl64.,CVE-2023-1579,tykio/tyk-plugin-compiler
binutils-dev,LOW,2.35.2-2,,A potential heap based buffer overflow was found in _bfd_elf_slurp_version_tables() in bfd/elf.c. This may lead to loss of availability.,CVE-2023-1972,tykio/tyk-plugin-compiler
binutils-dev,LOW,2.35.2-2,,An out-of-bounds read flaw was found in the parse_module function in bfd/vms-alpha.c in Binutils.,CVE-2023-25584,tykio/tyk-plugin-compiler
binutils-dev,LOW,2.35.2-2,,A flaw was found in Binutils. The use of an uninitialized field in the struct module *module may lead to application crash and local denial of service.,CVE-2023-25585,tykio/tyk-plugin-compiler
binutils-dev,LOW,2.35.2-2,,A flaw was found in Binutils. A logic fail in the bfd_init_section_decompress_status function may lead to the use of an uninitialized variable that can cause a crash and local denial of service.,CVE-2023-25586,tykio/tyk-plugin-compiler
binutils-dev,LOW,2.35.2-2,,A flaw was found in Binutils. The field `the_bfd` of `asymbol`struct is uninitialized in the `bfd_mach_o_get_synthetic_symtab` function which may lead to an application crash and local denial of service.,CVE-2023-25588,tykio/tyk-plugin-compiler
binutils-dev,LOW,2.35.2-2,,GNU objdump 2.43 is vulnerable to Buffer Overflow in the BFD (Binary File Descriptor) library's handling of tekhex format files.,CVE-2024-53589,tykio/tyk-plugin-compiler
binutils-dev,LOW,2.35.2-2,,https://www.gnu.org/software/binutils/ nm >=2.43 is affected by: Incorrect Access Control. The type of exploitation is: local. The component is: `nm --without-symbol-version` function.,CVE-2024-57360,tykio/tyk-plugin-compiler
binutils-dev,LOW,2.35.2-2,,A vulnerability which was classified as problematic was found in GNU Binutils up to 2.43. This affects the function disassemble_bytes of the file binutils/objdump.c. The manipulation of the argument buf leads to stack-based buffer overflow. It is possible to initiate the attack remotely. The complexity of an attack is rather high. The exploitability is told to be difficult. The exploit has been disclosed to the public and may be used. Upgrading to version 2.44 is able to address this issue. The identifier of the patch is baac6c221e9d69335bf41366a1c7d87d8ab2f893. It is recommended to upgrade the affected component.,CVE-2025-0840,tykio/tyk-plugin-compiler
binutils-dev,LOW,2.35.2-2,,A vulnerability has been found in GNU Binutils 2.43 and classified as problematic. Affected by this vulnerability is the function __sanitizer::internal_strlen of the file binutils/nm.c of the component nm. The manipulation of the argument const leads to buffer overflow. The attack can be launched remotely. The complexity of an attack is rather high. The exploitation appears to be difficult. The exploit has been disclosed to the public and may be used.,CVE-2025-1147,tykio/tyk-plugin-compiler
binutils-dev,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43 and classified as problematic. Affected by this issue is the function link_order_scan of the file ld/ldelfgen.c of the component ld. The manipulation leads to memory leak. The attack may be launched remotely. The complexity of an attack is rather high. The exploitation is known to be difficult. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue. The code maintainer explains: I'm not going to commit some of the leak fixes I've been working on to the 2.44 branch due to concern that would destabilise ld. All of the reported leaks in this bugzilla have been fixed on binutils master.,CVE-2025-1148,tykio/tyk-plugin-compiler
binutils-dev,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43. It has been classified as problematic. This affects the function xstrdup of the file libiberty/xmalloc.c of the component ld. The manipulation leads to memory leak. It is possible to initiate the attack remotely. The complexity of an attack is rather high. The exploitability is told to be difficult. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue. The code maintainer explains: I'm not going to commit some of the leak fixes I've been working on to the 2.44 branch due to concern that would destabilise ld. All of the reported leaks in this bugzilla have been fixed on binutils master.,CVE-2025-1149,tykio/tyk-plugin-compiler
binutils-dev,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43. It has been declared as problematic. This vulnerability affects the function bfd_malloc of the file libbfd.c of the component ld. The manipulation leads to memory leak. The attack can be initiated remotely. The complexity of an attack is rather high. The exploitation appears to be difficult. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue. The code maintainer explains: I'm not going to commit some of the leak fixes I've been working on to the 2.44 branch due to concern that would destabilise ld. All of the reported leaks in this bugzilla have been fixed on binutils master.,CVE-2025-1150,tykio/tyk-plugin-compiler
binutils-dev,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43. It has been rated as problematic. This issue affects the function xmemdup of the file xmemdup.c of the component ld. The manipulation leads to memory leak. The attack may be initiated remotely. The complexity of an attack is rather high. The exploitation is known to be difficult. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue. The code maintainer explains: I'm not going to commit some of the leak fixes I've been working on to the 2.44 branch due to concern that would destabilise ld. All of the reported leaks in this bugzilla have been fixed on binutils master.,CVE-2025-1151,tykio/tyk-plugin-compiler
binutils-dev,LOW,2.35.2-2,,A vulnerability classified as problematic has been found in GNU Binutils 2.43. Affected is the function xstrdup of the file xstrdup.c of the component ld. The manipulation leads to memory leak. It is possible to launch the attack remotely. The complexity of an attack is rather high. The exploitability is told to be difficult. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue. The code maintainer explains: I'm not going to commit some of the leak fixes I've been working on to the 2.44 branch due to concern that would destabilise ld. All of the reported leaks in this bugzilla have been fixed on binutils master.,CVE-2025-1152,tykio/tyk-plugin-compiler
binutils-dev,LOW,2.35.2-2,,A vulnerability classified as problematic was found in GNU Binutils 2.43/2.44. Affected by this vulnerability is the function bfd_set_format of the file format.c. The manipulation leads to memory corruption. The attack can be launched remotely. The complexity of an attack is rather high. The exploitation appears to be difficult. Upgrading to version 2.45 is able to address this issue. The identifier of the patch is 8d97c1a53f3dc9fd8e1ccdb039b8a33d50133150. It is recommended to upgrade the affected component.,CVE-2025-1153,tykio/tyk-plugin-compiler
binutils-dev,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43 and classified as critical. This issue affects the function _bfd_elf_gc_mark_rsec of the file elflink.c of the component ld. The manipulation leads to heap-based buffer overflow. The attack may be initiated remotely. The complexity of an attack is rather high. The exploitation is known to be difficult. The exploit has been disclosed to the public and may be used. The patch is named f9978defb6fab0bd8583942d97c112b0932ac814. It is recommended to apply a patch to fix this issue.,CVE-2025-1176,tykio/tyk-plugin-compiler
binutils-dev,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43. It has been declared as problematic. Affected by this vulnerability is the function bfd_putl64 of the file libbfd.c of the component ld. The manipulation leads to memory corruption. The attack can be launched remotely. The complexity of an attack is rather high. The exploitation appears to be difficult. The exploit has been disclosed to the public and may be used. The identifier of the patch is 75086e9de1707281172cc77f178e7949a4414ed0. It is recommended to apply a patch to fix this issue.,CVE-2025-1178,tykio/tyk-plugin-compiler
binutils-dev,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43. It has been rated as critical. Affected by this issue is the function bfd_putl64 of the file bfd/libbfd.c of the component ld. The manipulation leads to memory corruption. The attack may be launched remotely. The complexity of an attack is rather high. The exploitation is known to be difficult. The exploit has been disclosed to the public and may be used. Upgrading to version 2.44 is able to address this issue. It is recommended to upgrade the affected component. The code maintainer explains that [t]his bug has been fixed at some point between the 2.43 and 2.44 releases.,CVE-2025-1179,tykio/tyk-plugin-compiler
binutils-dev,LOW,2.35.2-2,,A vulnerability classified as problematic has been found in GNU Binutils 2.43. This affects the function _bfd_elf_write_section_eh_frame of the file bfd/elf-eh-frame.c of the component ld. The manipulation leads to memory corruption. It is possible to initiate the attack remotely. The complexity of an attack is rather high. The exploitability is told to be difficult. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue.,CVE-2025-1180,tykio/tyk-plugin-compiler
binutils-dev,LOW,2.35.2-2,,A vulnerability classified as critical was found in GNU Binutils 2.43. This vulnerability affects the function _bfd_elf_gc_mark_rsec of the file bfd/elflink.c of the component ld. The manipulation leads to memory corruption. The attack can be initiated remotely. The complexity of an attack is rather high. The exploitation appears to be difficult. The exploit has been disclosed to the public and may be used. The name of the patch is 931494c9a89558acb36a03a340c01726545eef24. It is recommended to apply a patch to fix this issue.,CVE-2025-1181,tykio/tyk-plugin-compiler
binutils-dev,LOW,2.35.2-2,,A vulnerability which was classified as critical was found in GNU Binutils 2.43. Affected is the function bfd_elf_reloc_symbol_deleted_p of the file bfd/elflink.c of the component ld. The manipulation leads to memory corruption. It is possible to launch the attack remotely. The complexity of an attack is rather high. The exploitability is told to be difficult. The exploit has been disclosed to the public and may be used. The patch is identified as b425859021d17adf62f06fb904797cf8642986ad. It is recommended to apply a patch to fix this issue.,CVE-2025-1182,tykio/tyk-plugin-compiler
binutils-dev,LOW,2.35.2-2,,A vulnerability has been found in GNU Binutils 2.43/2.44 and classified as problematic. Affected by this vulnerability is the function display_info of the file binutils/bucomm.c of the component objdump. The manipulation leads to memory leak. An attack has to be approached locally. The exploit has been disclosed to the public and may be used. The patch is named ba6ad3a18cb26b79e0e3b84c39f707535bbc344d. It is recommended to apply a patch to fix this issue.,CVE-2025-3198,tykio/tyk-plugin-compiler
binutils-multiarch,LOW,2.35.2-2,,The C++ symbol demangler routine in cplus-dem.c in libiberty as distributed in GNU Binutils 2.29 allows remote attackers to cause a denial of service (excessive memory allocation and application crash) via a crafted file as demonstrated by a call from the Binary File Descriptor (BFD) library (aka libbfd).,CVE-2017-13716,tykio/tyk-plugin-compiler
binutils-multiarch,LOW,2.35.2-2,,The demangle_template function in cplus-dem.c in GNU libiberty as distributed in GNU Binutils 2.31.1 contains an integer overflow vulnerability (for Create an array for saving the template argument values) that can trigger a heap-based buffer overflow as demonstrated by nm.,CVE-2018-20673,tykio/tyk-plugin-compiler
binutils-multiarch,LOW,2.35.2-2,,A heap-based buffer over-read exists in the function d_expression_1 in cp-demangle.c in GNU libiberty as distributed in GNU Binutils 2.31.1. A crafted input can cause segmentation faults leading to denial-of-service as demonstrated by c++filt.,CVE-2018-20712,tykio/tyk-plugin-compiler
binutils-multiarch,LOW,2.35.2-2,,An issue was discovered in cplus-dem.c in GNU libiberty as distributed in GNU Binutils 2.30. Stack Exhaustion occurs in the C++ demangling functions provided by libiberty and there are recursive stack frames: demangle_template_value_parm demangle_integral_value and demangle_expression.,CVE-2018-9996,tykio/tyk-plugin-compiler
binutils-multiarch,LOW,2.35.2-2,,GNU binutils gold gold v1.11-v1.16 (GNU binutils v2.21-v2.31.1) is affected by: Improper Input Validation Signed/Unsigned Comparison Out-of-bounds Read. The impact is: Denial of service. The component is: gold/fileread.cc:497 elfcpp/elfcpp_file.h:644. The attack vector is: An ELF file with an invalid e_shoff header field must be opened.,CVE-2019-1010204,tykio/tyk-plugin-compiler
binutils-multiarch,LOW,2.35.2-2,,An issue was discovered in binutils libbfd.c 2.36 relating to the auxiliary symbol data allows attackers to read or write to system memory or cause a denial of service.,CVE-2020-19726,tykio/tyk-plugin-compiler
binutils-multiarch,LOW,2.35.2-2,,An issue was discovered in the Binary File Descriptor (BFD) library (aka libbfd) as distributed in GNU Binutils 2.35.1. A heap-based buffer over-read can occur in bfd_getl_signed_32 in libbfd.c because sh_entsize is not validated in _bfd_elf_slurp_secondary_reloc_section in elf.c.,CVE-2020-35448,tykio/tyk-plugin-compiler
binutils-multiarch,LOW,2.35.2-2,,There is an open race window when writing output in the following utilities in GNU binutils version 2.35 and earlier:ar objcopy strip ranlib. When these utilities are run as a privileged user (presumably as part of a script updating binaries across different users) an unprivileged user can trick these utilities into getting ownership of arbitrary files through a symlink.,CVE-2021-20197,tykio/tyk-plugin-compiler
binutils-multiarch,LOW,2.35.2-2,,A flaw was found in GNU Binutils 2.35.1 where there is a heap-based buffer overflow in _bfd_elf_slurp_secondary_reloc_section in elf.c due to the number of symbols not calculated correctly. The highest threat from this vulnerability is to system availability.,CVE-2021-20284,tykio/tyk-plugin-compiler
binutils-multiarch,LOW,2.35.2-2,,An issue was discovered in GNU libiberty as distributed in GNU Binutils 2.36. It is a stack-overflow issue in demangle_type in rust-demangle.c.,CVE-2021-32256,tykio/tyk-plugin-compiler
binutils-multiarch,LOW,2.35.2-2,,A flaw was discovered in GNU libiberty within demangle_path() in rust-demangle.c as distributed in GNU Binutils version 2.36. A crafted symbol can cause stack memory to be exhausted leading to a crash.,CVE-2021-3530,tykio/tyk-plugin-compiler
binutils-multiarch,LOW,2.35.2-2,,An out of bounds flaw was found in GNU binutils objdump utility version 2.36. An attacker could use this flaw and pass a large section to avr_elf32_load_records_from_section() probably resulting in a crash or in some cases memory corruption. The highest threat from this vulnerability is to integrity as well as system availability.,CVE-2021-3549,tykio/tyk-plugin-compiler
binutils-multiarch,LOW,2.35.2-2,,Heap/stack buffer overflow in the dlang_lname function in d-demangle.c in libiberty allows attackers to potentially cause a denial of service (segmentation fault and crash) via a crafted mangled symbol.,CVE-2021-3826,tykio/tyk-plugin-compiler
binutils-multiarch,LOW,2.35.2-2,,stab_xcoff_builtin_type in stabs.c in GNU Binutils through 2.37 allows attackers to cause a denial of service (heap-based buffer overflow) or possibly have unspecified other impact as demonstrated by an out-of-bounds write. NOTE: this issue exists because of an incorrect fix for CVE-2018-12699.,CVE-2021-45078,tykio/tyk-plugin-compiler
binutils-multiarch,LOW,2.35.2-2,,Heap-based Buffer Overflow in function bfd_getl32 in Binutils objdump 3.37.,CVE-2021-46174,tykio/tyk-plugin-compiler
binutils-multiarch,LOW,2.35.2-2,,GCC v12.0 was discovered to contain an uncontrolled recursion via the component libiberty/rust-demangle.c. This vulnerability allows attackers to cause a Denial of Service (DoS) by consuming excessive CPU and memory resources.,CVE-2021-46195,tykio/tyk-plugin-compiler
binutils-multiarch,LOW,2.35.2-2,,An issue was discovered in Binutils readelf 2.38.50 reachable assertion failure in function display_debug_names allows attackers to cause a denial of service.,CVE-2022-35205,tykio/tyk-plugin-compiler
binutils-multiarch,LOW,2.35.2-2,,Null pointer dereference vulnerability in Binutils readelf 2.38.50 via function read_and_display_attr_value in file dwarf.c.,CVE-2022-35206,tykio/tyk-plugin-compiler
binutils-multiarch,LOW,2.35.2-2,,In GNU Binutils before 2.40 there is a heap-buffer-overflow in the error function bfd_getl32 when called from the strip_main function in strip-new via a crafted file.,CVE-2022-38533,tykio/tyk-plugin-compiler
binutils-multiarch,LOW,2.35.2-2,,An illegal memory access flaw was found in the binutils package. Parsing an ELF file containing corrupt symbol version information may result in a denial of service. This issue is the result of an incomplete fix for CVE-2020-16599.,CVE-2022-4285,tykio/tyk-plugin-compiler
binutils-multiarch,LOW,2.35.2-2,,Heap buffer overflow vulnerability in binutils readelf before 2.40 via function find_section_in_set in file readelf.c.,CVE-2022-44840,tykio/tyk-plugin-compiler
binutils-multiarch,LOW,2.35.2-2,,Heap buffer overflow vulnerability in binutils readelf before 2.40 via function display_debug_section in file readelf.c.,CVE-2022-45703,tykio/tyk-plugin-compiler
binutils-multiarch,LOW,2.35.2-2,,An issue was discovered function stab_demangle_v3_arg in stabs.c in Binutils 2.34 thru 2.38 allows attackers to cause a denial of service due to memory leaks.,CVE-2022-47007,tykio/tyk-plugin-compiler
binutils-multiarch,LOW,2.35.2-2,,An issue was discovered function make_tempdir and make_tempname in bucomm.c in Binutils 2.34 thru 2.38 allows attackers to cause a denial of service due to memory leaks.,CVE-2022-47008,tykio/tyk-plugin-compiler
binutils-multiarch,LOW,2.35.2-2,,An issue was discovered function pr_function_type in prdbg.c in Binutils 2.34 thru 2.38 allows attackers to cause a denial of service due to memory leaks.,CVE-2022-47010,tykio/tyk-plugin-compiler
binutils-multiarch,LOW,2.35.2-2,,An issue was discovered function parse_stab_struct_fields in stabs.c in Binutils 2.34 thru 2.38 allows attackers to cause a denial of service due to memory leaks.,CVE-2022-47011,tykio/tyk-plugin-compiler
binutils-multiarch,LOW,2.35.2-2,,An issue was discovered in Binutils addr2line before 2.39.3 function parse_module contains multiple out of bound reads which may cause a denial of service or other unspecified impacts.,CVE-2022-47673,tykio/tyk-plugin-compiler
binutils-multiarch,LOW,2.35.2-2,,An issue was discovered Binutils objdump before 2.39.3 allows attackers to cause a denial of service or other unspecified impacts via function bfd_mach_o_get_synthetic_symtab in match-o.c.,CVE-2022-47695,tykio/tyk-plugin-compiler
binutils-multiarch,LOW,2.35.2-2,,An issue was discovered Binutils objdump before 2.39.3 allows attackers to cause a denial of service or other unspecified impacts via function compare_symbols.,CVE-2022-47696,tykio/tyk-plugin-compiler
binutils-multiarch,LOW,2.35.2-2,,GNU Binutils before 2.40 was discovered to contain an excessive memory consumption vulnerability via the function load_separate_debug_files at dwarf2.c. The attacker could supply a crafted ELF file and cause a DNS attack.,CVE-2022-48063,tykio/tyk-plugin-compiler
binutils-multiarch,LOW,2.35.2-2,,GNU Binutils before 2.40 was discovered to contain an excessive memory consumption vulnerability via the function bfd_dwarf2_find_nearest_line_with_alt at dwarf2.c. The attacker could supply a crafted ELF file and cause a DNS attack.,CVE-2022-48064,tykio/tyk-plugin-compiler
binutils-multiarch,LOW,2.35.2-2,,GNU Binutils before 2.40 was discovered to contain a memory leak vulnerability var the function find_abstract_instance in dwarf2.c.,CVE-2022-48065,tykio/tyk-plugin-compiler
binutils-multiarch,LOW,2.35.2-2,,Heap based buffer overflow in binutils-gdb/bfd/libbfd.c in bfd_getl64.,CVE-2023-1579,tykio/tyk-plugin-compiler
binutils-multiarch,LOW,2.35.2-2,,A potential heap based buffer overflow was found in _bfd_elf_slurp_version_tables() in bfd/elf.c. This may lead to loss of availability.,CVE-2023-1972,tykio/tyk-plugin-compiler
binutils-multiarch,LOW,2.35.2-2,,An out-of-bounds read flaw was found in the parse_module function in bfd/vms-alpha.c in Binutils.,CVE-2023-25584,tykio/tyk-plugin-compiler
binutils-multiarch,LOW,2.35.2-2,,A flaw was found in Binutils. The use of an uninitialized field in the struct module *module may lead to application crash and local denial of service.,CVE-2023-25585,tykio/tyk-plugin-compiler
binutils-multiarch,LOW,2.35.2-2,,A flaw was found in Binutils. A logic fail in the bfd_init_section_decompress_status function may lead to the use of an uninitialized variable that can cause a crash and local denial of service.,CVE-2023-25586,tykio/tyk-plugin-compiler
binutils-multiarch,LOW,2.35.2-2,,A flaw was found in Binutils. The field `the_bfd` of `asymbol`struct is uninitialized in the `bfd_mach_o_get_synthetic_symtab` function which may lead to an application crash and local denial of service.,CVE-2023-25588,tykio/tyk-plugin-compiler
binutils-multiarch,LOW,2.35.2-2,,GNU objdump 2.43 is vulnerable to Buffer Overflow in the BFD (Binary File Descriptor) library's handling of tekhex format files.,CVE-2024-53589,tykio/tyk-plugin-compiler
binutils-multiarch,LOW,2.35.2-2,,https://www.gnu.org/software/binutils/ nm >=2.43 is affected by: Incorrect Access Control. The type of exploitation is: local. The component is: `nm --without-symbol-version` function.,CVE-2024-57360,tykio/tyk-plugin-compiler
binutils-multiarch,LOW,2.35.2-2,,A vulnerability which was classified as problematic was found in GNU Binutils up to 2.43. This affects the function disassemble_bytes of the file binutils/objdump.c. The manipulation of the argument buf leads to stack-based buffer overflow. It is possible to initiate the attack remotely. The complexity of an attack is rather high. The exploitability is told to be difficult. The exploit has been disclosed to the public and may be used. Upgrading to version 2.44 is able to address this issue. The identifier of the patch is baac6c221e9d69335bf41366a1c7d87d8ab2f893. It is recommended to upgrade the affected component.,CVE-2025-0840,tykio/tyk-plugin-compiler
binutils-multiarch,LOW,2.35.2-2,,A vulnerability has been found in GNU Binutils 2.43 and classified as problematic. Affected by this vulnerability is the function __sanitizer::internal_strlen of the file binutils/nm.c of the component nm. The manipulation of the argument const leads to buffer overflow. The attack can be launched remotely. The complexity of an attack is rather high. The exploitation appears to be difficult. The exploit has been disclosed to the public and may be used.,CVE-2025-1147,tykio/tyk-plugin-compiler
binutils-multiarch,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43 and classified as problematic. Affected by this issue is the function link_order_scan of the file ld/ldelfgen.c of the component ld. The manipulation leads to memory leak. The attack may be launched remotely. The complexity of an attack is rather high. The exploitation is known to be difficult. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue. The code maintainer explains: I'm not going to commit some of the leak fixes I've been working on to the 2.44 branch due to concern that would destabilise ld. All of the reported leaks in this bugzilla have been fixed on binutils master.,CVE-2025-1148,tykio/tyk-plugin-compiler
binutils-multiarch,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43. It has been classified as problematic. This affects the function xstrdup of the file libiberty/xmalloc.c of the component ld. The manipulation leads to memory leak. It is possible to initiate the attack remotely. The complexity of an attack is rather high. The exploitability is told to be difficult. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue. The code maintainer explains: I'm not going to commit some of the leak fixes I've been working on to the 2.44 branch due to concern that would destabilise ld. All of the reported leaks in this bugzilla have been fixed on binutils master.,CVE-2025-1149,tykio/tyk-plugin-compiler
binutils-multiarch,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43. It has been declared as problematic. This vulnerability affects the function bfd_malloc of the file libbfd.c of the component ld. The manipulation leads to memory leak. The attack can be initiated remotely. The complexity of an attack is rather high. The exploitation appears to be difficult. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue. The code maintainer explains: I'm not going to commit some of the leak fixes I've been working on to the 2.44 branch due to concern that would destabilise ld. All of the reported leaks in this bugzilla have been fixed on binutils master.,CVE-2025-1150,tykio/tyk-plugin-compiler
binutils-multiarch,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43. It has been rated as problematic. This issue affects the function xmemdup of the file xmemdup.c of the component ld. The manipulation leads to memory leak. The attack may be initiated remotely. The complexity of an attack is rather high. The exploitation is known to be difficult. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue. The code maintainer explains: I'm not going to commit some of the leak fixes I've been working on to the 2.44 branch due to concern that would destabilise ld. All of the reported leaks in this bugzilla have been fixed on binutils master.,CVE-2025-1151,tykio/tyk-plugin-compiler
binutils-multiarch,LOW,2.35.2-2,,A vulnerability classified as problematic has been found in GNU Binutils 2.43. Affected is the function xstrdup of the file xstrdup.c of the component ld. The manipulation leads to memory leak. It is possible to launch the attack remotely. The complexity of an attack is rather high. The exploitability is told to be difficult. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue. The code maintainer explains: I'm not going to commit some of the leak fixes I've been working on to the 2.44 branch due to concern that would destabilise ld. All of the reported leaks in this bugzilla have been fixed on binutils master.,CVE-2025-1152,tykio/tyk-plugin-compiler
binutils-multiarch,LOW,2.35.2-2,,A vulnerability classified as problematic was found in GNU Binutils 2.43/2.44. Affected by this vulnerability is the function bfd_set_format of the file format.c. The manipulation leads to memory corruption. The attack can be launched remotely. The complexity of an attack is rather high. The exploitation appears to be difficult. Upgrading to version 2.45 is able to address this issue. The identifier of the patch is 8d97c1a53f3dc9fd8e1ccdb039b8a33d50133150. It is recommended to upgrade the affected component.,CVE-2025-1153,tykio/tyk-plugin-compiler
binutils-multiarch,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43 and classified as critical. This issue affects the function _bfd_elf_gc_mark_rsec of the file elflink.c of the component ld. The manipulation leads to heap-based buffer overflow. The attack may be initiated remotely. The complexity of an attack is rather high. The exploitation is known to be difficult. The exploit has been disclosed to the public and may be used. The patch is named f9978defb6fab0bd8583942d97c112b0932ac814. It is recommended to apply a patch to fix this issue.,CVE-2025-1176,tykio/tyk-plugin-compiler
binutils-multiarch,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43. It has been declared as problematic. Affected by this vulnerability is the function bfd_putl64 of the file libbfd.c of the component ld. The manipulation leads to memory corruption. The attack can be launched remotely. The complexity of an attack is rather high. The exploitation appears to be difficult. The exploit has been disclosed to the public and may be used. The identifier of the patch is 75086e9de1707281172cc77f178e7949a4414ed0. It is recommended to apply a patch to fix this issue.,CVE-2025-1178,tykio/tyk-plugin-compiler
binutils-multiarch,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43. It has been rated as critical. Affected by this issue is the function bfd_putl64 of the file bfd/libbfd.c of the component ld. The manipulation leads to memory corruption. The attack may be launched remotely. The complexity of an attack is rather high. The exploitation is known to be difficult. The exploit has been disclosed to the public and may be used. Upgrading to version 2.44 is able to address this issue. It is recommended to upgrade the affected component. The code maintainer explains that [t]his bug has been fixed at some point between the 2.43 and 2.44 releases.,CVE-2025-1179,tykio/tyk-plugin-compiler
binutils-multiarch,LOW,2.35.2-2,,A vulnerability classified as problematic has been found in GNU Binutils 2.43. This affects the function _bfd_elf_write_section_eh_frame of the file bfd/elf-eh-frame.c of the component ld. The manipulation leads to memory corruption. It is possible to initiate the attack remotely. The complexity of an attack is rather high. The exploitability is told to be difficult. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue.,CVE-2025-1180,tykio/tyk-plugin-compiler
binutils-multiarch,LOW,2.35.2-2,,A vulnerability classified as critical was found in GNU Binutils 2.43. This vulnerability affects the function _bfd_elf_gc_mark_rsec of the file bfd/elflink.c of the component ld. The manipulation leads to memory corruption. The attack can be initiated remotely. The complexity of an attack is rather high. The exploitation appears to be difficult. The exploit has been disclosed to the public and may be used. The name of the patch is 931494c9a89558acb36a03a340c01726545eef24. It is recommended to apply a patch to fix this issue.,CVE-2025-1181,tykio/tyk-plugin-compiler
binutils-multiarch,LOW,2.35.2-2,,A vulnerability which was classified as critical was found in GNU Binutils 2.43. Affected is the function bfd_elf_reloc_symbol_deleted_p of the file bfd/elflink.c of the component ld. The manipulation leads to memory corruption. It is possible to launch the attack remotely. The complexity of an attack is rather high. The exploitability is told to be difficult. The exploit has been disclosed to the public and may be used. The patch is identified as b425859021d17adf62f06fb904797cf8642986ad. It is recommended to apply a patch to fix this issue.,CVE-2025-1182,tykio/tyk-plugin-compiler
binutils-multiarch,LOW,2.35.2-2,,A vulnerability has been found in GNU Binutils 2.43/2.44 and classified as problematic. Affected by this vulnerability is the function display_info of the file binutils/bucomm.c of the component objdump. The manipulation leads to memory leak. An attack has to be approached locally. The exploit has been disclosed to the public and may be used. The patch is named ba6ad3a18cb26b79e0e3b84c39f707535bbc344d. It is recommended to apply a patch to fix this issue.,CVE-2025-3198,tykio/tyk-plugin-compiler
binutils-multiarch-dev,LOW,2.35.2-2,,The C++ symbol demangler routine in cplus-dem.c in libiberty as distributed in GNU Binutils 2.29 allows remote attackers to cause a denial of service (excessive memory allocation and application crash) via a crafted file as demonstrated by a call from the Binary File Descriptor (BFD) library (aka libbfd).,CVE-2017-13716,tykio/tyk-plugin-compiler
binutils-multiarch-dev,LOW,2.35.2-2,,The demangle_template function in cplus-dem.c in GNU libiberty as distributed in GNU Binutils 2.31.1 contains an integer overflow vulnerability (for Create an array for saving the template argument values) that can trigger a heap-based buffer overflow as demonstrated by nm.,CVE-2018-20673,tykio/tyk-plugin-compiler
binutils-multiarch-dev,LOW,2.35.2-2,,A heap-based buffer over-read exists in the function d_expression_1 in cp-demangle.c in GNU libiberty as distributed in GNU Binutils 2.31.1. A crafted input can cause segmentation faults leading to denial-of-service as demonstrated by c++filt.,CVE-2018-20712,tykio/tyk-plugin-compiler
binutils-multiarch-dev,LOW,2.35.2-2,,An issue was discovered in cplus-dem.c in GNU libiberty as distributed in GNU Binutils 2.30. Stack Exhaustion occurs in the C++ demangling functions provided by libiberty and there are recursive stack frames: demangle_template_value_parm demangle_integral_value and demangle_expression.,CVE-2018-9996,tykio/tyk-plugin-compiler
binutils-multiarch-dev,LOW,2.35.2-2,,GNU binutils gold gold v1.11-v1.16 (GNU binutils v2.21-v2.31.1) is affected by: Improper Input Validation Signed/Unsigned Comparison Out-of-bounds Read. The impact is: Denial of service. The component is: gold/fileread.cc:497 elfcpp/elfcpp_file.h:644. The attack vector is: An ELF file with an invalid e_shoff header field must be opened.,CVE-2019-1010204,tykio/tyk-plugin-compiler
binutils-multiarch-dev,LOW,2.35.2-2,,An issue was discovered in binutils libbfd.c 2.36 relating to the auxiliary symbol data allows attackers to read or write to system memory or cause a denial of service.,CVE-2020-19726,tykio/tyk-plugin-compiler
binutils-multiarch-dev,LOW,2.35.2-2,,An issue was discovered in the Binary File Descriptor (BFD) library (aka libbfd) as distributed in GNU Binutils 2.35.1. A heap-based buffer over-read can occur in bfd_getl_signed_32 in libbfd.c because sh_entsize is not validated in _bfd_elf_slurp_secondary_reloc_section in elf.c.,CVE-2020-35448,tykio/tyk-plugin-compiler
binutils-multiarch-dev,LOW,2.35.2-2,,There is an open race window when writing output in the following utilities in GNU binutils version 2.35 and earlier:ar objcopy strip ranlib. When these utilities are run as a privileged user (presumably as part of a script updating binaries across different users) an unprivileged user can trick these utilities into getting ownership of arbitrary files through a symlink.,CVE-2021-20197,tykio/tyk-plugin-compiler
binutils-multiarch-dev,LOW,2.35.2-2,,A flaw was found in GNU Binutils 2.35.1 where there is a heap-based buffer overflow in _bfd_elf_slurp_secondary_reloc_section in elf.c due to the number of symbols not calculated correctly. The highest threat from this vulnerability is to system availability.,CVE-2021-20284,tykio/tyk-plugin-compiler
binutils-multiarch-dev,LOW,2.35.2-2,,An issue was discovered in GNU libiberty as distributed in GNU Binutils 2.36. It is a stack-overflow issue in demangle_type in rust-demangle.c.,CVE-2021-32256,tykio/tyk-plugin-compiler
binutils-multiarch-dev,LOW,2.35.2-2,,A flaw was discovered in GNU libiberty within demangle_path() in rust-demangle.c as distributed in GNU Binutils version 2.36. A crafted symbol can cause stack memory to be exhausted leading to a crash.,CVE-2021-3530,tykio/tyk-plugin-compiler
binutils-multiarch-dev,LOW,2.35.2-2,,An out of bounds flaw was found in GNU binutils objdump utility version 2.36. An attacker could use this flaw and pass a large section to avr_elf32_load_records_from_section() probably resulting in a crash or in some cases memory corruption. The highest threat from this vulnerability is to integrity as well as system availability.,CVE-2021-3549,tykio/tyk-plugin-compiler
binutils-multiarch-dev,LOW,2.35.2-2,,Heap/stack buffer overflow in the dlang_lname function in d-demangle.c in libiberty allows attackers to potentially cause a denial of service (segmentation fault and crash) via a crafted mangled symbol.,CVE-2021-3826,tykio/tyk-plugin-compiler
binutils-multiarch-dev,LOW,2.35.2-2,,stab_xcoff_builtin_type in stabs.c in GNU Binutils through 2.37 allows attackers to cause a denial of service (heap-based buffer overflow) or possibly have unspecified other impact as demonstrated by an out-of-bounds write. NOTE: this issue exists because of an incorrect fix for CVE-2018-12699.,CVE-2021-45078,tykio/tyk-plugin-compiler
binutils-multiarch-dev,LOW,2.35.2-2,,Heap-based Buffer Overflow in function bfd_getl32 in Binutils objdump 3.37.,CVE-2021-46174,tykio/tyk-plugin-compiler
binutils-multiarch-dev,LOW,2.35.2-2,,GCC v12.0 was discovered to contain an uncontrolled recursion via the component libiberty/rust-demangle.c. This vulnerability allows attackers to cause a Denial of Service (DoS) by consuming excessive CPU and memory resources.,CVE-2021-46195,tykio/tyk-plugin-compiler
binutils-multiarch-dev,LOW,2.35.2-2,,An issue was discovered in Binutils readelf 2.38.50 reachable assertion failure in function display_debug_names allows attackers to cause a denial of service.,CVE-2022-35205,tykio/tyk-plugin-compiler
binutils-multiarch-dev,LOW,2.35.2-2,,Null pointer dereference vulnerability in Binutils readelf 2.38.50 via function read_and_display_attr_value in file dwarf.c.,CVE-2022-35206,tykio/tyk-plugin-compiler
binutils-multiarch-dev,LOW,2.35.2-2,,In GNU Binutils before 2.40 there is a heap-buffer-overflow in the error function bfd_getl32 when called from the strip_main function in strip-new via a crafted file.,CVE-2022-38533,tykio/tyk-plugin-compiler
binutils-multiarch-dev,LOW,2.35.2-2,,An illegal memory access flaw was found in the binutils package. Parsing an ELF file containing corrupt symbol version information may result in a denial of service. This issue is the result of an incomplete fix for CVE-2020-16599.,CVE-2022-4285,tykio/tyk-plugin-compiler
binutils-multiarch-dev,LOW,2.35.2-2,,Heap buffer overflow vulnerability in binutils readelf before 2.40 via function find_section_in_set in file readelf.c.,CVE-2022-44840,tykio/tyk-plugin-compiler
binutils-multiarch-dev,LOW,2.35.2-2,,Heap buffer overflow vulnerability in binutils readelf before 2.40 via function display_debug_section in file readelf.c.,CVE-2022-45703,tykio/tyk-plugin-compiler
binutils-multiarch-dev,LOW,2.35.2-2,,An issue was discovered function stab_demangle_v3_arg in stabs.c in Binutils 2.34 thru 2.38 allows attackers to cause a denial of service due to memory leaks.,CVE-2022-47007,tykio/tyk-plugin-compiler
binutils-multiarch-dev,LOW,2.35.2-2,,An issue was discovered function make_tempdir and make_tempname in bucomm.c in Binutils 2.34 thru 2.38 allows attackers to cause a denial of service due to memory leaks.,CVE-2022-47008,tykio/tyk-plugin-compiler
binutils-multiarch-dev,LOW,2.35.2-2,,An issue was discovered function pr_function_type in prdbg.c in Binutils 2.34 thru 2.38 allows attackers to cause a denial of service due to memory leaks.,CVE-2022-47010,tykio/tyk-plugin-compiler
binutils-multiarch-dev,LOW,2.35.2-2,,An issue was discovered function parse_stab_struct_fields in stabs.c in Binutils 2.34 thru 2.38 allows attackers to cause a denial of service due to memory leaks.,CVE-2022-47011,tykio/tyk-plugin-compiler
binutils-multiarch-dev,LOW,2.35.2-2,,An issue was discovered in Binutils addr2line before 2.39.3 function parse_module contains multiple out of bound reads which may cause a denial of service or other unspecified impacts.,CVE-2022-47673,tykio/tyk-plugin-compiler
binutils-multiarch-dev,LOW,2.35.2-2,,An issue was discovered Binutils objdump before 2.39.3 allows attackers to cause a denial of service or other unspecified impacts via function bfd_mach_o_get_synthetic_symtab in match-o.c.,CVE-2022-47695,tykio/tyk-plugin-compiler
binutils-multiarch-dev,LOW,2.35.2-2,,An issue was discovered Binutils objdump before 2.39.3 allows attackers to cause a denial of service or other unspecified impacts via function compare_symbols.,CVE-2022-47696,tykio/tyk-plugin-compiler
binutils-multiarch-dev,LOW,2.35.2-2,,GNU Binutils before 2.40 was discovered to contain an excessive memory consumption vulnerability via the function load_separate_debug_files at dwarf2.c. The attacker could supply a crafted ELF file and cause a DNS attack.,CVE-2022-48063,tykio/tyk-plugin-compiler
binutils-multiarch-dev,LOW,2.35.2-2,,GNU Binutils before 2.40 was discovered to contain an excessive memory consumption vulnerability via the function bfd_dwarf2_find_nearest_line_with_alt at dwarf2.c. The attacker could supply a crafted ELF file and cause a DNS attack.,CVE-2022-48064,tykio/tyk-plugin-compiler
binutils-multiarch-dev,LOW,2.35.2-2,,GNU Binutils before 2.40 was discovered to contain a memory leak vulnerability var the function find_abstract_instance in dwarf2.c.,CVE-2022-48065,tykio/tyk-plugin-compiler
binutils-multiarch-dev,LOW,2.35.2-2,,Heap based buffer overflow in binutils-gdb/bfd/libbfd.c in bfd_getl64.,CVE-2023-1579,tykio/tyk-plugin-compiler
binutils-multiarch-dev,LOW,2.35.2-2,,A potential heap based buffer overflow was found in _bfd_elf_slurp_version_tables() in bfd/elf.c. This may lead to loss of availability.,CVE-2023-1972,tykio/tyk-plugin-compiler
binutils-multiarch-dev,LOW,2.35.2-2,,An out-of-bounds read flaw was found in the parse_module function in bfd/vms-alpha.c in Binutils.,CVE-2023-25584,tykio/tyk-plugin-compiler
binutils-multiarch-dev,LOW,2.35.2-2,,A flaw was found in Binutils. The use of an uninitialized field in the struct module *module may lead to application crash and local denial of service.,CVE-2023-25585,tykio/tyk-plugin-compiler
binutils-multiarch-dev,LOW,2.35.2-2,,A flaw was found in Binutils. A logic fail in the bfd_init_section_decompress_status function may lead to the use of an uninitialized variable that can cause a crash and local denial of service.,CVE-2023-25586,tykio/tyk-plugin-compiler
binutils-multiarch-dev,LOW,2.35.2-2,,A flaw was found in Binutils. The field `the_bfd` of `asymbol`struct is uninitialized in the `bfd_mach_o_get_synthetic_symtab` function which may lead to an application crash and local denial of service.,CVE-2023-25588,tykio/tyk-plugin-compiler
binutils-multiarch-dev,LOW,2.35.2-2,,GNU objdump 2.43 is vulnerable to Buffer Overflow in the BFD (Binary File Descriptor) library's handling of tekhex format files.,CVE-2024-53589,tykio/tyk-plugin-compiler
binutils-multiarch-dev,LOW,2.35.2-2,,https://www.gnu.org/software/binutils/ nm >=2.43 is affected by: Incorrect Access Control. The type of exploitation is: local. The component is: `nm --without-symbol-version` function.,CVE-2024-57360,tykio/tyk-plugin-compiler
binutils-multiarch-dev,LOW,2.35.2-2,,A vulnerability which was classified as problematic was found in GNU Binutils up to 2.43. This affects the function disassemble_bytes of the file binutils/objdump.c. The manipulation of the argument buf leads to stack-based buffer overflow. It is possible to initiate the attack remotely. The complexity of an attack is rather high. The exploitability is told to be difficult. The exploit has been disclosed to the public and may be used. Upgrading to version 2.44 is able to address this issue. The identifier of the patch is baac6c221e9d69335bf41366a1c7d87d8ab2f893. It is recommended to upgrade the affected component.,CVE-2025-0840,tykio/tyk-plugin-compiler
binutils-multiarch-dev,LOW,2.35.2-2,,A vulnerability has been found in GNU Binutils 2.43 and classified as problematic. Affected by this vulnerability is the function __sanitizer::internal_strlen of the file binutils/nm.c of the component nm. The manipulation of the argument const leads to buffer overflow. The attack can be launched remotely. The complexity of an attack is rather high. The exploitation appears to be difficult. The exploit has been disclosed to the public and may be used.,CVE-2025-1147,tykio/tyk-plugin-compiler
binutils-multiarch-dev,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43 and classified as problematic. Affected by this issue is the function link_order_scan of the file ld/ldelfgen.c of the component ld. The manipulation leads to memory leak. The attack may be launched remotely. The complexity of an attack is rather high. The exploitation is known to be difficult. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue. The code maintainer explains: I'm not going to commit some of the leak fixes I've been working on to the 2.44 branch due to concern that would destabilise ld. All of the reported leaks in this bugzilla have been fixed on binutils master.,CVE-2025-1148,tykio/tyk-plugin-compiler
binutils-multiarch-dev,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43. It has been classified as problematic. This affects the function xstrdup of the file libiberty/xmalloc.c of the component ld. The manipulation leads to memory leak. It is possible to initiate the attack remotely. The complexity of an attack is rather high. The exploitability is told to be difficult. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue. The code maintainer explains: I'm not going to commit some of the leak fixes I've been working on to the 2.44 branch due to concern that would destabilise ld. All of the reported leaks in this bugzilla have been fixed on binutils master.,CVE-2025-1149,tykio/tyk-plugin-compiler
binutils-multiarch-dev,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43. It has been declared as problematic. This vulnerability affects the function bfd_malloc of the file libbfd.c of the component ld. The manipulation leads to memory leak. The attack can be initiated remotely. The complexity of an attack is rather high. The exploitation appears to be difficult. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue. The code maintainer explains: I'm not going to commit some of the leak fixes I've been working on to the 2.44 branch due to concern that would destabilise ld. All of the reported leaks in this bugzilla have been fixed on binutils master.,CVE-2025-1150,tykio/tyk-plugin-compiler
binutils-multiarch-dev,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43. It has been rated as problematic. This issue affects the function xmemdup of the file xmemdup.c of the component ld. The manipulation leads to memory leak. The attack may be initiated remotely. The complexity of an attack is rather high. The exploitation is known to be difficult. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue. The code maintainer explains: I'm not going to commit some of the leak fixes I've been working on to the 2.44 branch due to concern that would destabilise ld. All of the reported leaks in this bugzilla have been fixed on binutils master.,CVE-2025-1151,tykio/tyk-plugin-compiler
binutils-multiarch-dev,LOW,2.35.2-2,,A vulnerability classified as problematic has been found in GNU Binutils 2.43. Affected is the function xstrdup of the file xstrdup.c of the component ld. The manipulation leads to memory leak. It is possible to launch the attack remotely. The complexity of an attack is rather high. The exploitability is told to be difficult. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue. The code maintainer explains: I'm not going to commit some of the leak fixes I've been working on to the 2.44 branch due to concern that would destabilise ld. All of the reported leaks in this bugzilla have been fixed on binutils master.,CVE-2025-1152,tykio/tyk-plugin-compiler
binutils-multiarch-dev,LOW,2.35.2-2,,A vulnerability classified as problematic was found in GNU Binutils 2.43/2.44. Affected by this vulnerability is the function bfd_set_format of the file format.c. The manipulation leads to memory corruption. The attack can be launched remotely. The complexity of an attack is rather high. The exploitation appears to be difficult. Upgrading to version 2.45 is able to address this issue. The identifier of the patch is 8d97c1a53f3dc9fd8e1ccdb039b8a33d50133150. It is recommended to upgrade the affected component.,CVE-2025-1153,tykio/tyk-plugin-compiler
binutils-multiarch-dev,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43 and classified as critical. This issue affects the function _bfd_elf_gc_mark_rsec of the file elflink.c of the component ld. The manipulation leads to heap-based buffer overflow. The attack may be initiated remotely. The complexity of an attack is rather high. The exploitation is known to be difficult. The exploit has been disclosed to the public and may be used. The patch is named f9978defb6fab0bd8583942d97c112b0932ac814. It is recommended to apply a patch to fix this issue.,CVE-2025-1176,tykio/tyk-plugin-compiler
binutils-multiarch-dev,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43. It has been declared as problematic. Affected by this vulnerability is the function bfd_putl64 of the file libbfd.c of the component ld. The manipulation leads to memory corruption. The attack can be launched remotely. The complexity of an attack is rather high. The exploitation appears to be difficult. The exploit has been disclosed to the public and may be used. The identifier of the patch is 75086e9de1707281172cc77f178e7949a4414ed0. It is recommended to apply a patch to fix this issue.,CVE-2025-1178,tykio/tyk-plugin-compiler
binutils-multiarch-dev,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43. It has been rated as critical. Affected by this issue is the function bfd_putl64 of the file bfd/libbfd.c of the component ld. The manipulation leads to memory corruption. The attack may be launched remotely. The complexity of an attack is rather high. The exploitation is known to be difficult. The exploit has been disclosed to the public and may be used. Upgrading to version 2.44 is able to address this issue. It is recommended to upgrade the affected component. The code maintainer explains that [t]his bug has been fixed at some point between the 2.43 and 2.44 releases.,CVE-2025-1179,tykio/tyk-plugin-compiler
binutils-multiarch-dev,LOW,2.35.2-2,,A vulnerability classified as problematic has been found in GNU Binutils 2.43. This affects the function _bfd_elf_write_section_eh_frame of the file bfd/elf-eh-frame.c of the component ld. The manipulation leads to memory corruption. It is possible to initiate the attack remotely. The complexity of an attack is rather high. The exploitability is told to be difficult. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue.,CVE-2025-1180,tykio/tyk-plugin-compiler
binutils-multiarch-dev,LOW,2.35.2-2,,A vulnerability classified as critical was found in GNU Binutils 2.43. This vulnerability affects the function _bfd_elf_gc_mark_rsec of the file bfd/elflink.c of the component ld. The manipulation leads to memory corruption. The attack can be initiated remotely. The complexity of an attack is rather high. The exploitation appears to be difficult. The exploit has been disclosed to the public and may be used. The name of the patch is 931494c9a89558acb36a03a340c01726545eef24. It is recommended to apply a patch to fix this issue.,CVE-2025-1181,tykio/tyk-plugin-compiler
binutils-multiarch-dev,LOW,2.35.2-2,,A vulnerability which was classified as critical was found in GNU Binutils 2.43. Affected is the function bfd_elf_reloc_symbol_deleted_p of the file bfd/elflink.c of the component ld. The manipulation leads to memory corruption. It is possible to launch the attack remotely. The complexity of an attack is rather high. The exploitability is told to be difficult. The exploit has been disclosed to the public and may be used. The patch is identified as b425859021d17adf62f06fb904797cf8642986ad. It is recommended to apply a patch to fix this issue.,CVE-2025-1182,tykio/tyk-plugin-compiler
binutils-multiarch-dev,LOW,2.35.2-2,,A vulnerability has been found in GNU Binutils 2.43/2.44 and classified as problematic. Affected by this vulnerability is the function display_info of the file binutils/bucomm.c of the component objdump. The manipulation leads to memory leak. An attack has to be approached locally. The exploit has been disclosed to the public and may be used. The patch is named ba6ad3a18cb26b79e0e3b84c39f707535bbc344d. It is recommended to apply a patch to fix this issue.,CVE-2025-3198,tykio/tyk-plugin-compiler
binutils-powerpc64le-linux-gnu,LOW,2.35.2-2,,The C++ symbol demangler routine in cplus-dem.c in libiberty as distributed in GNU Binutils 2.29 allows remote attackers to cause a denial of service (excessive memory allocation and application crash) via a crafted file as demonstrated by a call from the Binary File Descriptor (BFD) library (aka libbfd).,CVE-2017-13716,tykio/tyk-plugin-compiler
binutils-powerpc64le-linux-gnu,LOW,2.35.2-2,,The demangle_template function in cplus-dem.c in GNU libiberty as distributed in GNU Binutils 2.31.1 contains an integer overflow vulnerability (for Create an array for saving the template argument values) that can trigger a heap-based buffer overflow as demonstrated by nm.,CVE-2018-20673,tykio/tyk-plugin-compiler
binutils-powerpc64le-linux-gnu,LOW,2.35.2-2,,A heap-based buffer over-read exists in the function d_expression_1 in cp-demangle.c in GNU libiberty as distributed in GNU Binutils 2.31.1. A crafted input can cause segmentation faults leading to denial-of-service as demonstrated by c++filt.,CVE-2018-20712,tykio/tyk-plugin-compiler
binutils-powerpc64le-linux-gnu,LOW,2.35.2-2,,An issue was discovered in cplus-dem.c in GNU libiberty as distributed in GNU Binutils 2.30. Stack Exhaustion occurs in the C++ demangling functions provided by libiberty and there are recursive stack frames: demangle_template_value_parm demangle_integral_value and demangle_expression.,CVE-2018-9996,tykio/tyk-plugin-compiler
binutils-powerpc64le-linux-gnu,LOW,2.35.2-2,,GNU binutils gold gold v1.11-v1.16 (GNU binutils v2.21-v2.31.1) is affected by: Improper Input Validation Signed/Unsigned Comparison Out-of-bounds Read. The impact is: Denial of service. The component is: gold/fileread.cc:497 elfcpp/elfcpp_file.h:644. The attack vector is: An ELF file with an invalid e_shoff header field must be opened.,CVE-2019-1010204,tykio/tyk-plugin-compiler
binutils-powerpc64le-linux-gnu,LOW,2.35.2-2,,An issue was discovered in binutils libbfd.c 2.36 relating to the auxiliary symbol data allows attackers to read or write to system memory or cause a denial of service.,CVE-2020-19726,tykio/tyk-plugin-compiler
binutils-powerpc64le-linux-gnu,LOW,2.35.2-2,,An issue was discovered in the Binary File Descriptor (BFD) library (aka libbfd) as distributed in GNU Binutils 2.35.1. A heap-based buffer over-read can occur in bfd_getl_signed_32 in libbfd.c because sh_entsize is not validated in _bfd_elf_slurp_secondary_reloc_section in elf.c.,CVE-2020-35448,tykio/tyk-plugin-compiler
binutils-powerpc64le-linux-gnu,LOW,2.35.2-2,,There is an open race window when writing output in the following utilities in GNU binutils version 2.35 and earlier:ar objcopy strip ranlib. When these utilities are run as a privileged user (presumably as part of a script updating binaries across different users) an unprivileged user can trick these utilities into getting ownership of arbitrary files through a symlink.,CVE-2021-20197,tykio/tyk-plugin-compiler
binutils-powerpc64le-linux-gnu,LOW,2.35.2-2,,A flaw was found in GNU Binutils 2.35.1 where there is a heap-based buffer overflow in _bfd_elf_slurp_secondary_reloc_section in elf.c due to the number of symbols not calculated correctly. The highest threat from this vulnerability is to system availability.,CVE-2021-20284,tykio/tyk-plugin-compiler
binutils-powerpc64le-linux-gnu,LOW,2.35.2-2,,An issue was discovered in GNU libiberty as distributed in GNU Binutils 2.36. It is a stack-overflow issue in demangle_type in rust-demangle.c.,CVE-2021-32256,tykio/tyk-plugin-compiler
binutils-powerpc64le-linux-gnu,LOW,2.35.2-2,,A flaw was discovered in GNU libiberty within demangle_path() in rust-demangle.c as distributed in GNU Binutils version 2.36. A crafted symbol can cause stack memory to be exhausted leading to a crash.,CVE-2021-3530,tykio/tyk-plugin-compiler
binutils-powerpc64le-linux-gnu,LOW,2.35.2-2,,An out of bounds flaw was found in GNU binutils objdump utility version 2.36. An attacker could use this flaw and pass a large section to avr_elf32_load_records_from_section() probably resulting in a crash or in some cases memory corruption. The highest threat from this vulnerability is to integrity as well as system availability.,CVE-2021-3549,tykio/tyk-plugin-compiler
binutils-powerpc64le-linux-gnu,LOW,2.35.2-2,,Heap/stack buffer overflow in the dlang_lname function in d-demangle.c in libiberty allows attackers to potentially cause a denial of service (segmentation fault and crash) via a crafted mangled symbol.,CVE-2021-3826,tykio/tyk-plugin-compiler
binutils-powerpc64le-linux-gnu,LOW,2.35.2-2,,stab_xcoff_builtin_type in stabs.c in GNU Binutils through 2.37 allows attackers to cause a denial of service (heap-based buffer overflow) or possibly have unspecified other impact as demonstrated by an out-of-bounds write. NOTE: this issue exists because of an incorrect fix for CVE-2018-12699.,CVE-2021-45078,tykio/tyk-plugin-compiler
binutils-powerpc64le-linux-gnu,LOW,2.35.2-2,,Heap-based Buffer Overflow in function bfd_getl32 in Binutils objdump 3.37.,CVE-2021-46174,tykio/tyk-plugin-compiler
binutils-powerpc64le-linux-gnu,LOW,2.35.2-2,,GCC v12.0 was discovered to contain an uncontrolled recursion via the component libiberty/rust-demangle.c. This vulnerability allows attackers to cause a Denial of Service (DoS) by consuming excessive CPU and memory resources.,CVE-2021-46195,tykio/tyk-plugin-compiler
binutils-powerpc64le-linux-gnu,LOW,2.35.2-2,,An issue was discovered in Binutils readelf 2.38.50 reachable assertion failure in function display_debug_names allows attackers to cause a denial of service.,CVE-2022-35205,tykio/tyk-plugin-compiler
binutils-powerpc64le-linux-gnu,LOW,2.35.2-2,,Null pointer dereference vulnerability in Binutils readelf 2.38.50 via function read_and_display_attr_value in file dwarf.c.,CVE-2022-35206,tykio/tyk-plugin-compiler
binutils-powerpc64le-linux-gnu,LOW,2.35.2-2,,In GNU Binutils before 2.40 there is a heap-buffer-overflow in the error function bfd_getl32 when called from the strip_main function in strip-new via a crafted file.,CVE-2022-38533,tykio/tyk-plugin-compiler
binutils-powerpc64le-linux-gnu,LOW,2.35.2-2,,An illegal memory access flaw was found in the binutils package. Parsing an ELF file containing corrupt symbol version information may result in a denial of service. This issue is the result of an incomplete fix for CVE-2020-16599.,CVE-2022-4285,tykio/tyk-plugin-compiler
binutils-powerpc64le-linux-gnu,LOW,2.35.2-2,,Heap buffer overflow vulnerability in binutils readelf before 2.40 via function find_section_in_set in file readelf.c.,CVE-2022-44840,tykio/tyk-plugin-compiler
binutils-powerpc64le-linux-gnu,LOW,2.35.2-2,,Heap buffer overflow vulnerability in binutils readelf before 2.40 via function display_debug_section in file readelf.c.,CVE-2022-45703,tykio/tyk-plugin-compiler
binutils-powerpc64le-linux-gnu,LOW,2.35.2-2,,An issue was discovered function stab_demangle_v3_arg in stabs.c in Binutils 2.34 thru 2.38 allows attackers to cause a denial of service due to memory leaks.,CVE-2022-47007,tykio/tyk-plugin-compiler
binutils-powerpc64le-linux-gnu,LOW,2.35.2-2,,An issue was discovered function make_tempdir and make_tempname in bucomm.c in Binutils 2.34 thru 2.38 allows attackers to cause a denial of service due to memory leaks.,CVE-2022-47008,tykio/tyk-plugin-compiler
binutils-powerpc64le-linux-gnu,LOW,2.35.2-2,,An issue was discovered function pr_function_type in prdbg.c in Binutils 2.34 thru 2.38 allows attackers to cause a denial of service due to memory leaks.,CVE-2022-47010,tykio/tyk-plugin-compiler
binutils-powerpc64le-linux-gnu,LOW,2.35.2-2,,An issue was discovered function parse_stab_struct_fields in stabs.c in Binutils 2.34 thru 2.38 allows attackers to cause a denial of service due to memory leaks.,CVE-2022-47011,tykio/tyk-plugin-compiler
binutils-powerpc64le-linux-gnu,LOW,2.35.2-2,,An issue was discovered in Binutils addr2line before 2.39.3 function parse_module contains multiple out of bound reads which may cause a denial of service or other unspecified impacts.,CVE-2022-47673,tykio/tyk-plugin-compiler
binutils-powerpc64le-linux-gnu,LOW,2.35.2-2,,An issue was discovered Binutils objdump before 2.39.3 allows attackers to cause a denial of service or other unspecified impacts via function bfd_mach_o_get_synthetic_symtab in match-o.c.,CVE-2022-47695,tykio/tyk-plugin-compiler
binutils-powerpc64le-linux-gnu,LOW,2.35.2-2,,An issue was discovered Binutils objdump before 2.39.3 allows attackers to cause a denial of service or other unspecified impacts via function compare_symbols.,CVE-2022-47696,tykio/tyk-plugin-compiler
binutils-powerpc64le-linux-gnu,LOW,2.35.2-2,,GNU Binutils before 2.40 was discovered to contain an excessive memory consumption vulnerability via the function load_separate_debug_files at dwarf2.c. The attacker could supply a crafted ELF file and cause a DNS attack.,CVE-2022-48063,tykio/tyk-plugin-compiler
binutils-powerpc64le-linux-gnu,LOW,2.35.2-2,,GNU Binutils before 2.40 was discovered to contain an excessive memory consumption vulnerability via the function bfd_dwarf2_find_nearest_line_with_alt at dwarf2.c. The attacker could supply a crafted ELF file and cause a DNS attack.,CVE-2022-48064,tykio/tyk-plugin-compiler
binutils-powerpc64le-linux-gnu,LOW,2.35.2-2,,GNU Binutils before 2.40 was discovered to contain a memory leak vulnerability var the function find_abstract_instance in dwarf2.c.,CVE-2022-48065,tykio/tyk-plugin-compiler
binutils-powerpc64le-linux-gnu,LOW,2.35.2-2,,Heap based buffer overflow in binutils-gdb/bfd/libbfd.c in bfd_getl64.,CVE-2023-1579,tykio/tyk-plugin-compiler
binutils-powerpc64le-linux-gnu,LOW,2.35.2-2,,A potential heap based buffer overflow was found in _bfd_elf_slurp_version_tables() in bfd/elf.c. This may lead to loss of availability.,CVE-2023-1972,tykio/tyk-plugin-compiler
binutils-powerpc64le-linux-gnu,LOW,2.35.2-2,,An out-of-bounds read flaw was found in the parse_module function in bfd/vms-alpha.c in Binutils.,CVE-2023-25584,tykio/tyk-plugin-compiler
binutils-powerpc64le-linux-gnu,LOW,2.35.2-2,,A flaw was found in Binutils. The use of an uninitialized field in the struct module *module may lead to application crash and local denial of service.,CVE-2023-25585,tykio/tyk-plugin-compiler
binutils-powerpc64le-linux-gnu,LOW,2.35.2-2,,A flaw was found in Binutils. A logic fail in the bfd_init_section_decompress_status function may lead to the use of an uninitialized variable that can cause a crash and local denial of service.,CVE-2023-25586,tykio/tyk-plugin-compiler
binutils-powerpc64le-linux-gnu,LOW,2.35.2-2,,A flaw was found in Binutils. The field `the_bfd` of `asymbol`struct is uninitialized in the `bfd_mach_o_get_synthetic_symtab` function which may lead to an application crash and local denial of service.,CVE-2023-25588,tykio/tyk-plugin-compiler
binutils-powerpc64le-linux-gnu,LOW,2.35.2-2,,GNU objdump 2.43 is vulnerable to Buffer Overflow in the BFD (Binary File Descriptor) library's handling of tekhex format files.,CVE-2024-53589,tykio/tyk-plugin-compiler
binutils-powerpc64le-linux-gnu,LOW,2.35.2-2,,https://www.gnu.org/software/binutils/ nm >=2.43 is affected by: Incorrect Access Control. The type of exploitation is: local. The component is: `nm --without-symbol-version` function.,CVE-2024-57360,tykio/tyk-plugin-compiler
binutils-powerpc64le-linux-gnu,LOW,2.35.2-2,,A vulnerability which was classified as problematic was found in GNU Binutils up to 2.43. This affects the function disassemble_bytes of the file binutils/objdump.c. The manipulation of the argument buf leads to stack-based buffer overflow. It is possible to initiate the attack remotely. The complexity of an attack is rather high. The exploitability is told to be difficult. The exploit has been disclosed to the public and may be used. Upgrading to version 2.44 is able to address this issue. The identifier of the patch is baac6c221e9d69335bf41366a1c7d87d8ab2f893. It is recommended to upgrade the affected component.,CVE-2025-0840,tykio/tyk-plugin-compiler
binutils-powerpc64le-linux-gnu,LOW,2.35.2-2,,A vulnerability has been found in GNU Binutils 2.43 and classified as problematic. Affected by this vulnerability is the function __sanitizer::internal_strlen of the file binutils/nm.c of the component nm. The manipulation of the argument const leads to buffer overflow. The attack can be launched remotely. The complexity of an attack is rather high. The exploitation appears to be difficult. The exploit has been disclosed to the public and may be used.,CVE-2025-1147,tykio/tyk-plugin-compiler
binutils-powerpc64le-linux-gnu,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43 and classified as problematic. Affected by this issue is the function link_order_scan of the file ld/ldelfgen.c of the component ld. The manipulation leads to memory leak. The attack may be launched remotely. The complexity of an attack is rather high. The exploitation is known to be difficult. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue. The code maintainer explains: I'm not going to commit some of the leak fixes I've been working on to the 2.44 branch due to concern that would destabilise ld. All of the reported leaks in this bugzilla have been fixed on binutils master.,CVE-2025-1148,tykio/tyk-plugin-compiler
binutils-powerpc64le-linux-gnu,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43. It has been classified as problematic. This affects the function xstrdup of the file libiberty/xmalloc.c of the component ld. The manipulation leads to memory leak. It is possible to initiate the attack remotely. The complexity of an attack is rather high. The exploitability is told to be difficult. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue. The code maintainer explains: I'm not going to commit some of the leak fixes I've been working on to the 2.44 branch due to concern that would destabilise ld. All of the reported leaks in this bugzilla have been fixed on binutils master.,CVE-2025-1149,tykio/tyk-plugin-compiler
binutils-powerpc64le-linux-gnu,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43. It has been declared as problematic. This vulnerability affects the function bfd_malloc of the file libbfd.c of the component ld. The manipulation leads to memory leak. The attack can be initiated remotely. The complexity of an attack is rather high. The exploitation appears to be difficult. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue. The code maintainer explains: I'm not going to commit some of the leak fixes I've been working on to the 2.44 branch due to concern that would destabilise ld. All of the reported leaks in this bugzilla have been fixed on binutils master.,CVE-2025-1150,tykio/tyk-plugin-compiler
binutils-powerpc64le-linux-gnu,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43. It has been rated as problematic. This issue affects the function xmemdup of the file xmemdup.c of the component ld. The manipulation leads to memory leak. The attack may be initiated remotely. The complexity of an attack is rather high. The exploitation is known to be difficult. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue. The code maintainer explains: I'm not going to commit some of the leak fixes I've been working on to the 2.44 branch due to concern that would destabilise ld. All of the reported leaks in this bugzilla have been fixed on binutils master.,CVE-2025-1151,tykio/tyk-plugin-compiler
binutils-powerpc64le-linux-gnu,LOW,2.35.2-2,,A vulnerability classified as problematic has been found in GNU Binutils 2.43. Affected is the function xstrdup of the file xstrdup.c of the component ld. The manipulation leads to memory leak. It is possible to launch the attack remotely. The complexity of an attack is rather high. The exploitability is told to be difficult. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue. The code maintainer explains: I'm not going to commit some of the leak fixes I've been working on to the 2.44 branch due to concern that would destabilise ld. All of the reported leaks in this bugzilla have been fixed on binutils master.,CVE-2025-1152,tykio/tyk-plugin-compiler
binutils-powerpc64le-linux-gnu,LOW,2.35.2-2,,A vulnerability classified as problematic was found in GNU Binutils 2.43/2.44. Affected by this vulnerability is the function bfd_set_format of the file format.c. The manipulation leads to memory corruption. The attack can be launched remotely. The complexity of an attack is rather high. The exploitation appears to be difficult. Upgrading to version 2.45 is able to address this issue. The identifier of the patch is 8d97c1a53f3dc9fd8e1ccdb039b8a33d50133150. It is recommended to upgrade the affected component.,CVE-2025-1153,tykio/tyk-plugin-compiler
binutils-powerpc64le-linux-gnu,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43 and classified as critical. This issue affects the function _bfd_elf_gc_mark_rsec of the file elflink.c of the component ld. The manipulation leads to heap-based buffer overflow. The attack may be initiated remotely. The complexity of an attack is rather high. The exploitation is known to be difficult. The exploit has been disclosed to the public and may be used. The patch is named f9978defb6fab0bd8583942d97c112b0932ac814. It is recommended to apply a patch to fix this issue.,CVE-2025-1176,tykio/tyk-plugin-compiler
binutils-powerpc64le-linux-gnu,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43. It has been declared as problematic. Affected by this vulnerability is the function bfd_putl64 of the file libbfd.c of the component ld. The manipulation leads to memory corruption. The attack can be launched remotely. The complexity of an attack is rather high. The exploitation appears to be difficult. The exploit has been disclosed to the public and may be used. The identifier of the patch is 75086e9de1707281172cc77f178e7949a4414ed0. It is recommended to apply a patch to fix this issue.,CVE-2025-1178,tykio/tyk-plugin-compiler
binutils-powerpc64le-linux-gnu,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43. It has been rated as critical. Affected by this issue is the function bfd_putl64 of the file bfd/libbfd.c of the component ld. The manipulation leads to memory corruption. The attack may be launched remotely. The complexity of an attack is rather high. The exploitation is known to be difficult. The exploit has been disclosed to the public and may be used. Upgrading to version 2.44 is able to address this issue. It is recommended to upgrade the affected component. The code maintainer explains that [t]his bug has been fixed at some point between the 2.43 and 2.44 releases.,CVE-2025-1179,tykio/tyk-plugin-compiler
binutils-powerpc64le-linux-gnu,LOW,2.35.2-2,,A vulnerability classified as problematic has been found in GNU Binutils 2.43. This affects the function _bfd_elf_write_section_eh_frame of the file bfd/elf-eh-frame.c of the component ld. The manipulation leads to memory corruption. It is possible to initiate the attack remotely. The complexity of an attack is rather high. The exploitability is told to be difficult. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue.,CVE-2025-1180,tykio/tyk-plugin-compiler
binutils-powerpc64le-linux-gnu,LOW,2.35.2-2,,A vulnerability classified as critical was found in GNU Binutils 2.43. This vulnerability affects the function _bfd_elf_gc_mark_rsec of the file bfd/elflink.c of the component ld. The manipulation leads to memory corruption. The attack can be initiated remotely. The complexity of an attack is rather high. The exploitation appears to be difficult. The exploit has been disclosed to the public and may be used. The name of the patch is 931494c9a89558acb36a03a340c01726545eef24. It is recommended to apply a patch to fix this issue.,CVE-2025-1181,tykio/tyk-plugin-compiler
binutils-powerpc64le-linux-gnu,LOW,2.35.2-2,,A vulnerability which was classified as critical was found in GNU Binutils 2.43. Affected is the function bfd_elf_reloc_symbol_deleted_p of the file bfd/elflink.c of the component ld. The manipulation leads to memory corruption. It is possible to launch the attack remotely. The complexity of an attack is rather high. The exploitability is told to be difficult. The exploit has been disclosed to the public and may be used. The patch is identified as b425859021d17adf62f06fb904797cf8642986ad. It is recommended to apply a patch to fix this issue.,CVE-2025-1182,tykio/tyk-plugin-compiler
binutils-powerpc64le-linux-gnu,LOW,2.35.2-2,,A vulnerability has been found in GNU Binutils 2.43/2.44 and classified as problematic. Affected by this vulnerability is the function display_info of the file binutils/bucomm.c of the component objdump. The manipulation leads to memory leak. An attack has to be approached locally. The exploit has been disclosed to the public and may be used. The patch is named ba6ad3a18cb26b79e0e3b84c39f707535bbc344d. It is recommended to apply a patch to fix this issue.,CVE-2025-3198,tykio/tyk-plugin-compiler
binutils-s390x-linux-gnu,LOW,2.35.2-2,,The C++ symbol demangler routine in cplus-dem.c in libiberty as distributed in GNU Binutils 2.29 allows remote attackers to cause a denial of service (excessive memory allocation and application crash) via a crafted file as demonstrated by a call from the Binary File Descriptor (BFD) library (aka libbfd).,CVE-2017-13716,tykio/tyk-plugin-compiler
binutils-s390x-linux-gnu,LOW,2.35.2-2,,The demangle_template function in cplus-dem.c in GNU libiberty as distributed in GNU Binutils 2.31.1 contains an integer overflow vulnerability (for Create an array for saving the template argument values) that can trigger a heap-based buffer overflow as demonstrated by nm.,CVE-2018-20673,tykio/tyk-plugin-compiler
binutils-s390x-linux-gnu,LOW,2.35.2-2,,A heap-based buffer over-read exists in the function d_expression_1 in cp-demangle.c in GNU libiberty as distributed in GNU Binutils 2.31.1. A crafted input can cause segmentation faults leading to denial-of-service as demonstrated by c++filt.,CVE-2018-20712,tykio/tyk-plugin-compiler
binutils-s390x-linux-gnu,LOW,2.35.2-2,,An issue was discovered in cplus-dem.c in GNU libiberty as distributed in GNU Binutils 2.30. Stack Exhaustion occurs in the C++ demangling functions provided by libiberty and there are recursive stack frames: demangle_template_value_parm demangle_integral_value and demangle_expression.,CVE-2018-9996,tykio/tyk-plugin-compiler
binutils-s390x-linux-gnu,LOW,2.35.2-2,,GNU binutils gold gold v1.11-v1.16 (GNU binutils v2.21-v2.31.1) is affected by: Improper Input Validation Signed/Unsigned Comparison Out-of-bounds Read. The impact is: Denial of service. The component is: gold/fileread.cc:497 elfcpp/elfcpp_file.h:644. The attack vector is: An ELF file with an invalid e_shoff header field must be opened.,CVE-2019-1010204,tykio/tyk-plugin-compiler
binutils-s390x-linux-gnu,LOW,2.35.2-2,,An issue was discovered in binutils libbfd.c 2.36 relating to the auxiliary symbol data allows attackers to read or write to system memory or cause a denial of service.,CVE-2020-19726,tykio/tyk-plugin-compiler
binutils-s390x-linux-gnu,LOW,2.35.2-2,,An issue was discovered in the Binary File Descriptor (BFD) library (aka libbfd) as distributed in GNU Binutils 2.35.1. A heap-based buffer over-read can occur in bfd_getl_signed_32 in libbfd.c because sh_entsize is not validated in _bfd_elf_slurp_secondary_reloc_section in elf.c.,CVE-2020-35448,tykio/tyk-plugin-compiler
binutils-s390x-linux-gnu,LOW,2.35.2-2,,There is an open race window when writing output in the following utilities in GNU binutils version 2.35 and earlier:ar objcopy strip ranlib. When these utilities are run as a privileged user (presumably as part of a script updating binaries across different users) an unprivileged user can trick these utilities into getting ownership of arbitrary files through a symlink.,CVE-2021-20197,tykio/tyk-plugin-compiler
binutils-s390x-linux-gnu,LOW,2.35.2-2,,A flaw was found in GNU Binutils 2.35.1 where there is a heap-based buffer overflow in _bfd_elf_slurp_secondary_reloc_section in elf.c due to the number of symbols not calculated correctly. The highest threat from this vulnerability is to system availability.,CVE-2021-20284,tykio/tyk-plugin-compiler
binutils-s390x-linux-gnu,LOW,2.35.2-2,,An issue was discovered in GNU libiberty as distributed in GNU Binutils 2.36. It is a stack-overflow issue in demangle_type in rust-demangle.c.,CVE-2021-32256,tykio/tyk-plugin-compiler
binutils-s390x-linux-gnu,LOW,2.35.2-2,,A flaw was discovered in GNU libiberty within demangle_path() in rust-demangle.c as distributed in GNU Binutils version 2.36. A crafted symbol can cause stack memory to be exhausted leading to a crash.,CVE-2021-3530,tykio/tyk-plugin-compiler
binutils-s390x-linux-gnu,LOW,2.35.2-2,,An out of bounds flaw was found in GNU binutils objdump utility version 2.36. An attacker could use this flaw and pass a large section to avr_elf32_load_records_from_section() probably resulting in a crash or in some cases memory corruption. The highest threat from this vulnerability is to integrity as well as system availability.,CVE-2021-3549,tykio/tyk-plugin-compiler
binutils-s390x-linux-gnu,LOW,2.35.2-2,,Heap/stack buffer overflow in the dlang_lname function in d-demangle.c in libiberty allows attackers to potentially cause a denial of service (segmentation fault and crash) via a crafted mangled symbol.,CVE-2021-3826,tykio/tyk-plugin-compiler
binutils-s390x-linux-gnu,LOW,2.35.2-2,,stab_xcoff_builtin_type in stabs.c in GNU Binutils through 2.37 allows attackers to cause a denial of service (heap-based buffer overflow) or possibly have unspecified other impact as demonstrated by an out-of-bounds write. NOTE: this issue exists because of an incorrect fix for CVE-2018-12699.,CVE-2021-45078,tykio/tyk-plugin-compiler
binutils-s390x-linux-gnu,LOW,2.35.2-2,,Heap-based Buffer Overflow in function bfd_getl32 in Binutils objdump 3.37.,CVE-2021-46174,tykio/tyk-plugin-compiler
binutils-s390x-linux-gnu,LOW,2.35.2-2,,GCC v12.0 was discovered to contain an uncontrolled recursion via the component libiberty/rust-demangle.c. This vulnerability allows attackers to cause a Denial of Service (DoS) by consuming excessive CPU and memory resources.,CVE-2021-46195,tykio/tyk-plugin-compiler
binutils-s390x-linux-gnu,LOW,2.35.2-2,,An issue was discovered in Binutils readelf 2.38.50 reachable assertion failure in function display_debug_names allows attackers to cause a denial of service.,CVE-2022-35205,tykio/tyk-plugin-compiler
binutils-s390x-linux-gnu,LOW,2.35.2-2,,Null pointer dereference vulnerability in Binutils readelf 2.38.50 via function read_and_display_attr_value in file dwarf.c.,CVE-2022-35206,tykio/tyk-plugin-compiler
binutils-s390x-linux-gnu,LOW,2.35.2-2,,In GNU Binutils before 2.40 there is a heap-buffer-overflow in the error function bfd_getl32 when called from the strip_main function in strip-new via a crafted file.,CVE-2022-38533,tykio/tyk-plugin-compiler
binutils-s390x-linux-gnu,LOW,2.35.2-2,,An illegal memory access flaw was found in the binutils package. Parsing an ELF file containing corrupt symbol version information may result in a denial of service. This issue is the result of an incomplete fix for CVE-2020-16599.,CVE-2022-4285,tykio/tyk-plugin-compiler
binutils-s390x-linux-gnu,LOW,2.35.2-2,,Heap buffer overflow vulnerability in binutils readelf before 2.40 via function find_section_in_set in file readelf.c.,CVE-2022-44840,tykio/tyk-plugin-compiler
binutils-s390x-linux-gnu,LOW,2.35.2-2,,Heap buffer overflow vulnerability in binutils readelf before 2.40 via function display_debug_section in file readelf.c.,CVE-2022-45703,tykio/tyk-plugin-compiler
binutils-s390x-linux-gnu,LOW,2.35.2-2,,An issue was discovered function stab_demangle_v3_arg in stabs.c in Binutils 2.34 thru 2.38 allows attackers to cause a denial of service due to memory leaks.,CVE-2022-47007,tykio/tyk-plugin-compiler
binutils-s390x-linux-gnu,LOW,2.35.2-2,,An issue was discovered function make_tempdir and make_tempname in bucomm.c in Binutils 2.34 thru 2.38 allows attackers to cause a denial of service due to memory leaks.,CVE-2022-47008,tykio/tyk-plugin-compiler
binutils-s390x-linux-gnu,LOW,2.35.2-2,,An issue was discovered function pr_function_type in prdbg.c in Binutils 2.34 thru 2.38 allows attackers to cause a denial of service due to memory leaks.,CVE-2022-47010,tykio/tyk-plugin-compiler
binutils-s390x-linux-gnu,LOW,2.35.2-2,,An issue was discovered function parse_stab_struct_fields in stabs.c in Binutils 2.34 thru 2.38 allows attackers to cause a denial of service due to memory leaks.,CVE-2022-47011,tykio/tyk-plugin-compiler
binutils-s390x-linux-gnu,LOW,2.35.2-2,,An issue was discovered in Binutils addr2line before 2.39.3 function parse_module contains multiple out of bound reads which may cause a denial of service or other unspecified impacts.,CVE-2022-47673,tykio/tyk-plugin-compiler
binutils-s390x-linux-gnu,LOW,2.35.2-2,,An issue was discovered Binutils objdump before 2.39.3 allows attackers to cause a denial of service or other unspecified impacts via function bfd_mach_o_get_synthetic_symtab in match-o.c.,CVE-2022-47695,tykio/tyk-plugin-compiler
binutils-s390x-linux-gnu,LOW,2.35.2-2,,An issue was discovered Binutils objdump before 2.39.3 allows attackers to cause a denial of service or other unspecified impacts via function compare_symbols.,CVE-2022-47696,tykio/tyk-plugin-compiler
binutils-s390x-linux-gnu,LOW,2.35.2-2,,GNU Binutils before 2.40 was discovered to contain an excessive memory consumption vulnerability via the function load_separate_debug_files at dwarf2.c. The attacker could supply a crafted ELF file and cause a DNS attack.,CVE-2022-48063,tykio/tyk-plugin-compiler
binutils-s390x-linux-gnu,LOW,2.35.2-2,,GNU Binutils before 2.40 was discovered to contain an excessive memory consumption vulnerability via the function bfd_dwarf2_find_nearest_line_with_alt at dwarf2.c. The attacker could supply a crafted ELF file and cause a DNS attack.,CVE-2022-48064,tykio/tyk-plugin-compiler
binutils-s390x-linux-gnu,LOW,2.35.2-2,,GNU Binutils before 2.40 was discovered to contain a memory leak vulnerability var the function find_abstract_instance in dwarf2.c.,CVE-2022-48065,tykio/tyk-plugin-compiler
binutils-s390x-linux-gnu,LOW,2.35.2-2,,Heap based buffer overflow in binutils-gdb/bfd/libbfd.c in bfd_getl64.,CVE-2023-1579,tykio/tyk-plugin-compiler
binutils-s390x-linux-gnu,LOW,2.35.2-2,,A potential heap based buffer overflow was found in _bfd_elf_slurp_version_tables() in bfd/elf.c. This may lead to loss of availability.,CVE-2023-1972,tykio/tyk-plugin-compiler
binutils-s390x-linux-gnu,LOW,2.35.2-2,,An out-of-bounds read flaw was found in the parse_module function in bfd/vms-alpha.c in Binutils.,CVE-2023-25584,tykio/tyk-plugin-compiler
binutils-s390x-linux-gnu,LOW,2.35.2-2,,A flaw was found in Binutils. The use of an uninitialized field in the struct module *module may lead to application crash and local denial of service.,CVE-2023-25585,tykio/tyk-plugin-compiler
binutils-s390x-linux-gnu,LOW,2.35.2-2,,A flaw was found in Binutils. A logic fail in the bfd_init_section_decompress_status function may lead to the use of an uninitialized variable that can cause a crash and local denial of service.,CVE-2023-25586,tykio/tyk-plugin-compiler
binutils-s390x-linux-gnu,LOW,2.35.2-2,,A flaw was found in Binutils. The field `the_bfd` of `asymbol`struct is uninitialized in the `bfd_mach_o_get_synthetic_symtab` function which may lead to an application crash and local denial of service.,CVE-2023-25588,tykio/tyk-plugin-compiler
binutils-s390x-linux-gnu,LOW,2.35.2-2,,GNU objdump 2.43 is vulnerable to Buffer Overflow in the BFD (Binary File Descriptor) library's handling of tekhex format files.,CVE-2024-53589,tykio/tyk-plugin-compiler
binutils-s390x-linux-gnu,LOW,2.35.2-2,,https://www.gnu.org/software/binutils/ nm >=2.43 is affected by: Incorrect Access Control. The type of exploitation is: local. The component is: `nm --without-symbol-version` function.,CVE-2024-57360,tykio/tyk-plugin-compiler
binutils-s390x-linux-gnu,LOW,2.35.2-2,,A vulnerability which was classified as problematic was found in GNU Binutils up to 2.43. This affects the function disassemble_bytes of the file binutils/objdump.c. The manipulation of the argument buf leads to stack-based buffer overflow. It is possible to initiate the attack remotely. The complexity of an attack is rather high. The exploitability is told to be difficult. The exploit has been disclosed to the public and may be used. Upgrading to version 2.44 is able to address this issue. The identifier of the patch is baac6c221e9d69335bf41366a1c7d87d8ab2f893. It is recommended to upgrade the affected component.,CVE-2025-0840,tykio/tyk-plugin-compiler
binutils-s390x-linux-gnu,LOW,2.35.2-2,,A vulnerability has been found in GNU Binutils 2.43 and classified as problematic. Affected by this vulnerability is the function __sanitizer::internal_strlen of the file binutils/nm.c of the component nm. The manipulation of the argument const leads to buffer overflow. The attack can be launched remotely. The complexity of an attack is rather high. The exploitation appears to be difficult. The exploit has been disclosed to the public and may be used.,CVE-2025-1147,tykio/tyk-plugin-compiler
binutils-s390x-linux-gnu,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43 and classified as problematic. Affected by this issue is the function link_order_scan of the file ld/ldelfgen.c of the component ld. The manipulation leads to memory leak. The attack may be launched remotely. The complexity of an attack is rather high. The exploitation is known to be difficult. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue. The code maintainer explains: I'm not going to commit some of the leak fixes I've been working on to the 2.44 branch due to concern that would destabilise ld. All of the reported leaks in this bugzilla have been fixed on binutils master.,CVE-2025-1148,tykio/tyk-plugin-compiler
binutils-s390x-linux-gnu,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43. It has been classified as problematic. This affects the function xstrdup of the file libiberty/xmalloc.c of the component ld. The manipulation leads to memory leak. It is possible to initiate the attack remotely. The complexity of an attack is rather high. The exploitability is told to be difficult. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue. The code maintainer explains: I'm not going to commit some of the leak fixes I've been working on to the 2.44 branch due to concern that would destabilise ld. All of the reported leaks in this bugzilla have been fixed on binutils master.,CVE-2025-1149,tykio/tyk-plugin-compiler
binutils-s390x-linux-gnu,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43. It has been declared as problematic. This vulnerability affects the function bfd_malloc of the file libbfd.c of the component ld. The manipulation leads to memory leak. The attack can be initiated remotely. The complexity of an attack is rather high. The exploitation appears to be difficult. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue. The code maintainer explains: I'm not going to commit some of the leak fixes I've been working on to the 2.44 branch due to concern that would destabilise ld. All of the reported leaks in this bugzilla have been fixed on binutils master.,CVE-2025-1150,tykio/tyk-plugin-compiler
binutils-s390x-linux-gnu,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43. It has been rated as problematic. This issue affects the function xmemdup of the file xmemdup.c of the component ld. The manipulation leads to memory leak. The attack may be initiated remotely. The complexity of an attack is rather high. The exploitation is known to be difficult. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue. The code maintainer explains: I'm not going to commit some of the leak fixes I've been working on to the 2.44 branch due to concern that would destabilise ld. All of the reported leaks in this bugzilla have been fixed on binutils master.,CVE-2025-1151,tykio/tyk-plugin-compiler
binutils-s390x-linux-gnu,LOW,2.35.2-2,,A vulnerability classified as problematic has been found in GNU Binutils 2.43. Affected is the function xstrdup of the file xstrdup.c of the component ld. The manipulation leads to memory leak. It is possible to launch the attack remotely. The complexity of an attack is rather high. The exploitability is told to be difficult. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue. The code maintainer explains: I'm not going to commit some of the leak fixes I've been working on to the 2.44 branch due to concern that would destabilise ld. All of the reported leaks in this bugzilla have been fixed on binutils master.,CVE-2025-1152,tykio/tyk-plugin-compiler
binutils-s390x-linux-gnu,LOW,2.35.2-2,,A vulnerability classified as problematic was found in GNU Binutils 2.43/2.44. Affected by this vulnerability is the function bfd_set_format of the file format.c. The manipulation leads to memory corruption. The attack can be launched remotely. The complexity of an attack is rather high. The exploitation appears to be difficult. Upgrading to version 2.45 is able to address this issue. The identifier of the patch is 8d97c1a53f3dc9fd8e1ccdb039b8a33d50133150. It is recommended to upgrade the affected component.,CVE-2025-1153,tykio/tyk-plugin-compiler
binutils-s390x-linux-gnu,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43 and classified as critical. This issue affects the function _bfd_elf_gc_mark_rsec of the file elflink.c of the component ld. The manipulation leads to heap-based buffer overflow. The attack may be initiated remotely. The complexity of an attack is rather high. The exploitation is known to be difficult. The exploit has been disclosed to the public and may be used. The patch is named f9978defb6fab0bd8583942d97c112b0932ac814. It is recommended to apply a patch to fix this issue.,CVE-2025-1176,tykio/tyk-plugin-compiler
binutils-s390x-linux-gnu,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43. It has been declared as problematic. Affected by this vulnerability is the function bfd_putl64 of the file libbfd.c of the component ld. The manipulation leads to memory corruption. The attack can be launched remotely. The complexity of an attack is rather high. The exploitation appears to be difficult. The exploit has been disclosed to the public and may be used. The identifier of the patch is 75086e9de1707281172cc77f178e7949a4414ed0. It is recommended to apply a patch to fix this issue.,CVE-2025-1178,tykio/tyk-plugin-compiler
binutils-s390x-linux-gnu,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43. It has been rated as critical. Affected by this issue is the function bfd_putl64 of the file bfd/libbfd.c of the component ld. The manipulation leads to memory corruption. The attack may be launched remotely. The complexity of an attack is rather high. The exploitation is known to be difficult. The exploit has been disclosed to the public and may be used. Upgrading to version 2.44 is able to address this issue. It is recommended to upgrade the affected component. The code maintainer explains that [t]his bug has been fixed at some point between the 2.43 and 2.44 releases.,CVE-2025-1179,tykio/tyk-plugin-compiler
binutils-s390x-linux-gnu,LOW,2.35.2-2,,A vulnerability classified as problematic has been found in GNU Binutils 2.43. This affects the function _bfd_elf_write_section_eh_frame of the file bfd/elf-eh-frame.c of the component ld. The manipulation leads to memory corruption. It is possible to initiate the attack remotely. The complexity of an attack is rather high. The exploitability is told to be difficult. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue.,CVE-2025-1180,tykio/tyk-plugin-compiler
binutils-s390x-linux-gnu,LOW,2.35.2-2,,A vulnerability classified as critical was found in GNU Binutils 2.43. This vulnerability affects the function _bfd_elf_gc_mark_rsec of the file bfd/elflink.c of the component ld. The manipulation leads to memory corruption. The attack can be initiated remotely. The complexity of an attack is rather high. The exploitation appears to be difficult. The exploit has been disclosed to the public and may be used. The name of the patch is 931494c9a89558acb36a03a340c01726545eef24. It is recommended to apply a patch to fix this issue.,CVE-2025-1181,tykio/tyk-plugin-compiler
binutils-s390x-linux-gnu,LOW,2.35.2-2,,A vulnerability which was classified as critical was found in GNU Binutils 2.43. Affected is the function bfd_elf_reloc_symbol_deleted_p of the file bfd/elflink.c of the component ld. The manipulation leads to memory corruption. It is possible to launch the attack remotely. The complexity of an attack is rather high. The exploitability is told to be difficult. The exploit has been disclosed to the public and may be used. The patch is identified as b425859021d17adf62f06fb904797cf8642986ad. It is recommended to apply a patch to fix this issue.,CVE-2025-1182,tykio/tyk-plugin-compiler
binutils-s390x-linux-gnu,LOW,2.35.2-2,,A vulnerability has been found in GNU Binutils 2.43/2.44 and classified as problematic. Affected by this vulnerability is the function display_info of the file binutils/bucomm.c of the component objdump. The manipulation leads to memory leak. An attack has to be approached locally. The exploit has been disclosed to the public and may be used. The patch is named ba6ad3a18cb26b79e0e3b84c39f707535bbc344d. It is recommended to apply a patch to fix this issue.,CVE-2025-3198,tykio/tyk-plugin-compiler
binutils-x86-64-linux-gnu,LOW,2.35.2-2,,The C++ symbol demangler routine in cplus-dem.c in libiberty as distributed in GNU Binutils 2.29 allows remote attackers to cause a denial of service (excessive memory allocation and application crash) via a crafted file as demonstrated by a call from the Binary File Descriptor (BFD) library (aka libbfd).,CVE-2017-13716,tykio/tyk-plugin-compiler
binutils-x86-64-linux-gnu,LOW,2.35.2-2,,The demangle_template function in cplus-dem.c in GNU libiberty as distributed in GNU Binutils 2.31.1 contains an integer overflow vulnerability (for Create an array for saving the template argument values) that can trigger a heap-based buffer overflow as demonstrated by nm.,CVE-2018-20673,tykio/tyk-plugin-compiler
binutils-x86-64-linux-gnu,LOW,2.35.2-2,,A heap-based buffer over-read exists in the function d_expression_1 in cp-demangle.c in GNU libiberty as distributed in GNU Binutils 2.31.1. A crafted input can cause segmentation faults leading to denial-of-service as demonstrated by c++filt.,CVE-2018-20712,tykio/tyk-plugin-compiler
binutils-x86-64-linux-gnu,LOW,2.35.2-2,,An issue was discovered in cplus-dem.c in GNU libiberty as distributed in GNU Binutils 2.30. Stack Exhaustion occurs in the C++ demangling functions provided by libiberty and there are recursive stack frames: demangle_template_value_parm demangle_integral_value and demangle_expression.,CVE-2018-9996,tykio/tyk-plugin-compiler
binutils-x86-64-linux-gnu,LOW,2.35.2-2,,GNU binutils gold gold v1.11-v1.16 (GNU binutils v2.21-v2.31.1) is affected by: Improper Input Validation Signed/Unsigned Comparison Out-of-bounds Read. The impact is: Denial of service. The component is: gold/fileread.cc:497 elfcpp/elfcpp_file.h:644. The attack vector is: An ELF file with an invalid e_shoff header field must be opened.,CVE-2019-1010204,tykio/tyk-plugin-compiler
binutils-x86-64-linux-gnu,LOW,2.35.2-2,,An issue was discovered in binutils libbfd.c 2.36 relating to the auxiliary symbol data allows attackers to read or write to system memory or cause a denial of service.,CVE-2020-19726,tykio/tyk-plugin-compiler
binutils-x86-64-linux-gnu,LOW,2.35.2-2,,An issue was discovered in the Binary File Descriptor (BFD) library (aka libbfd) as distributed in GNU Binutils 2.35.1. A heap-based buffer over-read can occur in bfd_getl_signed_32 in libbfd.c because sh_entsize is not validated in _bfd_elf_slurp_secondary_reloc_section in elf.c.,CVE-2020-35448,tykio/tyk-plugin-compiler
binutils-x86-64-linux-gnu,LOW,2.35.2-2,,There is an open race window when writing output in the following utilities in GNU binutils version 2.35 and earlier:ar objcopy strip ranlib. When these utilities are run as a privileged user (presumably as part of a script updating binaries across different users) an unprivileged user can trick these utilities into getting ownership of arbitrary files through a symlink.,CVE-2021-20197,tykio/tyk-plugin-compiler
binutils-x86-64-linux-gnu,LOW,2.35.2-2,,A flaw was found in GNU Binutils 2.35.1 where there is a heap-based buffer overflow in _bfd_elf_slurp_secondary_reloc_section in elf.c due to the number of symbols not calculated correctly. The highest threat from this vulnerability is to system availability.,CVE-2021-20284,tykio/tyk-plugin-compiler
binutils-x86-64-linux-gnu,LOW,2.35.2-2,,An issue was discovered in GNU libiberty as distributed in GNU Binutils 2.36. It is a stack-overflow issue in demangle_type in rust-demangle.c.,CVE-2021-32256,tykio/tyk-plugin-compiler
binutils-x86-64-linux-gnu,LOW,2.35.2-2,,A flaw was discovered in GNU libiberty within demangle_path() in rust-demangle.c as distributed in GNU Binutils version 2.36. A crafted symbol can cause stack memory to be exhausted leading to a crash.,CVE-2021-3530,tykio/tyk-plugin-compiler
binutils-x86-64-linux-gnu,LOW,2.35.2-2,,An out of bounds flaw was found in GNU binutils objdump utility version 2.36. An attacker could use this flaw and pass a large section to avr_elf32_load_records_from_section() probably resulting in a crash or in some cases memory corruption. The highest threat from this vulnerability is to integrity as well as system availability.,CVE-2021-3549,tykio/tyk-plugin-compiler
binutils-x86-64-linux-gnu,LOW,2.35.2-2,,Heap/stack buffer overflow in the dlang_lname function in d-demangle.c in libiberty allows attackers to potentially cause a denial of service (segmentation fault and crash) via a crafted mangled symbol.,CVE-2021-3826,tykio/tyk-plugin-compiler
binutils-x86-64-linux-gnu,LOW,2.35.2-2,,stab_xcoff_builtin_type in stabs.c in GNU Binutils through 2.37 allows attackers to cause a denial of service (heap-based buffer overflow) or possibly have unspecified other impact as demonstrated by an out-of-bounds write. NOTE: this issue exists because of an incorrect fix for CVE-2018-12699.,CVE-2021-45078,tykio/tyk-plugin-compiler
binutils-x86-64-linux-gnu,LOW,2.35.2-2,,Heap-based Buffer Overflow in function bfd_getl32 in Binutils objdump 3.37.,CVE-2021-46174,tykio/tyk-plugin-compiler
binutils-x86-64-linux-gnu,LOW,2.35.2-2,,GCC v12.0 was discovered to contain an uncontrolled recursion via the component libiberty/rust-demangle.c. This vulnerability allows attackers to cause a Denial of Service (DoS) by consuming excessive CPU and memory resources.,CVE-2021-46195,tykio/tyk-plugin-compiler
binutils-x86-64-linux-gnu,LOW,2.35.2-2,,An issue was discovered in Binutils readelf 2.38.50 reachable assertion failure in function display_debug_names allows attackers to cause a denial of service.,CVE-2022-35205,tykio/tyk-plugin-compiler
binutils-x86-64-linux-gnu,LOW,2.35.2-2,,Null pointer dereference vulnerability in Binutils readelf 2.38.50 via function read_and_display_attr_value in file dwarf.c.,CVE-2022-35206,tykio/tyk-plugin-compiler
binutils-x86-64-linux-gnu,LOW,2.35.2-2,,In GNU Binutils before 2.40 there is a heap-buffer-overflow in the error function bfd_getl32 when called from the strip_main function in strip-new via a crafted file.,CVE-2022-38533,tykio/tyk-plugin-compiler
binutils-x86-64-linux-gnu,LOW,2.35.2-2,,An illegal memory access flaw was found in the binutils package. Parsing an ELF file containing corrupt symbol version information may result in a denial of service. This issue is the result of an incomplete fix for CVE-2020-16599.,CVE-2022-4285,tykio/tyk-plugin-compiler
binutils-x86-64-linux-gnu,LOW,2.35.2-2,,Heap buffer overflow vulnerability in binutils readelf before 2.40 via function find_section_in_set in file readelf.c.,CVE-2022-44840,tykio/tyk-plugin-compiler
binutils-x86-64-linux-gnu,LOW,2.35.2-2,,Heap buffer overflow vulnerability in binutils readelf before 2.40 via function display_debug_section in file readelf.c.,CVE-2022-45703,tykio/tyk-plugin-compiler
binutils-x86-64-linux-gnu,LOW,2.35.2-2,,An issue was discovered function stab_demangle_v3_arg in stabs.c in Binutils 2.34 thru 2.38 allows attackers to cause a denial of service due to memory leaks.,CVE-2022-47007,tykio/tyk-plugin-compiler
binutils-x86-64-linux-gnu,LOW,2.35.2-2,,An issue was discovered function make_tempdir and make_tempname in bucomm.c in Binutils 2.34 thru 2.38 allows attackers to cause a denial of service due to memory leaks.,CVE-2022-47008,tykio/tyk-plugin-compiler
binutils-x86-64-linux-gnu,LOW,2.35.2-2,,An issue was discovered function pr_function_type in prdbg.c in Binutils 2.34 thru 2.38 allows attackers to cause a denial of service due to memory leaks.,CVE-2022-47010,tykio/tyk-plugin-compiler
binutils-x86-64-linux-gnu,LOW,2.35.2-2,,An issue was discovered function parse_stab_struct_fields in stabs.c in Binutils 2.34 thru 2.38 allows attackers to cause a denial of service due to memory leaks.,CVE-2022-47011,tykio/tyk-plugin-compiler
binutils-x86-64-linux-gnu,LOW,2.35.2-2,,An issue was discovered in Binutils addr2line before 2.39.3 function parse_module contains multiple out of bound reads which may cause a denial of service or other unspecified impacts.,CVE-2022-47673,tykio/tyk-plugin-compiler
binutils-x86-64-linux-gnu,LOW,2.35.2-2,,An issue was discovered Binutils objdump before 2.39.3 allows attackers to cause a denial of service or other unspecified impacts via function bfd_mach_o_get_synthetic_symtab in match-o.c.,CVE-2022-47695,tykio/tyk-plugin-compiler
binutils-x86-64-linux-gnu,LOW,2.35.2-2,,An issue was discovered Binutils objdump before 2.39.3 allows attackers to cause a denial of service or other unspecified impacts via function compare_symbols.,CVE-2022-47696,tykio/tyk-plugin-compiler
binutils-x86-64-linux-gnu,LOW,2.35.2-2,,GNU Binutils before 2.40 was discovered to contain an excessive memory consumption vulnerability via the function load_separate_debug_files at dwarf2.c. The attacker could supply a crafted ELF file and cause a DNS attack.,CVE-2022-48063,tykio/tyk-plugin-compiler
binutils-x86-64-linux-gnu,LOW,2.35.2-2,,GNU Binutils before 2.40 was discovered to contain an excessive memory consumption vulnerability via the function bfd_dwarf2_find_nearest_line_with_alt at dwarf2.c. The attacker could supply a crafted ELF file and cause a DNS attack.,CVE-2022-48064,tykio/tyk-plugin-compiler
binutils-x86-64-linux-gnu,LOW,2.35.2-2,,GNU Binutils before 2.40 was discovered to contain a memory leak vulnerability var the function find_abstract_instance in dwarf2.c.,CVE-2022-48065,tykio/tyk-plugin-compiler
binutils-x86-64-linux-gnu,LOW,2.35.2-2,,Heap based buffer overflow in binutils-gdb/bfd/libbfd.c in bfd_getl64.,CVE-2023-1579,tykio/tyk-plugin-compiler
binutils-x86-64-linux-gnu,LOW,2.35.2-2,,A potential heap based buffer overflow was found in _bfd_elf_slurp_version_tables() in bfd/elf.c. This may lead to loss of availability.,CVE-2023-1972,tykio/tyk-plugin-compiler
binutils-x86-64-linux-gnu,LOW,2.35.2-2,,An out-of-bounds read flaw was found in the parse_module function in bfd/vms-alpha.c in Binutils.,CVE-2023-25584,tykio/tyk-plugin-compiler
binutils-x86-64-linux-gnu,LOW,2.35.2-2,,A flaw was found in Binutils. The use of an uninitialized field in the struct module *module may lead to application crash and local denial of service.,CVE-2023-25585,tykio/tyk-plugin-compiler
binutils-x86-64-linux-gnu,LOW,2.35.2-2,,A flaw was found in Binutils. A logic fail in the bfd_init_section_decompress_status function may lead to the use of an uninitialized variable that can cause a crash and local denial of service.,CVE-2023-25586,tykio/tyk-plugin-compiler
binutils-x86-64-linux-gnu,LOW,2.35.2-2,,A flaw was found in Binutils. The field `the_bfd` of `asymbol`struct is uninitialized in the `bfd_mach_o_get_synthetic_symtab` function which may lead to an application crash and local denial of service.,CVE-2023-25588,tykio/tyk-plugin-compiler
binutils-x86-64-linux-gnu,LOW,2.35.2-2,,GNU objdump 2.43 is vulnerable to Buffer Overflow in the BFD (Binary File Descriptor) library's handling of tekhex format files.,CVE-2024-53589,tykio/tyk-plugin-compiler
binutils-x86-64-linux-gnu,LOW,2.35.2-2,,https://www.gnu.org/software/binutils/ nm >=2.43 is affected by: Incorrect Access Control. The type of exploitation is: local. The component is: `nm --without-symbol-version` function.,CVE-2024-57360,tykio/tyk-plugin-compiler
binutils-x86-64-linux-gnu,LOW,2.35.2-2,,A vulnerability which was classified as problematic was found in GNU Binutils up to 2.43. This affects the function disassemble_bytes of the file binutils/objdump.c. The manipulation of the argument buf leads to stack-based buffer overflow. It is possible to initiate the attack remotely. The complexity of an attack is rather high. The exploitability is told to be difficult. The exploit has been disclosed to the public and may be used. Upgrading to version 2.44 is able to address this issue. The identifier of the patch is baac6c221e9d69335bf41366a1c7d87d8ab2f893. It is recommended to upgrade the affected component.,CVE-2025-0840,tykio/tyk-plugin-compiler
binutils-x86-64-linux-gnu,LOW,2.35.2-2,,A vulnerability has been found in GNU Binutils 2.43 and classified as problematic. Affected by this vulnerability is the function __sanitizer::internal_strlen of the file binutils/nm.c of the component nm. The manipulation of the argument const leads to buffer overflow. The attack can be launched remotely. The complexity of an attack is rather high. The exploitation appears to be difficult. The exploit has been disclosed to the public and may be used.,CVE-2025-1147,tykio/tyk-plugin-compiler
binutils-x86-64-linux-gnu,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43 and classified as problematic. Affected by this issue is the function link_order_scan of the file ld/ldelfgen.c of the component ld. The manipulation leads to memory leak. The attack may be launched remotely. The complexity of an attack is rather high. The exploitation is known to be difficult. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue. The code maintainer explains: I'm not going to commit some of the leak fixes I've been working on to the 2.44 branch due to concern that would destabilise ld. All of the reported leaks in this bugzilla have been fixed on binutils master.,CVE-2025-1148,tykio/tyk-plugin-compiler
binutils-x86-64-linux-gnu,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43. It has been classified as problematic. This affects the function xstrdup of the file libiberty/xmalloc.c of the component ld. The manipulation leads to memory leak. It is possible to initiate the attack remotely. The complexity of an attack is rather high. The exploitability is told to be difficult. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue. The code maintainer explains: I'm not going to commit some of the leak fixes I've been working on to the 2.44 branch due to concern that would destabilise ld. All of the reported leaks in this bugzilla have been fixed on binutils master.,CVE-2025-1149,tykio/tyk-plugin-compiler
binutils-x86-64-linux-gnu,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43. It has been declared as problematic. This vulnerability affects the function bfd_malloc of the file libbfd.c of the component ld. The manipulation leads to memory leak. The attack can be initiated remotely. The complexity of an attack is rather high. The exploitation appears to be difficult. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue. The code maintainer explains: I'm not going to commit some of the leak fixes I've been working on to the 2.44 branch due to concern that would destabilise ld. All of the reported leaks in this bugzilla have been fixed on binutils master.,CVE-2025-1150,tykio/tyk-plugin-compiler
binutils-x86-64-linux-gnu,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43. It has been rated as problematic. This issue affects the function xmemdup of the file xmemdup.c of the component ld. The manipulation leads to memory leak. The attack may be initiated remotely. The complexity of an attack is rather high. The exploitation is known to be difficult. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue. The code maintainer explains: I'm not going to commit some of the leak fixes I've been working on to the 2.44 branch due to concern that would destabilise ld. All of the reported leaks in this bugzilla have been fixed on binutils master.,CVE-2025-1151,tykio/tyk-plugin-compiler
binutils-x86-64-linux-gnu,LOW,2.35.2-2,,A vulnerability classified as problematic has been found in GNU Binutils 2.43. Affected is the function xstrdup of the file xstrdup.c of the component ld. The manipulation leads to memory leak. It is possible to launch the attack remotely. The complexity of an attack is rather high. The exploitability is told to be difficult. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue. The code maintainer explains: I'm not going to commit some of the leak fixes I've been working on to the 2.44 branch due to concern that would destabilise ld. All of the reported leaks in this bugzilla have been fixed on binutils master.,CVE-2025-1152,tykio/tyk-plugin-compiler
binutils-x86-64-linux-gnu,LOW,2.35.2-2,,A vulnerability classified as problematic was found in GNU Binutils 2.43/2.44. Affected by this vulnerability is the function bfd_set_format of the file format.c. The manipulation leads to memory corruption. The attack can be launched remotely. The complexity of an attack is rather high. The exploitation appears to be difficult. Upgrading to version 2.45 is able to address this issue. The identifier of the patch is 8d97c1a53f3dc9fd8e1ccdb039b8a33d50133150. It is recommended to upgrade the affected component.,CVE-2025-1153,tykio/tyk-plugin-compiler
binutils-x86-64-linux-gnu,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43 and classified as critical. This issue affects the function _bfd_elf_gc_mark_rsec of the file elflink.c of the component ld. The manipulation leads to heap-based buffer overflow. The attack may be initiated remotely. The complexity of an attack is rather high. The exploitation is known to be difficult. The exploit has been disclosed to the public and may be used. The patch is named f9978defb6fab0bd8583942d97c112b0932ac814. It is recommended to apply a patch to fix this issue.,CVE-2025-1176,tykio/tyk-plugin-compiler
binutils-x86-64-linux-gnu,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43. It has been declared as problematic. Affected by this vulnerability is the function bfd_putl64 of the file libbfd.c of the component ld. The manipulation leads to memory corruption. The attack can be launched remotely. The complexity of an attack is rather high. The exploitation appears to be difficult. The exploit has been disclosed to the public and may be used. The identifier of the patch is 75086e9de1707281172cc77f178e7949a4414ed0. It is recommended to apply a patch to fix this issue.,CVE-2025-1178,tykio/tyk-plugin-compiler
binutils-x86-64-linux-gnu,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43. It has been rated as critical. Affected by this issue is the function bfd_putl64 of the file bfd/libbfd.c of the component ld. The manipulation leads to memory corruption. The attack may be launched remotely. The complexity of an attack is rather high. The exploitation is known to be difficult. The exploit has been disclosed to the public and may be used. Upgrading to version 2.44 is able to address this issue. It is recommended to upgrade the affected component. The code maintainer explains that [t]his bug has been fixed at some point between the 2.43 and 2.44 releases.,CVE-2025-1179,tykio/tyk-plugin-compiler
binutils-x86-64-linux-gnu,LOW,2.35.2-2,,A vulnerability classified as problematic has been found in GNU Binutils 2.43. This affects the function _bfd_elf_write_section_eh_frame of the file bfd/elf-eh-frame.c of the component ld. The manipulation leads to memory corruption. It is possible to initiate the attack remotely. The complexity of an attack is rather high. The exploitability is told to be difficult. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue.,CVE-2025-1180,tykio/tyk-plugin-compiler
binutils-x86-64-linux-gnu,LOW,2.35.2-2,,A vulnerability classified as critical was found in GNU Binutils 2.43. This vulnerability affects the function _bfd_elf_gc_mark_rsec of the file bfd/elflink.c of the component ld. The manipulation leads to memory corruption. The attack can be initiated remotely. The complexity of an attack is rather high. The exploitation appears to be difficult. The exploit has been disclosed to the public and may be used. The name of the patch is 931494c9a89558acb36a03a340c01726545eef24. It is recommended to apply a patch to fix this issue.,CVE-2025-1181,tykio/tyk-plugin-compiler
binutils-x86-64-linux-gnu,LOW,2.35.2-2,,A vulnerability which was classified as critical was found in GNU Binutils 2.43. Affected is the function bfd_elf_reloc_symbol_deleted_p of the file bfd/elflink.c of the component ld. The manipulation leads to memory corruption. It is possible to launch the attack remotely. The complexity of an attack is rather high. The exploitability is told to be difficult. The exploit has been disclosed to the public and may be used. The patch is identified as b425859021d17adf62f06fb904797cf8642986ad. It is recommended to apply a patch to fix this issue.,CVE-2025-1182,tykio/tyk-plugin-compiler
binutils-x86-64-linux-gnu,LOW,2.35.2-2,,A vulnerability has been found in GNU Binutils 2.43/2.44 and classified as problematic. Affected by this vulnerability is the function display_info of the file binutils/bucomm.c of the component objdump. The manipulation leads to memory leak. An attack has to be approached locally. The exploit has been disclosed to the public and may be used. The patch is named ba6ad3a18cb26b79e0e3b84c39f707535bbc344d. It is recommended to apply a patch to fix this issue.,CVE-2025-3198,tykio/tyk-plugin-compiler
bsdutils,LOW,1:2.36.1-8+deb11u2,,A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an INPUTRC environment variable to get a path to the library config file. When the library cannot parse the specified file it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.,CVE-2022-0563,tykio/gromit & tykio/tyk-plugin-compiler
coreutils,LOW,8.32-4+b1,,chroot in GNU coreutils when used with --userspec allows local users to escape to the parent session via a crafted TIOCSTI ioctl call which pushes characters to the terminal's input buffer.,CVE-2016-2781,tykio/gromit & tykio/tyk-plugin-compiler
coreutils,LOW,8.32-4+b1,,In GNU Coreutils through 8.29 chown-core.c in chown and chgrp does not prevent replacement of a plain file with a symlink during use of the POSIX -R -L options which allows local users to modify the ownership of arbitrary files by leveraging a race condition.,CVE-2017-18018,tykio/gromit & tykio/tyk-plugin-compiler
cpp-10,LOW,10.2.1-6,,**DISPUTED**A failure in the -fstack-protector feature in GCC-based toolchains nthat target AArch64 allows an attacker to exploit an existing buffer noverflow in dynamically-sized local variables in your application nwithout this being detected. This stack-protector failure only applies nto C99-style dynamically-sized local variables or those created using nalloca(). The stack-protector operates as intended for statically-sized nlocal variables.nnThe default behavior when the stack-protector ndetects an overflow is to terminate your application resulting in ncontrolled loss of availability. An attacker who can exploit a buffer noverflow without triggering the stack-protector might be able to change nprogram flow control to cause an uncontrolled loss of availability or ton go further and affect confidentiality or integrity. NOTE: The GCC project argues that this is a missed hardening bug and not a vulnerability by itself.,CVE-2023-4039,tykio/tyk-plugin-compiler
cross-config,LOW,2.6.18+nmu1,,gccross in dpkg-cross 2.3.0 allows local users to overwrite arbitrary files via a symlink attack on the tmp/gccross2.log temporary file. NOTE: the vendor disputes this vulnerability stating that There is no sense in this bug - the script ... is called under specific cross-building environments within a chroot.,CVE-2008-4950,tykio/tyk-plugin-compiler
curl,MEDIUM,7.88.1-10+deb12u8,7.88.1-10+deb12u10,When asked to both use a `.netrc` file for credentials and to follow HTTPnredirects curl could leak the password used for the first host to thenfollowed-to host under certain circumstances.nnThis flaw only manifests itself if the netrc file has an entry that matchesnthe redirect target hostname but the entry either omits just the password ornomits both login and password.,CVE-2024-11053,tykio/gromit
curl,LOW,7.88.1-10+deb12u8,,libcurl skips the certificate verification for a QUIC connection under certain conditions when built to use wolfSSL. If told to use an unknown/bad cipher or curve the error path accidentally skips the verification and returns OK thus ignoring any certificate problems.,CVE-2024-2379,tykio/gromit
curl,MEDIUM,7.88.1-10+deb12u8,7.88.1-10+deb12u9,When curl is asked to use HSTS the expiry time for a subdomain mightnoverwrite a parent domain's cache entry making it end sooner or later thannotherwise intended.nnThis affects curl using applications that enable HSTS and use URLs with theninsecure `HTTP://` scheme and perform transfers with hosts liken`x.example.com` as well as `example.com` where the first host is a subdomainnof the second host.nn(The HSTS cache either needs to have been populated manually or there needs tonhave been previous HTTPS accesses done as the cache needs to have entries fornthe domains involved to trigger this problem.)nnWhen `x.example.com` responds with `Strict-Transport-Security:` headers thisnbug can make the subdomain's expiry timeout *bleed over* and get set for thenparent domain `example.com` in curl's HSTS cache.nnThe result of a triggered bug is that HTTP accesses to `example.com` getnconverted to HTTPS for a different period of time than what was asked for bynthe origin server. If `example.com` for example stops supporting HTTPS at itsnexpiry time curl might then fail to access `http://example.com` until then(wrongly set) timeout expires. This bug can also expire the parent's entryn*earlier* thus making curl inadvertently switch back to insecure HTTP earliernthan otherwise intended.,CVE-2024-9681,tykio/gromit
curl,LOW,7.88.1-10+deb12u8,7.88.1-10+deb12u11,When asked to use a `.netrc` file for credentials **and** to follow HTTPnredirects curl could leak the password used for the first host to thenfollowed-to host under certain circumstances.nnThis flaw only manifests itself if the netrc file has a `default` entry thatnomits both login and password. A rare circumstance.,CVE-2025-0167,tykio/gromit
curl,LOW,7.88.1-10+deb12u8,,When libcurl is asked to perform automatic gzip decompression ofncontent-encoded HTTP responses with the `CURLOPT_ACCEPT_ENCODING` optionn**using zlib 1.2.0.3 or older** an attacker-controlled integer overflow wouldnmake libcurl perform a buffer overflow.,CVE-2025-0725,tykio/gromit
dpkg-cross,LOW,2.6.18+nmu1,,gccross in dpkg-cross 2.3.0 allows local users to overwrite arbitrary files via a symlink attack on the tmp/gccross2.log temporary file. NOTE: the vendor disputes this vulnerability stating that There is no sense in this bug - the script ... is called under specific cross-building environments within a chroot.,CVE-2008-4950,tykio/tyk-plugin-compiler
g++-10,LOW,10.2.1-6,,**DISPUTED**A failure in the -fstack-protector feature in GCC-based toolchains nthat target AArch64 allows an attacker to exploit an existing buffer noverflow in dynamically-sized local variables in your application nwithout this being detected. This stack-protector failure only applies nto C99-style dynamically-sized local variables or those created using nalloca(). The stack-protector operates as intended for statically-sized nlocal variables.nnThe default behavior when the stack-protector ndetects an overflow is to terminate your application resulting in ncontrolled loss of availability. An attacker who can exploit a buffer noverflow without triggering the stack-protector might be able to change nprogram flow control to cause an uncontrolled loss of availability or ton go further and affect confidentiality or integrity. NOTE: The GCC project argues that this is a missed hardening bug and not a vulnerability by itself.,CVE-2023-4039,tykio/tyk-plugin-compiler
gcc-10,LOW,10.2.1-6,,**DISPUTED**A failure in the -fstack-protector feature in GCC-based toolchains nthat target AArch64 allows an attacker to exploit an existing buffer noverflow in dynamically-sized local variables in your application nwithout this being detected. This stack-protector failure only applies nto C99-style dynamically-sized local variables or those created using nalloca(). The stack-protector operates as intended for statically-sized nlocal variables.nnThe default behavior when the stack-protector ndetects an overflow is to terminate your application resulting in ncontrolled loss of availability. An attacker who can exploit a buffer noverflow without triggering the stack-protector might be able to change nprogram flow control to cause an uncontrolled loss of availability or ton go further and affect confidentiality or integrity. NOTE: The GCC project argues that this is a missed hardening bug and not a vulnerability by itself.,CVE-2023-4039,tykio/tyk-plugin-compiler
gcc-10-base,LOW,10.2.1-6,,**DISPUTED**A failure in the -fstack-protector feature in GCC-based toolchains nthat target AArch64 allows an attacker to exploit an existing buffer noverflow in dynamically-sized local variables in your application nwithout this being detected. This stack-protector failure only applies nto C99-style dynamically-sized local variables or those created using nalloca(). The stack-protector operates as intended for statically-sized nlocal variables.nnThe default behavior when the stack-protector ndetects an overflow is to terminate your application resulting in ncontrolled loss of availability. An attacker who can exploit a buffer noverflow without triggering the stack-protector might be able to change nprogram flow control to cause an uncontrolled loss of availability or ton go further and affect confidentiality or integrity. NOTE: The GCC project argues that this is a missed hardening bug and not a vulnerability by itself.,CVE-2023-4039,tykio/tyk-plugin-compiler
gcc-12-base,LOW,12.2.0-14,,libiberty/rust-demangle.c in GNU GCC 11.2 allows stack consumption in demangle_const as demonstrated by nm-new.,CVE-2022-27943,tykio/gromit
gcc-12-base,LOW,12.2.0-14,,**DISPUTED**A failure in the -fstack-protector feature in GCC-based toolchains nthat target AArch64 allows an attacker to exploit an existing buffer noverflow in dynamically-sized local variables in your application nwithout this being detected. This stack-protector failure only applies nto C99-style dynamically-sized local variables or those created using nalloca(). The stack-protector operates as intended for statically-sized nlocal variables.nnThe default behavior when the stack-protector ndetects an overflow is to terminate your application resulting in ncontrolled loss of availability. An attacker who can exploit a buffer noverflow without triggering the stack-protector might be able to change nprogram flow control to cause an uncontrolled loss of availability or ton go further and affect confidentiality or integrity. NOTE: The GCC project argues that this is a missed hardening bug and not a vulnerability by itself.,CVE-2023-4039,tykio/gromit
gcc-9-base,LOW,9.3.0-22,,**DISPUTED**A failure in the -fstack-protector feature in GCC-based toolchains nthat target AArch64 allows an attacker to exploit an existing buffer noverflow in dynamically-sized local variables in your application nwithout this being detected. This stack-protector failure only applies nto C99-style dynamically-sized local variables or those created using nalloca(). The stack-protector operates as intended for statically-sized nlocal variables.nnThe default behavior when the stack-protector ndetects an overflow is to terminate your application resulting in ncontrolled loss of availability. An attacker who can exploit a buffer noverflow without triggering the stack-protector might be able to change nprogram flow control to cause an uncontrolled loss of availability or ton go further and affect confidentiality or integrity. NOTE: The GCC project argues that this is a missed hardening bug and not a vulnerability by itself.,CVE-2023-4039,tykio/tyk-plugin-compiler
gh,CRITICAL,2.63.0,,The GitHub CLI version 2.6.1 and earlier are vulnerable to remote code execution through a malicious codespace SSH server when using `gh codespace ssh` or `gh codespace logs` commands. This has been patched in the cli v2.62.0.nnDevelopers connect to remote codespaces through an SSH server running within the devcontainer which is generally provided through the [default devcontainer image]( https://docs.github.com/en/codespaces/setting-up-your-project-for-codespaces/adding-a-dev-container-... https://docs.github.com/en/codespaces/setting-up-your-project-for-codespaces/adding-a-dev-container-configuration/introduction-to-dev-containers#using-the-default-dev-container-configuration) . GitHub CLI [retrieves SSH connection details]( https://github.com/cli/cli/blob/30066b0042d0c5928d959e288144300cb28196c9/internal/codespaces/rpc/inv... https://github.com/cli/cli/blob/30066b0042d0c5928d959e288144300cb28196c9/internal/codespaces/rpc/invoker.go#L230-L244 ) such as remote username which is used in [executing `ssh` commands]( https://github.com/cli/cli/blob/e356c69a6f0125cfaac782c35acf77314f18908d/pkg/cmd/codespace/ssh.go#L2... https://github.com/cli/cli/blob/e356c69a6f0125cfaac782c35acf77314f18908d/pkg/cmd/codespace/ssh.go#L263 ) for `gh codespace ssh` or `gh codespace logs` commands.nnThis exploit occurs when a malicious third-party devcontainer contains a modified SSH server that injects `ssh` arguments within the SSH connection details. `gh codespace ssh` and `gh codespace logs` commands could execute arbitrary code on the user's workstation if the remote username contains something like `-oProxyCommand=echo hacked #`. The `-oProxyCommand` flag causes `ssh` to execute the provided command while `#` shell comment causes any other `ssh` arguments to be ignored.nnIn `2.62.0` the remote username information is being validated before being used.,CVE-2024-52308,tykio/gromit
gh,MEDIUM,2.63.0,,The gh cli is GitHubs official command line tool. A security vulnerability has been identified in the GitHub CLI that could leak authentication tokens when cloning repositories containing `git` submodules hosted outside of GitHub.com and ghe.com. This vulnerability stems from several `gh` commands used to clone a repository with submodules from a non-GitHub host including `gh repo clone` `gh repo fork` and `gh pr checkout`. These GitHub CLI commands invoke git with instructions to retrieve authentication tokens using the `credential.helper` configuration variable for any host encountered. Prior to version `2.63.0` hosts other than GitHub.com and ghe.com are treated as GitHub Enterprise Server hosts and have tokens sourced from the following environment variables before falling back to host-specific tokens stored within system-specific secured storage: 1. `GITHUB_ENTERPRISE_TOKEN` 2. `GH_ENTERPRISE_TOKEN` and 3. `GITHUB_TOKEN` when the `CODESPACES` environment variable is set. The result being `git` sending authentication tokens when cloning submodules. In version `2.63.0` these GitHub CLI commands will limit the hosts for which `gh` acts as a credential helper to source authentication tokens. Additionally `GITHUB_TOKEN` will only be used for GitHub.com and ghe.com. Users are advised to upgrade. Additionally users are advised to revoke authentication tokens used with the GitHub CLI and to review their personal security log and any relevant audit logs for actions associated with their account or enterprise,CVE-2024-53858,tykio/gromit
gh,MEDIUM,2.63.0,,The GitHub CLI is GitHubs official command line tool. A security vulnerability has been identified in GitHub CLI that could create or overwrite files in unintended directories when users download a malicious GitHub Actions workflow artifact through gh run download. This vulnerability stems from a GitHub Actions workflow artifact named .. when downloaded using gh run download. The artifact name and --dir flag are used to determine the artifacts download path. When the artifact is named .. the resulting files within the artifact are extracted exactly 1 directory higher than the specified --dir flag value. This vulnerability is fixed in 2.63.1.,CVE-2024-54132,tykio/gromit
git,LOW,1:2.30.2-1+deb11u4,,GIT version 2.15.1 and earlier contains a Input Validation Error vulnerability in Client that can result in problems including messing up terminal configuration to RCE. This attack appear to be exploitable via The user must interact with a malicious git server (or have their traffic modified in a MITM attack).,CVE-2018-1000021,tykio/gromit & tykio/tyk-plugin-compiler
git,LOW,1:2.30.2-1+deb11u4,,The --mirror documentation for Git through 2.35.1 does not mention the availability of deleted content aka the GitBleed issue. This could present a security risk if information-disclosure auditing processes rely on a clone operation without the --mirror option. Note: This has been disputed by multiple 3rd parties who believe this is an intended feature of the git binary and does not pose a security risk.,CVE-2022-24975,tykio/gromit & tykio/tyk-plugin-compiler
git,LOW,1:2.30.2-1+deb11u4,,Git is a revision control system. Prior to versions 2.45.1 2.44.1 2.43.4 2.42.2 2.41.1 2.40.2 and 2.39.4 local clones may end up hardlinking files into the target repository's object database when source and target repository reside on the same disk. If the source repository is owned by a different user then those hardlinked files may be rewritten at any point in time by the untrusted user. Cloning local repositories will cause Git to either copy or hardlink files of the source repository into the target repository. This significantly speeds up such local clones compared to doing a proper clone and saves both disk space and compute time. When cloning a repository located on the same disk that is owned by a different user than the current user we also end up creating such hardlinks. These files will continue to be owned and controlled by the potentially-untrusted user and can be rewritten by them at will in the future. The problem has been patched in versions 2.45.1 2.44.1 2.43.4 2.42.2 2.41.1 2.40.2 and 2.39.4.,CVE-2024-32020,tykio/tyk-plugin-compiler
git,LOW,1:2.39.5-0+deb12u1,1:2.39.5-0+deb12u2,Git is a fast scalable distributed revision control system with an unusually rich command set that provides both high-level operations and full access to internals. When Git asks for credentials via a terminal prompt (i.e. without using any credential helper) it prints out the host name for which the user is expected to provide a username and/or a password. At this stage any URL-encoded parts have been decoded already and are printed verbatim. This allows attackers to craft URLs that contain ANSI escape sequences that the terminal interpret to confuse users e.g. into providing passwords for trusted Git hosting sites when in fact they are then sent to untrusted sites that are under the attacker's control. This issue has been patch via commits `7725b81` and `c903985` which are included in release versions v2.48.1 v2.47.2 v2.46.3 v2.45.3 v2.44.3 v2.43.6 v2.42.4 v2.41.3 and v2.40.4. Users are advised to upgrade. Users unable to upgrade should avoid cloning from untrusted URLs especially recursive clones.,CVE-2024-50349,tykio/gromit
git,LOW,1:2.30.2-1+deb11u4,,Git is a source code management tool. When cloning from a server (or fetching or pushing) informational or error messages are transported from the remote Git process to the client via the so-called sideband channel. These messages will be prefixed with remote: and printed directly to the standard error output. Typically this standard error output is connected to a terminal that understands ANSI escape sequences which Git did not protect against. Most modern terminals support control sequences that can be used by a malicious actor to hide and misrepresent information or to mislead the user into executing untrusted scripts. As requested on the git-security mailing list the patches are under discussion on the public mailing list. Users are advised to update as soon as possible. Users unable to upgrade should avoid recursive clones unless they are from trusted sources.,CVE-2024-52005,tykio/gromit & tykio/tyk-plugin-compiler
git,MEDIUM,1:2.39.5-0+deb12u1,1:2.39.5-0+deb12u2,Git is a fast scalable distributed revision control system with an unusually rich command set that provides both high-level operations and full access to internals. Git defines a line-based protocol that is used to exchange information between Git and Git credential helpers. Some ecosystems (most notably .NET and node.js) interpret single Carriage Return characters as newlines which renders the protections against CVE-2020-5260 incomplete for credential helpers that treat Carriage Returns in this way. This issue has been addressed in commit `b01b9b8` which is included in release versions v2.48.1 v2.47.2 v2.46.3 v2.45.3 v2.44.3 v2.43.6 v2.42.4 v2.41.3 and v2.40.4. Users are advised to upgrade. Users unable to upgrade should avoid cloning from untrusted URLs especially recursive clones.,CVE-2024-52006,tykio/gromit
git-man,LOW,1:2.30.2-1+deb11u4,,GIT version 2.15.1 and earlier contains a Input Validation Error vulnerability in Client that can result in problems including messing up terminal configuration to RCE. This attack appear to be exploitable via The user must interact with a malicious git server (or have their traffic modified in a MITM attack).,CVE-2018-1000021,tykio/gromit & tykio/tyk-plugin-compiler
git-man,LOW,1:2.30.2-1+deb11u4,,The --mirror documentation for Git through 2.35.1 does not mention the availability of deleted content aka the GitBleed issue. This could present a security risk if information-disclosure auditing processes rely on a clone operation without the --mirror option. Note: This has been disputed by multiple 3rd parties who believe this is an intended feature of the git binary and does not pose a security risk.,CVE-2022-24975,tykio/gromit & tykio/tyk-plugin-compiler
git-man,LOW,1:2.30.2-1+deb11u4,,Git is a revision control system. Prior to versions 2.45.1 2.44.1 2.43.4 2.42.2 2.41.1 2.40.2 and 2.39.4 local clones may end up hardlinking files into the target repository's object database when source and target repository reside on the same disk. If the source repository is owned by a different user then those hardlinked files may be rewritten at any point in time by the untrusted user. Cloning local repositories will cause Git to either copy or hardlink files of the source repository into the target repository. This significantly speeds up such local clones compared to doing a proper clone and saves both disk space and compute time. When cloning a repository located on the same disk that is owned by a different user than the current user we also end up creating such hardlinks. These files will continue to be owned and controlled by the potentially-untrusted user and can be rewritten by them at will in the future. The problem has been patched in versions 2.45.1 2.44.1 2.43.4 2.42.2 2.41.1 2.40.2 and 2.39.4.,CVE-2024-32020,tykio/tyk-plugin-compiler
git-man,LOW,1:2.39.5-0+deb12u1,1:2.39.5-0+deb12u2,Git is a fast scalable distributed revision control system with an unusually rich command set that provides both high-level operations and full access to internals. When Git asks for credentials via a terminal prompt (i.e. without using any credential helper) it prints out the host name for which the user is expected to provide a username and/or a password. At this stage any URL-encoded parts have been decoded already and are printed verbatim. This allows attackers to craft URLs that contain ANSI escape sequences that the terminal interpret to confuse users e.g. into providing passwords for trusted Git hosting sites when in fact they are then sent to untrusted sites that are under the attacker's control. This issue has been patch via commits `7725b81` and `c903985` which are included in release versions v2.48.1 v2.47.2 v2.46.3 v2.45.3 v2.44.3 v2.43.6 v2.42.4 v2.41.3 and v2.40.4. Users are advised to upgrade. Users unable to upgrade should avoid cloning from untrusted URLs especially recursive clones.,CVE-2024-50349,tykio/gromit
git-man,LOW,1:2.30.2-1+deb11u4,,Git is a source code management tool. When cloning from a server (or fetching or pushing) informational or error messages are transported from the remote Git process to the client via the so-called sideband channel. These messages will be prefixed with remote: and printed directly to the standard error output. Typically this standard error output is connected to a terminal that understands ANSI escape sequences which Git did not protect against. Most modern terminals support control sequences that can be used by a malicious actor to hide and misrepresent information or to mislead the user into executing untrusted scripts. As requested on the git-security mailing list the patches are under discussion on the public mailing list. Users are advised to update as soon as possible. Users unable to upgrade should avoid recursive clones unless they are from trusted sources.,CVE-2024-52005,tykio/gromit & tykio/tyk-plugin-compiler
git-man,MEDIUM,1:2.39.5-0+deb12u1,1:2.39.5-0+deb12u2,Git is a fast scalable distributed revision control system with an unusually rich command set that provides both high-level operations and full access to internals. Git defines a line-based protocol that is used to exchange information between Git and Git credential helpers. Some ecosystems (most notably .NET and node.js) interpret single Carriage Return characters as newlines which renders the protections against CVE-2020-5260 incomplete for credential helpers that treat Carriage Returns in this way. This issue has been addressed in commit `b01b9b8` which is included in release versions v2.48.1 v2.47.2 v2.46.3 v2.45.3 v2.44.3 v2.43.6 v2.42.4 v2.41.3 and v2.40.4. Users are advised to upgrade. Users unable to upgrade should avoid cloning from untrusted URLs especially recursive clones.,CVE-2024-52006,tykio/gromit
github.com/go-git/go-git/v5,CRITICAL,v5.12.0,5.13.0,go-git is a highly extensible git implementation library written in pure Go. An argument injection vulnerability was discovered in go-git versions prior to v5.13. Successful exploitation of this vulnerability could allow an attacker to set arbitrary values to git-upload-pack flags. This only happens when the file transport protocol is being used as that is the only protocol that shells out to git binaries. This vulnerability is fixed in 5.13.0.,CVE-2025-21613,tykio/gromit
github.com/go-git/go-git/v5,HIGH,v5.12.0,5.13.0,go-git is a highly extensible git implementation library written in pure Go. A denial of service (DoS) vulnerability was discovered in go-git versions prior to v5.13. This vulnerability allows an attacker to perform denial of service attacks by providing specially crafted responses from a Git server which triggers resource exhaustion in go-git clients. Users running versions of go-git from v4 and above are recommended to upgrade to v5.13 in order to mitigate this vulnerability.,CVE-2025-21614,tykio/gromit
github.com/redis/go-redis/v9,LOW,v9.7.0,9.7.3, 9.6.3, 9.5.5,go-redis is the official Redis client library for the Go programming language. Prior to 9.5.5 9.6.3 and 9.7.3 go-redis potentially responds out of order when `CLIENT SETINFO` times out during connection establishment. This can happen when the client is configured to transmit its identity there are network connectivity issues or the client was configured with aggressive timeouts. The problem occurs for multiple use cases. For sticky connections you receive persistent out-of-order responses for the lifetime of the connection. All commands in the pipeline receive incorrect responses. When used with the default ConnPool once a connection is returned after use with ConnPool#Put the read buffer will be checked and the connection will be marked as bad due to the unread data. This means that at most one out-of-order response before the connection is discarded. This issue is fixed in 9.5.5 9.6.3 and 9.7.3. You can prevent the vulnerability by setting the flag DisableIndentity to true when constructing the client instance.,CVE-2025-29923,tykio/tyk-dashboard & tykio/tyk-gateway & tykio/tyk-plugin-compiler
golang.org/x/crypto,CRITICAL,v0.27.0,0.31.0,Applications and libraries which misuse connection.serverAuthenticate (via callback field ServerConfig.PublicKeyCallback) may be susceptible to an authorization bypass. The documentation for ServerConfig.PublicKeyCallback says that A call to this function does not guarantee that the key offered is in fact used to authenticate. Specifically the SSH protocol allows clients to inquire about whether a public key is acceptable before proving control of the corresponding private key. PublicKeyCallback may be called with multiple keys and the order in which the keys were provided cannot be used to infer which key the client successfully authenticated with if any. Some applications which store the key(s) passed to PublicKeyCallback (or derived information) and make security relevant determinations based on it once the connection is established may make incorrect assumptions. For example an attacker may send public keys A and B and then authenticate with A. PublicKeyCallback would be called only twice first with A and then with B. A vulnerable application may then make authorization decisions based on key B for which the attacker does not actually control the private key. Since this API is widely misused as a partial mitigation golang.org/x/cry...@v0.31.0 enforces the property that when successfully authenticating via public key the last key passed to ServerConfig.PublicKeyCallback will be the key used to authenticate the connection. PublicKeyCallback will now be called multiple times with the same key if necessary. Note that the client may still not control the last key passed to PublicKeyCallback if the connection is then authenticated with a different method such as PasswordCallback KeyboardInteractiveCallback or NoClientAuth. Users should be using the Extensions field of the Permissions return value from the various authentication callbacks to record data associated with the authentication attempt instead of referencing external state. Once the connection is established the state corresponding to the successful authentication attempt can be retrieved via the ServerConn.Permissions field. Note that some third-party libraries misuse the Permissions type by sharing it across authentication attempts; users of third-party libraries should refer to the relevant projects for guidance.,CVE-2024-45337,tykio/gromit
golang.org/x/crypto,HIGH,v0.27.0,0.35.0,SSH servers which implement file transfer protocols are vulnerable to a denial of service attack from clients which complete the key exchange slowly or not at all causing pending content to be read into memory but never transmitted.,CVE-2025-22869,tykio/gromit
golang.org/x/net,MEDIUM,v0.25.0,0.36.0,Matching of hosts against proxy patterns can improperly treat an IPv6 zone ID as a hostname component. For example when the NO_PROXY environment variable is set to *.example.com a request to [::1%25.example.com]:80` will incorrectly match and not be proxied.,CVE-2025-22870,tykio/gromit
golang.org/x/net,MEDIUM,v0.36.0,0.38.0,The tokenizer incorrectly interprets tags with unquoted attribute values that end with a solidus character (/) as self-closing. When directly using Tokenizer this can result in such tags incorrectly being marked as self-closing and when using the Parse functions this can result in content following such tags as being placed in the wrong scope during DOM construction but only when tags are in foreign content (e.g. <math> <svg> etc contexts).,CVE-2025-22872,tykio/gromit & tykio/tyk-gateway & tykio/tyk-plugin-compiler & tykio/tyk-sync
google.golang.org/grpc,MEDIUM,v1.53.0,1.58.3, 1.57.1, 1.56.3,The HTTP/2 protocol allows a denial of service (server resource consumption) because request cancellation can reset many streams quickly as exploited in the wild in August through October 2023.,CVE-2023-44487,tykio/tyk-plugin-compiler
google.golang.org/grpc,HIGH,v1.53.0,1.56.3, 1.57.1, 1.58.3,### ImpactnIn affected releases of gRPC-Go it is possible for an attacker to send HTTP/2 requests cancel them and send subsequent requests which is valid by the HTTP/2 protocol but would cause the gRPC-Go server to launch more concurrent method handlers than the configured maximum stream limit.nn### PatchesnThis vulnerability was addressed by #6703 and has been included in patch releases: 1.56.3 1.57.1 1.58.3. It is also included in the latest release 1.59.0.nnAlong with applying the patch users should also ensure they are using the `grpc.MaxConcurrentStreams` server option to apply a limit to the server's resources used for any single connection.nn### WorkaroundsnNone.nn### Referencesn#6703n,GHSA-m425-mq94-257g,tykio/tyk-plugin-compiler
google.golang.org/protobuf,MEDIUM,v1.28.1,1.33.0,The protojson.Unmarshal function can enter an infinite loop when unmarshaling certain forms of invalid JSON. This condition can occur when unmarshaling into a message which contains a google.protobuf.Any value or when the UnmarshalOptions.DiscardUnknown option is set.,CVE-2024-24786,tykio/tyk-plugin-compiler
gpgv,LOW,2.2.27-2+deb11u2,,GnuPG can be made to spin on a relatively small input by (for example) crafting a public key with thousands of signatures attached compressed down to just a few KB.,CVE-2022-3219,tykio/gromit & tykio/tyk-plugin-compiler
gpgv,LOW,2.2.27-2+deb11u2,,In GnuPG before 2.5.5 if a user chooses to import a certificate with certain crafted subkey data that lacks a valid backsig or that has incorrect usage flags the user loses the ability to verify signatures made from certain other signing keys aka a verification DoS.,CVE-2025-30258,tykio/gromit & tykio/tyk-plugin-compiler
jq,MEDIUM,1.6-2.1,,decNumberCopy in decNumber.c in jq through 1.7.1 does not properly consider that NaN is interpreted as numeric which has a resultant stack-based buffer overflow and out-of-bounds write as demonstrated by use of --slurp with subtraction such as a filter of .-. when the input has a certain form of digit string with NaN (e.g. 1 NaN123 immediately followed by many more digits).,CVE-2024-53427,tykio/tyk-plugin-compiler
krb5-locales,LOW,1.20.1-2+deb12u2,,An issue was discovered in MIT Kerberos 5 (aka krb5) through 1.16. There is a variable dbentry->n_key_data in kadmin/dbutil/dump.c that can store 16-bit data but unknowingly the developer has assigned a u4 variable to it which is for 32-bit data. An attacker can use this vulnerability to affect other artifacts of the database as we know that a Kerberos database dump file contains trusted data.,CVE-2018-5709,tykio/gromit
krb5-locales,LOW,1.20.1-2+deb12u2,,Kerberos 5 (aka krb5) 1.21.2 contains a memory leak in /krb5/src/lib/rpc/pmap_rmt.c.,CVE-2024-26458,tykio/gromit
krb5-locales,LOW,1.20.1-2+deb12u2,,Kerberos 5 (aka krb5) 1.21.2 contains a memory leak vulnerability in /krb5/src/lib/gssapi/krb5/k5sealv3.c.,CVE-2024-26461,tykio/gromit
krb5-locales,MEDIUM,1.20.1-2+deb12u2,,Kerberos 5 (aka krb5) 1.21.2 contains a memory leak vulnerability in /krb5/src/kdc/ndr.c.,CVE-2024-26462,tykio/gromit
krb5-locales,MEDIUM,1.20.1-2+deb12u2,,A flaw was found in krb5. With incremental propagation enabled an authenticated attacker can cause kadmind to write beyond the end of the mapped region for the iprop log file. This issue can trigger a process crash and lead to a denial of service.,CVE-2025-24528,tykio/gromit
krb5-locales,MEDIUM,1.20.1-2+deb12u2,,A vulnerability in the MIT Kerberos implementation allows GSSAPI-protected messages using RC4-HMAC-MD5 to be spoofed due to weaknesses in the MD5 checksum design. If RC4 is preferred over stronger encryption types an attacker could exploit MD5 collisions to forge message integrity codes. This may lead to unauthorized message tampering.,CVE-2025-3576,tykio/gromit
lib32gcc-s1,LOW,10.2.1-6,,**DISPUTED**A failure in the -fstack-protector feature in GCC-based toolchains nthat target AArch64 allows an attacker to exploit an existing buffer noverflow in dynamically-sized local variables in your application nwithout this being detected. This stack-protector failure only applies nto C99-style dynamically-sized local variables or those created using nalloca(). The stack-protector operates as intended for statically-sized nlocal variables.nnThe default behavior when the stack-protector ndetects an overflow is to terminate your application resulting in ncontrolled loss of availability. An attacker who can exploit a buffer noverflow without triggering the stack-protector might be able to change nprogram flow control to cause an uncontrolled loss of availability or ton go further and affect confidentiality or integrity. NOTE: The GCC project argues that this is a missed hardening bug and not a vulnerability by itself.,CVE-2023-4039,tykio/tyk-plugin-compiler
lib32stdc++6,LOW,10.2.1-6,,**DISPUTED**A failure in the -fstack-protector feature in GCC-based toolchains nthat target AArch64 allows an attacker to exploit an existing buffer noverflow in dynamically-sized local variables in your application nwithout this being detected. This stack-protector failure only applies nto C99-style dynamically-sized local variables or those created using nalloca(). The stack-protector operates as intended for statically-sized nlocal variables.nnThe default behavior when the stack-protector ndetects an overflow is to terminate your application resulting in ncontrolled loss of availability. An attacker who can exploit a buffer noverflow without triggering the stack-protector might be able to change nprogram flow control to cause an uncontrolled loss of availability or ton go further and affect confidentiality or integrity. NOTE: The GCC project argues that this is a missed hardening bug and not a vulnerability by itself.,CVE-2023-4039,tykio/tyk-plugin-compiler
libapt-pkg6.0,LOW,2.2.4,,It was found that apt-key in apt all versions do not correctly validate gpg keys with the master keyring leading to a potential man-in-the-middle attack.,CVE-2011-3374,tykio/gromit & tykio/tyk-plugin-compiler
libasan6,LOW,10.2.1-6,,**DISPUTED**A failure in the -fstack-protector feature in GCC-based toolchains nthat target AArch64 allows an attacker to exploit an existing buffer noverflow in dynamically-sized local variables in your application nwithout this being detected. This stack-protector failure only applies nto C99-style dynamically-sized local variables or those created using nalloca(). The stack-protector operates as intended for statically-sized nlocal variables.nnThe default behavior when the stack-protector ndetects an overflow is to terminate your application resulting in ncontrolled loss of availability. An attacker who can exploit a buffer noverflow without triggering the stack-protector might be able to change nprogram flow control to cause an uncontrolled loss of availability or ton go further and affect confidentiality or integrity. NOTE: The GCC project argues that this is a missed hardening bug and not a vulnerability by itself.,CVE-2023-4039,tykio/tyk-plugin-compiler
libatomic1,LOW,10.2.1-6,,**DISPUTED**A failure in the -fstack-protector feature in GCC-based toolchains nthat target AArch64 allows an attacker to exploit an existing buffer noverflow in dynamically-sized local variables in your application nwithout this being detected. This stack-protector failure only applies nto C99-style dynamically-sized local variables or those created using nalloca(). The stack-protector operates as intended for statically-sized nlocal variables.nnThe default behavior when the stack-protector ndetects an overflow is to terminate your application resulting in ncontrolled loss of availability. An attacker who can exploit a buffer noverflow without triggering the stack-protector might be able to change nprogram flow control to cause an uncontrolled loss of availability or ton go further and affect confidentiality or integrity. NOTE: The GCC project argues that this is a missed hardening bug and not a vulnerability by itself.,CVE-2023-4039,tykio/tyk-plugin-compiler
libbinutils,LOW,2.35.2-2,,The C++ symbol demangler routine in cplus-dem.c in libiberty as distributed in GNU Binutils 2.29 allows remote attackers to cause a denial of service (excessive memory allocation and application crash) via a crafted file as demonstrated by a call from the Binary File Descriptor (BFD) library (aka libbfd).,CVE-2017-13716,tykio/tyk-plugin-compiler
libbinutils,LOW,2.35.2-2,,The demangle_template function in cplus-dem.c in GNU libiberty as distributed in GNU Binutils 2.31.1 contains an integer overflow vulnerability (for Create an array for saving the template argument values) that can trigger a heap-based buffer overflow as demonstrated by nm.,CVE-2018-20673,tykio/tyk-plugin-compiler
libbinutils,LOW,2.35.2-2,,A heap-based buffer over-read exists in the function d_expression_1 in cp-demangle.c in GNU libiberty as distributed in GNU Binutils 2.31.1. A crafted input can cause segmentation faults leading to denial-of-service as demonstrated by c++filt.,CVE-2018-20712,tykio/tyk-plugin-compiler
libbinutils,LOW,2.35.2-2,,An issue was discovered in cplus-dem.c in GNU libiberty as distributed in GNU Binutils 2.30. Stack Exhaustion occurs in the C++ demangling functions provided by libiberty and there are recursive stack frames: demangle_template_value_parm demangle_integral_value and demangle_expression.,CVE-2018-9996,tykio/tyk-plugin-compiler
libbinutils,LOW,2.35.2-2,,GNU binutils gold gold v1.11-v1.16 (GNU binutils v2.21-v2.31.1) is affected by: Improper Input Validation Signed/Unsigned Comparison Out-of-bounds Read. The impact is: Denial of service. The component is: gold/fileread.cc:497 elfcpp/elfcpp_file.h:644. The attack vector is: An ELF file with an invalid e_shoff header field must be opened.,CVE-2019-1010204,tykio/tyk-plugin-compiler
libbinutils,LOW,2.35.2-2,,An issue was discovered in binutils libbfd.c 2.36 relating to the auxiliary symbol data allows attackers to read or write to system memory or cause a denial of service.,CVE-2020-19726,tykio/tyk-plugin-compiler
libbinutils,LOW,2.35.2-2,,An issue was discovered in the Binary File Descriptor (BFD) library (aka libbfd) as distributed in GNU Binutils 2.35.1. A heap-based buffer over-read can occur in bfd_getl_signed_32 in libbfd.c because sh_entsize is not validated in _bfd_elf_slurp_secondary_reloc_section in elf.c.,CVE-2020-35448,tykio/tyk-plugin-compiler
libbinutils,LOW,2.35.2-2,,There is an open race window when writing output in the following utilities in GNU binutils version 2.35 and earlier:ar objcopy strip ranlib. When these utilities are run as a privileged user (presumably as part of a script updating binaries across different users) an unprivileged user can trick these utilities into getting ownership of arbitrary files through a symlink.,CVE-2021-20197,tykio/tyk-plugin-compiler
libbinutils,LOW,2.35.2-2,,A flaw was found in GNU Binutils 2.35.1 where there is a heap-based buffer overflow in _bfd_elf_slurp_secondary_reloc_section in elf.c due to the number of symbols not calculated correctly. The highest threat from this vulnerability is to system availability.,CVE-2021-20284,tykio/tyk-plugin-compiler
libbinutils,LOW,2.35.2-2,,An issue was discovered in GNU libiberty as distributed in GNU Binutils 2.36. It is a stack-overflow issue in demangle_type in rust-demangle.c.,CVE-2021-32256,tykio/tyk-plugin-compiler
libbinutils,LOW,2.35.2-2,,A flaw was discovered in GNU libiberty within demangle_path() in rust-demangle.c as distributed in GNU Binutils version 2.36. A crafted symbol can cause stack memory to be exhausted leading to a crash.,CVE-2021-3530,tykio/tyk-plugin-compiler
libbinutils,LOW,2.35.2-2,,An out of bounds flaw was found in GNU binutils objdump utility version 2.36. An attacker could use this flaw and pass a large section to avr_elf32_load_records_from_section() probably resulting in a crash or in some cases memory corruption. The highest threat from this vulnerability is to integrity as well as system availability.,CVE-2021-3549,tykio/tyk-plugin-compiler
libbinutils,LOW,2.35.2-2,,Heap/stack buffer overflow in the dlang_lname function in d-demangle.c in libiberty allows attackers to potentially cause a denial of service (segmentation fault and crash) via a crafted mangled symbol.,CVE-2021-3826,tykio/tyk-plugin-compiler
libbinutils,LOW,2.35.2-2,,stab_xcoff_builtin_type in stabs.c in GNU Binutils through 2.37 allows attackers to cause a denial of service (heap-based buffer overflow) or possibly have unspecified other impact as demonstrated by an out-of-bounds write. NOTE: this issue exists because of an incorrect fix for CVE-2018-12699.,CVE-2021-45078,tykio/tyk-plugin-compiler
libbinutils,LOW,2.35.2-2,,Heap-based Buffer Overflow in function bfd_getl32 in Binutils objdump 3.37.,CVE-2021-46174,tykio/tyk-plugin-compiler
libbinutils,LOW,2.35.2-2,,GCC v12.0 was discovered to contain an uncontrolled recursion via the component libiberty/rust-demangle.c. This vulnerability allows attackers to cause a Denial of Service (DoS) by consuming excessive CPU and memory resources.,CVE-2021-46195,tykio/tyk-plugin-compiler
libbinutils,LOW,2.35.2-2,,An issue was discovered in Binutils readelf 2.38.50 reachable assertion failure in function display_debug_names allows attackers to cause a denial of service.,CVE-2022-35205,tykio/tyk-plugin-compiler
libbinutils,LOW,2.35.2-2,,Null pointer dereference vulnerability in Binutils readelf 2.38.50 via function read_and_display_attr_value in file dwarf.c.,CVE-2022-35206,tykio/tyk-plugin-compiler
libbinutils,LOW,2.35.2-2,,In GNU Binutils before 2.40 there is a heap-buffer-overflow in the error function bfd_getl32 when called from the strip_main function in strip-new via a crafted file.,CVE-2022-38533,tykio/tyk-plugin-compiler
libbinutils,LOW,2.35.2-2,,An illegal memory access flaw was found in the binutils package. Parsing an ELF file containing corrupt symbol version information may result in a denial of service. This issue is the result of an incomplete fix for CVE-2020-16599.,CVE-2022-4285,tykio/tyk-plugin-compiler
libbinutils,LOW,2.35.2-2,,Heap buffer overflow vulnerability in binutils readelf before 2.40 via function find_section_in_set in file readelf.c.,CVE-2022-44840,tykio/tyk-plugin-compiler
libbinutils,LOW,2.35.2-2,,Heap buffer overflow vulnerability in binutils readelf before 2.40 via function display_debug_section in file readelf.c.,CVE-2022-45703,tykio/tyk-plugin-compiler
libbinutils,LOW,2.35.2-2,,An issue was discovered function stab_demangle_v3_arg in stabs.c in Binutils 2.34 thru 2.38 allows attackers to cause a denial of service due to memory leaks.,CVE-2022-47007,tykio/tyk-plugin-compiler
libbinutils,LOW,2.35.2-2,,An issue was discovered function make_tempdir and make_tempname in bucomm.c in Binutils 2.34 thru 2.38 allows attackers to cause a denial of service due to memory leaks.,CVE-2022-47008,tykio/tyk-plugin-compiler
libbinutils,LOW,2.35.2-2,,An issue was discovered function pr_function_type in prdbg.c in Binutils 2.34 thru 2.38 allows attackers to cause a denial of service due to memory leaks.,CVE-2022-47010,tykio/tyk-plugin-compiler
libbinutils,LOW,2.35.2-2,,An issue was discovered function parse_stab_struct_fields in stabs.c in Binutils 2.34 thru 2.38 allows attackers to cause a denial of service due to memory leaks.,CVE-2022-47011,tykio/tyk-plugin-compiler
libbinutils,LOW,2.35.2-2,,An issue was discovered in Binutils addr2line before 2.39.3 function parse_module contains multiple out of bound reads which may cause a denial of service or other unspecified impacts.,CVE-2022-47673,tykio/tyk-plugin-compiler
libbinutils,LOW,2.35.2-2,,An issue was discovered Binutils objdump before 2.39.3 allows attackers to cause a denial of service or other unspecified impacts via function bfd_mach_o_get_synthetic_symtab in match-o.c.,CVE-2022-47695,tykio/tyk-plugin-compiler
libbinutils,LOW,2.35.2-2,,An issue was discovered Binutils objdump before 2.39.3 allows attackers to cause a denial of service or other unspecified impacts via function compare_symbols.,CVE-2022-47696,tykio/tyk-plugin-compiler
libbinutils,LOW,2.35.2-2,,GNU Binutils before 2.40 was discovered to contain an excessive memory consumption vulnerability via the function load_separate_debug_files at dwarf2.c. The attacker could supply a crafted ELF file and cause a DNS attack.,CVE-2022-48063,tykio/tyk-plugin-compiler
libbinutils,LOW,2.35.2-2,,GNU Binutils before 2.40 was discovered to contain an excessive memory consumption vulnerability via the function bfd_dwarf2_find_nearest_line_with_alt at dwarf2.c. The attacker could supply a crafted ELF file and cause a DNS attack.,CVE-2022-48064,tykio/tyk-plugin-compiler
libbinutils,LOW,2.35.2-2,,GNU Binutils before 2.40 was discovered to contain a memory leak vulnerability var the function find_abstract_instance in dwarf2.c.,CVE-2022-48065,tykio/tyk-plugin-compiler
libbinutils,LOW,2.35.2-2,,Heap based buffer overflow in binutils-gdb/bfd/libbfd.c in bfd_getl64.,CVE-2023-1579,tykio/tyk-plugin-compiler
libbinutils,LOW,2.35.2-2,,A potential heap based buffer overflow was found in _bfd_elf_slurp_version_tables() in bfd/elf.c. This may lead to loss of availability.,CVE-2023-1972,tykio/tyk-plugin-compiler
libbinutils,LOW,2.35.2-2,,An out-of-bounds read flaw was found in the parse_module function in bfd/vms-alpha.c in Binutils.,CVE-2023-25584,tykio/tyk-plugin-compiler
libbinutils,LOW,2.35.2-2,,A flaw was found in Binutils. The use of an uninitialized field in the struct module *module may lead to application crash and local denial of service.,CVE-2023-25585,tykio/tyk-plugin-compiler
libbinutils,LOW,2.35.2-2,,A flaw was found in Binutils. A logic fail in the bfd_init_section_decompress_status function may lead to the use of an uninitialized variable that can cause a crash and local denial of service.,CVE-2023-25586,tykio/tyk-plugin-compiler
libbinutils,LOW,2.35.2-2,,A flaw was found in Binutils. The field `the_bfd` of `asymbol`struct is uninitialized in the `bfd_mach_o_get_synthetic_symtab` function which may lead to an application crash and local denial of service.,CVE-2023-25588,tykio/tyk-plugin-compiler
libbinutils,LOW,2.35.2-2,,GNU objdump 2.43 is vulnerable to Buffer Overflow in the BFD (Binary File Descriptor) library's handling of tekhex format files.,CVE-2024-53589,tykio/tyk-plugin-compiler
libbinutils,LOW,2.35.2-2,,https://www.gnu.org/software/binutils/ nm >=2.43 is affected by: Incorrect Access Control. The type of exploitation is: local. The component is: `nm --without-symbol-version` function.,CVE-2024-57360,tykio/tyk-plugin-compiler
libbinutils,LOW,2.35.2-2,,A vulnerability which was classified as problematic was found in GNU Binutils up to 2.43. This affects the function disassemble_bytes of the file binutils/objdump.c. The manipulation of the argument buf leads to stack-based buffer overflow. It is possible to initiate the attack remotely. The complexity of an attack is rather high. The exploitability is told to be difficult. The exploit has been disclosed to the public and may be used. Upgrading to version 2.44 is able to address this issue. The identifier of the patch is baac6c221e9d69335bf41366a1c7d87d8ab2f893. It is recommended to upgrade the affected component.,CVE-2025-0840,tykio/tyk-plugin-compiler
libbinutils,LOW,2.35.2-2,,A vulnerability has been found in GNU Binutils 2.43 and classified as problematic. Affected by this vulnerability is the function __sanitizer::internal_strlen of the file binutils/nm.c of the component nm. The manipulation of the argument const leads to buffer overflow. The attack can be launched remotely. The complexity of an attack is rather high. The exploitation appears to be difficult. The exploit has been disclosed to the public and may be used.,CVE-2025-1147,tykio/tyk-plugin-compiler
libbinutils,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43 and classified as problematic. Affected by this issue is the function link_order_scan of the file ld/ldelfgen.c of the component ld. The manipulation leads to memory leak. The attack may be launched remotely. The complexity of an attack is rather high. The exploitation is known to be difficult. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue. The code maintainer explains: I'm not going to commit some of the leak fixes I've been working on to the 2.44 branch due to concern that would destabilise ld. All of the reported leaks in this bugzilla have been fixed on binutils master.,CVE-2025-1148,tykio/tyk-plugin-compiler
libbinutils,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43. It has been classified as problematic. This affects the function xstrdup of the file libiberty/xmalloc.c of the component ld. The manipulation leads to memory leak. It is possible to initiate the attack remotely. The complexity of an attack is rather high. The exploitability is told to be difficult. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue. The code maintainer explains: I'm not going to commit some of the leak fixes I've been working on to the 2.44 branch due to concern that would destabilise ld. All of the reported leaks in this bugzilla have been fixed on binutils master.,CVE-2025-1149,tykio/tyk-plugin-compiler
libbinutils,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43. It has been declared as problematic. This vulnerability affects the function bfd_malloc of the file libbfd.c of the component ld. The manipulation leads to memory leak. The attack can be initiated remotely. The complexity of an attack is rather high. The exploitation appears to be difficult. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue. The code maintainer explains: I'm not going to commit some of the leak fixes I've been working on to the 2.44 branch due to concern that would destabilise ld. All of the reported leaks in this bugzilla have been fixed on binutils master.,CVE-2025-1150,tykio/tyk-plugin-compiler
libbinutils,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43. It has been rated as problematic. This issue affects the function xmemdup of the file xmemdup.c of the component ld. The manipulation leads to memory leak. The attack may be initiated remotely. The complexity of an attack is rather high. The exploitation is known to be difficult. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue. The code maintainer explains: I'm not going to commit some of the leak fixes I've been working on to the 2.44 branch due to concern that would destabilise ld. All of the reported leaks in this bugzilla have been fixed on binutils master.,CVE-2025-1151,tykio/tyk-plugin-compiler
libbinutils,LOW,2.35.2-2,,A vulnerability classified as problematic has been found in GNU Binutils 2.43. Affected is the function xstrdup of the file xstrdup.c of the component ld. The manipulation leads to memory leak. It is possible to launch the attack remotely. The complexity of an attack is rather high. The exploitability is told to be difficult. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue. The code maintainer explains: I'm not going to commit some of the leak fixes I've been working on to the 2.44 branch due to concern that would destabilise ld. All of the reported leaks in this bugzilla have been fixed on binutils master.,CVE-2025-1152,tykio/tyk-plugin-compiler
libbinutils,LOW,2.35.2-2,,A vulnerability classified as problematic was found in GNU Binutils 2.43/2.44. Affected by this vulnerability is the function bfd_set_format of the file format.c. The manipulation leads to memory corruption. The attack can be launched remotely. The complexity of an attack is rather high. The exploitation appears to be difficult. Upgrading to version 2.45 is able to address this issue. The identifier of the patch is 8d97c1a53f3dc9fd8e1ccdb039b8a33d50133150. It is recommended to upgrade the affected component.,CVE-2025-1153,tykio/tyk-plugin-compiler
libbinutils,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43 and classified as critical. This issue affects the function _bfd_elf_gc_mark_rsec of the file elflink.c of the component ld. The manipulation leads to heap-based buffer overflow. The attack may be initiated remotely. The complexity of an attack is rather high. The exploitation is known to be difficult. The exploit has been disclosed to the public and may be used. The patch is named f9978defb6fab0bd8583942d97c112b0932ac814. It is recommended to apply a patch to fix this issue.,CVE-2025-1176,tykio/tyk-plugin-compiler
libbinutils,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43. It has been declared as problematic. Affected by this vulnerability is the function bfd_putl64 of the file libbfd.c of the component ld. The manipulation leads to memory corruption. The attack can be launched remotely. The complexity of an attack is rather high. The exploitation appears to be difficult. The exploit has been disclosed to the public and may be used. The identifier of the patch is 75086e9de1707281172cc77f178e7949a4414ed0. It is recommended to apply a patch to fix this issue.,CVE-2025-1178,tykio/tyk-plugin-compiler
libbinutils,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43. It has been rated as critical. Affected by this issue is the function bfd_putl64 of the file bfd/libbfd.c of the component ld. The manipulation leads to memory corruption. The attack may be launched remotely. The complexity of an attack is rather high. The exploitation is known to be difficult. The exploit has been disclosed to the public and may be used. Upgrading to version 2.44 is able to address this issue. It is recommended to upgrade the affected component. The code maintainer explains that [t]his bug has been fixed at some point between the 2.43 and 2.44 releases.,CVE-2025-1179,tykio/tyk-plugin-compiler
libbinutils,LOW,2.35.2-2,,A vulnerability classified as problematic has been found in GNU Binutils 2.43. This affects the function _bfd_elf_write_section_eh_frame of the file bfd/elf-eh-frame.c of the component ld. The manipulation leads to memory corruption. It is possible to initiate the attack remotely. The complexity of an attack is rather high. The exploitability is told to be difficult. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue.,CVE-2025-1180,tykio/tyk-plugin-compiler
libbinutils,LOW,2.35.2-2,,A vulnerability classified as critical was found in GNU Binutils 2.43. This vulnerability affects the function _bfd_elf_gc_mark_rsec of the file bfd/elflink.c of the component ld. The manipulation leads to memory corruption. The attack can be initiated remotely. The complexity of an attack is rather high. The exploitation appears to be difficult. The exploit has been disclosed to the public and may be used. The name of the patch is 931494c9a89558acb36a03a340c01726545eef24. It is recommended to apply a patch to fix this issue.,CVE-2025-1181,tykio/tyk-plugin-compiler
libbinutils,LOW,2.35.2-2,,A vulnerability which was classified as critical was found in GNU Binutils 2.43. Affected is the function bfd_elf_reloc_symbol_deleted_p of the file bfd/elflink.c of the component ld. The manipulation leads to memory corruption. It is possible to launch the attack remotely. The complexity of an attack is rather high. The exploitability is told to be difficult. The exploit has been disclosed to the public and may be used. The patch is identified as b425859021d17adf62f06fb904797cf8642986ad. It is recommended to apply a patch to fix this issue.,CVE-2025-1182,tykio/tyk-plugin-compiler
libbinutils,LOW,2.35.2-2,,A vulnerability has been found in GNU Binutils 2.43/2.44 and classified as problematic. Affected by this vulnerability is the function display_info of the file binutils/bucomm.c of the component objdump. The manipulation leads to memory leak. An attack has to be approached locally. The exploit has been disclosed to the public and may be used. The patch is named ba6ad3a18cb26b79e0e3b84c39f707535bbc344d. It is recommended to apply a patch to fix this issue.,CVE-2025-3198,tykio/tyk-plugin-compiler
libblkid1,LOW,2.36.1-8+deb11u2,,A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an INPUTRC environment variable to get a path to the library config file. When the library cannot parse the specified file it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.,CVE-2022-0563,tykio/gromit & tykio/tyk-plugin-compiler
libc-bin,LOW,2.31-13+deb11u11,,The glob implementation in the GNU C Library (aka glibc or libc6) allows remote authenticated users to cause a denial of service (CPU and memory consumption) via crafted glob expressions that do not match any pathnames as demonstrated by glob expressions in STAT commands to an FTP daemon a different vulnerability than CVE-2010-2632.,CVE-2010-4756,tykio/gromit & tykio/tyk-plugin-compiler
libc-bin,LOW,2.31-13+deb11u11,,In the GNU C Library (aka glibc or libc6) through 2.29 check_dst_limits_calc_pos_1 in posix/regexec.c has Uncontrolled Recursion as demonstrated by '(227|)(11|t1|2537)+' in grep.,CVE-2018-20796,tykio/gromit & tykio/tyk-plugin-compiler
libc-bin,LOW,2.31-13+deb11u11,,GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may bypass stack guard protection. The component is: nptl. The attack vector is: Exploit stack buffer overflow vulnerability and use this bypass vulnerability to bypass stack guard. NOTE: Upstream comments indicate this is being treated as a non-security bug and no real threat.,CVE-2019-1010022,tykio/gromit & tykio/tyk-plugin-compiler
libc-bin,LOW,2.31-13+deb11u11,,GNU Libc current is affected by: Re-mapping current loaded library with malicious ELF file. The impact is: In worst case attacker may evaluate privileges. The component is: libld. The attack vector is: Attacker sends 2 ELF files to victim and asks to run ldd on it. ldd execute code. NOTE: Upstream comments indicate this is being treated as a non-security bug and no real threat.,CVE-2019-1010023,tykio/gromit & tykio/tyk-plugin-compiler
libc-bin,LOW,2.31-13+deb11u11,,GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may bypass ASLR using cache of thread stack and heap. The component is: glibc. NOTE: Upstream comments indicate this is being treated as a non-security bug and no real threat.,CVE-2019-1010024,tykio/gromit & tykio/tyk-plugin-compiler
libc-bin,LOW,2.31-13+deb11u11,,GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may guess the heap addresses of pthread_created thread. The component is: glibc. NOTE: the vendor's position is ASLR bypass itself is not a vulnerability.,CVE-2019-1010025,tykio/gromit & tykio/tyk-plugin-compiler
libc-bin,LOW,2.31-13+deb11u11,,In the GNU C Library (aka glibc or libc6) through 2.29 check_dst_limits_calc_pos_1 in posix/regexec.c has Uncontrolled Recursion as demonstrated by '(|)(11)*' in grep a different issue than CVE-2018-20796. NOTE: the software maintainer disputes that this is a vulnerability because the behavior occurs only with a crafted pattern,CVE-2019-9192,tykio/gromit & tykio/tyk-plugin-compiler
libc-bin,MEDIUM,2.31-13+deb11u11,,A flaw was found in glibc. In an extremely rare situation the getaddrinfo function may access memory that has been freed resulting in an application crash. This issue is only exploitable when a NSS module implements only the _nss_*_gethostbyname2_r and _nss_*_getcanonname_r hooks without implementing the _nss_*_gethostbyname3_r hook. The resolved name should return a large number of IPv6 and IPv4 and the call to the getaddrinfo function should have the AF_INET6 address family with AI_CANONNAME AI_ALL and AI_V4MAPPED as flags.,CVE-2023-4806,tykio/tyk-plugin-compiler
libc-bin,MEDIUM,2.31-13+deb11u11,,A flaw was found in glibc. In an uncommon situation the gaih_inet function may use memory that has been freed resulting in an application crash. This issue is only exploitable when the getaddrinfo function is called and the hosts database in /etc/nsswitch.conf is configured with SUCCESS=continue or SUCCESS=merge.,CVE-2023-4813,tykio/tyk-plugin-compiler
libc-bin,MEDIUM,2.31-13+deb11u11,2.31-13+deb11u12,When the assert() function in the GNU C Library versions 2.13 to 2.40 fails it does not allocate enough space for the assertion failure message string and size information which may lead to a buffer overflow if the message string size aligns to page size.,CVE-2025-0395,tykio/gromit & tykio/tyk-plugin-compiler
libc-dev-bin,LOW,2.31-13+deb11u11,,The glob implementation in the GNU C Library (aka glibc or libc6) allows remote authenticated users to cause a denial of service (CPU and memory consumption) via crafted glob expressions that do not match any pathnames as demonstrated by glob expressions in STAT commands to an FTP daemon a different vulnerability than CVE-2010-2632.,CVE-2010-4756,tykio/tyk-plugin-compiler
libc-dev-bin,LOW,2.31-13+deb11u11,,In the GNU C Library (aka glibc or libc6) through 2.29 check_dst_limits_calc_pos_1 in posix/regexec.c has Uncontrolled Recursion as demonstrated by '(227|)(11|t1|2537)+' in grep.,CVE-2018-20796,tykio/tyk-plugin-compiler
libc-dev-bin,LOW,2.31-13+deb11u11,,GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may bypass stack guard protection. The component is: nptl. The attack vector is: Exploit stack buffer overflow vulnerability and use this bypass vulnerability to bypass stack guard. NOTE: Upstream comments indicate this is being treated as a non-security bug and no real threat.,CVE-2019-1010022,tykio/tyk-plugin-compiler
libc-dev-bin,LOW,2.31-13+deb11u11,,GNU Libc current is affected by: Re-mapping current loaded library with malicious ELF file. The impact is: In worst case attacker may evaluate privileges. The component is: libld. The attack vector is: Attacker sends 2 ELF files to victim and asks to run ldd on it. ldd execute code. NOTE: Upstream comments indicate this is being treated as a non-security bug and no real threat.,CVE-2019-1010023,tykio/tyk-plugin-compiler
libc-dev-bin,LOW,2.31-13+deb11u11,,GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may bypass ASLR using cache of thread stack and heap. The component is: glibc. NOTE: Upstream comments indicate this is being treated as a non-security bug and no real threat.,CVE-2019-1010024,tykio/tyk-plugin-compiler
libc-dev-bin,LOW,2.31-13+deb11u11,,GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may guess the heap addresses of pthread_created thread. The component is: glibc. NOTE: the vendor's position is ASLR bypass itself is not a vulnerability.,CVE-2019-1010025,tykio/tyk-plugin-compiler
libc-dev-bin,LOW,2.31-13+deb11u11,,In the GNU C Library (aka glibc or libc6) through 2.29 check_dst_limits_calc_pos_1 in posix/regexec.c has Uncontrolled Recursion as demonstrated by '(|)(11)*' in grep a different issue than CVE-2018-20796. NOTE: the software maintainer disputes that this is a vulnerability because the behavior occurs only with a crafted pattern,CVE-2019-9192,tykio/tyk-plugin-compiler
libc-dev-bin,MEDIUM,2.31-13+deb11u11,,A flaw was found in glibc. In an extremely rare situation the getaddrinfo function may access memory that has been freed resulting in an application crash. This issue is only exploitable when a NSS module implements only the _nss_*_gethostbyname2_r and _nss_*_getcanonname_r hooks without implementing the _nss_*_gethostbyname3_r hook. The resolved name should return a large number of IPv6 and IPv4 and the call to the getaddrinfo function should have the AF_INET6 address family with AI_CANONNAME AI_ALL and AI_V4MAPPED as flags.,CVE-2023-4806,tykio/tyk-plugin-compiler
libc-dev-bin,MEDIUM,2.31-13+deb11u11,,A flaw was found in glibc. In an uncommon situation the gaih_inet function may use memory that has been freed resulting in an application crash. This issue is only exploitable when the getaddrinfo function is called and the hosts database in /etc/nsswitch.conf is configured with SUCCESS=continue or SUCCESS=merge.,CVE-2023-4813,tykio/tyk-plugin-compiler
libc-dev-bin,MEDIUM,2.31-13+deb11u11,2.31-13+deb11u12,When the assert() function in the GNU C Library versions 2.13 to 2.40 fails it does not allocate enough space for the assertion failure message string and size information which may lead to a buffer overflow if the message string size aligns to page size.,CVE-2025-0395,tykio/tyk-plugin-compiler
libc6,LOW,2.36-9+deb12u10,,The glob implementation in the GNU C Library (aka glibc or libc6) allows remote authenticated users to cause a denial of service (CPU and memory consumption) via crafted glob expressions that do not match any pathnames as demonstrated by glob expressions in STAT commands to an FTP daemon a different vulnerability than CVE-2010-2632.,CVE-2010-4756,tykio/gromit & tykio/tyk-dashboard & tykio/tyk-gateway & tykio/tyk-plugin-compiler
libc6,LOW,2.36-9+deb12u10,,In the GNU C Library (aka glibc or libc6) through 2.29 check_dst_limits_calc_pos_1 in posix/regexec.c has Uncontrolled Recursion as demonstrated by '(227|)(11|t1|2537)+' in grep.,CVE-2018-20796,tykio/gromit & tykio/tyk-dashboard & tykio/tyk-gateway & tykio/tyk-plugin-compiler
libc6,LOW,2.36-9+deb12u10,,GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may bypass stack guard protection. The component is: nptl. The attack vector is: Exploit stack buffer overflow vulnerability and use this bypass vulnerability to bypass stack guard. NOTE: Upstream comments indicate this is being treated as a non-security bug and no real threat.,CVE-2019-1010022,tykio/gromit & tykio/tyk-dashboard & tykio/tyk-gateway & tykio/tyk-plugin-compiler
libc6,LOW,2.36-9+deb12u10,,GNU Libc current is affected by: Re-mapping current loaded library with malicious ELF file. The impact is: In worst case attacker may evaluate privileges. The component is: libld. The attack vector is: Attacker sends 2 ELF files to victim and asks to run ldd on it. ldd execute code. NOTE: Upstream comments indicate this is being treated as a non-security bug and no real threat.,CVE-2019-1010023,tykio/gromit & tykio/tyk-dashboard & tykio/tyk-gateway & tykio/tyk-plugin-compiler
libc6,LOW,2.36-9+deb12u10,,GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may bypass ASLR using cache of thread stack and heap. The component is: glibc. NOTE: Upstream comments indicate this is being treated as a non-security bug and no real threat.,CVE-2019-1010024,tykio/gromit & tykio/tyk-dashboard & tykio/tyk-gateway & tykio/tyk-plugin-compiler
libc6,LOW,2.36-9+deb12u10,,GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may guess the heap addresses of pthread_created thread. The component is: glibc. NOTE: the vendor's position is ASLR bypass itself is not a vulnerability.,CVE-2019-1010025,tykio/gromit & tykio/tyk-dashboard & tykio/tyk-gateway & tykio/tyk-plugin-compiler
libc6,LOW,2.36-9+deb12u10,,In the GNU C Library (aka glibc or libc6) through 2.29 check_dst_limits_calc_pos_1 in posix/regexec.c has Uncontrolled Recursion as demonstrated by '(|)(11)*' in grep a different issue than CVE-2018-20796. NOTE: the software maintainer disputes that this is a vulnerability because the behavior occurs only with a crafted pattern,CVE-2019-9192,tykio/gromit & tykio/tyk-dashboard & tykio/tyk-gateway & tykio/tyk-plugin-compiler
libc6,MEDIUM,2.31-13+deb11u11,,A flaw was found in glibc. In an extremely rare situation the getaddrinfo function may access memory that has been freed resulting in an application crash. This issue is only exploitable when a NSS module implements only the _nss_*_gethostbyname2_r and _nss_*_getcanonname_r hooks without implementing the _nss_*_gethostbyname3_r hook. The resolved name should return a large number of IPv6 and IPv4 and the call to the getaddrinfo function should have the AF_INET6 address family with AI_CANONNAME AI_ALL and AI_V4MAPPED as flags.,CVE-2023-4806,tykio/tyk-plugin-compiler
libc6,MEDIUM,2.31-13+deb11u11,,A flaw was found in glibc. In an uncommon situation the gaih_inet function may use memory that has been freed resulting in an application crash. This issue is only exploitable when the getaddrinfo function is called and the hosts database in /etc/nsswitch.conf is configured with SUCCESS=continue or SUCCESS=merge.,CVE-2023-4813,tykio/tyk-plugin-compiler
libc6,MEDIUM,2.31-13+deb11u11,2.31-13+deb11u12,When the assert() function in the GNU C Library versions 2.13 to 2.40 fails it does not allocate enough space for the assertion failure message string and size information which may lead to a buffer overflow if the message string size aligns to page size.,CVE-2025-0395,tykio/gromit & tykio/tyk-plugin-compiler
libc6-dev,LOW,2.31-13+deb11u11,,The glob implementation in the GNU C Library (aka glibc or libc6) allows remote authenticated users to cause a denial of service (CPU and memory consumption) via crafted glob expressions that do not match any pathnames as demonstrated by glob expressions in STAT commands to an FTP daemon a different vulnerability than CVE-2010-2632.,CVE-2010-4756,tykio/tyk-plugin-compiler
libc6-dev,LOW,2.31-13+deb11u11,,In the GNU C Library (aka glibc or libc6) through 2.29 check_dst_limits_calc_pos_1 in posix/regexec.c has Uncontrolled Recursion as demonstrated by '(227|)(11|t1|2537)+' in grep.,CVE-2018-20796,tykio/tyk-plugin-compiler
libc6-dev,LOW,2.31-13+deb11u11,,GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may bypass stack guard protection. The component is: nptl. The attack vector is: Exploit stack buffer overflow vulnerability and use this bypass vulnerability to bypass stack guard. NOTE: Upstream comments indicate this is being treated as a non-security bug and no real threat.,CVE-2019-1010022,tykio/tyk-plugin-compiler
libc6-dev,LOW,2.31-13+deb11u11,,GNU Libc current is affected by: Re-mapping current loaded library with malicious ELF file. The impact is: In worst case attacker may evaluate privileges. The component is: libld. The attack vector is: Attacker sends 2 ELF files to victim and asks to run ldd on it. ldd execute code. NOTE: Upstream comments indicate this is being treated as a non-security bug and no real threat.,CVE-2019-1010023,tykio/tyk-plugin-compiler
libc6-dev,LOW,2.31-13+deb11u11,,GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may bypass ASLR using cache of thread stack and heap. The component is: glibc. NOTE: Upstream comments indicate this is being treated as a non-security bug and no real threat.,CVE-2019-1010024,tykio/tyk-plugin-compiler
libc6-dev,LOW,2.31-13+deb11u11,,GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may guess the heap addresses of pthread_created thread. The component is: glibc. NOTE: the vendor's position is ASLR bypass itself is not a vulnerability.,CVE-2019-1010025,tykio/tyk-plugin-compiler
libc6-dev,LOW,2.31-13+deb11u11,,In the GNU C Library (aka glibc or libc6) through 2.29 check_dst_limits_calc_pos_1 in posix/regexec.c has Uncontrolled Recursion as demonstrated by '(|)(11)*' in grep a different issue than CVE-2018-20796. NOTE: the software maintainer disputes that this is a vulnerability because the behavior occurs only with a crafted pattern,CVE-2019-9192,tykio/tyk-plugin-compiler
libc6-dev,MEDIUM,2.31-13+deb11u11,,A flaw was found in glibc. In an extremely rare situation the getaddrinfo function may access memory that has been freed resulting in an application crash. This issue is only exploitable when a NSS module implements only the _nss_*_gethostbyname2_r and _nss_*_getcanonname_r hooks without implementing the _nss_*_gethostbyname3_r hook. The resolved name should return a large number of IPv6 and IPv4 and the call to the getaddrinfo function should have the AF_INET6 address family with AI_CANONNAME AI_ALL and AI_V4MAPPED as flags.,CVE-2023-4806,tykio/tyk-plugin-compiler
libc6-dev,MEDIUM,2.31-13+deb11u11,,A flaw was found in glibc. In an uncommon situation the gaih_inet function may use memory that has been freed resulting in an application crash. This issue is only exploitable when the getaddrinfo function is called and the hosts database in /etc/nsswitch.conf is configured with SUCCESS=continue or SUCCESS=merge.,CVE-2023-4813,tykio/tyk-plugin-compiler
libc6-dev,MEDIUM,2.31-13+deb11u11,2.31-13+deb11u12,When the assert() function in the GNU C Library versions 2.13 to 2.40 fails it does not allocate enough space for the assertion failure message string and size information which may lead to a buffer overflow if the message string size aligns to page size.,CVE-2025-0395,tykio/tyk-plugin-compiler
libc6-i386,LOW,2.31-13+deb11u11,,The glob implementation in the GNU C Library (aka glibc or libc6) allows remote authenticated users to cause a denial of service (CPU and memory consumption) via crafted glob expressions that do not match any pathnames as demonstrated by glob expressions in STAT commands to an FTP daemon a different vulnerability than CVE-2010-2632.,CVE-2010-4756,tykio/tyk-plugin-compiler
libc6-i386,LOW,2.31-13+deb11u11,,In the GNU C Library (aka glibc or libc6) through 2.29 check_dst_limits_calc_pos_1 in posix/regexec.c has Uncontrolled Recursion as demonstrated by '(227|)(11|t1|2537)+' in grep.,CVE-2018-20796,tykio/tyk-plugin-compiler
libc6-i386,LOW,2.31-13+deb11u11,,GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may bypass stack guard protection. The component is: nptl. The attack vector is: Exploit stack buffer overflow vulnerability and use this bypass vulnerability to bypass stack guard. NOTE: Upstream comments indicate this is being treated as a non-security bug and no real threat.,CVE-2019-1010022,tykio/tyk-plugin-compiler
libc6-i386,LOW,2.31-13+deb11u11,,GNU Libc current is affected by: Re-mapping current loaded library with malicious ELF file. The impact is: In worst case attacker may evaluate privileges. The component is: libld. The attack vector is: Attacker sends 2 ELF files to victim and asks to run ldd on it. ldd execute code. NOTE: Upstream comments indicate this is being treated as a non-security bug and no real threat.,CVE-2019-1010023,tykio/tyk-plugin-compiler
libc6-i386,LOW,2.31-13+deb11u11,,GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may bypass ASLR using cache of thread stack and heap. The component is: glibc. NOTE: Upstream comments indicate this is being treated as a non-security bug and no real threat.,CVE-2019-1010024,tykio/tyk-plugin-compiler
libc6-i386,LOW,2.31-13+deb11u11,,GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may guess the heap addresses of pthread_created thread. The component is: glibc. NOTE: the vendor's position is ASLR bypass itself is not a vulnerability.,CVE-2019-1010025,tykio/tyk-plugin-compiler
libc6-i386,LOW,2.31-13+deb11u11,,In the GNU C Library (aka glibc or libc6) through 2.29 check_dst_limits_calc_pos_1 in posix/regexec.c has Uncontrolled Recursion as demonstrated by '(|)(11)*' in grep a different issue than CVE-2018-20796. NOTE: the software maintainer disputes that this is a vulnerability because the behavior occurs only with a crafted pattern,CVE-2019-9192,tykio/tyk-plugin-compiler
libc6-i386,MEDIUM,2.31-13+deb11u11,,A flaw was found in glibc. In an extremely rare situation the getaddrinfo function may access memory that has been freed resulting in an application crash. This issue is only exploitable when a NSS module implements only the _nss_*_gethostbyname2_r and _nss_*_getcanonname_r hooks without implementing the _nss_*_gethostbyname3_r hook. The resolved name should return a large number of IPv6 and IPv4 and the call to the getaddrinfo function should have the AF_INET6 address family with AI_CANONNAME AI_ALL and AI_V4MAPPED as flags.,CVE-2023-4806,tykio/tyk-plugin-compiler
libc6-i386,MEDIUM,2.31-13+deb11u11,,A flaw was found in glibc. In an uncommon situation the gaih_inet function may use memory that has been freed resulting in an application crash. This issue is only exploitable when the getaddrinfo function is called and the hosts database in /etc/nsswitch.conf is configured with SUCCESS=continue or SUCCESS=merge.,CVE-2023-4813,tykio/tyk-plugin-compiler
libc6-i386,MEDIUM,2.31-13+deb11u11,2.31-13+deb11u12,When the assert() function in the GNU C Library versions 2.13 to 2.40 fails it does not allocate enough space for the assertion failure message string and size information which may lead to a buffer overflow if the message string size aligns to page size.,CVE-2025-0395,tykio/tyk-plugin-compiler
libcap2,MEDIUM,1:2.66-4,,The PAM module pam_cap.so of libcap configuration supports group names starting with @ during actual parsing configurations not starting with @ are incorrectly recognized as group names. This may result in nonintended users being granted an inherited capability set potentially leading to security risks. Attackers can exploit this vulnerability to achieve local privilege escalation on systems where /etc/security/capability.conf is used to configure user inherited privileges by constructing specific usernames.,CVE-2025-1390,tykio/gromit
libcc1-0,LOW,10.2.1-6,,**DISPUTED**A failure in the -fstack-protector feature in GCC-based toolchains nthat target AArch64 allows an attacker to exploit an existing buffer noverflow in dynamically-sized local variables in your application nwithout this being detected. This stack-protector failure only applies nto C99-style dynamically-sized local variables or those created using nalloca(). The stack-protector operates as intended for statically-sized nlocal variables.nnThe default behavior when the stack-protector ndetects an overflow is to terminate your application resulting in ncontrolled loss of availability. An attacker who can exploit a buffer noverflow without triggering the stack-protector might be able to change nprogram flow control to cause an uncontrolled loss of availability or ton go further and affect confidentiality or integrity. NOTE: The GCC project argues that this is a missed hardening bug and not a vulnerability by itself.,CVE-2023-4039,tykio/tyk-plugin-compiler
libctf-nobfd0,LOW,2.35.2-2,,The C++ symbol demangler routine in cplus-dem.c in libiberty as distributed in GNU Binutils 2.29 allows remote attackers to cause a denial of service (excessive memory allocation and application crash) via a crafted file as demonstrated by a call from the Binary File Descriptor (BFD) library (aka libbfd).,CVE-2017-13716,tykio/tyk-plugin-compiler
libctf-nobfd0,LOW,2.35.2-2,,The demangle_template function in cplus-dem.c in GNU libiberty as distributed in GNU Binutils 2.31.1 contains an integer overflow vulnerability (for Create an array for saving the template argument values) that can trigger a heap-based buffer overflow as demonstrated by nm.,CVE-2018-20673,tykio/tyk-plugin-compiler
libctf-nobfd0,LOW,2.35.2-2,,A heap-based buffer over-read exists in the function d_expression_1 in cp-demangle.c in GNU libiberty as distributed in GNU Binutils 2.31.1. A crafted input can cause segmentation faults leading to denial-of-service as demonstrated by c++filt.,CVE-2018-20712,tykio/tyk-plugin-compiler
libctf-nobfd0,LOW,2.35.2-2,,An issue was discovered in cplus-dem.c in GNU libiberty as distributed in GNU Binutils 2.30. Stack Exhaustion occurs in the C++ demangling functions provided by libiberty and there are recursive stack frames: demangle_template_value_parm demangle_integral_value and demangle_expression.,CVE-2018-9996,tykio/tyk-plugin-compiler
libctf-nobfd0,LOW,2.35.2-2,,GNU binutils gold gold v1.11-v1.16 (GNU binutils v2.21-v2.31.1) is affected by: Improper Input Validation Signed/Unsigned Comparison Out-of-bounds Read. The impact is: Denial of service. The component is: gold/fileread.cc:497 elfcpp/elfcpp_file.h:644. The attack vector is: An ELF file with an invalid e_shoff header field must be opened.,CVE-2019-1010204,tykio/tyk-plugin-compiler
libctf-nobfd0,LOW,2.35.2-2,,An issue was discovered in binutils libbfd.c 2.36 relating to the auxiliary symbol data allows attackers to read or write to system memory or cause a denial of service.,CVE-2020-19726,tykio/tyk-plugin-compiler
libctf-nobfd0,LOW,2.35.2-2,,An issue was discovered in the Binary File Descriptor (BFD) library (aka libbfd) as distributed in GNU Binutils 2.35.1. A heap-based buffer over-read can occur in bfd_getl_signed_32 in libbfd.c because sh_entsize is not validated in _bfd_elf_slurp_secondary_reloc_section in elf.c.,CVE-2020-35448,tykio/tyk-plugin-compiler
libctf-nobfd0,LOW,2.35.2-2,,There is an open race window when writing output in the following utilities in GNU binutils version 2.35 and earlier:ar objcopy strip ranlib. When these utilities are run as a privileged user (presumably as part of a script updating binaries across different users) an unprivileged user can trick these utilities into getting ownership of arbitrary files through a symlink.,CVE-2021-20197,tykio/tyk-plugin-compiler
libctf-nobfd0,LOW,2.35.2-2,,A flaw was found in GNU Binutils 2.35.1 where there is a heap-based buffer overflow in _bfd_elf_slurp_secondary_reloc_section in elf.c due to the number of symbols not calculated correctly. The highest threat from this vulnerability is to system availability.,CVE-2021-20284,tykio/tyk-plugin-compiler
libctf-nobfd0,LOW,2.35.2-2,,An issue was discovered in GNU libiberty as distributed in GNU Binutils 2.36. It is a stack-overflow issue in demangle_type in rust-demangle.c.,CVE-2021-32256,tykio/tyk-plugin-compiler
libctf-nobfd0,LOW,2.35.2-2,,A flaw was discovered in GNU libiberty within demangle_path() in rust-demangle.c as distributed in GNU Binutils version 2.36. A crafted symbol can cause stack memory to be exhausted leading to a crash.,CVE-2021-3530,tykio/tyk-plugin-compiler
libctf-nobfd0,LOW,2.35.2-2,,An out of bounds flaw was found in GNU binutils objdump utility version 2.36. An attacker could use this flaw and pass a large section to avr_elf32_load_records_from_section() probably resulting in a crash or in some cases memory corruption. The highest threat from this vulnerability is to integrity as well as system availability.,CVE-2021-3549,tykio/tyk-plugin-compiler
libctf-nobfd0,LOW,2.35.2-2,,Heap/stack buffer overflow in the dlang_lname function in d-demangle.c in libiberty allows attackers to potentially cause a denial of service (segmentation fault and crash) via a crafted mangled symbol.,CVE-2021-3826,tykio/tyk-plugin-compiler
libctf-nobfd0,LOW,2.35.2-2,,stab_xcoff_builtin_type in stabs.c in GNU Binutils through 2.37 allows attackers to cause a denial of service (heap-based buffer overflow) or possibly have unspecified other impact as demonstrated by an out-of-bounds write. NOTE: this issue exists because of an incorrect fix for CVE-2018-12699.,CVE-2021-45078,tykio/tyk-plugin-compiler
libctf-nobfd0,LOW,2.35.2-2,,Heap-based Buffer Overflow in function bfd_getl32 in Binutils objdump 3.37.,CVE-2021-46174,tykio/tyk-plugin-compiler
libctf-nobfd0,LOW,2.35.2-2,,GCC v12.0 was discovered to contain an uncontrolled recursion via the component libiberty/rust-demangle.c. This vulnerability allows attackers to cause a Denial of Service (DoS) by consuming excessive CPU and memory resources.,CVE-2021-46195,tykio/tyk-plugin-compiler
libctf-nobfd0,LOW,2.35.2-2,,An issue was discovered in Binutils readelf 2.38.50 reachable assertion failure in function display_debug_names allows attackers to cause a denial of service.,CVE-2022-35205,tykio/tyk-plugin-compiler
libctf-nobfd0,LOW,2.35.2-2,,Null pointer dereference vulnerability in Binutils readelf 2.38.50 via function read_and_display_attr_value in file dwarf.c.,CVE-2022-35206,tykio/tyk-plugin-compiler
libctf-nobfd0,LOW,2.35.2-2,,In GNU Binutils before 2.40 there is a heap-buffer-overflow in the error function bfd_getl32 when called from the strip_main function in strip-new via a crafted file.,CVE-2022-38533,tykio/tyk-plugin-compiler
libctf-nobfd0,LOW,2.35.2-2,,An illegal memory access flaw was found in the binutils package. Parsing an ELF file containing corrupt symbol version information may result in a denial of service. This issue is the result of an incomplete fix for CVE-2020-16599.,CVE-2022-4285,tykio/tyk-plugin-compiler
libctf-nobfd0,LOW,2.35.2-2,,Heap buffer overflow vulnerability in binutils readelf before 2.40 via function find_section_in_set in file readelf.c.,CVE-2022-44840,tykio/tyk-plugin-compiler
libctf-nobfd0,LOW,2.35.2-2,,Heap buffer overflow vulnerability in binutils readelf before 2.40 via function display_debug_section in file readelf.c.,CVE-2022-45703,tykio/tyk-plugin-compiler
libctf-nobfd0,LOW,2.35.2-2,,An issue was discovered function stab_demangle_v3_arg in stabs.c in Binutils 2.34 thru 2.38 allows attackers to cause a denial of service due to memory leaks.,CVE-2022-47007,tykio/tyk-plugin-compiler
libctf-nobfd0,LOW,2.35.2-2,,An issue was discovered function make_tempdir and make_tempname in bucomm.c in Binutils 2.34 thru 2.38 allows attackers to cause a denial of service due to memory leaks.,CVE-2022-47008,tykio/tyk-plugin-compiler
libctf-nobfd0,LOW,2.35.2-2,,An issue was discovered function pr_function_type in prdbg.c in Binutils 2.34 thru 2.38 allows attackers to cause a denial of service due to memory leaks.,CVE-2022-47010,tykio/tyk-plugin-compiler
libctf-nobfd0,LOW,2.35.2-2,,An issue was discovered function parse_stab_struct_fields in stabs.c in Binutils 2.34 thru 2.38 allows attackers to cause a denial of service due to memory leaks.,CVE-2022-47011,tykio/tyk-plugin-compiler
libctf-nobfd0,LOW,2.35.2-2,,An issue was discovered in Binutils addr2line before 2.39.3 function parse_module contains multiple out of bound reads which may cause a denial of service or other unspecified impacts.,CVE-2022-47673,tykio/tyk-plugin-compiler
libctf-nobfd0,LOW,2.35.2-2,,An issue was discovered Binutils objdump before 2.39.3 allows attackers to cause a denial of service or other unspecified impacts via function bfd_mach_o_get_synthetic_symtab in match-o.c.,CVE-2022-47695,tykio/tyk-plugin-compiler
libctf-nobfd0,LOW,2.35.2-2,,An issue was discovered Binutils objdump before 2.39.3 allows attackers to cause a denial of service or other unspecified impacts via function compare_symbols.,CVE-2022-47696,tykio/tyk-plugin-compiler
libctf-nobfd0,LOW,2.35.2-2,,GNU Binutils before 2.40 was discovered to contain an excessive memory consumption vulnerability via the function load_separate_debug_files at dwarf2.c. The attacker could supply a crafted ELF file and cause a DNS attack.,CVE-2022-48063,tykio/tyk-plugin-compiler
libctf-nobfd0,LOW,2.35.2-2,,GNU Binutils before 2.40 was discovered to contain an excessive memory consumption vulnerability via the function bfd_dwarf2_find_nearest_line_with_alt at dwarf2.c. The attacker could supply a crafted ELF file and cause a DNS attack.,CVE-2022-48064,tykio/tyk-plugin-compiler
libctf-nobfd0,LOW,2.35.2-2,,GNU Binutils before 2.40 was discovered to contain a memory leak vulnerability var the function find_abstract_instance in dwarf2.c.,CVE-2022-48065,tykio/tyk-plugin-compiler
libctf-nobfd0,LOW,2.35.2-2,,Heap based buffer overflow in binutils-gdb/bfd/libbfd.c in bfd_getl64.,CVE-2023-1579,tykio/tyk-plugin-compiler
libctf-nobfd0,LOW,2.35.2-2,,A potential heap based buffer overflow was found in _bfd_elf_slurp_version_tables() in bfd/elf.c. This may lead to loss of availability.,CVE-2023-1972,tykio/tyk-plugin-compiler
libctf-nobfd0,LOW,2.35.2-2,,An out-of-bounds read flaw was found in the parse_module function in bfd/vms-alpha.c in Binutils.,CVE-2023-25584,tykio/tyk-plugin-compiler
libctf-nobfd0,LOW,2.35.2-2,,A flaw was found in Binutils. The use of an uninitialized field in the struct module *module may lead to application crash and local denial of service.,CVE-2023-25585,tykio/tyk-plugin-compiler
libctf-nobfd0,LOW,2.35.2-2,,A flaw was found in Binutils. A logic fail in the bfd_init_section_decompress_status function may lead to the use of an uninitialized variable that can cause a crash and local denial of service.,CVE-2023-25586,tykio/tyk-plugin-compiler
libctf-nobfd0,LOW,2.35.2-2,,A flaw was found in Binutils. The field `the_bfd` of `asymbol`struct is uninitialized in the `bfd_mach_o_get_synthetic_symtab` function which may lead to an application crash and local denial of service.,CVE-2023-25588,tykio/tyk-plugin-compiler
libctf-nobfd0,LOW,2.35.2-2,,GNU objdump 2.43 is vulnerable to Buffer Overflow in the BFD (Binary File Descriptor) library's handling of tekhex format files.,CVE-2024-53589,tykio/tyk-plugin-compiler
libctf-nobfd0,LOW,2.35.2-2,,https://www.gnu.org/software/binutils/ nm >=2.43 is affected by: Incorrect Access Control. The type of exploitation is: local. The component is: `nm --without-symbol-version` function.,CVE-2024-57360,tykio/tyk-plugin-compiler
libctf-nobfd0,LOW,2.35.2-2,,A vulnerability which was classified as problematic was found in GNU Binutils up to 2.43. This affects the function disassemble_bytes of the file binutils/objdump.c. The manipulation of the argument buf leads to stack-based buffer overflow. It is possible to initiate the attack remotely. The complexity of an attack is rather high. The exploitability is told to be difficult. The exploit has been disclosed to the public and may be used. Upgrading to version 2.44 is able to address this issue. The identifier of the patch is baac6c221e9d69335bf41366a1c7d87d8ab2f893. It is recommended to upgrade the affected component.,CVE-2025-0840,tykio/tyk-plugin-compiler
libctf-nobfd0,LOW,2.35.2-2,,A vulnerability has been found in GNU Binutils 2.43 and classified as problematic. Affected by this vulnerability is the function __sanitizer::internal_strlen of the file binutils/nm.c of the component nm. The manipulation of the argument const leads to buffer overflow. The attack can be launched remotely. The complexity of an attack is rather high. The exploitation appears to be difficult. The exploit has been disclosed to the public and may be used.,CVE-2025-1147,tykio/tyk-plugin-compiler
libctf-nobfd0,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43 and classified as problematic. Affected by this issue is the function link_order_scan of the file ld/ldelfgen.c of the component ld. The manipulation leads to memory leak. The attack may be launched remotely. The complexity of an attack is rather high. The exploitation is known to be difficult. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue. The code maintainer explains: I'm not going to commit some of the leak fixes I've been working on to the 2.44 branch due to concern that would destabilise ld. All of the reported leaks in this bugzilla have been fixed on binutils master.,CVE-2025-1148,tykio/tyk-plugin-compiler
libctf-nobfd0,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43. It has been classified as problematic. This affects the function xstrdup of the file libiberty/xmalloc.c of the component ld. The manipulation leads to memory leak. It is possible to initiate the attack remotely. The complexity of an attack is rather high. The exploitability is told to be difficult. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue. The code maintainer explains: I'm not going to commit some of the leak fixes I've been working on to the 2.44 branch due to concern that would destabilise ld. All of the reported leaks in this bugzilla have been fixed on binutils master.,CVE-2025-1149,tykio/tyk-plugin-compiler
libctf-nobfd0,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43. It has been declared as problematic. This vulnerability affects the function bfd_malloc of the file libbfd.c of the component ld. The manipulation leads to memory leak. The attack can be initiated remotely. The complexity of an attack is rather high. The exploitation appears to be difficult. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue. The code maintainer explains: I'm not going to commit some of the leak fixes I've been working on to the 2.44 branch due to concern that would destabilise ld. All of the reported leaks in this bugzilla have been fixed on binutils master.,CVE-2025-1150,tykio/tyk-plugin-compiler
libctf-nobfd0,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43. It has been rated as problematic. This issue affects the function xmemdup of the file xmemdup.c of the component ld. The manipulation leads to memory leak. The attack may be initiated remotely. The complexity of an attack is rather high. The exploitation is known to be difficult. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue. The code maintainer explains: I'm not going to commit some of the leak fixes I've been working on to the 2.44 branch due to concern that would destabilise ld. All of the reported leaks in this bugzilla have been fixed on binutils master.,CVE-2025-1151,tykio/tyk-plugin-compiler
libctf-nobfd0,LOW,2.35.2-2,,A vulnerability classified as problematic has been found in GNU Binutils 2.43. Affected is the function xstrdup of the file xstrdup.c of the component ld. The manipulation leads to memory leak. It is possible to launch the attack remotely. The complexity of an attack is rather high. The exploitability is told to be difficult. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue. The code maintainer explains: I'm not going to commit some of the leak fixes I've been working on to the 2.44 branch due to concern that would destabilise ld. All of the reported leaks in this bugzilla have been fixed on binutils master.,CVE-2025-1152,tykio/tyk-plugin-compiler
libctf-nobfd0,LOW,2.35.2-2,,A vulnerability classified as problematic was found in GNU Binutils 2.43/2.44. Affected by this vulnerability is the function bfd_set_format of the file format.c. The manipulation leads to memory corruption. The attack can be launched remotely. The complexity of an attack is rather high. The exploitation appears to be difficult. Upgrading to version 2.45 is able to address this issue. The identifier of the patch is 8d97c1a53f3dc9fd8e1ccdb039b8a33d50133150. It is recommended to upgrade the affected component.,CVE-2025-1153,tykio/tyk-plugin-compiler
libctf-nobfd0,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43 and classified as critical. This issue affects the function _bfd_elf_gc_mark_rsec of the file elflink.c of the component ld. The manipulation leads to heap-based buffer overflow. The attack may be initiated remotely. The complexity of an attack is rather high. The exploitation is known to be difficult. The exploit has been disclosed to the public and may be used. The patch is named f9978defb6fab0bd8583942d97c112b0932ac814. It is recommended to apply a patch to fix this issue.,CVE-2025-1176,tykio/tyk-plugin-compiler
libctf-nobfd0,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43. It has been declared as problematic. Affected by this vulnerability is the function bfd_putl64 of the file libbfd.c of the component ld. The manipulation leads to memory corruption. The attack can be launched remotely. The complexity of an attack is rather high. The exploitation appears to be difficult. The exploit has been disclosed to the public and may be used. The identifier of the patch is 75086e9de1707281172cc77f178e7949a4414ed0. It is recommended to apply a patch to fix this issue.,CVE-2025-1178,tykio/tyk-plugin-compiler
libctf-nobfd0,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43. It has been rated as critical. Affected by this issue is the function bfd_putl64 of the file bfd/libbfd.c of the component ld. The manipulation leads to memory corruption. The attack may be launched remotely. The complexity of an attack is rather high. The exploitation is known to be difficult. The exploit has been disclosed to the public and may be used. Upgrading to version 2.44 is able to address this issue. It is recommended to upgrade the affected component. The code maintainer explains that [t]his bug has been fixed at some point between the 2.43 and 2.44 releases.,CVE-2025-1179,tykio/tyk-plugin-compiler
libctf-nobfd0,LOW,2.35.2-2,,A vulnerability classified as problematic has been found in GNU Binutils 2.43. This affects the function _bfd_elf_write_section_eh_frame of the file bfd/elf-eh-frame.c of the component ld. The manipulation leads to memory corruption. It is possible to initiate the attack remotely. The complexity of an attack is rather high. The exploitability is told to be difficult. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue.,CVE-2025-1180,tykio/tyk-plugin-compiler
libctf-nobfd0,LOW,2.35.2-2,,A vulnerability classified as critical was found in GNU Binutils 2.43. This vulnerability affects the function _bfd_elf_gc_mark_rsec of the file bfd/elflink.c of the component ld. The manipulation leads to memory corruption. The attack can be initiated remotely. The complexity of an attack is rather high. The exploitation appears to be difficult. The exploit has been disclosed to the public and may be used. The name of the patch is 931494c9a89558acb36a03a340c01726545eef24. It is recommended to apply a patch to fix this issue.,CVE-2025-1181,tykio/tyk-plugin-compiler
libctf-nobfd0,LOW,2.35.2-2,,A vulnerability which was classified as critical was found in GNU Binutils 2.43. Affected is the function bfd_elf_reloc_symbol_deleted_p of the file bfd/elflink.c of the component ld. The manipulation leads to memory corruption. It is possible to launch the attack remotely. The complexity of an attack is rather high. The exploitability is told to be difficult. The exploit has been disclosed to the public and may be used. The patch is identified as b425859021d17adf62f06fb904797cf8642986ad. It is recommended to apply a patch to fix this issue.,CVE-2025-1182,tykio/tyk-plugin-compiler
libctf-nobfd0,LOW,2.35.2-2,,A vulnerability has been found in GNU Binutils 2.43/2.44 and classified as problematic. Affected by this vulnerability is the function display_info of the file binutils/bucomm.c of the component objdump. The manipulation leads to memory leak. An attack has to be approached locally. The exploit has been disclosed to the public and may be used. The patch is named ba6ad3a18cb26b79e0e3b84c39f707535bbc344d. It is recommended to apply a patch to fix this issue.,CVE-2025-3198,tykio/tyk-plugin-compiler
libctf0,LOW,2.35.2-2,,The C++ symbol demangler routine in cplus-dem.c in libiberty as distributed in GNU Binutils 2.29 allows remote attackers to cause a denial of service (excessive memory allocation and application crash) via a crafted file as demonstrated by a call from the Binary File Descriptor (BFD) library (aka libbfd).,CVE-2017-13716,tykio/tyk-plugin-compiler
libctf0,LOW,2.35.2-2,,The demangle_template function in cplus-dem.c in GNU libiberty as distributed in GNU Binutils 2.31.1 contains an integer overflow vulnerability (for Create an array for saving the template argument values) that can trigger a heap-based buffer overflow as demonstrated by nm.,CVE-2018-20673,tykio/tyk-plugin-compiler
libctf0,LOW,2.35.2-2,,A heap-based buffer over-read exists in the function d_expression_1 in cp-demangle.c in GNU libiberty as distributed in GNU Binutils 2.31.1. A crafted input can cause segmentation faults leading to denial-of-service as demonstrated by c++filt.,CVE-2018-20712,tykio/tyk-plugin-compiler
libctf0,LOW,2.35.2-2,,An issue was discovered in cplus-dem.c in GNU libiberty as distributed in GNU Binutils 2.30. Stack Exhaustion occurs in the C++ demangling functions provided by libiberty and there are recursive stack frames: demangle_template_value_parm demangle_integral_value and demangle_expression.,CVE-2018-9996,tykio/tyk-plugin-compiler
libctf0,LOW,2.35.2-2,,GNU binutils gold gold v1.11-v1.16 (GNU binutils v2.21-v2.31.1) is affected by: Improper Input Validation Signed/Unsigned Comparison Out-of-bounds Read. The impact is: Denial of service. The component is: gold/fileread.cc:497 elfcpp/elfcpp_file.h:644. The attack vector is: An ELF file with an invalid e_shoff header field must be opened.,CVE-2019-1010204,tykio/tyk-plugin-compiler
libctf0,LOW,2.35.2-2,,An issue was discovered in binutils libbfd.c 2.36 relating to the auxiliary symbol data allows attackers to read or write to system memory or cause a denial of service.,CVE-2020-19726,tykio/tyk-plugin-compiler
libctf0,LOW,2.35.2-2,,An issue was discovered in the Binary File Descriptor (BFD) library (aka libbfd) as distributed in GNU Binutils 2.35.1. A heap-based buffer over-read can occur in bfd_getl_signed_32 in libbfd.c because sh_entsize is not validated in _bfd_elf_slurp_secondary_reloc_section in elf.c.,CVE-2020-35448,tykio/tyk-plugin-compiler
libctf0,LOW,2.35.2-2,,There is an open race window when writing output in the following utilities in GNU binutils version 2.35 and earlier:ar objcopy strip ranlib. When these utilities are run as a privileged user (presumably as part of a script updating binaries across different users) an unprivileged user can trick these utilities into getting ownership of arbitrary files through a symlink.,CVE-2021-20197,tykio/tyk-plugin-compiler
libctf0,LOW,2.35.2-2,,A flaw was found in GNU Binutils 2.35.1 where there is a heap-based buffer overflow in _bfd_elf_slurp_secondary_reloc_section in elf.c due to the number of symbols not calculated correctly. The highest threat from this vulnerability is to system availability.,CVE-2021-20284,tykio/tyk-plugin-compiler
libctf0,LOW,2.35.2-2,,An issue was discovered in GNU libiberty as distributed in GNU Binutils 2.36. It is a stack-overflow issue in demangle_type in rust-demangle.c.,CVE-2021-32256,tykio/tyk-plugin-compiler
libctf0,LOW,2.35.2-2,,A flaw was discovered in GNU libiberty within demangle_path() in rust-demangle.c as distributed in GNU Binutils version 2.36. A crafted symbol can cause stack memory to be exhausted leading to a crash.,CVE-2021-3530,tykio/tyk-plugin-compiler
libctf0,LOW,2.35.2-2,,An out of bounds flaw was found in GNU binutils objdump utility version 2.36. An attacker could use this flaw and pass a large section to avr_elf32_load_records_from_section() probably resulting in a crash or in some cases memory corruption. The highest threat from this vulnerability is to integrity as well as system availability.,CVE-2021-3549,tykio/tyk-plugin-compiler
libctf0,LOW,2.35.2-2,,Heap/stack buffer overflow in the dlang_lname function in d-demangle.c in libiberty allows attackers to potentially cause a denial of service (segmentation fault and crash) via a crafted mangled symbol.,CVE-2021-3826,tykio/tyk-plugin-compiler
libctf0,LOW,2.35.2-2,,stab_xcoff_builtin_type in stabs.c in GNU Binutils through 2.37 allows attackers to cause a denial of service (heap-based buffer overflow) or possibly have unspecified other impact as demonstrated by an out-of-bounds write. NOTE: this issue exists because of an incorrect fix for CVE-2018-12699.,CVE-2021-45078,tykio/tyk-plugin-compiler
libctf0,LOW,2.35.2-2,,Heap-based Buffer Overflow in function bfd_getl32 in Binutils objdump 3.37.,CVE-2021-46174,tykio/tyk-plugin-compiler
libctf0,LOW,2.35.2-2,,GCC v12.0 was discovered to contain an uncontrolled recursion via the component libiberty/rust-demangle.c. This vulnerability allows attackers to cause a Denial of Service (DoS) by consuming excessive CPU and memory resources.,CVE-2021-46195,tykio/tyk-plugin-compiler
libctf0,LOW,2.35.2-2,,An issue was discovered in Binutils readelf 2.38.50 reachable assertion failure in function display_debug_names allows attackers to cause a denial of service.,CVE-2022-35205,tykio/tyk-plugin-compiler
libctf0,LOW,2.35.2-2,,Null pointer dereference vulnerability in Binutils readelf 2.38.50 via function read_and_display_attr_value in file dwarf.c.,CVE-2022-35206,tykio/tyk-plugin-compiler
libctf0,LOW,2.35.2-2,,In GNU Binutils before 2.40 there is a heap-buffer-overflow in the error function bfd_getl32 when called from the strip_main function in strip-new via a crafted file.,CVE-2022-38533,tykio/tyk-plugin-compiler
libctf0,LOW,2.35.2-2,,An illegal memory access flaw was found in the binutils package. Parsing an ELF file containing corrupt symbol version information may result in a denial of service. This issue is the result of an incomplete fix for CVE-2020-16599.,CVE-2022-4285,tykio/tyk-plugin-compiler
libctf0,LOW,2.35.2-2,,Heap buffer overflow vulnerability in binutils readelf before 2.40 via function find_section_in_set in file readelf.c.,CVE-2022-44840,tykio/tyk-plugin-compiler
libctf0,LOW,2.35.2-2,,Heap buffer overflow vulnerability in binutils readelf before 2.40 via function display_debug_section in file readelf.c.,CVE-2022-45703,tykio/tyk-plugin-compiler
libctf0,LOW,2.35.2-2,,An issue was discovered function stab_demangle_v3_arg in stabs.c in Binutils 2.34 thru 2.38 allows attackers to cause a denial of service due to memory leaks.,CVE-2022-47007,tykio/tyk-plugin-compiler
libctf0,LOW,2.35.2-2,,An issue was discovered function make_tempdir and make_tempname in bucomm.c in Binutils 2.34 thru 2.38 allows attackers to cause a denial of service due to memory leaks.,CVE-2022-47008,tykio/tyk-plugin-compiler
libctf0,LOW,2.35.2-2,,An issue was discovered function pr_function_type in prdbg.c in Binutils 2.34 thru 2.38 allows attackers to cause a denial of service due to memory leaks.,CVE-2022-47010,tykio/tyk-plugin-compiler
libctf0,LOW,2.35.2-2,,An issue was discovered function parse_stab_struct_fields in stabs.c in Binutils 2.34 thru 2.38 allows attackers to cause a denial of service due to memory leaks.,CVE-2022-47011,tykio/tyk-plugin-compiler
libctf0,LOW,2.35.2-2,,An issue was discovered in Binutils addr2line before 2.39.3 function parse_module contains multiple out of bound reads which may cause a denial of service or other unspecified impacts.,CVE-2022-47673,tykio/tyk-plugin-compiler
libctf0,LOW,2.35.2-2,,An issue was discovered Binutils objdump before 2.39.3 allows attackers to cause a denial of service or other unspecified impacts via function bfd_mach_o_get_synthetic_symtab in match-o.c.,CVE-2022-47695,tykio/tyk-plugin-compiler
libctf0,LOW,2.35.2-2,,An issue was discovered Binutils objdump before 2.39.3 allows attackers to cause a denial of service or other unspecified impacts via function compare_symbols.,CVE-2022-47696,tykio/tyk-plugin-compiler
libctf0,LOW,2.35.2-2,,GNU Binutils before 2.40 was discovered to contain an excessive memory consumption vulnerability via the function load_separate_debug_files at dwarf2.c. The attacker could supply a crafted ELF file and cause a DNS attack.,CVE-2022-48063,tykio/tyk-plugin-compiler
libctf0,LOW,2.35.2-2,,GNU Binutils before 2.40 was discovered to contain an excessive memory consumption vulnerability via the function bfd_dwarf2_find_nearest_line_with_alt at dwarf2.c. The attacker could supply a crafted ELF file and cause a DNS attack.,CVE-2022-48064,tykio/tyk-plugin-compiler
libctf0,LOW,2.35.2-2,,GNU Binutils before 2.40 was discovered to contain a memory leak vulnerability var the function find_abstract_instance in dwarf2.c.,CVE-2022-48065,tykio/tyk-plugin-compiler
libctf0,LOW,2.35.2-2,,Heap based buffer overflow in binutils-gdb/bfd/libbfd.c in bfd_getl64.,CVE-2023-1579,tykio/tyk-plugin-compiler
libctf0,LOW,2.35.2-2,,A potential heap based buffer overflow was found in _bfd_elf_slurp_version_tables() in bfd/elf.c. This may lead to loss of availability.,CVE-2023-1972,tykio/tyk-plugin-compiler
libctf0,LOW,2.35.2-2,,An out-of-bounds read flaw was found in the parse_module function in bfd/vms-alpha.c in Binutils.,CVE-2023-25584,tykio/tyk-plugin-compiler
libctf0,LOW,2.35.2-2,,A flaw was found in Binutils. The use of an uninitialized field in the struct module *module may lead to application crash and local denial of service.,CVE-2023-25585,tykio/tyk-plugin-compiler
libctf0,LOW,2.35.2-2,,A flaw was found in Binutils. A logic fail in the bfd_init_section_decompress_status function may lead to the use of an uninitialized variable that can cause a crash and local denial of service.,CVE-2023-25586,tykio/tyk-plugin-compiler
libctf0,LOW,2.35.2-2,,A flaw was found in Binutils. The field `the_bfd` of `asymbol`struct is uninitialized in the `bfd_mach_o_get_synthetic_symtab` function which may lead to an application crash and local denial of service.,CVE-2023-25588,tykio/tyk-plugin-compiler
libctf0,LOW,2.35.2-2,,GNU objdump 2.43 is vulnerable to Buffer Overflow in the BFD (Binary File Descriptor) library's handling of tekhex format files.,CVE-2024-53589,tykio/tyk-plugin-compiler
libctf0,LOW,2.35.2-2,,https://www.gnu.org/software/binutils/ nm >=2.43 is affected by: Incorrect Access Control. The type of exploitation is: local. The component is: `nm --without-symbol-version` function.,CVE-2024-57360,tykio/tyk-plugin-compiler
libctf0,LOW,2.35.2-2,,A vulnerability which was classified as problematic was found in GNU Binutils up to 2.43. This affects the function disassemble_bytes of the file binutils/objdump.c. The manipulation of the argument buf leads to stack-based buffer overflow. It is possible to initiate the attack remotely. The complexity of an attack is rather high. The exploitability is told to be difficult. The exploit has been disclosed to the public and may be used. Upgrading to version 2.44 is able to address this issue. The identifier of the patch is baac6c221e9d69335bf41366a1c7d87d8ab2f893. It is recommended to upgrade the affected component.,CVE-2025-0840,tykio/tyk-plugin-compiler
libctf0,LOW,2.35.2-2,,A vulnerability has been found in GNU Binutils 2.43 and classified as problematic. Affected by this vulnerability is the function __sanitizer::internal_strlen of the file binutils/nm.c of the component nm. The manipulation of the argument const leads to buffer overflow. The attack can be launched remotely. The complexity of an attack is rather high. The exploitation appears to be difficult. The exploit has been disclosed to the public and may be used.,CVE-2025-1147,tykio/tyk-plugin-compiler
libctf0,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43 and classified as problematic. Affected by this issue is the function link_order_scan of the file ld/ldelfgen.c of the component ld. The manipulation leads to memory leak. The attack may be launched remotely. The complexity of an attack is rather high. The exploitation is known to be difficult. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue. The code maintainer explains: I'm not going to commit some of the leak fixes I've been working on to the 2.44 branch due to concern that would destabilise ld. All of the reported leaks in this bugzilla have been fixed on binutils master.,CVE-2025-1148,tykio/tyk-plugin-compiler
libctf0,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43. It has been classified as problematic. This affects the function xstrdup of the file libiberty/xmalloc.c of the component ld. The manipulation leads to memory leak. It is possible to initiate the attack remotely. The complexity of an attack is rather high. The exploitability is told to be difficult. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue. The code maintainer explains: I'm not going to commit some of the leak fixes I've been working on to the 2.44 branch due to concern that would destabilise ld. All of the reported leaks in this bugzilla have been fixed on binutils master.,CVE-2025-1149,tykio/tyk-plugin-compiler
libctf0,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43. It has been declared as problematic. This vulnerability affects the function bfd_malloc of the file libbfd.c of the component ld. The manipulation leads to memory leak. The attack can be initiated remotely. The complexity of an attack is rather high. The exploitation appears to be difficult. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue. The code maintainer explains: I'm not going to commit some of the leak fixes I've been working on to the 2.44 branch due to concern that would destabilise ld. All of the reported leaks in this bugzilla have been fixed on binutils master.,CVE-2025-1150,tykio/tyk-plugin-compiler
libctf0,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43. It has been rated as problematic. This issue affects the function xmemdup of the file xmemdup.c of the component ld. The manipulation leads to memory leak. The attack may be initiated remotely. The complexity of an attack is rather high. The exploitation is known to be difficult. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue. The code maintainer explains: I'm not going to commit some of the leak fixes I've been working on to the 2.44 branch due to concern that would destabilise ld. All of the reported leaks in this bugzilla have been fixed on binutils master.,CVE-2025-1151,tykio/tyk-plugin-compiler
libctf0,LOW,2.35.2-2,,A vulnerability classified as problematic has been found in GNU Binutils 2.43. Affected is the function xstrdup of the file xstrdup.c of the component ld. The manipulation leads to memory leak. It is possible to launch the attack remotely. The complexity of an attack is rather high. The exploitability is told to be difficult. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue. The code maintainer explains: I'm not going to commit some of the leak fixes I've been working on to the 2.44 branch due to concern that would destabilise ld. All of the reported leaks in this bugzilla have been fixed on binutils master.,CVE-2025-1152,tykio/tyk-plugin-compiler
libctf0,LOW,2.35.2-2,,A vulnerability classified as problematic was found in GNU Binutils 2.43/2.44. Affected by this vulnerability is the function bfd_set_format of the file format.c. The manipulation leads to memory corruption. The attack can be launched remotely. The complexity of an attack is rather high. The exploitation appears to be difficult. Upgrading to version 2.45 is able to address this issue. The identifier of the patch is 8d97c1a53f3dc9fd8e1ccdb039b8a33d50133150. It is recommended to upgrade the affected component.,CVE-2025-1153,tykio/tyk-plugin-compiler
libctf0,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43 and classified as critical. This issue affects the function _bfd_elf_gc_mark_rsec of the file elflink.c of the component ld. The manipulation leads to heap-based buffer overflow. The attack may be initiated remotely. The complexity of an attack is rather high. The exploitation is known to be difficult. The exploit has been disclosed to the public and may be used. The patch is named f9978defb6fab0bd8583942d97c112b0932ac814. It is recommended to apply a patch to fix this issue.,CVE-2025-1176,tykio/tyk-plugin-compiler
libctf0,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43. It has been declared as problematic. Affected by this vulnerability is the function bfd_putl64 of the file libbfd.c of the component ld. The manipulation leads to memory corruption. The attack can be launched remotely. The complexity of an attack is rather high. The exploitation appears to be difficult. The exploit has been disclosed to the public and may be used. The identifier of the patch is 75086e9de1707281172cc77f178e7949a4414ed0. It is recommended to apply a patch to fix this issue.,CVE-2025-1178,tykio/tyk-plugin-compiler
libctf0,LOW,2.35.2-2,,A vulnerability was found in GNU Binutils 2.43. It has been rated as critical. Affected by this issue is the function bfd_putl64 of the file bfd/libbfd.c of the component ld. The manipulation leads to memory corruption. The attack may be launched remotely. The complexity of an attack is rather high. The exploitation is known to be difficult. The exploit has been disclosed to the public and may be used. Upgrading to version 2.44 is able to address this issue. It is recommended to upgrade the affected component. The code maintainer explains that [t]his bug has been fixed at some point between the 2.43 and 2.44 releases.,CVE-2025-1179,tykio/tyk-plugin-compiler
libctf0,LOW,2.35.2-2,,A vulnerability classified as problematic has been found in GNU Binutils 2.43. This affects the function _bfd_elf_write_section_eh_frame of the file bfd/elf-eh-frame.c of the component ld. The manipulation leads to memory corruption. It is possible to initiate the attack remotely. The complexity of an attack is rather high. The exploitability is told to be difficult. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue.,CVE-2025-1180,tykio/tyk-plugin-compiler
libctf0,LOW,2.35.2-2,,A vulnerability classified as critical was found in GNU Binutils 2.43. This vulnerability affects the function _bfd_elf_gc_mark_rsec of the file bfd/elflink.c of the component ld. The manipulation leads to memory corruption. The attack can be initiated remotely. The complexity of an attack is rather high. The exploitation appears to be difficult. The exploit has been disclosed to the public and may be used. The name of the patch is 931494c9a89558acb36a03a340c01726545eef24. It is recommended to apply a patch to fix this issue.,CVE-2025-1181,tykio/tyk-plugin-compiler
libctf0,LOW,2.35.2-2,,A vulnerability which was classified as critical was found in GNU Binutils 2.43. Affected is the function bfd_elf_reloc_symbol_deleted_p of the file bfd/elflink.c of the component ld. The manipulation leads to memory corruption. It is possible to launch the attack remotely. The complexity of an attack is rather high. The exploitability is told to be difficult. The exploit has been disclosed to the public and may be used. The patch is identified as b425859021d17adf62f06fb904797cf8642986ad. It is recommended to apply a patch to fix this issue.,CVE-2025-1182,tykio/tyk-plugin-compiler
libctf0,LOW,2.35.2-2,,A vulnerability has been found in GNU Binutils 2.43/2.44 and classified as problematic. Affected by this vulnerability is the function display_info of the file binutils/bucomm.c of the component objdump. The manipulation leads to memory leak. An attack has to be approached locally. The exploit has been disclosed to the public and may be used. The patch is named ba6ad3a18cb26b79e0e3b84c39f707535bbc344d. It is recommended to apply a patch to fix this issue.,CVE-2025-3198,tykio/tyk-plugin-compiler
libcurl3-gnutls,LOW,7.74.0-1.3+deb11u14,,When curl is instructed to download content using the metalink feature thecontents is verified against a hash provided in the metalink XML file.The metalink XML file points out to the client how to get the same contentfrom a set of different URLs potentially hosted by different servers and theclient can then download the file from one or several of them. In a serial orparallel manner.If one of the servers hosting the contents has been breached and the contentsof the specific file on that server is replaced with a modified payload curlshould detect this when the hash of the file mismatches after a completeddownload. It should remove the contents and instead try getting the contentsfrom another URL. This is not done and instead such a hash mismatch is onlymentioned in text and the potentially malicious content is kept in the file ondisk.,CVE-2021-22922,tykio/tyk-plugin-compiler
libcurl3-gnutls,LOW,7.74.0-1.3+deb11u14,,When curl is instructed to get content using the metalink feature and a user name and password are used to download the metalink XML file those same credentials are then subsequently passed on to each of the servers from which curl will download or try to download the contents from. Often contrary to the user's expectations and intentions and without telling the user it happened.,CVE-2021-22923,tykio/tyk-plugin-compiler
libcurl3-gnutls,HIGH,7.74.0-1.3+deb11u14,,In curl before 7.86.0 the HSTS check could be bypassed to trick it into staying with HTTP. Using its HSTS support curl can be instructed to use HTTPS directly (instead of using an insecure cleartext HTTP step) even when HTTP is provided in the URL. This mechanism could be bypassed if the host name in the given URL uses IDN characters that get replaced with ASCII counterparts as part of the IDN conversion e.g. using the character UTF-8 U+3002 (IDEOGRAPHIC FULL STOP) instead of the common ASCII full stop of U+002E (.). The earliest affected version is 7.77.0 2021-05-26.,CVE-2022-42916,tykio/tyk-plugin-compiler
libcurl3-gnutls,HIGH,7.74.0-1.3+deb11u14,,A vulnerability exists in curl <7.87.0 HSTS check that could be bypassed to trick it to keep using HTTP. Using its HSTS support curl can be instructed to use HTTPS instead of using an insecure clear-text HTTP step even when HTTP is provided in the URL. However the HSTS mechanism could be bypassed if the host name in the given URL first uses IDN characters that get replaced to ASCII counterparts as part of the IDN conversion. Like using the character UTF-8 U+3002 (IDEOGRAPHIC FULL STOP) instead of the common ASCII full stop (U+002E) `.`. Then in a subsequent request it does not detect the HSTS state and makes a clear text transfer. Because it would store the info IDN encoded but look for it IDN decoded.,CVE-2022-43551,tykio/tyk-plugin-compiler
libcurl3-gnutls,CRITICAL,7.74.0-1.3+deb11u14,,A cleartext transmission of sensitive information vulnerability exists in curl <v7.88.0 that could cause HSTS functionality fail when multiple URLs are requested serially. Using its HSTS support curl can be instructed to use HTTPS instead of usingan insecure clear-text HTTP step even when HTTP is provided in the URL. ThisHSTS mechanism would however surprisingly be ignored by subsequent transferswhen done on the same command line because the state would not be properlycarried on.,CVE-2023-23914,tykio/tyk-plugin-compiler
libcurl3-gnutls,MEDIUM,7.74.0-1.3+deb11u14,,A cleartext transmission of sensitive information vulnerability exists in curl <v7.88.0 that could cause HSTS functionality to behave incorrectly when multiple URLs are requested in parallel. Using its HSTS support curl can be instructed to use HTTPS instead of using an insecure clear-text HTTP step even when HTTP is provided in the URL. This HSTS mechanism would however surprisingly fail when multiple transfers are done in parallel as the HSTS cache file gets overwritten by the most recentlycompleted transfer. A later HTTP-only transfer to the earlier host name would then *not* get upgraded properly to HSTS.,CVE-2023-23915,tykio/tyk-plugin-compiler
libcurl3-gnutls,LOW,7.74.0-1.3+deb11u14,,A denial of service vulnerability exists in curl <v8.1.0 in the way libcurl provides several different backends for resolving host names selected at build time. If it is built to use the synchronous resolver it allows name resolves to time-out slow operations using `alarm()` and `siglongjmp()`. When doing this libcurl used a global buffer that was not mutex protected and a multi-threaded application might therefore crash or otherwise misbehave.,CVE-2023-28320,tykio/tyk-plugin-compiler
libcurl3-gnutls,MEDIUM,7.74.0-1.3+deb11u14,,When saving HSTS data to an excessively long file name curl could end upnremoving all contents making subsequent requests using that file unaware ofnthe HSTS status they should otherwise use.,CVE-2023-46219,tykio/tyk-plugin-compiler
libcurl3-gnutls,MEDIUM,7.88.1-10+deb12u8,7.88.1-10+deb12u10,When asked to both use a `.netrc` file for credentials and to follow HTTPnredirects curl could leak the password used for the first host to thenfollowed-to host under certain circumstances.nnThis flaw only manifests itself if the netrc file has an entry that matchesnthe redirect target hostname but the entry either omits just the password ornomits both login and password.,CVE-2024-11053,tykio/gromit
libcurl3-gnutls,LOW,7.74.0-1.3+deb11u14,,libcurl skips the certificate verification for a QUIC connection under certain conditions when built to use wolfSSL. If told to use an unknown/bad cipher or curve the error path accidentally skips the verification and returns OK thus ignoring any certificate problems.,CVE-2024-2379,tykio/gromit & tykio/tyk-plugin-compiler
libcurl3-gnutls,MEDIUM,7.74.0-1.3+deb11u14,,When curl is asked to use HSTS the expiry time for a subdomain mightnoverwrite a parent domain's cache entry making it end sooner or later thannotherwise intended.nnThis affects curl using applications that enable HSTS and use URLs with theninsecure `HTTP://` scheme and perform transfers with hosts liken`x.example.com` as well as `example.com` where the first host is a subdomainnof the second host.nn(The HSTS cache either needs to have been populated manually or there needs tonhave been previous HTTPS accesses done as the cache needs to have entries fornthe domains involved to trigger this problem.)nnWhen `x.example.com` responds with `Strict-Transport-Security:` headers thisnbug can make the subdomain's expiry timeout *bleed over* and get set for thenparent domain `example.com` in curl's HSTS cache.nnThe result of a triggered bug is that HTTP accesses to `example.com` getnconverted to HTTPS for a different period of time than what was asked for bynthe origin server. If `example.com` for example stops supporting HTTPS at itsnexpiry time curl might then fail to access `http://example.com` until then(wrongly set) timeout expires. This bug can also expire the parent's entryn*earlier* thus making curl inadvertently switch back to insecure HTTP earliernthan otherwise intended.,CVE-2024-9681,tykio/gromit & tykio/tyk-plugin-compiler
libcurl3-gnutls,LOW,7.88.1-10+deb12u8,7.88.1-10+deb12u11,When asked to use a `.netrc` file for credentials **and** to follow HTTPnredirects curl could leak the password used for the first host to thenfollowed-to host under certain circumstances.nnThis flaw only manifests itself if the netrc file has a `default` entry thatnomits both login and password. A rare circumstance.,CVE-2025-0167,tykio/gromit
libcurl3-gnutls,LOW,7.74.0-1.3+deb11u14,,When libcurl is asked to perform automatic gzip decompression ofncontent-encoded HTTP responses with the `CURLOPT_ACCEPT_ENCODING` optionn**using zlib 1.2.0.3 or older** an attacker-controlled integer overflow wouldnmake libcurl perform a buffer overflow.,CVE-2025-0725,tykio/gromit & tykio/tyk-plugin-compiler
libcurl4,MEDIUM,7.88.1-10+deb12u8,7.88.1-10+deb12u10,When asked to both use a `.netrc` file for credentials and to follow HTTPnredirects curl could leak the password used for the first host to thenfollowed-to host under certain circumstances.nnThis flaw only manifests itself if the netrc file has an entry that matchesnthe redirect target hostname but the entry either omits just the password ornomits both login and password.,CVE-2024-11053,tykio/gromit
libcurl4,LOW,7.88.1-10+deb12u8,,libcurl skips the certificate verification for a QUIC connection under certain conditions when built to use wolfSSL. If told to use an unknown/bad cipher or curve the error path accidentally skips the verification and returns OK thus ignoring any certificate problems.,CVE-2024-2379,tykio/gromit
libcurl4,MEDIUM,7.88.1-10+deb12u8,7.88.1-10+deb12u9,When curl is asked to use HSTS the expiry time for a subdomain mightnoverwrite a parent domain's cache entry making it end sooner or later thannotherwise intended.nnThis affects curl using applications that enable HSTS and use URLs with theninsecure `HTTP://` scheme and perform transfers with hosts liken`x.example.com` as well as `example.com` where the first host is a subdomainnof the second host.nn(The HSTS cache either needs to have been populated manually or there needs tonhave been previous HTTPS accesses done as the cache needs to have entries fornthe domains involved to trigger this problem.)nnWhen `x.example.com` responds with `Strict-Transport-Security:` headers thisnbug can make the subdomain's expiry timeout *bleed over* and get set for thenparent domain `example.com` in curl's HSTS cache.nnThe result of a triggered bug is that HTTP accesses to `example.com` getnconverted to HTTPS for a different period of time than what was asked for bynthe origin server. If `example.com` for example stops supporting HTTPS at itsnexpiry time curl might then fail to access `http://example.com` until then(wrongly set) timeout expires. This bug can also expire the parent's entryn*earlier* thus making curl inadvertently switch back to insecure HTTP earliernthan otherwise intended.,CVE-2024-9681,tykio/gromit
libcurl4,LOW,7.88.1-10+deb12u8,7.88.1-10+deb12u11,When asked to use a `.netrc` file for credentials **and** to follow HTTPnredirects curl could leak the password used for the first host to thenfollowed-to host under certain circumstances.nnThis flaw only manifests itself if the netrc file has a `default` entry thatnomits both login and password. A rare circumstance.,CVE-2025-0167,tykio/gromit
libcurl4,LOW,7.88.1-10+deb12u8,,When libcurl is asked to perform automatic gzip decompression ofncontent-encoded HTTP responses with the `CURLOPT_ACCEPT_ENCODING` optionn**using zlib 1.2.0.3 or older** an attacker-controlled integer overflow wouldnmake libcurl perform a buffer overflow.,CVE-2025-0725,tykio/gromit
libdb5.3,CRITICAL,5.3.28+dfsg1-0.8,,SQLite3 from 3.6.0 to and including 3.27.2 is vulnerable to heap out-of-bound read in the rtreenode() function when handling invalid rtree tables.,CVE-2019-8457,tykio/tyk-plugin-compiler
libdebian-dpkgcross-perl,LOW,2.6.18+nmu1,,gccross in dpkg-cross 2.3.0 allows local users to overwrite arbitrary files via a symlink attack on the tmp/gccross2.log temporary file. NOTE: the vendor disputes this vulnerability stating that There is no sense in this bug - the script ... is called under specific cross-building environments within a chroot.,CVE-2008-4950,tykio/tyk-plugin-compiler
libexpat1,LOW,2.2.10-2+deb11u6,,expat 2.1.0 and earlier does not properly handle entities expansion unless an application developer uses the XML_SetEntityDeclHandler function which allows remote attackers to cause a denial of service (resource consumption) send HTTP requests to intranet servers or read arbitrary files via a crafted XML document aka an XML External Entity (XXE) issue. NOTE: it could be argued that because expat already provides the ability to disable external entity expansion the responsibility for resolving this issue lies with application developers; according to this argument this entry should be REJECTed and each affected application would need its own CVE.,CVE-2013-0340,tykio/tyk-plugin-compiler
libexpat1,HIGH,2.5.0-1+deb12u1,,libexpat through 2.5.0 allows a denial of service (resource consumption) because many full reparsings are required in the case of a large token for which multiple buffer fills are needed.,CVE-2023-52425,tykio/gromit
libexpat1,LOW,2.2.10-2+deb11u6,,libexpat through 2.5.0 allows recursive XML Entity Expansion if XML_DTD is undefined at compile time.,CVE-2023-52426,tykio/gromit & tykio/tyk-plugin-compiler
libexpat1,LOW,2.2.10-2+deb11u6,,libexpat through 2.6.1 allows an XML Entity Expansion attack when there is isolated use of external parsers (created via XML_ExternalEntityParserCreate).,CVE-2024-28757,tykio/gromit & tykio/tyk-plugin-compiler
libexpat1,MEDIUM,2.2.10-2+deb11u6,2.2.10-2+deb11u7,An issue was discovered in libexpat before 2.6.4. There is a crash within the XML_ResumeParser function because XML_StopParser can stop/suspend an unstarted parser.,CVE-2024-50602,tykio/gromit & tykio/tyk-plugin-compiler
libexpat1,HIGH,2.2.10-2+deb11u6,,A stack overflow vulnerability exists in the libexpat library due to the way it handles recursive entity expansion in XML documents. When parsing an XML document with deeply nested entity references libexpat can be forced to recurse indefinitely exhausting the stack space and causing a crash. This issue could lead to denial of service (DoS) or in some cases exploitable memory corruption depending on the environment and library usage.,CVE-2024-8176,tykio/gromit & tykio/tyk-plugin-compiler
libgcc-10-dev,LOW,10.2.1-6,,**DISPUTED**A failure in the -fstack-protector feature in GCC-based toolchains nthat target AArch64 allows an attacker to exploit an existing buffer noverflow in dynamically-sized local variables in your application nwithout this being detected. This stack-protector failure only applies nto C99-style dynamically-sized local variables or those created using nalloca(). The stack-protector operates as intended for statically-sized nlocal variables.nnThe default behavior when the stack-protector ndetects an overflow is to terminate your application resulting in ncontrolled loss of availability. An attacker who can exploit a buffer noverflow without triggering the stack-protector might be able to change nprogram flow control to cause an uncontrolled loss of availability or ton go further and affect confidentiality or integrity. NOTE: The GCC project argues that this is a missed hardening bug and not a vulnerability by itself.,CVE-2023-4039,tykio/tyk-plugin-compiler
libgcc-s1,LOW,12.2.0-14,,libiberty/rust-demangle.c in GNU GCC 11.2 allows stack consumption in demangle_const as demonstrated by nm-new.,CVE-2022-27943,tykio/gromit
libgcc-s1,LOW,10.2.1-6,,**DISPUTED**A failure in the -fstack-protector feature in GCC-based toolchains nthat target AArch64 allows an attacker to exploit an existing buffer noverflow in dynamically-sized local variables in your application nwithout this being detected. This stack-protector failure only applies nto C99-style dynamically-sized local variables or those created using nalloca(). The stack-protector operates as intended for statically-sized nlocal variables.nnThe default behavior when the stack-protector ndetects an overflow is to terminate your application resulting in ncontrolled loss of availability. An attacker who can exploit a buffer noverflow without triggering the stack-protector might be able to change nprogram flow control to cause an uncontrolled loss of availability or ton go further and affect confidentiality or integrity. NOTE: The GCC project argues that this is a missed hardening bug and not a vulnerability by itself.,CVE-2023-4039,tykio/gromit & tykio/tyk-plugin-compiler
libgcrypt20,LOW,1.8.7-6,,cipher/elgamal.c in Libgcrypt through 1.8.2 when used to encrypt messages directly improperly encodes plaintexts which allows attackers to obtain sensitive information by reading ciphertext data (i.e. it does not have semantic security in face of a ciphertext-only attack). The Decisional Diffie-Hellman (DDH) assumption does not hold for Libgcrypt's ElGamal implementation.,CVE-2018-6829,tykio/gromit & tykio/tyk-plugin-compiler
libgcrypt20,HIGH,1.8.7-6,,Libgcrypt before 1.8.8 and 1.9.x before 1.9.3 mishandles ElGamal encryption because it lacks exponent blinding to address a side-channel attack against mpi_powm and the window size is not chosen appropriately. This for example affects use of ElGamal in OpenPGP.,CVE-2021-33560,tykio/tyk-plugin-compiler
libgcrypt20,LOW,1.8.7-6,,A timing-based side-channel flaw was found in libgcrypt's RSA implementation. This issue may allow a remote attacker to initiate a Bleichenbacher-style attack which can lead to the decryption of RSA ciphertexts.,CVE-2024-2236,tykio/gromit & tykio/tyk-plugin-compiler
libglib2.0-0,LOW,2.66.8-1+deb11u6,,GLib 2.31.8 and earlier when the g_str_hash function is used computes hash values without restricting the ability to trigger hash collisions predictably which allows context-dependent attackers to cause a denial of service (CPU consumption) via crafted input to an application that maintains a hash table. NOTE: this issue may be disputed by the vendor; the existence of the g_str_hash function is not a vulnerability in the library because callers of g_hash_table_new and g_hash_table_new_full can specify an arbitrary hash function that is appropriate for the application.,CVE-2012-0039,tykio/tyk-plugin-compiler
libglib2.0-0,MEDIUM,2.66.8-1+deb11u6,,A flaw was found in GLib which is vulnerable to an integer overflow in the g_string_insert_unichar() function. When the position at which to insert the character is large the position will overflow leading to a buffer underwrite.,CVE-2025-4373,tykio/tyk-plugin-compiler
libgnutls30,LOW,3.7.1-5+deb11u7,,The SSL protocol as used in certain configurations in Microsoft Windows and Microsoft Internet Explorer Mozilla Firefox Google Chrome Opera and other products encrypts data by using CBC mode with chained initialization vectors which allows man-in-the-middle attackers to obtain plaintext HTTP headers via a blockwise chosen-boundary attack (BCBA) on an HTTPS session in conjunction with JavaScript code that uses (1) the HTML5 WebSocket API (2) the Java URLConnection API or (3) the Silverlight WebClient API aka a BEAST attack.,CVE-2011-3389,tykio/gromit & tykio/tyk-plugin-compiler
libgnutls30,MEDIUM,3.7.9-2+deb12u3,3.7.9-2+deb12u4,A flaw was found in GnuTLS which relies on libtasn1 for ASN.1 data processing. Due to an inefficient algorithm in libtasn1 decoding certain DER-encoded certificate data can take excessive time leading to increased resource consumption. This flaw allows a remote attacker to send a specially crafted certificate causing GnuTLS to become unresponsive or slow resulting in a denial-of-service condition.,CVE-2024-12243,tykio/gromit
libgomp1,LOW,10.2.1-6,,**DISPUTED**A failure in the -fstack-protector feature in GCC-based toolchains nthat target AArch64 allows an attacker to exploit an existing buffer noverflow in dynamically-sized local variables in your application nwithout this being detected. This stack-protector failure only applies nto C99-style dynamically-sized local variables or those created using nalloca(). The stack-protector operates as intended for statically-sized nlocal variables.nnThe default behavior when the stack-protector ndetects an overflow is to terminate your application resulting in ncontrolled loss of availability. An attacker who can exploit a buffer noverflow without triggering the stack-protector might be able to change nprogram flow control to cause an uncontrolled loss of availability or ton go further and affect confidentiality or integrity. NOTE: The GCC project argues that this is a missed hardening bug and not a vulnerability by itself.,CVE-2023-4039,tykio/tyk-plugin-compiler
libgssapi-krb5-2,LOW,1.18.3-6+deb11u6,,An issue was discovered in MIT Kerberos 5 (aka krb5) through 1.16. There is a variable dbentry->n_key_data in kadmin/dbutil/dump.c that can store 16-bit data but unknowingly the developer has assigned a u4 variable to it which is for 32-bit data. An attacker can use this vulnerability to affect other artifacts of the database as we know that a Kerberos database dump file contains trusted data.,CVE-2018-5709,tykio/gromit & tykio/tyk-plugin-compiler
libgssapi-krb5-2,LOW,1.18.3-6+deb11u6,,Kerberos 5 (aka krb5) 1.21.2 contains a memory leak in /krb5/src/lib/rpc/pmap_rmt.c.,CVE-2024-26458,tykio/gromit & tykio/tyk-plugin-compiler
libgssapi-krb5-2,LOW,1.18.3-6+deb11u6,,Kerberos 5 (aka krb5) 1.21.2 contains a memory leak vulnerability in /krb5/src/lib/gssapi/krb5/k5sealv3.c.,CVE-2024-26461,tykio/gromit & tykio/tyk-plugin-compiler
libgssapi-krb5-2,MEDIUM,1.20.1-2+deb12u2,,Kerberos 5 (aka krb5) 1.21.2 contains a memory leak vulnerability in /krb5/src/kdc/ndr.c.,CVE-2024-26462,tykio/gromit
libgssapi-krb5-2,MEDIUM,1.20.1-2+deb12u2,,A flaw was found in krb5. With incremental propagation enabled an authenticated attacker can cause kadmind to write beyond the end of the mapped region for the iprop log file. This issue can trigger a process crash and lead to a denial of service.,CVE-2025-24528,tykio/gromit
libgssapi-krb5-2,MEDIUM,1.18.3-6+deb11u6,,A vulnerability in the MIT Kerberos implementation allows GSSAPI-protected messages using RC4-HMAC-MD5 to be spoofed due to weaknesses in the MD5 checksum design. If RC4 is preferred over stronger encryption types an attacker could exploit MD5 collisions to forge message integrity codes. This may lead to unauthorized message tampering.,CVE-2025-3576,tykio/gromit & tykio/tyk-plugin-compiler
libitm1,LOW,10.2.1-6,,**DISPUTED**A failure in the -fstack-protector feature in GCC-based toolchains nthat target AArch64 allows an attacker to exploit an existing buffer noverflow in dynamically-sized local variables in your application nwithout this being detected. This stack-protector failure only applies nto C99-style dynamically-sized local variables or those created using nalloca(). The stack-protector operates as intended for statically-sized nlocal variables.nnThe default behavior when the stack-protector ndetects an overflow is to terminate your application resulting in ncontrolled loss of availability. An attacker who can exploit a buffer noverflow without triggering the stack-protector might be able to change nprogram flow control to cause an uncontrolled loss of availability or ton go further and affect confidentiality or integrity. NOTE: The GCC project argues that this is a missed hardening bug and not a vulnerability by itself.,CVE-2023-4039,tykio/tyk-plugin-compiler
libjq1,MEDIUM,1.6-2.1,,decNumberCopy in decNumber.c in jq through 1.7.1 does not properly consider that NaN is interpreted as numeric which has a resultant stack-based buffer overflow and out-of-bounds write as demonstrated by use of --slurp with subtraction such as a filter of .-. when the input has a certain form of digit string with NaN (e.g. 1 NaN123 immediately followed by many more digits).,CVE-2024-53427,tykio/tyk-plugin-compiler
libk5crypto3,LOW,1.18.3-6+deb11u6,,An issue was discovered in MIT Kerberos 5 (aka krb5) through 1.16. There is a variable dbentry->n_key_data in kadmin/dbutil/dump.c that can store 16-bit data but unknowingly the developer has assigned a u4 variable to it which is for 32-bit data. An attacker can use this vulnerability to affect other artifacts of the database as we know that a Kerberos database dump file contains trusted data.,CVE-2018-5709,tykio/gromit & tykio/tyk-plugin-compiler
libk5crypto3,LOW,1.18.3-6+deb11u6,,Kerberos 5 (aka krb5) 1.21.2 contains a memory leak in /krb5/src/lib/rpc/pmap_rmt.c.,CVE-2024-26458,tykio/gromit & tykio/tyk-plugin-compiler
libk5crypto3,LOW,1.18.3-6+deb11u6,,Kerberos 5 (aka krb5) 1.21.2 contains a memory leak vulnerability in /krb5/src/lib/gssapi/krb5/k5sealv3.c.,CVE-2024-26461,tykio/gromit & tykio/tyk-plugin-compiler
libk5crypto3,MEDIUM,1.20.1-2+deb12u2,,Kerberos 5 (aka krb5) 1.21.2 contains a memory leak vulnerability in /krb5/src/kdc/ndr.c.,CVE-2024-26462,tykio/gromit
libk5crypto3,MEDIUM,1.20.1-2+deb12u2,,A flaw was found in krb5. With incremental propagation enabled an authenticated attacker can cause kadmind to write beyond the end of the mapped region for the iprop log file. This issue can trigger a process crash and lead to a denial of service.,CVE-2025-24528,tykio/gromit
libk5crypto3,MEDIUM,1.18.3-6+deb11u6,,A vulnerability in the MIT Kerberos implementation allows GSSAPI-protected messages using RC4-HMAC-MD5 to be spoofed due to weaknesses in the MD5 checksum design. If RC4 is preferred over stronger encryption types an attacker could exploit MD5 collisions to forge message integrity codes. This may lead to unauthorized message tampering.,CVE-2025-3576,tykio/gromit & tykio/tyk-plugin-compiler
libkrb5-3,LOW,1.18.3-6+deb11u6,,An issue was discovered in MIT Kerberos 5 (aka krb5) through 1.16. There is a variable dbentry->n_key_data in kadmin/dbutil/dump.c that can store 16-bit data but unknowingly the developer has assigned a u4 variable to it which is for 32-bit data. An attacker can use this vulnerability to affect other artifacts of the database as we know that a Kerberos database dump file contains trusted data.,CVE-2018-5709,tykio/gromit & tykio/tyk-plugin-compiler
libkrb5-3,LOW,1.18.3-6+deb11u6,,Kerberos 5 (aka krb5) 1.21.2 contains a memory leak in /krb5/src/lib/rpc/pmap_rmt.c.,CVE-2024-26458,tykio/gromit & tykio/tyk-plugin-compiler
libkrb5-3,LOW,1.18.3-6+deb11u6,,Kerberos 5 (aka krb5) 1.21.2 contains a memory leak vulnerability in /krb5/src/lib/gssapi/krb5/k5sealv3.c.,CVE-2024-26461,tykio/gromit & tykio/tyk-plugin-compiler
libkrb5-3,MEDIUM,1.20.1-2+deb12u2,,Kerberos 5 (aka krb5) 1.21.2 contains a memory leak vulnerability in /krb5/src/kdc/ndr.c.,CVE-2024-26462,tykio/gromit
libkrb5-3,MEDIUM,1.20.1-2+deb12u2,,A flaw was found in krb5. With incremental propagation enabled an authenticated attacker can cause kadmind to write beyond the end of the mapped region for the iprop log file. This issue can trigger a process crash and lead to a denial of service.,CVE-2025-24528,tykio/gromit
libkrb5-3,MEDIUM,1.18.3-6+deb11u6,,A vulnerability in the MIT Kerberos implementation allows GSSAPI-protected messages using RC4-HMAC-MD5 to be spoofed due to weaknesses in the MD5 checksum design. If RC4 is preferred over stronger encryption types an attacker could exploit MD5 collisions to forge message integrity codes. This may lead to unauthorized message tampering.,CVE-2025-3576,tykio/gromit & tykio/tyk-plugin-compiler
libkrb5support0,LOW,1.18.3-6+deb11u6,,An issue was discovered in MIT Kerberos 5 (aka krb5) through 1.16. There is a variable dbentry->n_key_data in kadmin/dbutil/dump.c that can store 16-bit data but unknowingly the developer has assigned a u4 variable to it which is for 32-bit data. An attacker can use this vulnerability to affect other artifacts of the database as we know that a Kerberos database dump file contains trusted data.,CVE-2018-5709,tykio/gromit & tykio/tyk-plugin-compiler
libkrb5support0,LOW,1.18.3-6+deb11u6,,Kerberos 5 (aka krb5) 1.21.2 contains a memory leak in /krb5/src/lib/rpc/pmap_rmt.c.,CVE-2024-26458,tykio/gromit & tykio/tyk-plugin-compiler
libkrb5support0,LOW,1.18.3-6+deb11u6,,Kerberos 5 (aka krb5) 1.21.2 contains a memory leak vulnerability in /krb5/src/lib/gssapi/krb5/k5sealv3.c.,CVE-2024-26461,tykio/gromit & tykio/tyk-plugin-compiler
libkrb5support0,MEDIUM,1.20.1-2+deb12u2,,Kerberos 5 (aka krb5) 1.21.2 contains a memory leak vulnerability in /krb5/src/kdc/ndr.c.,CVE-2024-26462,tykio/gromit
libkrb5support0,MEDIUM,1.20.1-2+deb12u2,,A flaw was found in krb5. With incremental propagation enabled an authenticated attacker can cause kadmind to write beyond the end of the mapped region for the iprop log file. This issue can trigger a process crash and lead to a denial of service.,CVE-2025-24528,tykio/gromit
libkrb5support0,MEDIUM,1.18.3-6+deb11u6,,A vulnerability in the MIT Kerberos implementation allows GSSAPI-protected messages using RC4-HMAC-MD5 to be spoofed due to weaknesses in the MD5 checksum design. If RC4 is preferred over stronger encryption types an attacker could exploit MD5 collisions to forge message integrity codes. This may lead to unauthorized message tampering.,CVE-2025-3576,tykio/gromit & tykio/tyk-plugin-compiler
libldap-2.4-2,LOW,2.4.57+dfsg-3+deb11u1,,The nss_parse_ciphers function in libraries/libldap/tls_m.c in OpenLDAP does not properly parse OpenSSL-style multi-keyword mode cipher strings which might cause a weaker than intended cipher to be used and allow remote attackers to have unspecified impact via unknown vectors.,CVE-2015-3276,tykio/tyk-plugin-compiler
libldap-2.4-2,LOW,2.4.57+dfsg-3+deb11u1,,slapd in OpenLDAP 2.4.45 and earlier creates a PID file after dropping privileges to a non-root account which might allow local users to kill arbitrary processes by leveraging access to this non-root account for PID file modification before a root script executes a kill `cat /pathname` command as demonstrated by openldap-initscript.,CVE-2017-14159,tykio/tyk-plugin-compiler
libldap-2.4-2,LOW,2.4.57+dfsg-3+deb11u1,,contrib/slapd-modules/nops/nops.c in OpenLDAP through 2.4.45 when both the nops module and the memberof overlay are enabled attempts to free a buffer that was allocated on the stack which allows remote attackers to cause a denial of service (slapd crash) via a member MODDN operation.,CVE-2017-17740,tykio/tyk-plugin-compiler
libldap-2.4-2,LOW,2.4.57+dfsg-3+deb11u1,,libldap in certain third-party OpenLDAP packages has a certificate-validation flaw when the third-party package is asserting RFC6125 support. It considers CN even when there is a non-matching subjectAltName (SAN). This is fixed in for example openldap-2.4.46-10.el8 in Red Hat Enterprise Linux.,CVE-2020-15719,tykio/tyk-plugin-compiler
libldap-2.4-2,HIGH,2.4.57+dfsg-3+deb11u1,,A vulnerability was found in openldap. This security flaw causes a null pointer dereference in ber_memalloc_x() function.,CVE-2023-2953,tykio/tyk-plugin-compiler
libldap-2.5-0,LOW,2.5.13+dfsg-5,,The nss_parse_ciphers function in libraries/libldap/tls_m.c in OpenLDAP does not properly parse OpenSSL-style multi-keyword mode cipher strings which might cause a weaker than intended cipher to be used and allow remote attackers to have unspecified impact via unknown vectors.,CVE-2015-3276,tykio/gromit
libldap-2.5-0,LOW,2.5.13+dfsg-5,,slapd in OpenLDAP 2.4.45 and earlier creates a PID file after dropping privileges to a non-root account which might allow local users to kill arbitrary processes by leveraging access to this non-root account for PID file modification before a root script executes a kill `cat /pathname` command as demonstrated by openldap-initscript.,CVE-2017-14159,tykio/gromit
libldap-2.5-0,LOW,2.5.13+dfsg-5,,contrib/slapd-modules/nops/nops.c in OpenLDAP through 2.4.45 when both the nops module and the memberof overlay are enabled attempts to free a buffer that was allocated on the stack which allows remote attackers to cause a denial of service (slapd crash) via a member MODDN operation.,CVE-2017-17740,tykio/gromit
libldap-2.5-0,LOW,2.5.13+dfsg-5,,libldap in certain third-party OpenLDAP packages has a certificate-validation flaw when the third-party package is asserting RFC6125 support. It considers CN even when there is a non-matching subjectAltName (SAN). This is fixed in for example openldap-2.4.46-10.el8 in Red Hat Enterprise Linux.,CVE-2020-15719,tykio/gromit
libldap-2.5-0,HIGH,2.5.13+dfsg-5,,A vulnerability was found in openldap. This security flaw causes a null pointer dereference in ber_memalloc_x() function.,CVE-2023-2953,tykio/gromit
libldap-common,LOW,2.5.13+dfsg-5,,The nss_parse_ciphers function in libraries/libldap/tls_m.c in OpenLDAP does not properly parse OpenSSL-style multi-keyword mode cipher strings which might cause a weaker than intended cipher to be used and allow remote attackers to have unspecified impact via unknown vectors.,CVE-2015-3276,tykio/gromit
libldap-common,LOW,2.5.13+dfsg-5,,slapd in OpenLDAP 2.4.45 and earlier creates a PID file after dropping privileges to a non-root account which might allow local users to kill arbitrary processes by leveraging access to this non-root account for PID file modification before a root script executes a kill `cat /pathname` command as demonstrated by openldap-initscript.,CVE-2017-14159,tykio/gromit
libldap-common,LOW,2.5.13+dfsg-5,,contrib/slapd-modules/nops/nops.c in OpenLDAP through 2.4.45 when both the nops module and the memberof overlay are enabled attempts to free a buffer that was allocated on the stack which allows remote attackers to cause a denial of service (slapd crash) via a member MODDN operation.,CVE-2017-17740,tykio/gromit
libldap-common,LOW,2.5.13+dfsg-5,,libldap in certain third-party OpenLDAP packages has a certificate-validation flaw when the third-party package is asserting RFC6125 support. It considers CN even when there is a non-matching subjectAltName (SAN). This is fixed in for example openldap-2.4.46-10.el8 in Red Hat Enterprise Linux.,CVE-2020-15719,tykio/gromit
libldap-common,HIGH,2.5.13+dfsg-5,,A vulnerability was found in openldap. This security flaw causes a null pointer dereference in ber_memalloc_x() function.,CVE-2023-2953,tykio/gromit
liblsan0,LOW,10.2.1-6,,**DISPUTED**A failure in the -fstack-protector feature in GCC-based toolchains nthat target AArch64 allows an attacker to exploit an existing buffer noverflow in dynamically-sized local variables in your application nwithout this being detected. This stack-protector failure only applies nto C99-style dynamically-sized local variables or those created using nalloca(). The stack-protector operates as intended for statically-sized nlocal variables.nnThe default behavior when the stack-protector ndetects an overflow is to terminate your application resulting in ncontrolled loss of availability. An attacker who can exploit a buffer noverflow without triggering the stack-protector might be able to change nprogram flow control to cause an uncontrolled loss of availability or ton go further and affect confidentiality or integrity. NOTE: The GCC project argues that this is a missed hardening bug and not a vulnerability by itself.,CVE-2023-4039,tykio/tyk-plugin-compiler
liblzma5,HIGH,5.4.1-0.2,5.4.1-1,XZ Utils provide a general-purpose data-compression library plus command-line tools. In XZ Utils 5.3.3alpha to 5.8.0 the multithreaded .xz decoder in liblzma has a bug where invalid input can at least result in a crash. The effects include heap use after free and writing to an address based on the null pointer plus an offset. Applications and libraries that use the lzma_stream_decoder_mt function are affected. The bug has been fixed in XZ Utils 5.8.1 and the fix has been committed to the v5.4 v5.6 v5.8 and master branches in the xz Git repository. No new release packages will be made from the old stable branches but a standalone patch is available that applies to all affected releases.,CVE-2025-31115,tykio/gromit
libmount1,LOW,2.36.1-8+deb11u2,,A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an INPUTRC environment variable to get a path to the library config file. When the library cannot parse the specified file it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.,CVE-2022-0563,tykio/gromit & tykio/tyk-plugin-compiler
libncurses6,MEDIUM,6.2+20201114-2+deb11u2,,NCurse v6.4-20230418 was discovered to contain a segmentation fault via the component _nc_wrap_entry().,CVE-2023-50495,tykio/tyk-plugin-compiler
libncursesw6,MEDIUM,6.2+20201114-2+deb11u2,,NCurse v6.4-20230418 was discovered to contain a segmentation fault via the component _nc_wrap_entry().,CVE-2023-50495,tykio/tyk-plugin-compiler
libobjc-10-dev,LOW,10.2.1-6,,**DISPUTED**A failure in the -fstack-protector feature in GCC-based toolchains nthat target AArch64 allows an attacker to exploit an existing buffer noverflow in dynamically-sized local variables in your application nwithout this being detected. This stack-protector failure only applies nto C99-style dynamically-sized local variables or those created using nalloca(). The stack-protector operates as intended for statically-sized nlocal variables.nnThe default behavior when the stack-protector ndetects an overflow is to terminate your application resulting in ncontrolled loss of availability. An attacker who can exploit a buffer noverflow without triggering the stack-protector might be able to change nprogram flow control to cause an uncontrolled loss of availability or ton go further and affect confidentiality or integrity. NOTE: The GCC project argues that this is a missed hardening bug and not a vulnerability by itself.,CVE-2023-4039,tykio/tyk-plugin-compiler
libobjc4,LOW,10.2.1-6,,**DISPUTED**A failure in the -fstack-protector feature in GCC-based toolchains nthat target AArch64 allows an attacker to exploit an existing buffer noverflow in dynamically-sized local variables in your application nwithout this being detected. This stack-protector failure only applies nto C99-style dynamically-sized local variables or those created using nalloca(). The stack-protector operates as intended for statically-sized nlocal variables.nnThe default behavior when the stack-protector ndetects an overflow is to terminate your application resulting in ncontrolled loss of availability. An attacker who can exploit a buffer noverflow without triggering the stack-protector might be able to change nprogram flow control to cause an uncontrolled loss of availability or ton go further and affect confidentiality or integrity. NOTE: The GCC project argues that this is a missed hardening bug and not a vulnerability by itself.,CVE-2023-4039,tykio/tyk-plugin-compiler
libpam-modules,MEDIUM,1.4.0-9+deb11u1,,A vulnerability was found in PAM. The secret information is stored in memory where the attacker can trigger the victim program to execute by sending characters to its standard input (stdin). As this occurs the attacker can train the branch predictor to execute an ROP chain speculatively. This flaw could result in leaked passwords such as those found in /etc/shadow while performing authentications.,CVE-2024-10041,tykio/gromit & tykio/tyk-plugin-compiler
libpam-modules,MEDIUM,1.4.0-9+deb11u1,,linux-pam (aka Linux PAM) before 1.6.0 allows attackers to cause a denial of service (blocked login process) via mkfifo because the openat call (for protect_dir) lacks O_DIRECTORY.,CVE-2024-22365,tykio/gromit & tykio/tyk-plugin-compiler
libpam-modules-bin,MEDIUM,1.4.0-9+deb11u1,,A vulnerability was found in PAM. The secret information is stored in memory where the attacker can trigger the victim program to execute by sending characters to its standard input (stdin). As this occurs the attacker can train the branch predictor to execute an ROP chain speculatively. This flaw could result in leaked passwords such as those found in /etc/shadow while performing authentications.,CVE-2024-10041,tykio/gromit & tykio/tyk-plugin-compiler
libpam-modules-bin,MEDIUM,1.4.0-9+deb11u1,,linux-pam (aka Linux PAM) before 1.6.0 allows attackers to cause a denial of service (blocked login process) via mkfifo because the openat call (for protect_dir) lacks O_DIRECTORY.,CVE-2024-22365,tykio/gromit & tykio/tyk-plugin-compiler
libpam-runtime,MEDIUM,1.4.0-9+deb11u1,,A vulnerability was found in PAM. The secret information is stored in memory where the attacker can trigger the victim program to execute by sending characters to its standard input (stdin). As this occurs the attacker can train the branch predictor to execute an ROP chain speculatively. This flaw could result in leaked passwords such as those found in /etc/shadow while performing authentications.,CVE-2024-10041,tykio/gromit & tykio/tyk-plugin-compiler
libpam-runtime,MEDIUM,1.4.0-9+deb11u1,,linux-pam (aka Linux PAM) before 1.6.0 allows attackers to cause a denial of service (blocked login process) via mkfifo because the openat call (for protect_dir) lacks O_DIRECTORY.,CVE-2024-22365,tykio/gromit & tykio/tyk-plugin-compiler
libpam0g,MEDIUM,1.4.0-9+deb11u1,,A vulnerability was found in PAM. The secret information is stored in memory where the attacker can trigger the victim program to execute by sending characters to its standard input (stdin). As this occurs the attacker can train the branch predictor to execute an ROP chain speculatively. This flaw could result in leaked passwords such as those found in /etc/shadow while performing authentications.,CVE-2024-10041,tykio/gromit & tykio/tyk-plugin-compiler
libpam0g,MEDIUM,1.4.0-9+deb11u1,,linux-pam (aka Linux PAM) before 1.6.0 allows attackers to cause a denial of service (blocked login process) via mkfifo because the openat call (for protect_dir) lacks O_DIRECTORY.,CVE-2024-22365,tykio/gromit & tykio/tyk-plugin-compiler
libpcre2-8-0,LOW,10.36-2+deb11u1,,Integer overflow vulnerability in pcre2test before 10.41 allows attackers to cause a denial of service or other unspecified impacts via negative input.,CVE-2022-41409,tykio/tyk-plugin-compiler
libpcre3,LOW,2:8.39-13,,In PCRE 8.41 the OP_KETRMAX feature in the match function in pcre_exec.c allows stack exhaustion (uncontrolled recursion) when processing a crafted regular expression.,CVE-2017-11164,tykio/tyk-plugin-compiler
libpcre3,LOW,2:8.39-13,,In PCRE 8.41 after compiling a pcretest load test PoC produces a crash overflow in the function match() in pcre_exec.c because of a self-recursive call. NOTE: third parties dispute the relevance of this report noting that there are options that can be used to limit the amount of stack that is used,CVE-2017-16231,tykio/tyk-plugin-compiler
libpcre3,LOW,2:8.39-13,,Stack-based buffer overflow in the pcre32_copy_substring function in pcre_get.c in libpcre1 in PCRE 8.40 allows remote attackers to cause a denial of service (WRITE of size 4) or possibly have unspecified other impact via a crafted file.,CVE-2017-7245,tykio/tyk-plugin-compiler
libpcre3,LOW,2:8.39-13,,Stack-based buffer overflow in the pcre32_copy_substring function in pcre_get.c in libpcre1 in PCRE 8.40 allows remote attackers to cause a denial of service (WRITE of size 268) or possibly have unspecified other impact via a crafted file.,CVE-2017-7246,tykio/tyk-plugin-compiler
libpcre3,LOW,2:8.39-13,,libpcre in PCRE before 8.43 allows a subject buffer over-read in JIT when UTF is disabled and X or R has more than one fixed quantifier a related issue to CVE-2019-20454.,CVE-2019-20838,tykio/tyk-plugin-compiler
libperl5.32,LOW,5.32.1-4+deb11u4,,_is_safe in the File::Temp module for Perl does not properly handle symlinks.,CVE-2011-4116,tykio/tyk-plugin-compiler
libperl5.32,LOW,5.32.1-4+deb11u4,,HTTP::Tiny before 0.083 a Perl core module since 5.13.9 and available standalone on CPAN has an insecure default TLS configuration where users must opt in to verify certificates.,CVE-2023-31486,tykio/tyk-plugin-compiler
libperl5.36,LOW,5.36.0-7+deb12u1,,_is_safe in the File::Temp module for Perl does not properly handle symlinks.,CVE-2011-4116,tykio/gromit
libperl5.36,HIGH,5.36.0-7+deb12u1,,CPAN.pm before 2.35 does not verify TLS certificates when downloading distributions over HTTPS.,CVE-2023-31484,tykio/gromit
libperl5.36,LOW,5.36.0-7+deb12u1,,HTTP::Tiny before 0.083 a Perl core module since 5.13.9 and available standalone on CPAN has an insecure default TLS configuration where users must opt in to verify certificates.,CVE-2023-31486,tykio/gromit
libperl5.36,HIGH,5.36.0-7+deb12u1,5.36.0-7+deb12u2,A heap buffer overflow vulnerability was discovered in Perl. nnRelease branches 5.34 5.36 5.38 and 5.40 are affected including development versions from 5.33.1 through 5.41.10.nnWhen there are non-ASCII bytes in the left-hand-side of the `tr` operator `S_do_trans_invmap` can overflow the destination pointer `d`.nn $ perl -e '$_ = x{FF} x 1000000; tr/xFF/x{100}/;' n Segmentation fault (core dumped)nnIt is believed that this vulnerability can enable Denial of Service and possibly Code Execution attacks on platforms that lack sufficient defenses.,CVE-2024-56406,tykio/gromit
libprocps8,LOW,2:3.3.17-5,,Under some circumstances this weakness allows a user who has access to run the ps utility on a machine the ability to write almost unlimited amounts of unfiltered data into the process heap.,CVE-2023-4016,tykio/tyk-plugin-compiler
libquadmath0,LOW,10.2.1-6,,**DISPUTED**A failure in the -fstack-protector feature in GCC-based toolchains nthat target AArch64 allows an attacker to exploit an existing buffer noverflow in dynamically-sized local variables in your application nwithout this being detected. This stack-protector failure only applies nto C99-style dynamically-sized local variables or those created using nalloca(). The stack-protector operates as intended for statically-sized nlocal variables.nnThe default behavior when the stack-protector ndetects an overflow is to terminate your application resulting in ncontrolled loss of availability. An attacker who can exploit a buffer noverflow without triggering the stack-protector might be able to change nprogram flow control to cause an uncontrolled loss of availability or ton go further and affect confidentiality or integrity. NOTE: The GCC project argues that this is a missed hardening bug and not a vulnerability by itself.,CVE-2023-4039,tykio/tyk-plugin-compiler
libsmartcols1,LOW,2.36.1-8+deb11u2,,A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an INPUTRC environment variable to get a path to the library config file. When the library cannot parse the specified file it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.,CVE-2022-0563,tykio/gromit & tykio/tyk-plugin-compiler
libssl-dev,MEDIUM,1.1.1w-0+deb11u2,,Issue summary: A timing side-channel which could potentially allow recoveringnthe private key exists in the ECDSA signature computation.nnImpact summary: A timing side-channel in ECDSA signature computationsncould allow recovering the private key by an attacker. However measuringnthe timing would require either local access to the signing application orna very fast network connection with low latency.nnThere is a timing signal of around 300 nanoseconds when the top word ofnthe inverted ECDSA nonce value is zero. This can happen with significantnprobability only for some of the supported elliptic curves. In particularnthe NIST P-521 curve is affected. To be able to measure this leak the attackernprocess must either be located in the same physical computer or mustnhave a very fast network connection with low latency. For that reasonnthe severity of this vulnerability is Low.nnThe FIPS modules in 3.4 3.3 3.2 3.1 and 3.0 are affected by this issue.,CVE-2024-13176,tykio/tyk-plugin-compiler
libssl1.1,MEDIUM,1.1.1w-0+deb11u2,,Issue summary: A timing side-channel which could potentially allow recoveringnthe private key exists in the ECDSA signature computation.nnImpact summary: A timing side-channel in ECDSA signature computationsncould allow recovering the private key by an attacker. However measuringnthe timing would require either local access to the signing application orna very fast network connection with low latency.nnThere is a timing signal of around 300 nanoseconds when the top word ofnthe inverted ECDSA nonce value is zero. This can happen with significantnprobability only for some of the supported elliptic curves. In particularnthe NIST P-521 curve is affected. To be able to measure this leak the attackernprocess must either be located in the same physical computer or mustnhave a very fast network connection with low latency. For that reasonnthe severity of this vulnerability is Low.nnThe FIPS modules in 3.4 3.3 3.2 3.1 and 3.0 are affected by this issue.,CVE-2024-13176,tykio/tyk-plugin-compiler
libssl3,MEDIUM,3.0.15-1~deb12u1,,Issue summary: A timing side-channel which could potentially allow recoveringnthe private key exists in the ECDSA signature computation.nnImpact summary: A timing side-channel in ECDSA signature computationsncould allow recovering the private key by an attacker. However measuringnthe timing would require either local access to the signing application orna very fast network connection with low latency.nnThere is a timing signal of around 300 nanoseconds when the top word ofnthe inverted ECDSA nonce value is zero. This can happen with significantnprobability only for some of the supported elliptic curves. In particularnthe NIST P-521 curve is affected. To be able to measure this leak the attackernprocess must either be located in the same physical computer or mustnhave a very fast network connection with low latency. For that reasonnthe severity of this vulnerability is Low.nnThe FIPS modules in 3.4 3.3 3.2 3.1 and 3.0 are affected by this issue.,CVE-2024-13176,tykio/gromit & tykio/tyk-dashboard & tykio/tyk-gateway
libstdc++-10-dev,LOW,10.2.1-6,,**DISPUTED**A failure in the -fstack-protector feature in GCC-based toolchains nthat target AArch64 allows an attacker to exploit an existing buffer noverflow in dynamically-sized local variables in your application nwithout this being detected. This stack-protector failure only applies nto C99-style dynamically-sized local variables or those created using nalloca(). The stack-protector operates as intended for statically-sized nlocal variables.nnThe default behavior when the stack-protector ndetects an overflow is to terminate your application resulting in ncontrolled loss of availability. An attacker who can exploit a buffer noverflow without triggering the stack-protector might be able to change nprogram flow control to cause an uncontrolled loss of availability or ton go further and affect confidentiality or integrity. NOTE: The GCC project argues that this is a missed hardening bug and not a vulnerability by itself.,CVE-2023-4039,tykio/tyk-plugin-compiler
libstdc++6,LOW,12.2.0-14,,libiberty/rust-demangle.c in GNU GCC 11.2 allows stack consumption in demangle_const as demonstrated by nm-new.,CVE-2022-27943,tykio/gromit
libstdc++6,LOW,10.2.1-6,,**DISPUTED**A failure in the -fstack-protector feature in GCC-based toolchains nthat target AArch64 allows an attacker to exploit an existing buffer noverflow in dynamically-sized local variables in your application nwithout this being detected. This stack-protector failure only applies nto C99-style dynamically-sized local variables or those created using nalloca(). The stack-protector operates as intended for statically-sized nlocal variables.nnThe default behavior when the stack-protector ndetects an overflow is to terminate your application resulting in ncontrolled loss of availability. An attacker who can exploit a buffer noverflow without triggering the stack-protector might be able to change nprogram flow control to cause an uncontrolled loss of availability or ton go further and affect confidentiality or integrity. NOTE: The GCC project argues that this is a missed hardening bug and not a vulnerability by itself.,CVE-2023-4039,tykio/gromit & tykio/tyk-plugin-compiler
libsystemd0,LOW,247.3-7+deb11u6,,systemd when updating file permissions allows local users to change the permissions and SELinux security contexts for arbitrary files via a symlink attack on unspecified files.,CVE-2013-4392,tykio/gromit & tykio/tyk-plugin-compiler
libsystemd0,LOW,247.3-7+deb11u6,,An exploitable denial-of-service vulnerability exists in Systemd 245. A specially crafted DHCP FORCERENEW packet can cause a server running the DHCP client to be vulnerable to a DHCP ACK spoofing attack. An attacker can forge a pair of FORCERENEW and DCHP ACK packets to reconfigure the server.,CVE-2020-13529,tykio/tyk-plugin-compiler
libsystemd0,LOW,247.3-7+deb11u6,,An issue was discovered in systemd 253. An attacker can modify a sealed log file such that in some views not all existing and sealed log messages are displayed. NOTE: the vendor reportedly sent a reply denying that any of the finding was a security vulnerability.,CVE-2023-31437,tykio/gromit & tykio/tyk-plugin-compiler
libsystemd0,LOW,247.3-7+deb11u6,,An issue was discovered in systemd 253. An attacker can truncate a sealed log file and then resume log sealing such that checking the integrity shows no error despite modifications. NOTE: the vendor reportedly sent a reply denying that any of the finding was a security vulnerability.,CVE-2023-31438,tykio/gromit & tykio/tyk-plugin-compiler
libsystemd0,LOW,247.3-7+deb11u6,,An issue was discovered in systemd 253. An attacker can modify the contents of past events in a sealed log file and then adjust the file such that checking the integrity shows no error despite modifications. NOTE: the vendor reportedly sent a reply denying that any of the finding was a security vulnerability.,CVE-2023-31439,tykio/gromit & tykio/tyk-plugin-compiler
libtasn1-6,MEDIUM,4.19.0-2,4.19.0-2+deb12u1,A flaw in libtasn1 causes inefficient handling of specific certificate data. When processing a large number of elements in a certificate libtasn1 takes much longer than expected which can slow down or even crash the system. This flaw allows an attacker to send a specially crafted certificate causing a denial of service attack.,CVE-2024-12133,tykio/gromit
libtinfo6,MEDIUM,6.2+20201114-2+deb11u2,,NCurse v6.4-20230418 was discovered to contain a segmentation fault via the component _nc_wrap_entry().,CVE-2023-50495,tykio/gromit & tykio/tyk-plugin-compiler
libtsan0,LOW,10.2.1-6,,**DISPUTED**A failure in the -fstack-protector feature in GCC-based toolchains nthat target AArch64 allows an attacker to exploit an existing buffer noverflow in dynamically-sized local variables in your application nwithout this being detected. This stack-protector failure only applies nto C99-style dynamically-sized local variables or those created using nalloca(). The stack-protector operates as intended for statically-sized nlocal variables.nnThe default behavior when the stack-protector ndetects an overflow is to terminate your application resulting in ncontrolled loss of availability. An attacker who can exploit a buffer noverflow without triggering the stack-protector might be able to change nprogram flow control to cause an uncontrolled loss of availability or ton go further and affect confidentiality or integrity. NOTE: The GCC project argues that this is a missed hardening bug and not a vulnerability by itself.,CVE-2023-4039,tykio/tyk-plugin-compiler
libubsan1,LOW,10.2.1-6,,**DISPUTED**A failure in the -fstack-protector feature in GCC-based toolchains nthat target AArch64 allows an attacker to exploit an existing buffer noverflow in dynamically-sized local variables in your application nwithout this being detected. This stack-protector failure only applies nto C99-style dynamically-sized local variables or those created using nalloca(). The stack-protector operates as intended for statically-sized nlocal variables.nnThe default behavior when the stack-protector ndetects an overflow is to terminate your application resulting in ncontrolled loss of availability. An attacker who can exploit a buffer noverflow without triggering the stack-protector might be able to change nprogram flow control to cause an uncontrolled loss of availability or ton go further and affect confidentiality or integrity. NOTE: The GCC project argues that this is a missed hardening bug and not a vulnerability by itself.,CVE-2023-4039,tykio/tyk-plugin-compiler
libudev1,LOW,247.3-7+deb11u6,,systemd when updating file permissions allows local users to change the permissions and SELinux security contexts for arbitrary files via a symlink attack on unspecified files.,CVE-2013-4392,tykio/gromit & tykio/tyk-plugin-compiler
libudev1,LOW,247.3-7+deb11u6,,An exploitable denial-of-service vulnerability exists in Systemd 245. A specially crafted DHCP FORCERENEW packet can cause a server running the DHCP client to be vulnerable to a DHCP ACK spoofing attack. An attacker can forge a pair of FORCERENEW and DCHP ACK packets to reconfigure the server.,CVE-2020-13529,tykio/tyk-plugin-compiler
libudev1,LOW,247.3-7+deb11u6,,An issue was discovered in systemd 253. An attacker can modify a sealed log file such that in some views not all existing and sealed log messages are displayed. NOTE: the vendor reportedly sent a reply denying that any of the finding was a security vulnerability.,CVE-2023-31437,tykio/gromit & tykio/tyk-plugin-compiler
libudev1,LOW,247.3-7+deb11u6,,An issue was discovered in systemd 253. An attacker can truncate a sealed log file and then resume log sealing such that checking the integrity shows no error despite modifications. NOTE: the vendor reportedly sent a reply denying that any of the finding was a security vulnerability.,CVE-2023-31438,tykio/gromit & tykio/tyk-plugin-compiler
libudev1,LOW,247.3-7+deb11u6,,An issue was discovered in systemd 253. An attacker can modify the contents of past events in a sealed log file and then adjust the file such that checking the integrity shows no error despite modifications. NOTE: the vendor reportedly sent a reply denying that any of the finding was a security vulnerability.,CVE-2023-31439,tykio/gromit & tykio/tyk-plugin-compiler
libuuid1,LOW,2.36.1-8+deb11u2,,A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an INPUTRC environment variable to get a path to the library config file. When the library cannot parse the specified file it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.,CVE-2022-0563,tykio/gromit & tykio/tyk-plugin-compiler
libxml2,LOW,2.9.10+dfsg-6.7+deb11u6,,An issue was discovered in xmllint (from libxml2) before 2.11.8 and 2.12.x before 2.12.7. Formatting error messages with xmllint --htmlout can result in a buffer over-read in xmlHTMLPrintFileContext in xmllint.c.,CVE-2024-34459,tykio/tyk-plugin-compiler
libxml2,HIGH,2.9.10+dfsg-6.7+deb11u6,2.9.10+dfsg-6.7+deb11u7,In libxml2 before 2.13.8 and 2.14.x before 2.14.2 out-of-bounds memory access can occur in the Python API (Python bindings) because of an incorrect return value. This occurs in xmlPythonFileRead and xmlPythonFileReadRaw because of a difference between bytes and characters.,CVE-2025-32414,tykio/tyk-plugin-compiler
libxml2,HIGH,2.9.10+dfsg-6.7+deb11u6,2.9.10+dfsg-6.7+deb11u7,In libxml2 before 2.13.8 and 2.14.x before 2.14.2 xmlSchemaIDCFillNodeTables in xmlschemas.c has a heap-based buffer under-read. To exploit this a crafted XML document must be validated against an XML schema with certain identity constraints or a crafted XML schema must be used.,CVE-2025-32415,tykio/tyk-plugin-compiler
libxml2-dev,LOW,2.9.10+dfsg-6.7+deb11u6,,An issue was discovered in xmllint (from libxml2) before 2.11.8 and 2.12.x before 2.12.7. Formatting error messages with xmllint --htmlout can result in a buffer over-read in xmlHTMLPrintFileContext in xmllint.c.,CVE-2024-34459,tykio/tyk-plugin-compiler
libxml2-dev,HIGH,2.9.10+dfsg-6.7+deb11u6,2.9.10+dfsg-6.7+deb11u7,In libxml2 before 2.13.8 and 2.14.x before 2.14.2 out-of-bounds memory access can occur in the Python API (Python bindings) because of an incorrect return value. This occurs in xmlPythonFileRead and xmlPythonFileReadRaw because of a difference between bytes and characters.,CVE-2025-32414,tykio/tyk-plugin-compiler
libxml2-dev,HIGH,2.9.10+dfsg-6.7+deb11u6,2.9.10+dfsg-6.7+deb11u7,In libxml2 before 2.13.8 and 2.14.x before 2.14.2 xmlSchemaIDCFillNodeTables in xmlschemas.c has a heap-based buffer under-read. To exploit this a crafted XML document must be validated against an XML schema with certain identity constraints or a crafted XML schema must be used.,CVE-2025-32415,tykio/tyk-plugin-compiler
libzstd1,HIGH,1.4.8+dfsg-2.1,,A vulnerability was found in zstd v1.4.10 where an attacker can supply empty string as an argument to the command line tool to cause buffer overrun.,CVE-2022-4899,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,TCP when using a large Window Size makes it easier for remote attackers to guess sequence numbers and cause a denial of service (connection loss) to persistent TCP connections by repeatedly injecting a TCP RST packet especially in protocols that use long-lived connections such as BGP.,CVE-2004-0230,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,Linux kernel 2.4 and 2.6 allows attackers to cause a denial of service (memory exhaustion and panic) by creating a large number of connected file descriptors or socketpairs and setting a large data transfer buffer then preventing Linux from being able to finish the transfer by causing the process to become a zombie or closing the file descriptor without closing an associated reference.,CVE-2005-3660,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,The process scheduler in the Linux kernel 2.6.16 gives preference to interactive processes that perform voluntary sleeps which allows local users to cause a denial of service (CPU consumption) as described in Secretly Monopolizing the CPU Without Superuser Privileges.,CVE-2007-3719,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,Mounting /proc filesystem via chroot command silently mounts it in read-write mode. The user could bypass the chroot environment and gain write access to files he would never have otherwise.,CVE-2008-2544,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,The TCP implementation in (1) Linux (2) platforms based on BSD Unix (3) Microsoft Windows (4) Cisco products and probably other operating systems allows remote attackers to cause a denial of service (connection queue exhaustion) via multiple vectors that manipulate information in the TCP state table as demonstrated by sockstress.,CVE-2008-4609,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,The Linux kernel when using IPv6 allows remote attackers to determine whether a host is sniffing the network by sending an ICMPv6 Echo Request to a multicast address and determining whether an Echo Reply is sent as demonstrated by thcping.,CVE-2010-4563,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,Memory leak in drivers/media/video/videobuf-core.c in the videobuf subsystem in the Linux kernel 2.6.x through 4.x allows local users to cause a denial of service (memory consumption) by leveraging /dev/video access for a series of mmap calls that require new allocations a different vulnerability than CVE-2007-6761. NOTE: as of 2016-06-18 this affects only 11 drivers that have not been updated to use videobuf2 instead of videobuf.,CVE-2010-5321,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,fs/proc/base.c in the Linux kernel through 3.1 allows local users to obtain sensitive keystroke information via access to /proc/interrupts.,CVE-2011-4915,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,Linux kernel through 3.1 allows local users to obtain sensitive keystroke information via access to /dev/pts/ and /dev/tty*.,CVE-2011-4916,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,In the Linux kernel through 3.1 there is an information disclosure issue via /proc/stat.,CVE-2011-4917,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,block/scsi_ioctl.c in the Linux kernel through 3.8 does not properly consider the SCSI device class during authorization of SCSI commands which allows local users to bypass intended access restrictions via an SG_IO ioctl call that leverages overlapping opcodes.,CVE-2012-4542,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,The Direct Rendering Manager (DRM) subsystem in the Linux kernel through 4.x mishandles requests for Graphics Execution Manager (GEM) objects which allows context-dependent attackers to cause a denial of service (memory consumption) via an application that processes graphics data as demonstrated by JavaScript code that creates many CANVAS elements for rendering by Chrome or Firefox.,CVE-2013-7445,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,The snd_compr_tstamp function in sound/core/compress_offload.c in the Linux kernel through 4.7 as used in Android before 2016-08-05 on Nexus 5 and 7 (2013) devices does not properly initialize a timestamp data structure which allows attackers to obtain sensitive information via a crafted application aka Android internal bug 28770164 and Qualcomm internal bug CR568717.,CVE-2014-9892,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,The ethtool_get_wol function in net/core/ethtool.c in the Linux kernel through 4.7 as used in Android before 2016-08-05 on Nexus 5 and 7 (2013) devices does not initialize a certain data structure which allows local users to obtain sensitive information via a crafted application aka Android internal bug 28803952 and Qualcomm internal bug CR570754.,CVE-2014-9900,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,Kernel Samepage Merging (KSM) in the Linux kernel 2.6.32 through 4.x does not prevent use of a write-timing side channel which allows guest OS users to defeat the ASLR protection mechanism on other guest OS instances via a Cross-VM ASL INtrospection (CAIN) attack. NOTE: the vendor states Basically if you care about this attack vector disable deduplication. Share-until-written approaches for memory conservation among mutually untrusting tenants are inherently detectable for information disclosure and can be classified as potentially misunderstood behaviors rather than vulnerabilities,CVE-2015-2877,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,An issue was discovered in the Linux kernel through 4.17.2. Since the page allocator does not yield CPU resources to the owner of the oom_lock mutex a local unprivileged user can trivially lock up the system forever by wasting CPU resources from the page allocator (e.g. via concurrent page fault events) when the global OOM killer is invoked. NOTE: the software maintainer has not accepted certain proposed patches in part because of a viewpoint that the underlying problem is non-trivial to handle.,CVE-2016-10723,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,The XFS subsystem in the Linux kernel through 4.8.2 allows local users to cause a denial of service (fdatasync failure and system hang) by using the vfs syscall group in the trinity program related to a page lock order bug in the XFS seek hole/data implementation.,CVE-2016-8660,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,An information disclosure vulnerability in the kernel trace subsystem could enable a local malicious application to access data outside of its permission levels. This issue is rated as Moderate because it first requires compromising a privileged process. Product: Android. Versions: Kernel-3.10 Kernel-3.18. Android ID: A-34277115.,CVE-2017-0630,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,The acpi_ds_create_operands() function in drivers/acpi/acpica/dsutils.c in the Linux kernel through 4.12.9 does not flush the operand cache and causes a kernel stack dump which allows local users to obtain sensitive information from kernel memory and bypass the KASLR protection mechanism (in the kernel through 4.9) via a crafted ACPI table.,CVE-2017-13693,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,The acpi_ps_complete_final_op() function in drivers/acpi/acpica/psobject.c in the Linux kernel through 4.12.9 does not flush the node and node_ext caches and causes a kernel stack dump which allows local users to obtain sensitive information from kernel memory and bypass the KASLR protection mechanism (in the kernel through 4.9) via a crafted ACPI table.,CVE-2017-13694,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,procps-ng procps is vulnerable to a process hiding through race condition. Since the kernel's proc_pid_readdir() returns PID entries in ascending numeric order a process occupying a high PID can use inotify events to determine when the process list is being scanned and fork/exec to obtain a lower PID thus avoiding enumeration. An unprivileged attacker can hide a process from procps-ng's utilities by exploiting a race condition in reading /proc/PID entries. This vulnerability affects procps and procps-ng up to version 3.3.15 newer versions might be affected also.,CVE-2018-1121,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,In the Linux kernel 4.15.0 a NULL pointer dereference was discovered in hfs_ext_read_extent in hfs.ko. This can occur during a mount of a crafted hfs filesystem.,CVE-2018-12928,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,The Linux kernel 4.14.67 mishandles certain interaction among XFRM Netlink messages IPPROTO_AH packets and IPPROTO_IP packets which allows local users to cause a denial of service (memory consumption and system hang) by leveraging root access to execute crafted applications as demonstrated on CentOS 7.,CVE-2018-17977,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,The Linux kernel through 5.0.7 when CONFIG_IA32_AOUT is enabled and ia32_aout is loaded allows local users to bypass ASLR on setuid a.out programs (if any exist) because install_exec_creds() is called too late in load_aout_binary() in fs/binfmt_aout.c and thus the ptrace_may_access() check has a race condition when reading /proc/pid/stat. NOTE: the software maintainer disputes that this is a vulnerability because ASLR for a.out format executables has never been supported,CVE-2019-11191,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,An issue was discovered in ip6_ra_control in net/ipv6/ipv6_sockglue.c in the Linux kernel through 5.1.5. There is an unchecked kmalloc of new_ra which might allow an attacker to cause a denial of service (NULL pointer dereference and system crash). NOTE: This has been disputed as not an issue,CVE-2019-12378,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,An issue was discovered in con_insert_unipair in drivers/tty/vt/consolemap.c in the Linux kernel through 5.1.5. There is a memory leak in a certain case of an ENOMEM outcome of kmalloc. NOTE: This id is disputed as not being an issue,CVE-2019-12379,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,**DISPUTED** An issue was discovered in the efi subsystem in the Linux kernel through 5.1.5. phys_efi_set_virtual_address_map in arch/x86/platform/efi/efi.c and efi_call_phys_prolog in arch/x86/platform/efi/efi_64.c mishandle memory allocation failures. NOTE: This id is disputed as not being an issue because All the code touched by the referenced commit runs only at boot before any user processes are started. Therefore there is no possibility for an unprivileged user to control it..,CVE-2019-12380,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,An issue was discovered in ip_ra_control in net/ipv4/ip_sockglue.c in the Linux kernel through 5.1.5. There is an unchecked kmalloc of new_ra which might allow an attacker to cause a denial of service (NULL pointer dereference and system crash). NOTE: this is disputed because new_ra is never used if it is NULL,CVE-2019-12381,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,An issue was discovered in drm_load_edid_firmware in drivers/gpu/drm/drm_edid_load.c in the Linux kernel through 5.1.5. There is an unchecked kstrdup of fwstr which might allow an attacker to cause a denial of service (NULL pointer dereference and system crash). NOTE: The vendor disputes this issues as not being a vulnerability because kstrdup() returning NULL is handled sufficiently and there is no chance for a NULL pointer dereference,CVE-2019-12382,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,An issue was discovered in sunxi_divs_clk_setup in drivers/clk/sunxi/clk-sunxi.c in the Linux kernel through 5.1.5. There is an unchecked kstrndup of derived_name which might allow an attacker to cause a denial of service (NULL pointer dereference and system crash). NOTE: This id is disputed as not being an issue because The memory allocation that was not checked is part of a code that only runs at boot time before user processes are started. Therefore there is no possibility for an unprivileged user to control it and no denial of service.,CVE-2019-12455,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,An issue was discovered in the MPT3COMMAND case in _ctl_ioctl_main in drivers/scsi/mpt3sas/mpt3sas_ctl.c in the Linux kernel through 5.1.5. It allows local users to cause a denial of service or possibly have unspecified other impact by changing the value of ioc_number between two kernel reads of that value aka a double fetch vulnerability. NOTE: a third party reports that this is unexploitable because the doubly fetched value is not used,CVE-2019-12456,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,An issue was discovered in the Linux kernel before 5.2.3. There is a use-after-free caused by a malicious USB device in the drivers/media/usb/dvb-usb/dvb-usb-init.c driver.,CVE-2019-15213,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,Overlayfs in the Linux kernel and shiftfs a non-upstream patch to the Linux kernel included in the Ubuntu 5.0 and 5.3 kernel series both replace vma->vm_file in their mmap handlers. On error the original value is not restored and the reference is put for the file to which vm_file points. On upstream kernels this is not an issue as no callers dereference vm_file following after call_mmap() returns an error. However the aufs patchs change mmap_region() to replace the fput() using a local variable with vma_fput() which will fput() vm_file leading to a refcount underflow.,CVE-2019-15794,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,An issue was discovered in the Linux kernel through 5.2.13. nbd_genl_status in drivers/block/nbd.c does not check the nla_nest_start_noflag return value.,CVE-2019-16089,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,drivers/gpu/drm/amd/amdkfd/kfd_interrupt.c in the Linux kernel 5.2.14 does not check the alloc_workqueue return value leading to a NULL pointer dereference. NOTE: The security community disputes this issues as not being serious enough to be deserving a CVE id,CVE-2019-16229,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,drivers/gpu/drm/radeon/radeon_display.c in the Linux kernel 5.2.14 does not check the alloc_workqueue return value leading to a NULL pointer dereference. NOTE: A third-party software maintainer states that the work queue allocation is happening during device initialization which for a graphics card occurs during boot. It is not attacker controllable and OOM at that time is highly unlikely,CVE-2019-16230,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,drivers/net/fjes/fjes_main.c in the Linux kernel 5.2.14 does not check the alloc_workqueue return value leading to a NULL pointer dereference.,CVE-2019-16231,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,drivers/net/wireless/marvell/libertas/if_sdio.c in the Linux kernel 5.2.14 does not check the alloc_workqueue return value leading to a NULL pointer dereference.,CVE-2019-16232,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,drivers/scsi/qla2xxx/qla_os.c in the Linux kernel 5.2.14 does not check the alloc_workqueue return value leading to a NULL pointer dereference.,CVE-2019-16233,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,drivers/net/wireless/intel/iwlwifi/pcie/trans.c in the Linux kernel 5.2.14 does not check the alloc_workqueue return value leading to a NULL pointer dereference.,CVE-2019-16234,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,A memory leak in the spi_gpio_probe() function in drivers/spi/spi-gpio.c in the Linux kernel through 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering devm_add_action_or_reset() failures aka CID-d3b0ffa1d75d. NOTE: third parties dispute the relevance of this because the system must have already been out of memory before the probe began,CVE-2019-19070,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,In the Linux kernel 5.0.21 mounting a crafted btrfs filesystem image can lead to slab-out-of-bounds write access in index_rbio_pages in fs/btrfs/raid56.c.,CVE-2019-19378,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel 5.0.21 mounting a crafted f2fs filesystem image can lead to slab-out-of-bounds read access in f2fs_build_segment_manager in fs/f2fs/segment.c related to init_min_max_mtime in fs/f2fs/segment.c (because the second argument to get_seg_entry is not validated).,CVE-2019-19449,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel 5.0.21 mounting a crafted f2fs filesystem image can cause __remove_dirty_segment slab-out-of-bounds write access because an array is bounded by the number of dirty types (8) but the array index can exceed this.,CVE-2019-19814,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,An issue was discovered in the Linux kernel 4.18 through 5.6.11 when unprivileged user namespaces are allowed. A user can create their own PID namespace and mount a FUSE filesystem. Upon interaction with this FUSE filesystem if the userspace component is terminated via a kill of the PID namespace's pid 1 it will result in a hung task and resources being permanently locked up until system reboot. This can result in resource exhaustion.,CVE-2019-20794,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,snd_ctl_elem_add in sound/core/control.c in the Linux kernel through 5.6.3 has a count=info->owner line which later affects a private_size*count multiplication for unspecified interesting side effects. NOTE: kernel engineers dispute this finding because it could be relevant only if new callers were added that were unfamiliar with the misuse of the info->owner field to represent data unrelated to the owner concept. The existing callers SNDRV_CTL_IOCTL_ELEM_ADD and SNDRV_CTL_IOCTL_ELEM_REPLACE have been designed to misuse the info->owner field in a safe way,CVE-2020-11725,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,Integer overflow in the firmware for some Intel(R) Graphics Drivers for Windows output.log scan_tyk_dockerimages.sh vulnerabilities.csv before version 26.20.100.7212 and before Linux kernel version 5.5 may allow a privileged user to potentially enable an escalation of privilege via local access.,CVE-2020-12362,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,Improper input validation in some Intel(R) Graphics Drivers for Windows* before version 26.20.100.7212 and before Linux kernel version 5.5 may allow a privileged user to potentially enable a denial of service via local access.,CVE-2020-12363,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,Null pointer reference in some Intel(R) Graphics Drivers for Windows* before version 26.20.100.7212 and before version Linux kernel version 5.5 may allow a privileged user to potentially enable a denial of service via local access.,CVE-2020-12364,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,A memory disclosure flaw was found in the Linux kernel's ethernet drivers in the way it read data from the EEPROM of the device. This flaw allows a local user to read uninitialized values from the kernel memory. The highest threat from this vulnerability is to confidentiality.,CVE-2020-14304,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,Uncontrolled resource consumption in some Intel(R) Ethernet E810 Adapter drivers for Linux before version 1.0.4 may allow an authenticated user to potentially enable denial of service via local access.,CVE-2020-24504,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,A flaw was found in the Linux kernels implementation of audit rules where a syscall can unexpectedly not be correctly not be logged by the audit subsystem,CVE-2020-35501,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,An issue was discovered in netfilter in the Linux kernel before 5.10. There can be a use-after-free in the packet processing context because the per-CPU sequence count is mishandled during concurrent iptables rules replacement. This could be exploited with the CAP_NET_ADMIN capability in an unprivileged namespace. NOTE: cc00bca was reverted in 5.12.,CVE-2020-36694,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,An issue was discovered in the Linux kernel 4.18 through 5.10.16 as used by Xen. The backend allocation (aka be-alloc) mode of the drm_xen_front drivers was not meant to be a supported configuration but this wasn't stated accordingly in its support status entry.,CVE-2021-26934,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,An Out-of-Bounds Read was discovered in arch/arm/mach-footbridge/personal-pci.c in the Linux kernel through 5.12.11 because of the lack of a check for a value that shouldn't be negative e.g. access to element -2 of an array aka CID-298a58e165e4.,CVE-2021-32078,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,Insufficient control flow management for the Intel(R) 82599 Ethernet Controllers and Adapters may allow an authenticated user to potentially enable denial of service via local access.,CVE-2021-33061,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,A flaw was found in the Linux kernels memory deduplication mechanism. Previous work has shown that memory deduplication can be attacked via a local exploitation mechanism. The same technique can be used if an attacker can upload page sized files and detect the change in access time from a networked service to determine if the page has been merged.,CVE-2021-3714,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,An unauthorized access to the execution of the setuid file with capabilities flaw in the Linux kernel OverlayFS subsystem was found in the way user copying a capable file from a nosuid mount into another mount. A local user could use this flaw to escalate their privileges on the system.,CVE-2021-3847,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,A flaw was found in the way the dumpable flag setting was handled when certain SUID binaries executed its descendants. The prerequisite is a SUID binary that sets real UID equal to effective UID and real GID equal to effective GID. The descendant will then have a dumpable value set to 1. As a result if the descendant process crashes and core_pattern is set to a relative value its core dump is stored in the current directory with uid:gid permissions. An unprivileged local user with eligible root SUID binary could use this flaw to place core dumps into root-owned directories potentially resulting in escalation of privileges.,CVE-2021-3864,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In several functions of binder.c there is a possible way to represent the wrong domain to SELinux due to a race condition. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-200688826References: Upstream kernel,CVE-2021-39686,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,A flaw was found in the io-workqueue implementation in the Linux kernel versions prior to 5.15-rc1. The kernel can panic when an improper cancellation operation triggers the submission of new io-uring operations during a shortage of free space. This flaw allows a local user with permissions to execute io-uring requests to possibly crash the system.,CVE-2021-4023,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,A vulnerability was found in btrfs_alloc_tree_b in fs/btrfs/extent-tree.c in the Linux kernel due to an improper lock operation in btrfs. In this flaw a user with a local privilege may cause a denial of service (DOS) due to a deadlock problem.,CVE-2021-4149,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,An out-of-bounds (OOB) memory access flaw was found in the Linux kernel's eBPF due to an Improper Input Validation. This flaw allows a local attacker with a special privilege to crash the system or leak internal information.,CVE-2021-4204,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnALSA: hda: intel-sdw-acpi: harden detection of controllernnThe existing code currently sets a pointer to an ACPI handle beforenchecking that it's actually a SoundWire controller. This can lead tonissues where the graph walk continues and eventually fails but thenpointer was set already.nnThis patch changes the logic so that the information provided tonthe caller is set when a controller is found.,CVE-2021-46926,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnmm/damon/dbgfs: fix 'struct pid' leaks in 'dbgfs_target_ids_write()'nnDAMON debugfs interface increases the reference counts of 'struct pid'snfor targets from the 'target_ids' file write callbackn('dbgfs_target_ids_write()') but decreases the counts only in DAMONnmonitoring termination callback ('dbgfs_before_terminate()').nnTherefore when 'target_ids' file is repeatedly written without DAMONnmonitoring start/termination the reference count is not decreased andntherefore memory for the 'struct pid' cannot be freed. This commitnfixes this issue by decreasing the reference counts when 'target_ids' isnwritten.,CVE-2021-46937,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbtrfs: fix deadlock when cloning inline extents and using qgroupsnnThere are a few exceptional cases where cloning an inline extent needs toncopy the inline extent data into a page of the destination inode.nnWhen this happens we end up starting a transaction while having a dirtynpage for the destination inode and while having the range locked in thendestination's inode iotree too. Because when reserving metadata spacenfor a transaction we may need to flush existing delalloc in case there isnnot enough free space we have a mechanism in place to prevent a deadlocknwhich was introduced in commit 3d45f221ce627d (btrfs: fix deadlock whenncloning inline extent and low on free metadata space).nnHowever when using qgroups a transaction also reserves metadata qgroupnspace which can also result in flushing delalloc in case there is notnenough available space at the moment. When this happens we deadlock sincenflushing delalloc requires locking the file range in the inode's iotreenand the range was already locked at the very beginning of the clonenoperation before attempting to start the transaction.nnWhen this issue happens stack traces like the following are reported:nn [72747.556262] task:kworker/u81:9 state:D stack: 0 pid: 225 ppid: 2 flags:0x00004000n [72747.556268] Workqueue: writeback wb_workfn (flush-btrfs-1142)n [72747.556271] Call Trace:n [72747.556273] __schedule+0x296/0x760n [72747.556277] schedule+0x3c/0xa0n [72747.556279] io_schedule+0x12/0x40n [72747.556284] __lock_page+0x13c/0x280n [72747.556287] ? generic_file_readonly_mmap+0x70/0x70n [72747.556325] extent_write_cache_pages+0x22a/0x440 [btrfs]n [72747.556331] ? __set_page_dirty_nobuffers+0xe7/0x160n [72747.556358] ? set_extent_buffer_dirty+0x5e/0x80 [btrfs]n [72747.556362] ? update_group_capacity+0x25/0x210n [72747.556366] ? cpumask_next_and+0x1a/0x20n [72747.556391] extent_writepages+0x44/0xa0 [btrfs]n [72747.556394] do_writepages+0x41/0xd0n [72747.556398] __writeback_single_inode+0x39/0x2a0n [72747.556403] writeback_sb_inodes+0x1ea/0x440n [72747.556407] __writeback_inodes_wb+0x5f/0xc0n [72747.556410] wb_writeback+0x235/0x2b0n [72747.556414] ? get_nr_inodes+0x35/0x50n [72747.556417] wb_workfn+0x354/0x490n [72747.556420] ? newidle_balance+0x2c5/0x3e0n [72747.556424] process_one_work+0x1aa/0x340n [72747.556426] worker_thread+0x30/0x390n [72747.556429] ? create_worker+0x1a0/0x1a0n [72747.556432] kthread+0x116/0x130n [72747.556435] ? kthread_park+0x80/0x80n [72747.556438] ret_from_fork+0x1f/0x30nn [72747.566958] Workqueue: btrfs-flush_delalloc btrfs_work_helper [btrfs]n [72747.566961] Call Trace:n [72747.566964] __schedule+0x296/0x760n [72747.566968] ? finish_wait+0x80/0x80n [72747.566970] schedule+0x3c/0xa0n [72747.566995] wait_extent_bit.constprop.68+0x13b/0x1c0 [btrfs]n [72747.566999] ? finish_wait+0x80/0x80n [72747.567024] lock_extent_bits+0x37/0x90 [btrfs]n [72747.567047] btrfs_invalidatepage+0x299/0x2c0 [btrfs]n [72747.567051] ? find_get_pages_range_tag+0x2cd/0x380n [72747.567076] __extent_writepage+0x203/0x320 [btrfs]n [72747.567102] extent_write_cache_pages+0x2bb/0x440 [btrfs]n [72747.567106] ? update_load_avg+0x7e/0x5f0n [72747.567109] ? enqueue_entity+0xf4/0x6f0n [72747.567134] extent_writepages+0x44/0xa0 [btrfs]n [72747.567137] ? enqueue_task_fair+0x93/0x6f0n [72747.567140] do_writepages+0x41/0xd0n [72747.567144] __filemap_fdatawrite_range+0xc7/0x100n [72747.567167] btrfs_run_delalloc_work+0x17/0x40 [btrfs]n [72747.567195] btrfs_work_helper+0xc2/0x300 [btrfs]n [72747.567200] process_one_work+0x1aa/0x340n [72747.567202] worker_thread+0x30/0x390n [72747.567205] ? create_worker+0x1a0/0x1a0n [72747.567208] kthread+0x116/0x130n [72747.567211] ? kthread_park+0x80/0x80n [72747.567214] ret_from_fork+0x1f/0x30nn [72747.569686] task:fsstress state:D stack: n---truncated---,CVE-2021-46987,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet/sched: act_ct: fix wild memory access when clearing fragmentsnnwhile testing re-assembly/re-fragmentation using act_ct it's possible tonobserve a crash like the following one:nn KASAN: maybe wild-memory-access in range [0x0001000000000448-0x000100000000044f]n CPU: 50 PID: 0 Comm: swapper/50 Tainted: G S 5.12.0-rc7+ #424n Hardware name: Dell Inc. PowerEdge R730/072T6D BIOS 2.4.3 01/17/2017n RIP: 0010:inet_frag_rbtree_purge+0x50/0xc0n Code: 00 fc ff df 48 89 c3 31 ed 48 89 df e8 a9 7a 38 ff 4c 89 fe 48 89 df 49 89 c6 e8 5b 3a 38 ff 48 8d 7b 40 48 89 f8 48 c1 e8 03 <42> 80 3c 20 00 75 59 48 8d bb d0 00 00 00 4c 8b 6b 40 48 89 f8 48n RSP: 0018:ffff888c31449db8 EFLAGS: 00010203n RAX: 0000200000000089 RBX: 000100000000040e RCX: ffffffff989eb960n RDX: 0000000000000140 RSI: ffffffff97cfb977 RDI: 000100000000044en RBP: 0000000000000900 R08: 0000000000000000 R09: ffffed1186289350n R10: 0000000000000003 R11: ffffed1186289350 R12: dffffc0000000000n R13: 000100000000040e R14: 0000000000000000 R15: ffff888155e02160n FS: 0000000000000000(0000) GS:ffff888c31440000(0000) knlGS:0000000000000000n CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033n CR2: 00005600cb70a5b8 CR3: 0000000a2c014005 CR4: 00000000003706e0n DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000n DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400n Call Trace:n <IRQ>n inet_frag_destroy+0xa9/0x150n call_timer_fn+0x2d/0x180n run_timer_softirq+0x4fe/0xe70n __do_softirq+0x197/0x5a0n irq_exit_rcu+0x1de/0x200n sysvec_apic_timer_interrupt+0x6b/0x80n </IRQ>nnwhen act_ct temporarily stores an IP fragment restoring the skb qdisc cbnresults in putting random data in FRAG_CB() and this causes those wildnmemory accesses later when the rbtree is purged. Never overwrite the skbncb in case tcf_ct_handle_fragments() returns -EINPROGRESS.,CVE-2021-47014,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnmt76: mt7915: fix txrate reportingnnProperly check rate_info to fix unexpected reporting.nn[ 1215.161863] Call trace:n[ 1215.164307] cfg80211_calculate_bitrate+0x124/0x200 [cfg80211]n[ 1215.170139] ieee80211s_update_metric+0x80/0xc0 [mac80211]n[ 1215.175624] ieee80211_tx_status_ext+0x508/0x838 [mac80211]n[ 1215.181190] mt7915_mcu_get_rx_rate+0x28c/0x8d0 [mt7915e]n[ 1215.186580] mt7915_mac_tx_free+0x324/0x7c0 [mt7915e]n[ 1215.191623] mt7915_queue_rx_skb+0xa8/0xd0 [mt7915e]n[ 1215.196582] mt76_dma_cleanup+0x7b0/0x11d0 [mt76]n[ 1215.201276] __napi_poll+0x38/0xf8n[ 1215.204668] napi_workfn+0x40/0x80n[ 1215.208062] process_one_work+0x1fc/0x390n[ 1215.212062] worker_thread+0x48/0x4d0n[ 1215.215715] kthread+0x120/0x128n[ 1215.218935] ret_from_fork+0x10/0x1c,CVE-2021-47028,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnudp: skip L4 aggregation for UDP tunnel packetsnnIf NETIF_F_GRO_FRAGLIST or NETIF_F_GRO_UDP_FWD are enabled and therenare UDP tunnels available in the system udp_gro_receive() could end-upndoing L4 aggregation (either SKB_GSO_UDP_L4 or SKB_GSO_FRAGLIST) atnthe outer UDP tunnel level for packets effectively carrying and UDPntunnel header.nnThat could cause inner protocol corruption. If e.g. the relevantnpackets carry a vxlan header different vxlan ids will be ignored/naggregated to the same GSO packet. Inner headers will be ignored toonso that e.g. TCP over vxlan push packets will be held in the GROnengine till the next flush etc.nnJust skip the SKB_GSO_UDP_L4 and SKB_GSO_FRAGLIST code path if thencurrent packet could land in a UDP tunnel and let udp_gro_receive()ndo GRO via udp_sk(sk)->gro_receive.nnThe check implemented in this patch is broader than what is strictlynneeded as the existing UDP tunnel could be e.g. configured on top ofna different device: we could end-up skipping GRO at-all for some packets.nnAnyhow that is a very thin corner case and covering it will add quitena bit of complexity.nnv1 -> v2:n - hopefully clarify the commit message,CVE-2021-47036,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnASoC: q6afe-clocks: fix reprobing of the drivernnQ6afe-clocks driver can get reprobed. For example if the APR servicesnare restarted after the firmware crash. However currently Q6afe-clocksndriver will oops because hw.init will get cleared during first _probencall. Rewrite the driver to fill the clock data at runtime rather thannusing big static array of clocks.,CVE-2021-47037,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnuio_hv_generic: Fix another memory leak in error handling pathsnnMemory allocated by 'vmbus_alloc_ring()' at the beginning of the probenfunction is never freed in the error handling path.nnAdd the missing 'vmbus_free_ring()' call.nnNote that it is already freed in the .remove function.,CVE-2021-47070,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnRDMA/rxe: Return CQE error if invalid lkey was suppliednnRXE is missing update of WQE status in LOCAL_WRITE failures. This causednthe following kernel panic if someone sent an atomic operation with annexplicitly wrong lkey.nn[leonro@vm ~]$ mkt testntest_atomic_invalid_lkey (tests.test_atomic.AtomicTest) ...n WARNING: CPU: 5 PID: 263 at drivers/infiniband/sw/rxe/rxe_comp.c:740 rxe_completer+0x1a6d/0x2e30 [rdma_rxe]n Modules linked in: crc32_generic rdma_rxe ip6_udp_tunnel udp_tunnel rdma_ucm rdma_cm ib_umad ib_ipoib iw_cm ib_cm mlx5_ib ib_uverbs ib_core mlx5_core ptp pps_coren CPU: 5 PID: 263 Comm: python3 Not tainted 5.13.0-rc1+ #2936n Hardware name: QEMU Standard PC (Q35 + ICH9 2009) BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014n RIP: 0010:rxe_completer+0x1a6d/0x2e30 [rdma_rxe]n Code: 03 0f 8e 65 0e 00 00 3b 93 10 06 00 00 0f 84 82 0a 00 00 4c 89 ff 4c 89 44 24 38 e8 2d 74 a9 e1 4c 8b 44 24 38 e9 1c f5 ff ff <0f> 0b e9 0c e8 ff ff b8 05 00 00 00 41 bf 05 00 00 00 e9 ab e7 ffn RSP: 0018:ffff8880158af090 EFLAGS: 00010246n RAX: 0000000000000000 RBX: ffff888016a78000 RCX: ffffffffa0cf1652n RDX: 1ffff9200004b442 RSI: 0000000000000004 RDI: ffffc9000025a210n RBP: dffffc0000000000 R08: 00000000ffffffea R09: ffff88801617740bn R10: ffffed1002c2ee81 R11: 0000000000000007 R12: ffff88800f3b63e8n R13: ffff888016a78008 R14: ffffc9000025a180 R15: 000000000000000cn FS: 00007f88b622a740(0000) GS:ffff88806d540000(0000) knlGS:0000000000000000n CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033n CR2: 00007f88b5a1fa10 CR3: 000000000d848004 CR4: 0000000000370ea0n DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000n DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400n Call Trace:n rxe_do_task+0x130/0x230 [rdma_rxe]n rxe_rcv+0xb11/0x1df0 [rdma_rxe]n rxe_loopback+0x157/0x1e0 [rdma_rxe]n rxe_responder+0x5532/0x7620 [rdma_rxe]n rxe_do_task+0x130/0x230 [rdma_rxe]n rxe_rcv+0x9c8/0x1df0 [rdma_rxe]n rxe_loopback+0x157/0x1e0 [rdma_rxe]n rxe_requester+0x1efd/0x58c0 [rdma_rxe]n rxe_do_task+0x130/0x230 [rdma_rxe]n rxe_post_send+0x998/0x1860 [rdma_rxe]n ib_uverbs_post_send+0xd5f/0x1220 [ib_uverbs]n ib_uverbs_write+0x847/0xc80 [ib_uverbs]n vfs_write+0x1c5/0x840n ksys_write+0x176/0x1d0n do_syscall_64+0x3f/0x80n entry_SYSCALL_64_after_hwframe+0x44/0xae,CVE-2021-47076,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnKVM: x86/mmu: Don't advance iterator after restart due to yieldingnnAfter dropping mmu_lock in the TDP MMU restart the iterator duringntdp_iter_next() and do not advance the iterator. Advancing the iteratornresults in skipping the top-level SPTE and all its children which isnfatal if any of the skipped SPTEs were not visited before yielding.nnWhen zapping all SPTEs i.e. when min_level == root_level restarting theniter and then invoking tdp_iter_next() is always fatal if the current gfnnhas as a valid SPTE as advancing the iterator results in try_step_side()nskipping the current gfn which wasn't visited before yielding.nnSprinkle WARNs on iter->yielded being true in various helpers that arenoften used in conjunction with yielding and tag the helper withn__must_check to reduce the probabily of improper usage.nnFailing to zap a top-level SPTE manifests in one of two ways. If a validnSPTE is skipped by both kvm_tdp_mmu_zap_all() and kvm_tdp_mmu_put_root()nthe shadow page will be leaked and KVM will WARN accordingly.nn WARNING: CPU: 1 PID: 3509 at arch/x86/kvm/mmu/tdp_mmu.c:46 [kvm]n RIP: 0010:kvm_mmu_uninit_tdp_mmu+0x3e/0x50 [kvm]n Call Trace:n <TASK>n kvm_arch_destroy_vm+0x130/0x1b0 [kvm]n kvm_destroy_vm+0x162/0x2a0 [kvm]n kvm_vcpu_release+0x34/0x60 [kvm]n __fput+0x82/0x240n task_work_run+0x5c/0x90n do_exit+0x364/0xa10n ? futex_unqueue+0x38/0x60n do_group_exit+0x33/0xa0n get_signal+0x155/0x850n arch_do_signal_or_restart+0xed/0x750n exit_to_user_mode_prepare+0xc5/0x120n syscall_exit_to_user_mode+0x1d/0x40n do_syscall_64+0x48/0xc0n entry_SYSCALL_64_after_hwframe+0x44/0xaennIf kvm_tdp_mmu_zap_all() skips a gfn/SPTE but that SPTE is then zapped bynkvm_tdp_mmu_put_root() KVM triggers a use-after-free in the form ofnmarking a struct page as dirty/accessed after it has been put back on thenfree list. This directly triggers a WARN due to encountering a page withnpage_count() == 0 but it can also lead to data corruption and additionalnerrors in the kernel.nn WARNING: CPU: 7 PID: 1995658 at arch/x86/kvm/../../../virt/kvm/kvm_main.c:171n RIP: 0010:kvm_is_zone_device_pfn.part.0+0x9e/0xd0 [kvm]n Call Trace:n <TASK>n kvm_set_pfn_dirty+0x120/0x1d0 [kvm]n __handle_changed_spte+0x92e/0xca0 [kvm]n __handle_changed_spte+0x63c/0xca0 [kvm]n __handle_changed_spte+0x63c/0xca0 [kvm]n __handle_changed_spte+0x63c/0xca0 [kvm]n zap_gfn_range+0x549/0x620 [kvm]n kvm_tdp_mmu_put_root+0x1b6/0x270 [kvm]n mmu_free_root_page+0x219/0x2c0 [kvm]n kvm_mmu_free_roots+0x1b4/0x4e0 [kvm]n kvm_mmu_unload+0x1c/0xa0 [kvm]n kvm_arch_destroy_vm+0x1f2/0x5c0 [kvm]n kvm_put_kvm+0x3b1/0x8b0 [kvm]n kvm_vcpu_release+0x4e/0x70 [kvm]n __fput+0x1f7/0x8c0n task_work_run+0xf8/0x1a0n do_exit+0x97b/0x2230n do_group_exit+0xda/0x2a0n get_signal+0x3be/0x1e50n arch_do_signal_or_restart+0x244/0x17f0n exit_to_user_mode_prepare+0xcb/0x120n syscall_exit_to_user_mode+0x1d/0x40n do_syscall_64+0x4d/0x90n entry_SYSCALL_64_after_hwframe+0x44/0xaennNote the underlying bug existed even before commit 1af4a96025b3 (KVM:nx86/mmu: Yield in TDU MMU iter even if no SPTES changed) moved calls tontdp_mmu_iter_cond_resched() to the beginning of loops as KVM could stillnincorrectly advance past a top-level entry when yielding on a lower-levelnentry. But with respect to leaking shadow pages the bug was introducednby yielding before processing the current gfn.nnAlternatively tdp_mmu_iter_cond_resched() could simply fall through orncallers could jump to their retry label. The downside of that approachnis that tdp_mmu_iter_cond_resched() _must_ be called before anything elsenin the loop and there's no easy way to enfornce that requirement.nnIdeally KVM would handling the cond_resched() fully within the iteratornmacro (the code is actually quite clean) and avoid this entire class ofnbugs but that is extremely difficult do whn---truncated---,CVE-2021-47094,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnasix: fix uninit-value in asix_mdio_read()nnasix_read_cmd() may read less than sizeof(smsr) bytes and in this casensmsr will be uninitialized.nnFail log:nBUG: KMSAN: uninit-value in asix_check_host_enable drivers/net/usb/asix_common.c:82 [inline]nBUG: KMSAN: uninit-value in asix_check_host_enable drivers/net/usb/asix_common.c:82 [inline] drivers/net/usb/asix_common.c:497nBUG: KMSAN: uninit-value in asix_mdio_read+0x3c1/0xb00 drivers/net/usb/asix_common.c:497 drivers/net/usb/asix_common.c:497n asix_check_host_enable drivers/net/usb/asix_common.c:82 [inline]n asix_check_host_enable drivers/net/usb/asix_common.c:82 [inline] drivers/net/usb/asix_common.c:497n asix_mdio_read+0x3c1/0xb00 drivers/net/usb/asix_common.c:497 drivers/net/usb/asix_common.c:497,CVE-2021-47101,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnice: xsk: return xsk buffers back to pool when cleaning the ringnnCurrently we only NULL the xdp_buff pointer in the internal SW ring butnwe never give it back to the xsk buffer pool. This means that buffersncan be leaked out of the buff pool and never be used again.nnAdd missing xsk_buff_free() call to the routine that is supposed tonclean the entries that are left in the ring so that these buffers in thenumem can be used by other sockets.nnAlso only go through the space that is actually left to be cleanedninstead of a whole ring.,CVE-2021-47105,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnscsi: target: core: Avoid smp_processor_id() in preemptible codennThe BUG message BUG: using smp_processor_id() in preemptible [00000000]ncode was observed for TCMU devices with kernel config DEBUG_PREEMPT.nnThe message was observed when blktests block/005 was run on TCMU devicesnwith fileio backend or user:zbc backend [1]. The commit 1130b499b4a7n(scsi: target: tcm_loop: Use LIO wq cmd submission helper) triggered thensymptom. The commit modified work queue to handle commands and changedn'current->nr_cpu_allowed' at smp_processor_id() call.nnThe message was also observed at system shutdown when TCMU devices were notncleaned up [2]. The function smp_processor_id() was called in SCSI hostnwork queue for abort handling and triggered the BUG message. This symptomnwas observed regardless of the commit 1130b499b4a7 (scsi: target:ntcm_loop: Use LIO wq cmd submission helper).nnTo avoid the preemptible code check at smp_processor_id() get CPU ID withnraw_smp_processor_id() instead. The CPU ID is used for performancenimprovement then thread move to other CPU will not affect the code.nn[1]nn[ 56.468103] run blktests block/005 at 2021-05-12 14:16:38n[ 57.369473] check_preemption_disabled: 85 callbacks suppressedn[ 57.369480] BUG: using smp_processor_id() in preemptible [00000000] code: fio/1511n[ 57.369506] BUG: using smp_processor_id() in preemptible [00000000] code: fio/1510n[ 57.369512] BUG: using smp_processor_id() in preemptible [00000000] code: fio/1506n[ 57.369552] caller is __target_init_cmd+0x157/0x170 [target_core_mod]n[ 57.369606] CPU: 4 PID: 1506 Comm: fio Not tainted 5.13.0-rc1+ #34n[ 57.369613] Hardware name: System manufacturer System Product Name/PRIME Z270-A BIOS 1302 03/15/2018n[ 57.369617] Call Trace:n[ 57.369621] BUG: using smp_processor_id() in preemptible [00000000] code: fio/1507n[ 57.369628] dump_stack+0x6d/0x89n[ 57.369642] check_preemption_disabled+0xc8/0xd0n[ 57.369628] caller is __target_init_cmd+0x157/0x170 [target_core_mod]n[ 57.369655] __target_init_cmd+0x157/0x170 [target_core_mod]n[ 57.369695] target_init_cmd+0x76/0x90 [target_core_mod]n[ 57.369732] tcm_loop_queuecommand+0x109/0x210 [tcm_loop]n[ 57.369744] scsi_queue_rq+0x38e/0xc40n[ 57.369761] __blk_mq_try_issue_directly+0x109/0x1c0n[ 57.369779] blk_mq_try_issue_directly+0x43/0x90n[ 57.369790] blk_mq_submit_bio+0x4e5/0x5d0n[ 57.369812] submit_bio_noacct+0x46e/0x4e0n[ 57.369830] __blkdev_direct_IO_simple+0x1a3/0x2d0n[ 57.369859] ? set_init_blocksize.isra.0+0x60/0x60n[ 57.369880] generic_file_read_iter+0x89/0x160n[ 57.369898] blkdev_read_iter+0x44/0x60n[ 57.369906] new_sync_read+0x102/0x170n[ 57.369929] vfs_read+0xd4/0x160n[ 57.369941] __x64_sys_pread64+0x6e/0xa0n[ 57.369946] ? lockdep_hardirqs_on+0x79/0x100n[ 57.369958] do_syscall_64+0x3a/0x70n[ 57.369965] entry_SYSCALL_64_after_hwframe+0x44/0xaen[ 57.369973] RIP: 0033:0x7f7ed4c1399fn[ 57.369979] Code: 08 89 3c 24 48 89 4c 24 18 e8 7d f3 ff ff 4c 8b 54 24 18 48 8b 54 24 10 41 89 c0 48 8b 74 24 08 8b 3c 24 b8 11 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 31 44 89 c7 48 89 04 24 e8 cd f3 ff ff 48 8bn[ 57.369983] RSP: 002b:00007ffd7918c580 EFLAGS: 00000293 ORIG_RAX: 0000000000000011n[ 57.369990] RAX: ffffffffffffffda RBX: 00000000015b4540 RCX: 00007f7ed4c1399fn[ 57.369993] RDX: 0000000000001000 RSI: 00000000015de000 RDI: 0000000000000009n[ 57.369996] RBP: 00000000015b4540 R08: 0000000000000000 R09: 0000000000000001n[ 57.369999] R10: 0000000000e5c000 R11: 0000000000000293 R12: 00007f7eb5269a70n[ 57.370002] R13: 0000000000000000 R14: 0000000000001000 R15: 00000000015b4568n[ 57.370031] CPU: 7 PID: 1507 Comm: fio Not tainted 5.13.0-rc1+ #34n[ 57.370036] Hardware name: System manufacturer System Product Name/PRIME Z270-A BIOS 1302 03/15/2018n[ 57.370039] Call Trace:n[ 57.370045] dump_stack+0x6d/0x89n[ 57.370056] chn---truncated---,CVE-2021-47178,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnscsi: core: Fix scsi_mode_sense() buffer length handlingnnSeveral problems exist with scsi_mode_sense() buffer length handling:nn 1) The allocation length field of the MODE SENSE(10) command is 16-bitsn occupying bytes 7 and 8 of the CDB. With this command access to moden pages larger than 255 bytes is thus possible. However the CDBn allocation length field is set by assigning len to byte 8 only thusn truncating buffer length larger than 255.nn 2) If scsi_mode_sense() is called with len smaller than 8 withn sdev->use_10_for_ms set or smaller than 4 otherwise the buffer lengthn is increased to 8 and 4 respectively and the buffer is zero filledn with these increased values thus corrupting the memory following then buffer.nnFix these 2 problems by using put_unaligned_be16() to set the allocationnlength field of MODE SENSE(10) CDB and by returning an error when len isntoo small.nnFurthermore if len is larger than 255B always try MODE SENSE(10) firstneven if the device driver did not set sdev->use_10_for_ms. In case ofninvalid opcode error for MODE SENSE(10) access to mode pages larger thann255 bytes are not retried using MODE SENSE(6). To avoid buffer lengthnoverflows for the MODE_SENSE(10) case check that len is smaller than 65535nbytes.nnWhile at it also fix the folowing:nn output.log scan_tyk_dockerimages.sh vulnerabilities.csv Use get_unaligned_be16() to retrieve the mode data length and blockn descriptor length fields of the mode sense reply header instead of usingn an open coded calculation.nn output.log scan_tyk_dockerimages.sh vulnerabilities.csv Fix the kdoc dbd argument explanation: the DBD bit stands for Disablen Block Descriptor which is the opposite of what the dbd argumentn description was.,CVE-2021-47182,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnscsi: lpfc: Fix link down processing to address NULL pointer dereferencennIf an FC link down transition while PLOGIs are outstanding to fabric wellnknown addresses outstanding ABTS requests may result in a NULL pointerndereference. Driver unload requests may hang with repeated 2878 lognmessages.nnThe Link down processing results in ABTS requests for outstanding ELSnrequests. The Abort WQEs are sent for the ELSs before the driver had setnthe link state to down. Thus the driver is sending the Abort with thenexpectation that an ABTS will be sent on the wire. The Abort request isnstalled waiting for the link to come up. In some conditions the driver maynauto-complete the ELSs thus if the link does come up the Abort completionsnmay reference an invalid structure.nnFix by ensuring that Abort set the flag to avoid link traffic if issued duento conditions where the link failed.,CVE-2021-47183,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnscsi: ufs: core: Improve SCSI abort handlingnnThe following has been observed on a test setup:nnWARNING: CPU: 4 PID: 250 at drivers/scsi/ufs/ufshcd.c:2737 ufshcd_queuecommand+0x468/0x65cnCall trace:n ufshcd_queuecommand+0x468/0x65cn scsi_send_eh_cmnd+0x224/0x6a0n scsi_eh_test_devices+0x248/0x418n scsi_eh_ready_devs+0xc34/0xe58n scsi_error_handler+0x204/0x80cn kthread+0x150/0x1b4n ret_from_fork+0x10/0x30nnThat warning is triggered by the following statement:nntWARN_ON(lrbp->cmd);nnFix this warning by clearing lrbp->cmd from the abort handler.,CVE-2021-47188,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnscsi: pm80xx: Fix memory leak during rmmodnnDriver failed to release all memory allocated. This would lead to memorynleak during driver removal.nnProperly free memory when the module is removed.,CVE-2021-47193,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnscsi: lpfc: Fix use-after-free in lpfc_unreg_rpi() routinennAn error is detected with the following report when unloading the driver:n KASAN: use-after-free in lpfc_unreg_rpi+0x1b1bnnThe NLP_REG_LOGIN_SEND nlp_flag is set in lpfc_reg_fab_ctrl_node() but thenflag is not cleared upon completion of the login.nnThis allows a second call to lpfc_unreg_rpi() to proceed with nlp_rpi setnto LPFC_RPI_ALLOW_ERROR. This results in a use after free access when usednas an rpi_ids array index.nnFix by clearing the NLP_REG_LOGIN_SEND nlp_flag innlpfc_mbx_cmpl_fc_reg_login().,CVE-2021-47198,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet/mlx5e: CT Fix multiple allocations and memleak of mod actsnnCT clear action offload adds additional mod hdr actions to thenflow's original mod actions in order to clear the registers whichnhold ct_state.nWhen such flow also includes encap action a neigh update eventncan cause the driver to unoffload the flow and then reoffload it.nnEach time this happens the ct clear handling adds that same setnof mod hdr actions to reset ct_state until the max of mod hdrnactions is reached.nnAlso the driver never releases the allocated mod hdr actions andncausing a memleak.nnFix above two issues by moving CT clear mod acts allocationninto the parsing actions phase and only use it when offloading the rule.nThe release of mod acts will be done in the normal flow_put().nn backtrace:n [<000000007316e2f3>] krealloc+0x83/0xd0n [<00000000ef157de1>] mlx5e_mod_hdr_alloc+0x147/0x300 [mlx5_core]n [<00000000970ce4ae>] mlx5e_tc_match_to_reg_set_and_get_id+0xd7/0x240 [mlx5_core]n [<0000000067c5fa17>] mlx5e_tc_match_to_reg_set+0xa/0x20 [mlx5_core]n [<00000000d032eb98>] mlx5_tc_ct_entry_set_registers.isra.0+0x36/0xc0 [mlx5_core]n [<00000000fd23b869>] mlx5_tc_ct_flow_offload+0x272/0x1f10 [mlx5_core]n [<000000004fc24acc>] mlx5e_tc_offload_fdb_rules.part.0+0x150/0x620 [mlx5_core]n [<00000000dc741c17>] mlx5e_tc_encap_flows_add+0x489/0x690 [mlx5_core]n [<00000000e92e49d7>] mlx5e_rep_update_flows+0x6e4/0x9b0 [mlx5_core]n [<00000000f60f5602>] mlx5e_rep_neigh_update+0x39a/0x5d0 [mlx5_core],CVE-2021-47199,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/prime: Fix use after free in mmap with drm_gem_ttm_mmapnndrm_gem_ttm_mmap() drops a reference to the gem object on success. Ifnthe gem object's refcount == 1 on entry to drm_gem_prime_mmap() thatndrop will free the gem object and the subsequent drm_gem_object_get()nwill be a UAF. Fix by grabbing a reference before calling the mmapnhelper.nnThis issue was forseen when the reference dropping was adding inncommit 9786b65bc61ac (drm/ttm: fix mmap refcounting):n For that to work properly the drm_gem_object_get() call inn drm_gem_ttm_mmap() must be moved so it happens before callingn obj->funcs->mmap() otherwise the gem refcount would go downn to zero.,CVE-2021-47200,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnclk: sunxi-ng: Unregister clocks/resets when unbindingnnCurrently unbinding a CCU driver unmaps the device's MMIO region whilenleaving its clocks/resets and their providers registered. This can causena page fault later when some clock operation tries to perform MMIO. Fixnthis by separating the CCU initialization from the memory allocationnand then using a devres callback to unregister the clocks and resets.nnThis also fixes a memory leak of the `struct ccu_reset` and uses thencorrect owner (the specific platform driver) for the clocks and resets.nnEarly OF clock providers are never unregistered and limited errornhandling is possible so they are mostly unchanged. The error reportingnis made more consistent by moving the message inside of_sunxi_ccu_probe.,CVE-2021-47205,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnALSA: usb-audio: fix null pointer dereference on pointer cs_descnnThe pointer cs_desc return from snd_usb_find_clock_source couldnbe null so there is a potential null pointer dereference issue.nFix this by adding a null check before dereference.,CVE-2021-47211,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet/mlx5: Update error handler for UCTX and UMEMnnIn the fast unload flow the device state is set to internal errornwhich indicates that the driver started the destroy process.nIn this case when a destroy command is being executed it should returnnMLX5_CMD_STAT_OK.nFix MLX5_CMD_OP_DESTROY_UCTX and MLX5_CMD_OP_DESTROY_UMEM to return OKninstead of EIO.nnThis fixes a call trace in the umem release process -n[ 2633.536695] Call Trace:n[ 2633.537518] ib_uverbs_remove_one+0xc3/0x140 [ib_uverbs]n[ 2633.538596] remove_client_context+0x8b/0xd0 [ib_core]n[ 2633.539641] disable_device+0x8c/0x130 [ib_core]n[ 2633.540615] __ib_unregister_device+0x35/0xa0 [ib_core]n[ 2633.541640] ib_unregister_device+0x21/0x30 [ib_core]n[ 2633.542663] __mlx5_ib_remove+0x38/0x90 [mlx5_ib]n[ 2633.543640] auxiliary_bus_remove+0x1e/0x30 [auxiliary]n[ 2633.544661] device_release_driver_internal+0x103/0x1f0n[ 2633.545679] bus_remove_device+0xf7/0x170n[ 2633.546640] device_del+0x181/0x410n[ 2633.547606] mlx5_rescan_drivers_locked.part.10+0x63/0x160 [mlx5_core]n[ 2633.548777] mlx5_unregister_device+0x27/0x40 [mlx5_core]n[ 2633.549841] mlx5_uninit_one+0x21/0xc0 [mlx5_core]n[ 2633.550864] remove_one+0x69/0xe0 [mlx5_core]n[ 2633.551819] pci_device_remove+0x3b/0xc0n[ 2633.552731] device_release_driver_internal+0x103/0x1f0n[ 2633.553746] unbind_store+0xf6/0x130n[ 2633.554657] kernfs_fop_write+0x116/0x190n[ 2633.555567] vfs_write+0xa5/0x1a0n[ 2633.556407] ksys_write+0x4f/0xb0n[ 2633.557233] do_syscall_64+0x5b/0x1a0n[ 2633.558071] entry_SYSCALL_64_after_hwframe+0x65/0xcan[ 2633.559018] RIP: 0033:0x7f9977132648n[ 2633.559821] Code: 89 02 48 c7 c0 ff ff ff ff eb b3 0f 1f 80 00 00 00 00 f3 0f 1e fa 48 8d 05 55 6f 2d 00 8b 00 85 c0 75 17 b8 01 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 58 c3 0f 1f 80 00 00 00 00 41 54 49 89 d4 55n[ 2633.562332] RSP: 002b:00007fffb1a83888 EFLAGS: 00000246 ORIG_RAX: 0000000000000001n[ 2633.563472] RAX: ffffffffffffffda RBX: 000000000000000c RCX: 00007f9977132648n[ 2633.564541] RDX: 000000000000000c RSI: 000055b90546e230 RDI: 0000000000000001n[ 2633.565596] RBP: 000055b90546e230 R08: 00007f9977406860 R09: 00007f9977a54740n[ 2633.566653] R10: 0000000000000000 R11: 0000000000000246 R12: 00007f99774056e0n[ 2633.567692] R13: 000000000000000c R14: 00007f9977400880 R15: 000000000000000cn[ 2633.568725] ---[ end trace 10b4fe52945e544d ]---,CVE-2021-47212,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet/mlx5e: Fix use-after-free of encap entry in neigh update handlernnFunction mlx5e_rep_neigh_update() wasn't updated to accommodate rtnl locknremoval from TC filter update path and properly handle concurrent encapnentry insertion/deletion which can lead to following use-after-free:nn [23827.464923] ==================================================================n [23827.469446] BUG: KASAN: use-after-free in mlx5e_encap_take+0x72/0x140 [mlx5_core]n [23827.470971] Read of size 4 at addr ffff8881d132228c by task kworker/u20:6/21635n [23827.472251]n [23827.472615] CPU: 9 PID: 21635 Comm: kworker/u20:6 Not tainted 5.13.0-rc3+ #5n [23827.473788] Hardware name: QEMU Standard PC (Q35 + ICH9 2009) BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014n [23827.475639] Workqueue: mlx5e mlx5e_rep_neigh_update [mlx5_core]n [23827.476731] Call Trace:n [23827.477260] dump_stack+0xbb/0x107n [23827.477906] print_address_description.constprop.0+0x18/0x140n [23827.478896] ? mlx5e_encap_take+0x72/0x140 [mlx5_core]n [23827.479879] ? mlx5e_encap_take+0x72/0x140 [mlx5_core]n [23827.480905] kasan_report.cold+0x7c/0xd8n [23827.481701] ? mlx5e_encap_take+0x72/0x140 [mlx5_core]n [23827.482744] kasan_check_range+0x145/0x1a0n [23827.493112] mlx5e_encap_take+0x72/0x140 [mlx5_core]n [23827.494054] ? mlx5e_tc_tun_encap_info_equal_generic+0x140/0x140 [mlx5_core]n [23827.495296] mlx5e_rep_neigh_update+0x41e/0x5e0 [mlx5_core]n [23827.496338] ? mlx5e_rep_neigh_entry_release+0xb80/0xb80 [mlx5_core]n [23827.497486] ? read_word_at_a_time+0xe/0x20n [23827.498250] ? strscpy+0xa0/0x2a0n [23827.498889] process_one_work+0x8ac/0x14e0n [23827.499638] ? lockdep_hardirqs_on_prepare+0x400/0x400n [23827.500537] ? pwq_dec_nr_in_flight+0x2c0/0x2c0n [23827.501359] ? rwlock_bug.part.0+0x90/0x90n [23827.502116] worker_thread+0x53b/0x1220n [23827.502831] ? process_one_work+0x14e0/0x14e0n [23827.503627] kthread+0x328/0x3f0n [23827.504254] ? _raw_spin_unlock_irq+0x24/0x40n [23827.505065] ? __kthread_bind_mask+0x90/0x90n [23827.505912] ret_from_fork+0x1f/0x30n [23827.506621]n [23827.506987] Allocated by task 28248:n [23827.507694] kasan_save_stack+0x1b/0x40n [23827.508476] __kasan_kmalloc+0x7c/0x90n [23827.509197] mlx5e_attach_encap+0xde1/0x1d40 [mlx5_core]n [23827.510194] mlx5e_tc_add_fdb_flow+0x397/0xc40 [mlx5_core]n [23827.511218] __mlx5e_add_fdb_flow+0x519/0xb30 [mlx5_core]n [23827.512234] mlx5e_configure_flower+0x191c/0x4870 [mlx5_core]n [23827.513298] tc_setup_cb_add+0x1d5/0x420n [23827.514023] fl_hw_replace_filter+0x382/0x6a0 [cls_flower]n [23827.514975] fl_change+0x2ceb/0x4a51 [cls_flower]n [23827.515821] tc_new_tfilter+0x89a/0x2070n [23827.516548] rtnetlink_rcv_msg+0x644/0x8c0n [23827.517300] netlink_rcv_skb+0x11d/0x340n [23827.518021] netlink_unicast+0x42b/0x700n [23827.518742] netlink_sendmsg+0x743/0xc20n [23827.519467] sock_sendmsg+0xb2/0xe0n [23827.520131] ____sys_sendmsg+0x590/0x770n [23827.520851] ___sys_sendmsg+0xd8/0x160n [23827.521552] __sys_sendmsg+0xb7/0x140n [23827.522238] do_syscall_64+0x3a/0x70n [23827.522907] entry_SYSCALL_64_after_hwframe+0x44/0xaen [23827.523797]n [23827.524163] Freed by task 25948:n [23827.524780] kasan_save_stack+0x1b/0x40n [23827.525488] kasan_set_track+0x1c/0x30n [23827.526187] kasan_set_free_info+0x20/0x30n [23827.526968] __kasan_slab_free+0xed/0x130n [23827.527709] slab_free_freelist_hook+0xcf/0x1d0n [23827.528528] kmem_cache_free_bulk+0x33a/0x6e0n [23827.529317] kfree_rcu_work+0x55f/0xb70n [23827.530024] process_one_work+0x8ac/0x14e0n [23827.530770] worker_thread+0x53b/0x1220n [23827.531480] kthread+0x328/0x3f0n [23827.532114] ret_from_fork+0x1f/0x30n [23827.532785]n [23827.533147] Last potentially related work creation:n [23827.534007] kasan_save_stack+0x1b/0x40n [23827.534710] kasan_record_aux_stack+0xab/0xc0n [23827.535492] kvfree_call_rcu+0x31/0x7b0n [23827.536206] mlx5e_tc_deln---truncated---,CVE-2021-47247,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnRDMA: Verify port when creating flow rulennValidate port value provided by the user and with that remove no longernneeded validation by the driver. The missing check in the mlx5_ib driverncould cause to the below oops.nnCall trace:n _create_flow_rule+0x2d4/0xf28 [mlx5_ib]n mlx5_ib_create_flow+0x2d0/0x5b0 [mlx5_ib]n ib_uverbs_ex_create_flow+0x4cc/0x624 [ib_uverbs]n ib_uverbs_handler_UVERBS_METHOD_INVOKE_WRITE+0xd4/0x150 [ib_uverbs]n ib_uverbs_cmd_verbs.isra.7+0xb28/0xc50 [ib_uverbs]n ib_uverbs_ioctl+0x158/0x1d0 [ib_uverbs]n do_vfs_ioctl+0xd0/0xaf0n ksys_ioctl+0x84/0xb4n __arm64_sys_ioctl+0x28/0xc4n el0_svc_common.constprop.3+0xa4/0x254n el0_svc_handler+0x84/0xa0n el0_svc+0x10/0x26cn Code: b9401260 f9615681 51000400 8b001c20 (f9403c1a),CVE-2021-47265,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbcache: avoid oversized read request in cache missing code pathnnIn the cache missing code path of cached device if a proper locationnfrom the internal B+ tree is matched for a cache miss range functionncached_dev_cache_miss() will be called in cache_lookup_fn() in thenfollowing code blockn[code block 1]n 526 unsigned int sectors = KEY_INODE(k) == s->iop.inoden 527 ? min_t(uint64_t INT_MAXn 528 KEY_START(k) - bio->bi_iter.bi_sector)n 529 : INT_MAX;n 530 int ret = s->d->cache_miss(b s bio sectors);nnHere s->d->cache_miss() is the call backfunction pointer initialized asncached_dev_cache_miss() the last parameter 'sectors' is an importantnhint to calculate the size of read request to backing device of thenmissing cache data.nnCurrent calculation in above code block may generate oversized value ofn'sectors' which consequently may trigger 2 different potential kernelnpanics by BUG() or BUG_ON() as listed belownn1) BUG_ON() inside bch_btree_insert_key()n[code block 2]n 886 BUG_ON(b->ops->is_extents && !KEY_SIZE(k));n2) BUG() inside biovec_slab()n[code block 3]n 51 default:n 52 BUG();n 53 return NULL;nnAll the above panics are original from cached_dev_cache_miss() by thenoversized parameter 'sectors'.nnInside cached_dev_cache_miss() parameter 'sectors' is used to calculatenthe size of data read from backing device for the cache missing. Thisnsize is stored in s->insert_bio_sectors by the following lines of coden[code block 4]n 909 s->insert_bio_sectors = min(sectors bio_sectors(bio) + reada);nnThen the actual key inserting to the internal B+ tree is generated andnstored in s->iop.replace_key by the following lines of coden[code block 5]n 911 s->iop.replace_key = KEY(s->iop.inoden 912 bio->bi_iter.bi_sector + s->insert_bio_sectorsn 913 s->insert_bio_sectors);nThe oversized parameter 'sectors' may trigger panic 1) by BUG_ON() fromnthe above code block.nnAnd the bio sending to backing device for the missing data is allocatednwith hint from s->insert_bio_sectors by the following lines of coden[code block 6]n 926 cache_bio = bio_alloc_bioset(GFP_NOWAITn 927 DIV_ROUND_UP(s->insert_bio_sectors PAGE_SECTORS)n 928 &dc->disk.bio_split);nThe oversized parameter 'sectors' may trigger panic 2) by BUG() from thenagove code block.nnNow let me explain how the panics happen with the oversized 'sectors'.nIn code block 5 replace_key is generated by macro KEY(). From thendefinition of macro KEY()n[code block 7]n 71 #define KEY(inode offset size) n 72 ((struct bkey) { n 73 .high = (1ULL << 63) | ((__u64) (size) << 20) | (inode) n 74 .low = (offset) n 75 })nnHere 'size' is 16bits width embedded in 64bits member 'high' of structnbkey. But in code block 1 if KEY_START(k) - bio->bi_iter.bi_sector isnvery probably to be larger than (1<<16) - 1 which makes the bkey sizencalculation in code block 5 is overflowed. In one bug report the valuenof parameter 'sectors' is 131072 (= 1 << 17) the overflowed 'sectors'nresults the overflowed s->insert_bio_sectors in code block 4 then makesnsize field of s->iop.replace_key to be 0 in code block 5. Then the 0-nsized s->iop.replace_key is inserted into the internal B+ tree as cachenmissing check key (a special key to detect and avoid a racing betweennnormal write request and cache missing read request) asn[code block 8]n 915 ret = bch_btree_insert_check_key(b &s->op &s->iop.replace_key);nnThen the 0-sized s->iop.replace_key as 3rd parameter triggers the bkeynsize check BUG_ON() in code block 2 and causes the kernel panic 1).nnAnother ken---truncated---,CVE-2021-47275,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnmedia: v4l2-core: explicitly clear ioctl input datannAs seen from a recent syzbot bug report mistakes in the compat ioctlnimplementation can lead to uninitialized kernel stack data getting usednas input for driver ioctl handlers.nnThe reported bug is now fixed but it's possible that other relatednbugs are still present or get added in the future. As the drivers neednto check user input already the possible impact is fairly low but itnmight still cause an information leak.nnTo be on the safe side always clear the entire ioctl buffer beforencalling the conversion handler functions that are meant to initializenthem.,CVE-2021-47339,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nncifs: Fix soft lockup during fsstressnnBelow traces are observed during fsstress and system got hung.n[ 130.698396] watchdog: BUG: soft lockup - CPU#6 stuck for 26s!,CVE-2021-47359,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnafs: Fix corruption in reads at fpos 2G-4G from an OpenAFS servernnAFS-3 has two data fetch RPC variants FS.FetchData and FS.FetchData64 andnLinux's afs client switches between them when talking to a non-YFS servernif the read size the file position or the sum of the two have the upper 32nbits set of the 64-bit value.nnThis is a problem however since the file position and length fields ofnFS.FetchData are *signed* 32-bit values.nnFix this by capturing the capability bits obtained from the fileserver whennit's sent an FS.GetCapabilities RPC rather than just discarding them andnthen picking out the VICED_CAPABILITY_64BITFILES flag. This can then benused to decide whether to use FS.FetchData or FS.FetchData64 - and alsonFS.StoreData or FS.StoreData64 - rather than using upper_32_bits() tonswitch on the parameter values.nnThis capabilities flag could also be used to limit the maximum size of thenfile but all servers must be checked for that.nnNote that the issue does not exist with FS.StoreData - that uses *unsigned*n32-bit values. It's also not a problem with Auristor servers as itsnYFS.FetchData64 op uses unsigned 64-bit values.nnThis can be tested by cloning a git repo through an OpenAFS client to annOpenAFS server and then doing git status on it from a Linux afsnclient[1]. Provided the clone has a pack file that's in the 2G-4G rangenthe git status will show errors like:nnterror: packfile .git/objects/pack/pack-5e813c51d12b6847bbc0fcd97c2bca66da50079c.pack does not match indexnterror: packfile .git/objects/pack/pack-5e813c51d12b6847bbc0fcd97c2bca66da50079c.pack does not match indexnnThis can be observed in the server's FileLog with something like thenfollowing appearing:nnSun Aug 29 19:31:39 2021 SRXAFS_FetchData Fid = 2303380852.491776.3263114 Host 192.168.11.201:7001 Id 1001nSun Aug 29 19:31:39 2021 CheckRights: len=0 for host=192.168.11.201:7001nSun Aug 29 19:31:39 2021 FetchData_RXStyle: Pos 18446744071815340032 Len 3154nSun Aug 29 19:31:39 2021 FetchData_RXStyle: file size 2400758866n...nSun Aug 29 19:31:40 2021 SRXAFS_FetchData returns 5nnNote the file position of 18446744071815340032. This is the requested filenposition sign-extended.,CVE-2021-47366,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndma-debug: prevent an error message from causing runtime problemsnnFor some drivers that use the DMA API. This error message can be reachednseveral millions of times per second causing spam to the kernel's printknbuffer and bringing the CPU usage up to 100% (so it should be ratenlimited). However since there is at least one driver that is in thenmainline and suffers from the error condition it is more useful tonerr_printk() here instead of just rate limiting the error message (in hopesnthat it will make it easier for other drivers that suffer from this issuento be spotted).,CVE-2021-47374,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnASoC: SOF: Fix DSP oops stack dump output contentsnnFix @buf arg given to hex_dump_to_buffer() and stack address usednin dump error output.,CVE-2021-47381,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nns390/qeth: fix deadlock during failing recoverynnCommit 0b9902c1fcc5 (s390/qeth: fix deadlock during recovery) removedntaking discipline_mutex inside qeth_do_reset() fixing potentialndeadlocks. An error path was missed though that still takesndiscipline_mutex and thus has the original deadlock potential.nnIntermittent deadlocks were seen when a qeth channel path is configurednoffline causing a race between qeth_do_reset and ccwgroup_remove.nCall qeth_set_offline() directly in the qeth_do_reset() error case andnthen a new variant of ccwgroup_set_offline() without takingndiscipline_mutex.,CVE-2021-47382,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amdkfd: fix svm_migrate_fini warningnnDevice manager releases device-specific resources when a driverndisconnects from a device devm_memunmap_pages andndevm_release_mem_region calls in svm_migrate_fini are redundant.nnIt causes below warning trace after patch drm/amdgpu: Splitnamdgpu_device_fini into early and late so remove functionnsvm_migrate_fini.nnBUG: https://gitlab.freedesktop.org/drm/amd/-/issues/1718nnWARNING: CPU: 1 PID: 3646 at drivers/base/devres.c:795ndevm_release_action+0x51/0x60nCall Trace:n ? memunmap_pages+0x360/0x360n svm_migrate_fini+0x2d/0x60 [amdgpu]n kgd2kfd_device_exit+0x23/0xa0 [amdgpu]n amdgpu_amdkfd_device_fini_sw+0x1d/0x30 [amdgpu]n amdgpu_device_fini_sw+0x45/0x290 [amdgpu]n amdgpu_driver_release_kms+0x12/0x30 [amdgpu]n drm_dev_release+0x20/0x40 [drm]n release_nodes+0x196/0x1e0n device_release_driver_internal+0x104/0x1d0n driver_detach+0x47/0x90n bus_remove_driver+0x7a/0xd0n pci_unregister_driver+0x3d/0x90n amdgpu_exit+0x11/0x20 [amdgpu],CVE-2021-47410,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnblock: don't call rq_qos_ops->done_bio if the bio isn't trackednnrq_qos framework is only applied on request based driver so:nn1) rq_qos_done_bio() needn't to be called for bio based drivernn2) rq_qos_done_bio() needn't to be called for bio which isn't trackednsuch as bios ended from error handling code.nnEspecially in bio_endio():nn1) request queue is referred via bio->bi_bdev->bd_disk->queue whichnmay be gone since request queue refcount may not be held in above twoncasesnn2) q->rq_qos may be freed in blk_cleanup_queue() when calling inton__rq_qos_done_bio()nnFix the potential kernel panic by not calling rq_qos_ops->done_bio ifnthe bio isn't tracked. This way is safe because both ioc_rqos_done_bio()nand blkcg_iolatency_done_bio() are nop if the bio isn't tracked.,CVE-2021-47412,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amdgpu: handle the case of pci_channel_io_frozen only in amdgpu_pci_resumennIn current code when a PCI error state pci_channel_io_normal is detectdnit will report PCI_ERS_RESULT_CAN_RECOVER status to PCI driver and PCIndriver will continue the execution of PCI resume callback report_resume bynpci_walk_bridge and the callback will go into amdgpu_pci_resumenfinally where write lock is releasd unconditionally without acquiringnsuch lock first. In this case a deadlock will happen when other threadsnstart to acquire the read lock.nnTo fix this add a member in amdgpu_device strucutre to cachenpci_channel_state and only continue the execution in amdgpu_pci_resumenwhen it's pci_channel_io_frozen.,CVE-2021-47421,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnlib/generic-radix-tree.c: Don't overflow in peek()nnWhen we started spreading new inode numbers throughout most of the 64nbit inode space that triggered some corner case bugs in particularnsome integer overflows related to the radix tree code. Oops.,CVE-2021-47432,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnmptcp: fix possible stall on recvmsg()nnrecvmsg() can enter an infinite loop if the caller provides thenMSG_WAITALL the data present in the receive queue is not sufficient tonfulfill the request and no more data is received by the peer.nnWhen the above happens mptcp_wait_data() will always return withnno wait as the MPTCP_DATA_READY flag checked by such function isnset and never cleared in such code path.nnLeveraging the above syzbot was able to trigger an RCU stall:nnrcu: INFO: rcu_preempt self-detected stall on CPUnrcu: 0-...!: (10499 ticks this GP) idle=0af/1/0x4000000000000000 softirq=10678/10678 fqs=1n (t=10500 jiffies g=13089 q=109)nrcu: rcu_preempt kthread starved for 10497 jiffies! g13089 f0x0 RCU_GP_WAIT_FQS(5) ->state=0x0 ->cpu=1nrcu: Unless rcu_preempt kthread gets sufficient CPU time OOM is now expected behavior.nrcu: RCU grace-period kthread stack dump:ntask:rcu_preempt state:R running task stack:28696 pid: 14 ppid: 2 flags:0x00004000nCall Trace:n context_switch kernel/sched/core.c:4955 [inline]n __schedule+0x940/0x26f0 kernel/sched/core.c:6236n schedule+0xd3/0x270 kernel/sched/core.c:6315n schedule_timeout+0x14a/0x2a0 kernel/time/timer.c:1881n rcu_gp_fqs_loop+0x186/0x810 kernel/rcu/tree.c:1955n rcu_gp_kthread+0x1de/0x320 kernel/rcu/tree.c:2128n kthread+0x405/0x4f0 kernel/kthread.c:327n ret_from_fork+0x1f/0x30 arch/x86/entry/entry_64.S:295nrcu: Stack dump where RCU GP kthread last ran:nSending NMI from CPU 0 to CPUs 1:nNMI backtrace for cpu 1nCPU: 1 PID: 8510 Comm: syz-executor827 Not tainted 5.15.0-rc2-next-20210920-syzkaller #0nHardware name: Google Google Compute Engine/Google Compute Engine BIOS Google 01/01/2011nRIP: 0010:bytes_is_nonzero mm/kasan/generic.c:84 [inline]nRIP: 0010:memory_is_nonzero mm/kasan/generic.c:102 [inline]nRIP: 0010:memory_is_poisoned_n mm/kasan/generic.c:128 [inline]nRIP: 0010:memory_is_poisoned mm/kasan/generic.c:159 [inline]nRIP: 0010:check_region_inline mm/kasan/generic.c:180 [inline]nRIP: 0010:kasan_check_range+0xc8/0x180 mm/kasan/generic.c:189nCode: 38 00 74 ed 48 8d 50 08 eb 09 48 83 c0 01 48 39 d0 74 7a 80 38 00 74 f2 48 89 c2 b8 01 00 00 00 48 85 d2 75 56 5b 5d 41 5c c3 <48> 85 d2 74 5e 48 01 ea eb 09 48 83 c0 01 48 39 d0 74 50 80 38 00nRSP: 0018:ffffc9000cd676c8 EFLAGS: 00000283nRAX: ffffed100e9a110e RBX: ffffed100e9a110f RCX: ffffffff88ea062anRDX: 0000000000000001 RSI: 0000000000000008 RDI: ffff888074d08870nRBP: ffffed100e9a110e R08: 0000000000000001 R09: ffff888074d08877nR10: ffffed100e9a110e R11: 0000000000000000 R12: ffff888074d08000nR13: ffff888074d08000 R14: ffff888074d08088 R15: ffff888074d08000nFS: 0000555556d8e300(0000) GS:ffff8880b9d00000(0000) knlGS:0000000000000000nS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033nCR2: 0000000020000180 CR3: 0000000068909000 CR4: 00000000001506e0nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400nCall Trace:n instrument_atomic_read_write include/linux/instrumented.h:101 [inline]n test_and_clear_bit include/asm-generic/bitops/instrumented-atomic.h:83 [inline]n mptcp_release_cb+0x14a/0x210 net/mptcp/protocol.c:3016n release_sock+0xb4/0x1b0 net/core/sock.c:3204n mptcp_wait_data net/mptcp/protocol.c:1770 [inline]n mptcp_recvmsg+0xfd1/0x27b0 net/mptcp/protocol.c:2080n inet6_recvmsg+0x11b/0x5e0 net/ipv6/af_inet6.c:659n sock_recvmsg_nosec net/socket.c:944 [inline]n ____sys_recvmsg+0x527/0x600 net/socket.c:2626n ___sys_recvmsg+0x127/0x200 net/socket.c:2670n do_recvmmsg+0x24d/0x6d0 net/socket.c:2764n __sys_recvmmsg net/socket.c:2843 [inline]n __do_sys_recvmmsg net/socket.c:2866 [inline]n __se_sys_recvmmsg net/socket.c:2859 [inline]n __x64_sys_recvmmsg+0x20b/0x260 net/socket.c:2859n do_syscall_x64 arch/x86/entry/common.c:50 [inline]n do_syscall_64+0x35/0xb0 arch/x86/entry/common.c:80n entry_SYSCALL_64_after_hwframe+0x44/0xaenRIP: 0033:0x7fc200d2n---truncated---,CVE-2021-47448,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnetfilter: nf_tables: skip netdev events generated on netns removalnnsyzbot reported following (harmless) WARN:nn WARNING: CPU: 1 PID: 2648 at net/netfilter/core.c:468n nft_netdev_unregister_hooks net/netfilter/nf_tables_api.c:230 [inline]n nf_tables_unregister_hook include/net/netfilter/nf_tables.h:1090 [inline]n __nft_release_basechain+0x138/0x640 net/netfilter/nf_tables_api.c:9524n nft_netdev_event net/netfilter/nft_chain_filter.c:351 [inline]n nf_tables_netdev_event+0x521/0x8a0 net/netfilter/nft_chain_filter.c:382nnreproducer:nunshare -n bash -c 'ip link add br0 type bridge; nft add table netdev t ; n nft add chain netdev t ingress { type filter hook ingress device br0 n priority 0; policy drop; }'nnProblem is that when netns device exit hooks create the UNREGISTERnevent the .pre_exit hook for nf_tables core has already removed thenbase hook. Notifier attempts to do this again.nnThe need to do base hook unregister unconditionally was needed in the pastnbecause notifier was last stage where reg->dev dereference was safe.nnNow that nf_tables does the hook removal in .pre_exit this isn'tnneeded anymore.,CVE-2021-47452,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnptp: Fix possible memory leak in ptp_clock_register()nnI got memory leak as follows when doing fault injection test:nnunreferenced object 0xffff88800906c618 (size 8):n comm i2c-idt82p33931 pid 4421 jiffies 4294948083 (age 13.188s)n hex dump (first 8 bytes):n 70 74 70 30 00 00 00 00 ptp0....n backtrace:n [<00000000312ed458>] __kmalloc_track_caller+0x19f/0x3a0n [<0000000079f6e2ff>] kvasprintf+0xb5/0x150n [<0000000026aae54f>] kvasprintf_const+0x60/0x190n [<00000000f323a5f7>] kobject_set_name_vargs+0x56/0x150n [<000000004e35abdd>] dev_set_name+0xc0/0x100n [<00000000f20cfe25>] ptp_clock_register+0x9f4/0xd30 [ptp]n [<000000008bb9f0de>] idt82p33_probe.cold+0x8b6/0x1561 [ptp_idt82p33]nnWhen posix_clock_register() returns an error the name allocatednin dev_set_name() will be leaked the put_device() should be usednto give up the device reference then the name will be freed innkobject_cleanup() and other memory will be freed in ptp_clock_release().,CVE-2021-47455,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnocteontx2-af: Fix possible null pointer dereference.nnThis patch fixes possible null pointer dereference in filesnrvu_debugfs.c and rvu_nix.c,CVE-2021-47484,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amdgpu: Fix even more out of bound writes from debugfsnnCVE-2021-42327 was fixed by:nncommit f23750b5b3d98653b31d4469592935ef6364ad67nAuthor: Thelford Williams <tdwilliamsiv@gmail.com>nDate: Wed Oct 13 16:04:13 2021 -0400nn drm/amdgpu: fix out of bounds writennbut amdgpu_dm_debugfs.c contains more of the same issue so fix thenremaining ones.nnv2:nt* Add missing fix in dp_max_bpc_write (Harry Wentland),CVE-2021-47489,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndm rq: don't queue request to blk-mq during DM suspendnnDM uses blk-mq's quiesce/unquiesce to stop/start device mapper queue.nnBut blk-mq's unquiesce may come from outside events such as elevatornswitch updating nr_requests or others and request may come duringnsuspend so simply ask for blk-mq to requeue it.nnFixes one kernel panic issue when running updating nr_requests andndm-mpath suspend/resume stress test.,CVE-2021-47498,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnio_uring: ensure task_work gets run as part of cancelationsnnIf we successfully cancel a work item but that work item needs to benprocessed through task_work then we can be sleeping uninterruptiblynin io_uring_cancel_generic() and never process it. Hence we don'tnmake forward progress and we end up with an uninterruptible sleepnwarning.nnWhile in there correct a comment that should be IFF not IIF.,CVE-2021-47504,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbtrfs: free exchange changeset on failuresnnFstests runs on my VMs have show several kmemleak reports like the following.nn unreferenced object 0xffff88811ae59080 (size 64):n comm xfs_io pid 12124 jiffies 4294987392 (age 6.368s)n hex dump (first 32 bytes):n 00 c0 1c 00 00 00 00 00 ff cf 1c 00 00 00 00 00 ................n 90 97 e5 1a 81 88 ff ff 90 97 e5 1a 81 88 ff ff ................n backtrace:n [<00000000ac0176d2>] ulist_add_merge+0x60/0x150 [btrfs]n [<0000000076e9f312>] set_state_bits+0x86/0xc0 [btrfs]n [<0000000014fe73d6>] set_extent_bit+0x270/0x690 [btrfs]n [<000000004f675208>] set_record_extent_bits+0x19/0x20 [btrfs]n [<00000000b96137b1>] qgroup_reserve_data+0x274/0x310 [btrfs]n [<0000000057e9dcbb>] btrfs_check_data_free_space+0x5c/0xa0 [btrfs]n [<0000000019c4511d>] btrfs_delalloc_reserve_space+0x1b/0xa0 [btrfs]n [<000000006d37e007>] btrfs_dio_iomap_begin+0x415/0x970 [btrfs]n [<00000000fb8a74b8>] iomap_iter+0x161/0x1e0n [<0000000071dff6ff>] __iomap_dio_rw+0x1df/0x700n [<000000002567ba53>] iomap_dio_rw+0x5/0x20n [<0000000072e555f8>] btrfs_file_write_iter+0x290/0x530 [btrfs]n [<000000005eb3d845>] new_sync_write+0x106/0x180n [<000000003fb505bf>] vfs_write+0x24d/0x2f0n [<000000009bb57d37>] __x64_sys_pwrite64+0x69/0xa0n [<000000003eba3fdf>] do_syscall_64+0x43/0x90nnIn case brtfs_qgroup_reserve_data() or btrfs_delalloc_reserve_metadata()nfail the allocated extent_changeset will not be freed.nnSo in btrfs_check_data_free_space() and btrfs_delalloc_reserve_space()nfree the allocated extent_changeset to get rid of the allocated memory.nnThe issue currently only happens in the direct IO write path but onlynafter 65b3c08606e5 (btrfs: fix ENOSPC failure when attempting direct IOnwrite into NOCOW range) and also at defrag_one_locked_target(). Everynother place is always calling extent_changeset_free() even if its callnto btrfs_delalloc_reserve_space() or btrfs_check_data_free_space() hasnfailed.,CVE-2021-47508,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnblk-mq: cancel blk-mq dispatch work in both blk_cleanup_queue and disk_release()nnFor avoiding to slow down queue destroy we don't callnblk_mq_quiesce_queue() in blk_cleanup_queue() instead of delaying toncancel dispatch work in blk_release_queue().nnHowever this way has caused kernel oops[1] reported by Changhui. The lognshows that scsi_device can be freed before running blk_release_queue()nwhich is expected too since scsi_device is released after the scsi disknis closed and the scsi_device is removed.nnFixes the issue by canceling blk-mq dispatch work in both blk_cleanup_queue()nand disk_release():nn1) when disk_release() is run the disk has been closed and any syncndispatch activities have been done so canceling dispatch work is enough tonquiesce filesystem I/O dispatch activity.nn2) in blk_cleanup_queue() we only focus on passthrough request andnpassthrough request is always explicitly allocated & freed bynits caller so once queue is frozen all sync dispatch activitynfor passthrough request has been done then it is enough to just cancelndispatch work for avoiding any dispatch activity.nn[1] kernel panic logn[12622.769416] BUG: kernel NULL pointer dereference address: 0000000000000300n[12622.777186] #PF: supervisor read access in kernel moden[12622.782918] #PF: error_code(0x0000) - not-present pagen[12622.788649] PGD 0 P4D 0n[12622.791474] Oops: 0000 [#1] PREEMPT SMP PTIn[12622.796138] CPU: 10 PID: 744 Comm: kworker/10:1H Kdump: loaded Not tainted 5.15.0+ #1n[12622.804877] Hardware name: Dell Inc. PowerEdge R730/0H21J3 BIOS 1.5.4 10/002/2015n[12622.813321] Workqueue: kblockd blk_mq_run_work_fnn[12622.818572] RIP: 0010:sbitmap_get+0x75/0x190n[12622.823336] Code: 85 80 00 00 00 41 8b 57 08 85 d2 0f 84 b1 00 00 00 45 31 e4 48 63 cd 48 8d 1c 49 48 c1 e3 06 49 03 5f 10 4c 8d 6b 40 83 f0 01 <48> 8b 33 44 89 f2 4c 89 ef 0f b6 c8 e8 fa f3 ff ff 83 f8 ff 75 58n[12622.844290] RSP: 0018:ffffb00a446dbd40 EFLAGS: 00010202n[12622.850120] RAX: 0000000000000001 RBX: 0000000000000300 RCX: 0000000000000004n[12622.858082] RDX: 0000000000000006 RSI: 0000000000000082 RDI: ffffa0b7a2dfe030n[12622.866042] RBP: 0000000000000004 R08: 0000000000000001 R09: ffffa0b742721334n[12622.874003] R10: 0000000000000008 R11: 0000000000000008 R12: 0000000000000000n[12622.881964] R13: 0000000000000340 R14: 0000000000000000 R15: ffffa0b7a2dfe030n[12622.889926] FS: 0000000000000000(0000) GS:ffffa0baafb40000(0000) knlGS:0000000000000000n[12622.898956] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033n[12622.905367] CR2: 0000000000000300 CR3: 0000000641210001 CR4: 00000000001706e0n[12622.913328] Call Trace:n[12622.916055] <TASK>n[12622.918394] scsi_mq_get_budget+0x1a/0x110n[12622.922969] __blk_mq_do_dispatch_sched+0x1d4/0x320n[12622.928404] ? pick_next_task_fair+0x39/0x390n[12622.933268] __blk_mq_sched_dispatch_requests+0xf4/0x140n[12622.939194] blk_mq_sched_dispatch_requests+0x30/0x60n[12622.944829] __blk_mq_run_hw_queue+0x30/0xa0n[12622.949593] process_one_work+0x1e8/0x3c0n[12622.954059] worker_thread+0x50/0x3b0n[12622.958144] ? rescuer_thread+0x370/0x370n[12622.962616] kthread+0x158/0x180n[12622.966218] ? set_kthread_struct+0x40/0x40n[12622.970884] ret_from_fork+0x22/0x30n[12622.974875] </TASK>n[12622.977309] Modules linked in: scsi_debug rpcsec_gss_krb5 auth_rpcgss nfsv4 dns_resolver nfs lockd grace fscache netfs sunrpc dm_multipath intel_rapl_msr intel_rapl_common dell_wmi_descriptor sb_edac rfkill video x86_pkg_temp_thermal intel_powerclamp dcdbas coretemp kvm_intel kvm mgag200 irqbypass i2c_algo_bit rapl drm_kms_helper ipmi_ssif intel_cstate intel_uncore syscopyarea sysfillrect sysimgblt fb_sys_fops pcspkr cec mei_me lpc_ich mei ipmi_si ipmi_devintf ipmi_msghandler acpi_power_meter drm fuse xfs libcrc32c sr_mod cdrom sd_mod t10_pi sg ixgbe ahci libahci crct10dif_pclmul crc32_pclmul crc32c_intel libata megaraid_sas ghash_clmulni_intel tg3 wdat_wn---truncated---,CVE-2021-47552,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet: stmmac: Disable Tx queues when reconfiguring the interfacennThe Tx queues were not disabled in situations where the driver needed tonstop the interface to apply a new configuration. This could result in ankernel panic when doing any of the 3 following actions:n* reconfiguring the number of queues (ethtool -L)n* reconfiguring the size of the ring buffers (ethtool -G)n* installing/removing an XDP program (ip l set dev ethX xdp)nnPrevent the panic by making sure netif_tx_disable is called when stoppingnan interface.nnWithout this patch the following kernel panic can be observed when doingnany of the actions above:nnUnable to handle kernel paging request at virtual address ffff80001238d040n[....]n Call trace:n dwmac4_set_addr+0x8/0x10n dev_hard_start_xmit+0xe4/0x1acn sch_direct_xmit+0xe8/0x39cn __dev_queue_xmit+0x3ec/0xaf0n dev_queue_xmit+0x14/0x20n[...]n[ end trace 0000000000000002 ]---,CVE-2021-47558,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnio-wq: check for wq exit after adding new worker task_worknnWe check IO_WQ_BIT_EXIT before attempting to create a new worker andnwq exit cancels pending work if we have any. But it's possible to havena race between the two where creation checks exit finding it not setnbut we're in the process of exiting. The exit side will cancel pendingncreation task_work but there's a gap where we add task_work after we'vencanceled existing creations at exit time.nnFix this by checking the EXIT bit post adding the creation task_work.nIf it's set run the same cancelation that exit does.,CVE-2021-47577,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnUSB: core: Make do_proc_control() and do_proc_bulk() killablennThe USBDEVFS_CONTROL and USBDEVFS_BULK ioctls invokenusb_start_wait_urb() which contains an uninterruptible wait with anuser-specified timeout value. If timeout value is very large and thendevice being accessed does not respond in a reasonable amount of timenthe kernel will complain about Task X blocked for more than Nnseconds as found in testing by syzbot:nnINFO: task syz-executor.0:8700 blocked for more than 143 seconds.n Not tainted 5.14.0-rc7-syzkaller #0necho 0 > /proc/sys/kernel/hung_task_timeout_secs disables this message.ntask:syz-executor.0 state:D stack:23192 pid: 8700 ppid: 8455 flags:0x00004004nCall Trace:n context_switch kernel/sched/core.c:4681 [inline]n __schedule+0xc07/0x11f0 kernel/sched/core.c:5938n schedule+0x14b/0x210 kernel/sched/core.c:6017n schedule_timeout+0x98/0x2f0 kernel/time/timer.c:1857n do_wait_for_common+0x2da/0x480 kernel/sched/completion.c:85n __wait_for_common kernel/sched/completion.c:106 [inline]n wait_for_common kernel/sched/completion.c:117 [inline]n wait_for_completion_timeout+0x46/0x60 kernel/sched/completion.c:157n usb_start_wait_urb+0x167/0x550 drivers/usb/core/message.c:63n do_proc_bulk+0x978/0x1080 drivers/usb/core/devio.c:1236n proc_bulk drivers/usb/core/devio.c:1273 [inline]n usbdev_do_ioctl drivers/usb/core/devio.c:2547 [inline]n usbdev_ioctl+0x3441/0x6b10 drivers/usb/core/devio.c:2713n...nnTo fix this problem this patch replaces usbfs's calls tonusb_control_msg() and usb_bulk_msg() with special-purpose code thatndoes essentially the same thing (as recommended in the comment fornusb_start_wait_urb()) except that it always uses a killable wait andnit uses GFP_KERNEL rather than GFP_NOIO.,CVE-2021-47582,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbtrfs: use latest_dev in btrfs_show_devnamennThe test case btrfs/238 reports the warning below:nn WARNING: CPU: 3 PID: 481 at fs/btrfs/super.c:2509 btrfs_show_devname+0x104/0x1e8 [btrfs]n CPU: 2 PID: 1 Comm: systemd Tainted: G W O 5.14.0-rc1-custom #72n Hardware name: QEMU QEMU Virtual Machine BIOS 0.0.0 02/06/2015n Call trace:n btrfs_show_devname+0x108/0x1b4 [btrfs]n show_mountinfo+0x234/0x2c4n m_show+0x28/0x34n seq_read_iter+0x12c/0x3c4n vfs_read+0x29c/0x2c8n ksys_read+0x80/0xecn __arm64_sys_read+0x28/0x34n invoke_syscall+0x50/0xf8n do_el0_svc+0x88/0x138n el0_svc+0x2c/0x8cn el0t_64_sync_handler+0x84/0xe4n el0t_64_sync+0x198/0x19cnnReason:nWhile btrfs_prepare_sprout() moves the fs_devices::devices intonfs_devices::seed_list the btrfs_show_devname() searches for the devicesnand found none leading to the warning as in above.nnFix:nlatest_dev is updated according to the changes to the device list.nThat means we could use the latest_dev->name to show the device name inn/proc/self/mounts the pointer will be always valid as it's assignednbefore the device is deleted from the list in remove or replace.nThe RCU protection is sufficient as the device structure is freed afternsynchronization.,CVE-2021-47599,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/msm: Fix null ptr access msm_ioctl_gem_submit()nnFix the below null pointer dereference in msm_ioctl_gem_submit():nn 26545.260705: Call trace:n 26545.263223: kref_put+0x1c/0x60n 26545.266452: msm_ioctl_gem_submit+0x254/0x744n 26545.270937: drm_ioctl_kernel+0xa8/0x124n 26545.274976: drm_ioctl+0x21c/0x33cn 26545.278478: drm_compat_ioctl+0xdc/0xf0n 26545.282428: __arm64_compat_sys_ioctl+0xc8/0x100n 26545.287169: el0_svc_common+0xf8/0x250n 26545.291025: do_el0_svc_compat+0x28/0x54n 26545.295066: el0_svc_compat+0x10/0x1cn 26545.298838: el0_sync_compat_handler+0xa8/0xccn 26545.303403: el0_sync_compat+0x188/0x1c0n 26545.307445: Code: d503201f d503201f 52800028 4b0803e8 (b8680008)n 26545.318799: Kernel panic - not syncing: Oops: Fatal exception,CVE-2021-47610,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnARM: 9170/1: fix panic when kasan and kprobe are enablednnarm32 uses software to simulate the instruction replacednby kprobe. some instructions may be simulated by constructingnassembly functions. therefore before executing instructionnsimulation it is necessary to construct assembly functionnexecution environment in C language through binding registers.nafter kasan is enabled the register binding relationship willnbe destroyed resulting in instruction simulation errors andncausing kernel panic.nnthe kprobe emulate instruction function is distributed in threenfiles: actions-common.c actions-arm.c actions-thumb.c so disablenKASAN when compiling these files.nnfor example use kprobe insert on cap_capable+20 after kasannenabled the cap_capable assembly code is as follows:n<cap_capable>:ne92d47f0tpusht{r4 r5 r6 r7 r8 r9 sl lr}ne1a05000tmovtr5 r0ne280006ctaddtr0 r0 #108 ; 0x6cne1a04001tmovtr4 r1ne1a06002tmovtr6 r2ne59fa090tldrtsl [pc #144] ;nebfc7bf8tbltc03aa4b4 <__asan_load4>ne595706ctldrtr7 [r5 #108] ; 0x6cne2859014taddtr9 r5 #20n......nThe emulate_ldr assembly code after enabling kasan is as follows:nc06f1384 <emulate_ldr>:ne92d47f0tpusht{r4 r5 r6 r7 r8 r9 sl lr}ne282803ctaddtr8 r2 #60 ; 0x3cne1a05000tmovtr5 r0ne7e37855tubfxtr7 r5 #16 #4ne1a00008tmovtr0 r8ne1a09001tmovtr9 r1ne1a04002tmovtr4 r2nebf35462tbltc03c6530 <__asan_load4>ne357000ftcmptr7 #15ne7e36655tubfxtr6 r5 #12 #4ne205a00ftandtsl r5 #15n0a000001tbeqtc06f13bc <emulate_ldr+0x38>ne0840107taddtr0 r4 r7 lsl #2nebf3545ctbltc03c6530 <__asan_load4>ne084010ataddtr0 r4 sl lsl #2nebf3545atbltc03c6530 <__asan_load4>ne2890010taddtr0 r9 #16nebf35458tbltc03c6530 <__asan_load4>ne5990010tldrtr0 [r9 #16]ne12fff30tblxtr0ne356000ftcmtr6 #15n1a000014tbnetc06f1430 <emulate_ldr+0xac>ne1a06000tmovtr6 r0ne2840040taddtr0 r4 #64 ; 0x40n......nnwhen running in emulate_ldr to simulate the ldr instruction panicnoccurred and the log is as follows:nUnable to handle kernel NULL pointer dereference at virtual addressn00000090npgd = ecb46400n[00000090] *pgd=2e0fa003 *pmd=00000000nInternal error: Oops: 206 [#1] SMP ARMnPC is at cap_capable+0x14/0xb0nLR is at emulate_ldr+0x50/0xc0npsr: 600d0293 sp : ecd63af8 ip : 00000004 fp : c0a7c30cnr10: 00000000 r9 : c30897f4 r8 : ecd63cd4nr7 : 0000000f r6 : 0000000a r5 : e59fa090 r4 : ecd63c98nr3 : c06ae294 r2 : 00000000 r1 : b7611300 r0 : bf4ec008nFlags: nZCv IRQs off FIQs on Mode SVC_32 ISA ARM Segment usernControl: 32c5387d Table: 2d546400 DAC: 55555555nProcess bash (pid: 1643 stack limit = 0xecd60190)n(cap_capable) from (kprobe_handler+0x218/0x340)n(kprobe_handler) from (kprobe_trap_handler+0x24/0x48)n(kprobe_trap_handler) from (do_undefinstr+0x13c/0x364)n(do_undefinstr) from (__und_svc_finish+0x0/0x30)n(__und_svc_finish) from (cap_capable+0x18/0xb0)n(cap_capable) from (cap_vm_enough_memory+0x38/0x48)n(cap_vm_enough_memory) fromn(security_vm_enough_memory_mm+0x48/0x6c)n(security_vm_enough_memory_mm) fromn(copy_process.constprop.5+0x16b4/0x25c8)n(copy_process.constprop.5) from (_do_fork+0xe8/0x55c)n(_do_fork) from (SyS_clone+0x1c/0x24)n(SyS_clone) from (__sys_trace_return+0x0/0x10)nCode: 0050a0e1 6c0080e2 0140a0e1 0260a0e1 (f801f0e7),CVE-2021-47618,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnscsi: ufs: Fix a deadlock in the error handlernnThe following deadlock has been observed on a test setup:nn - All tags allocatednn - The SCSI error handler calls ufshcd_eh_host_reset_handler()nn - ufshcd_eh_host_reset_handler() queues work that callsn ufshcd_err_handler()nn - ufshcd_err_handler() locks up as follows:nnWorkqueue: ufs_eh_wq_0 ufshcd_err_handler.cfi_jtnCall trace:n __switch_to+0x298/0x5d8n __schedule+0x6cc/0xa94n schedule+0x12c/0x298n blk_mq_get_tag+0x210/0x480n __blk_mq_alloc_request+0x1c8/0x284n blk_get_request+0x74/0x134n ufshcd_exec_dev_cmd+0x68/0x640n ufshcd_verify_dev_init+0x68/0x35cn ufshcd_probe_hba+0x12c/0x1cb8n ufshcd_host_reset_and_restore+0x88/0x254n ufshcd_reset_and_restore+0xd0/0x354n ufshcd_err_handler+0x408/0xc58n process_one_work+0x24c/0x66cn worker_thread+0x3e8/0xa4cn kthread+0x150/0x1b4n ret_from_fork+0x10/0x30nnFix this lockup by making ufshcd_exec_dev_cmd() allocate a reservednrequest.,CVE-2021-47622,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet/sunrpc: fix reference count leaks in rpc_sysfs_xprt_state_changennThe refcount leak issues take place in an error handling path. When then3rd argument buf doesn't match with offline online or remove thenfunction simply returns -EINVAL and forgets to decrease the referencencount of a rpc_xprt object and a rpc_xprt_switch object increased bynrpc_sysfs_xprt_kobj_get_xprt() andnrpc_sysfs_xprt_kobj_get_xprt_switch() causing reference count leaks ofnboth unused objects.nnFix this issue by jumping to the error handling path labelled withnout_put when buf matches none of offline online or remove.,CVE-2021-47624,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnpowerpc/set_memory: Avoid spinlock recursion in change_page_attr()nnCommit 1f9ad21c3b38 (powerpc/mm: Implement set_memory() routines)nincluded a spin_lock() to change_page_attr() in order tonsafely perform the three step operations. But thenncommit 9f7853d7609d (powerpc/mm: Fix set_memory_*() againstnconcurrent accesses) modify it to use pte_update() and donthe operation safely against concurrent access.nnIn the meantime Maxime reported some spinlock recursion.nn[ 15.351649] BUG: spinlock recursion on CPU#0 kworker/0:2/217n[ 15.357540] lock: init_mm+0x3c/0x420 .magic: dead4ead .owner: kworker/0:2/217 .owner_cpu: 0n[ 15.366563] CPU: 0 PID: 217 Comm: kworker/0:2 Not tainted 5.15.0+ #523n[ 15.373350] Workqueue: events do_free_initn[ 15.377615] Call Trace:n[ 15.380232] [e4105ac0] [800946a4] do_raw_spin_lock+0xf8/0x120 (unreliable)n[ 15.387340] [e4105ae0] [8001f4ec] change_page_attr+0x40/0x1d4n[ 15.393413] [e4105b10] [801424e0] __apply_to_page_range+0x164/0x310n[ 15.400009] [e4105b60] [80169620] free_pcp_prepare+0x1e4/0x4a0n[ 15.406045] [e4105ba0] [8016c5a0] free_unref_page+0x40/0x2b8n[ 15.411979] [e4105be0] [8018724c] kasan_depopulate_vmalloc_pte+0x6c/0x94n[ 15.418989] [e4105c00] [801424e0] __apply_to_page_range+0x164/0x310n[ 15.425451] [e4105c50] [80187834] kasan_release_vmalloc+0xbc/0x134n[ 15.431898] [e4105c70] [8015f7a8] __purge_vmap_area_lazy+0x4e4/0xdd8n[ 15.438560] [e4105d30] [80160d10] _vm_unmap_aliases.part.0+0x17c/0x24cn[ 15.445283] [e4105d60] [801642d0] __vunmap+0x2f0/0x5c8n[ 15.450684] [e4105db0] [800e32d0] do_free_init+0x68/0x94n[ 15.456181] [e4105dd0] [8005d094] process_one_work+0x4bc/0x7b8n[ 15.462283] [e4105e90] [8005d614] worker_thread+0x284/0x6e8n[ 15.468227] [e4105f00] [8006aaec] kthread+0x1f0/0x210n[ 15.473489] [e4105f40] [80017148] ret_from_kernel_thread+0x14/0x1cnnRemove the read / modify / write sequence to make the operation atomicnand remove the spin_lock() in change_page_attr().nnTo do the operation atomically we can't use pte modification helpersnanymore. Because all platforms have different combination of bits itnis not easy to use those bits directly. But all have then_PAGE_KERNEL_{RO/ROX/RW/RWX} set of flags. All we need it to comparentwo sets to know which bits are set or cleared.nnFor instance by comparing _PAGE_KERNEL_ROX and _PAGE_KERNEL_RO younknow which bit gets cleared and which bit get set when changing execnpermission.,CVE-2021-47632,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnmedia: davinci: vpif: fix use-after-free on driver unbindnnThe driver allocates and registers two platform device structures duringnprobe but the devices were never deregistered on driver unbind.nnThis results in a use-after-free on driver unbind as the devicenstructures were allocated using devres and would be freed by driverncore when remove() returns.nnFix this by adding the missing deregistration calls to the remove()ncallback and failing probe on registration errors.nnNote that the platform device structures must be freed using a propernrelease callback to avoid leaking associated resources like devicennames.,CVE-2021-47653,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/pm: fix a potential gpu_metrics_table memory leaknnMemory is allocated for gpu_metrics_table in renoir_init_smc_tables()nbut not freed in int smu_v12_0_fini_smc_tables(). Free it!,CVE-2021-47658,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,An out-of-bounds read vulnerability was discovered in linux kernel in the smc protocol stack causing remote dos.,CVE-2022-0400,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,A flaw was found in the filelock_init in fs/locks.c function in the Linux kernel. This issue can lead to host memory exhaustion due to memcg not limiting the number of Portable Operating System Interface (POSIX) file locks.,CVE-2022-0480,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,A flaw was found in unrestricted eBPF usage by the BPF_BTF_LOAD leading to a possible out-of-bounds memory write in the Linux kernels BPF subsystem due to the way a user loads BTF. This flaw allows a local user to crash or escalate their privileges on the system.,CVE-2022-0500,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,An issue found in linux-kernel that leads to a race condition in rose_connect(). The rose driver uses rose_neigh->use to represent how many objects are using the rose_neigh. When a user wants to delete a rose_route via rose_ioctl() the rose driver calls rose_del_node() and removes neighbours only if their count and use are zero.,CVE-2022-1247,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,A use-after-free vulnerability was found in drm_lease_held in drivers/gpu/drm/drm_lease.c in the Linux kernel due to a race problem. This flaw allows a local user privilege attacker to cause a denial of service (DoS) or a kernel information leak.,CVE-2022-1280,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnscsi: target: Fix WRITE_SAME No Data Buffer crashnnIn newer version of the SBC specs we have a NDOB bit that indicates therenis no data buffer that gets written out. If this bit is set using commandsnlike sg_write_same --ndob we will crash in target_core_iblock/file'snexecute_write_same handlers when we go to access the se_cmd->t_data_sgnbecause its NULL.nnThis patch adds a check for the NDOB bit in the common WRITE SAME codenbecause we don't support it. And it adds a check for zero SG elements inneach handler in case the initiator tries to send a normal WRITE SAME withnno data buffer.,CVE-2022-21546,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,In the Linux kernel through 5.16.10 certain binary files may have the exec-all attribute if they were built in approximately 2003 (e.g. with GCC 3.2.2 and Linux kernel 2.4.20). This can cause execution of bytes located in supposedly non-executable regions of a file.,CVE-2022-25265,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,nWhen SMT is enabled certain AMD processors may speculatively execute instructions using a targetnfrom the sibling thread after an SMT mode switch potentially resulting in information disclosure.nnn,CVE-2022-27672,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,A use-after-free flaw was found in the Linux kernels PLP Rose functionality in the way a user triggers a race condition by calling bind while simultaneously triggering the rose_bind() function. This flaw allows a local user to crash or potentially escalate their privileges on the system.,CVE-2022-2961,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,An issue was discovered in the Linux kernel through 5.16-rc6. kfd_parse_subtype_iolink in drivers/gpu/drm/amd/amdkfd/kfd_crat.c lacks check of the return value of kmemdup().,CVE-2022-3108,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,An issue was discovered in the Linux kernel through 5.16-rc6. imx_register_uart_clocks in drivers/clk/imx/clk.c lacks check of the return value of kcalloc() and will cause the null pointer dereference.,CVE-2022-3114,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,A flaw was found in the KVM's AMD nested virtualization (SVM). A malicious L1 guest could purposely fail to intercept the shutdown of a cooperative nested guest (L2) possibly leading to a page fault and kernel panic in the host (L0).,CVE-2022-3344,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,A vulnerability was found in Linux Kernel. It has been classified as problematic. Affected is an unknown function of the file mm/memory.c of the component Driver Handler. The manipulation leads to use after free. It is possible to launch the attack remotely. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-211020.,CVE-2022-3523,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,A vulnerability which was classified as problematic was found in Linux Kernel. This affects the function tcp_getsockopt/tcp_setsockopt of the component TCP Handler. The manipulation leads to race condition. It is recommended to apply a patch to fix this issue. The identifier VDB-211089 was assigned to this vulnerability.,CVE-2022-3566,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,A vulnerability has been found in Linux Kernel and classified as problematic. This vulnerability affects the function inet6_stream_ops/inet6_dgram_ops of the component IPv6 Handler. The manipulation leads to race condition. It is recommended to apply a patch to fix this issue. VDB-211090 is the identifier assigned to this vulnerability.,CVE-2022-3567,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,A use-after-free(UAF) vulnerability was found in function 'vmw_cmd_res_check' in drivers/gpu/vmxgfx/vmxgfx_execbuf.c in Linux kernel's vmwgfx driver with device file '/dev/dri/renderD128 (or Dxxx)'. This flaw allows a local attacker with a user account on the system to gain privilege causing a denial of service(DoS).,CVE-2022-38457,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,A use-after-free(UAF) vulnerability was found in function 'vmw_execbuf_tie_context' in drivers/gpu/vmxgfx/vmxgfx_execbuf.c in Linux kernel's vmwgfx driver with device file '/dev/dri/renderD128 (or Dxxx)'. This flaw allows a local attacker with a user account on the system to gain privilege causing a denial of service(DoS).,CVE-2022-40133,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,drivers/char/pcmcia/synclink_cs.c in the Linux kernel through 5.19.12 has a race condition and resultant use-after-free if a physically proximate attacker removes a PCMCIA device while calling ioctl aka a race condition between mgslpc_ioctl and mgslpc_detach.,CVE-2022-41848,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,An issue was discovered in the Linux kernel through 6.0.6. drivers/char/pcmcia/cm4000_cs.c has a race condition and resultant use-after-free if a physically proximate attacker removes a PCMCIA device while calling open() aka a race condition between cmm_open() and cm4000_detach().,CVE-2022-44032,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,An issue was discovered in the Linux kernel through 6.0.6. drivers/char/pcmcia/cm4040_cs.c has a race condition and resultant use-after-free if a physically proximate attacker removes a PCMCIA device while calling open() aka a race condition between cm4040_open() and reader_detach().,CVE-2022-44033,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,An issue was discovered in the Linux kernel through 6.0.6. drivers/char/pcmcia/scr24x_cs.c has a race condition and resultant use-after-free if a physically proximate attacker removes a PCMCIA device while calling open() aka a race condition between scr24x_open() and scr24x_remove().,CVE-2022-44034,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,A flaw named EntryBleed was found in the Linux Kernel Page Table Isolation (KPTI). This issue could allow a local attacker to leak KASLR base via prefetch side-channels based on TLB timing for Intel systems.,CVE-2022-4543,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,An issue was discovered in the Linux kernel through 6.0.9. drivers/media/dvb-core/dvbdev.c has a use-after-free related to dvb_register_device dynamically allocating fops.,CVE-2022-45884,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,An issue was discovered in the Linux kernel through 6.0.9. drivers/media/dvb-core/dvb_frontend.c has a race condition that can cause a use-after-free when a device is disconnected.,CVE-2022-45885,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnmoxart: fix potential use-after-free on remove pathnnIt was reported that the mmc host structure could be accessed after itnwas freed in moxart_remove() so fix this by saving the base register ofnthe device and using it instead of the pointer dereference.,CVE-2022-48626,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnceph: drop messages from MDS when unmountingnnWhen unmounting all the dirty buffers will be flushed and afternthe last osd request is finished the last reference of the i_countnwill be released. Then it will flush the dirty cap/snap to MDSsnand the unmounting won't wait the possible acks which will iholdnthe inodes when updating the metadata locally but makes no sensenany more of this. This will make the evict_inodes() to skip theseninodes.nnIf encrypt is enabled the kernel generate a warning when removingnthe encrypt keys when the skipped inodes still hold the keyring:nnWARNING: CPU: 4 PID: 168846 at fs/crypto/keyring.c:242 fscrypt_destroy_keyring+0x7e/0xd0nCPU: 4 PID: 168846 Comm: umount Tainted: G S 6.1.0-rc5-ceph-g72ead199864c #1nHardware name: Supermicro SYS-5018R-WR/X10SRW-F BIOS 2.0 12/17/2015nRIP: 0010:fscrypt_destroy_keyring+0x7e/0xd0nRSP: 0018:ffffc9000b277e28 EFLAGS: 00010202nRAX: 0000000000000002 RBX: ffff88810d52ac00 RCX: ffff88810b56aa00nRDX: 0000000080000000 RSI: ffffffff822f3a09 RDI: ffff888108f59000nRBP: ffff8881d394fb88 R08: 0000000000000028 R09: 0000000000000000nR10: 0000000000000001 R11: 11ff4fe6834fcd91 R12: ffff8881d394fc40nR13: ffff888108f59000 R14: ffff8881d394f800 R15: 0000000000000000nFS: 00007fd83f6f1080(0000) GS:ffff88885fd00000(0000) knlGS:0000000000000000nCS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033nCR2: 00007f918d417000 CR3: 000000017f89a005 CR4: 00000000003706e0nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400nCall Trace:n<TASK>ngeneric_shutdown_super+0x47/0x120nkill_anon_super+0x14/0x30nceph_kill_sb+0x36/0x90 [ceph]ndeactivate_locked_super+0x29/0x60ncleanup_mnt+0xb8/0x140ntask_work_run+0x67/0xb0nexit_to_user_mode_prepare+0x23d/0x240nsyscall_exit_to_user_mode+0x25/0x60ndo_syscall_64+0x40/0x80nentry_SYSCALL_64_after_hwframe+0x63/0xcdnRIP: 0033:0x7fd83dc39e9bnnLater the kernel will crash when iput() the inodes and dereferencingnthe sb->s_master_keys which has been released by thengeneric_shutdown_super().,CVE-2022-48628,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/gma500: Fix WARN_ON(lock->magic != lock) errornnpsb_gem_unpin() calls dma_resv_lock() but the underlying ww_mutexngets destroyed by drm_gem_object_release() move thendrm_gem_object_release() call in psb_gem_free_object() to afternthe unpin to fix the below warning:nn[ 79.693962] ------------[ cut here ]------------n[ 79.693992] DEBUG_LOCKS_WARN_ON(lock->magic != lock)n[ 79.694015] WARNING: CPU: 0 PID: 240 at kernel/locking/mutex.c:582 __ww_mutex_lock.constprop.0+0x569/0xfb0n[ 79.694052] Modules linked in: rfcomm snd_seq_dummy snd_hrtimer qrtr bnep ath9k ath9k_common ath9k_hw snd_hda_codec_realtek snd_hda_codec_generic ledtrig_audio snd_hda_codec_hdmi snd_hda_intel ath3k snd_intel_dspcfg mac80211 snd_intel_sdw_acpi btusb snd_hda_codec btrtl btbcm btintel btmtk bluetooth at24 snd_hda_core snd_hwdep uvcvideo snd_seq libarc4 videobuf2_vmalloc ath videobuf2_memops videobuf2_v4l2 videobuf2_common snd_seq_device videodev acer_wmi intel_powerclamp coretemp mc snd_pcm joydev sparse_keymap ecdh_generic pcspkr wmi_bmof cfg80211 i2c_i801 i2c_smbus snd_timer snd r8169 rfkill lpc_ich soundcore acpi_cpufreq zram rtsx_pci_sdmmc mmc_core serio_raw rtsx_pci gma500_gfx(E) video wmi ip6_tables ip_tables i2c_dev fusen[ 79.694436] CPU: 0 PID: 240 Comm: plymouthd Tainted: G W E 6.0.0-rc3+ #490n[ 79.694457] Hardware name: Packard Bell dot s/SJE01_CT BIOS V1.10 07/23/2013n[ 79.694469] RIP: 0010:__ww_mutex_lock.constprop.0+0x569/0xfb0n[ 79.694496] Code: ff 85 c0 0f 84 15 fb ff ff 8b 05 ca 3c 11 01 85 c0 0f 85 07 fb ff ff 48 c7 c6 30 cb 84 aa 48 c7 c7 a3 e1 82 aa e8 ac 29 f8 ff <0f> 0b e9 ed fa ff ff e8 5b 83 8a ff 85 c0 74 10 44 8b 0d 98 3c 11n[ 79.694513] RSP: 0018:ffffad1dc048bbe0 EFLAGS: 00010282n[ 79.694623] RAX: 0000000000000028 RBX: 0000000000000000 RCX: 0000000000000000n[ 79.694636] RDX: 0000000000000001 RSI: ffffffffaa8b0ffc RDI: 00000000ffffffffn[ 79.694650] RBP: ffffad1dc048bc80 R08: 0000000000000000 R09: ffffad1dc048ba90n[ 79.694662] R10: 0000000000000003 R11: ffffffffaad62fe8 R12: ffff9ff302103138n[ 79.694675] R13: ffff9ff306ec8000 R14: ffff9ff307779078 R15: ffff9ff3014c0270n[ 79.694690] FS: 00007ff1cccf1740(0000) GS:ffff9ff3bc200000(0000) knlGS:0000000000000000n[ 79.694705] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033n[ 79.694719] CR2: 0000559ecbcb4420 CR3: 0000000013210000 CR4: 00000000000006f0n[ 79.694734] Call Trace:n[ 79.694749] <TASK>n[ 79.694761] ? __schedule+0x47f/0x1670n[ 79.694796] ? psb_gem_unpin+0x27/0x1a0 [gma500_gfx]n[ 79.694830] ? lock_is_held_type+0xe3/0x140n[ 79.694864] ? ww_mutex_lock+0x38/0xa0n[ 79.694885] ? __cond_resched+0x1c/0x30n[ 79.694902] ww_mutex_lock+0x38/0xa0n[ 79.694925] psb_gem_unpin+0x27/0x1a0 [gma500_gfx]n[ 79.694964] psb_gem_unpin+0x199/0x1a0 [gma500_gfx]n[ 79.694996] drm_gem_object_release_handle+0x50/0x60n[ 79.695020] ? drm_gem_object_handle_put_unlocked+0xf0/0xf0n[ 79.695042] idr_for_each+0x4b/0xb0n[ 79.695066] ? _raw_spin_unlock_irqrestore+0x30/0x60n[ 79.695095] drm_gem_release+0x1c/0x30n[ 79.695118] drm_file_free.part.0+0x1ea/0x260n[ 79.695150] drm_release+0x6a/0x120n[ 79.695175] __fput+0x9f/0x260n[ 79.695203] task_work_run+0x59/0xa0n[ 79.695227] do_exit+0x387/0xbe0n[ 79.695250] ? seqcount_lockdep_reader_access.constprop.0+0x82/0x90n[ 79.695275] ? lockdep_hardirqs_on+0x7d/0x100n[ 79.695304] do_group_exit+0x33/0xb0n[ 79.695331] __x64_sys_exit_group+0x14/0x20n[ 79.695353] do_syscall_64+0x58/0x80n[ 79.695376] ? up_read+0x17/0x20n[ 79.695401] ? lock_is_held_type+0xe3/0x140n[ 79.695429] ? asm_exc_page_fault+0x22/0x30n[ 79.695450] ? lockdep_hardirqs_on+0x7d/0x100n[ 79.695473] entry_SYSCALL_64_after_hwframe+0x63/0xcdn[ 79.695493] RIP: 0033:0x7ff1ccefe3f1n[ 79.695516] Code: Unable to access opcode bytes at RIP 0x7ff1ccefe3c7.n[ 79.695607] RSP: 002b:00007ffed4413378 EFLAGS: n---truncated---,CVE-2022-48633,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet: enetc: deny offload of tc-based TSN features on VF interfacesnnTSN features on the ENETC (taprio cbs gate police) are configurednthrough a mix of command BD ring messages and port registers:nenetc_port_rd() enetc_port_wr().nnPort registers are a region of the ENETC memory map which are onlynaccessible from the PCIe Physical Function. They are not accessible fromnthe Virtual Functions.nnMoreover attempting to access these registers crashes the kernel:nn$ echo 1 > /sys/bus/pci/devices/0000:00:00.0/sriov_numvfsnpci 0000:00:01.0: [1957:ef00] type 00 class 0x020001nfsl_enetc_vf 0000:00:01.0: Adding to iommu group 15nfsl_enetc_vf 0000:00:01.0: enabling device (0000 -> 0002)nfsl_enetc_vf 0000:00:01.0 eno0vf0: renamed from eth0n$ tc qdisc replace dev eno0vf0 root taprio num_tc 8 map 0 1 2 3 4 5 6 7 ntqueues 1@0 1@1 1@2 1@3 1@4 1@5 1@6 1@7 base-time 0 ntsched-entry S 0x7f 900000 sched-entry S 0x80 100000 flags 0x2nUnable to handle kernel paging request at virtual address ffff800009551a08nInternal error: Oops: 96000007 [#1] PREEMPT SMPnpc : enetc_setup_tc_taprio+0x170/0x47cnlr : enetc_setup_tc_taprio+0x16c/0x47cnCall trace:n enetc_setup_tc_taprio+0x170/0x47cn enetc_setup_tc+0x38/0x2dcn taprio_change+0x43c/0x970n taprio_init+0x188/0x1e0n qdisc_create+0x114/0x470n tc_modify_qdisc+0x1fc/0x6c0n rtnetlink_rcv_msg+0x12c/0x390nnSplit enetc_setup_tc() into separate functions for the PF and for thenVF drivers. Also remove enetc_qos.o from being included intonenetc-vf.ko since it serves absolutely no purpose there.,CVE-2022-48645,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnsfc/siena: fix null pointer dereference in efx_hard_start_xmitnnLike in previous patch for sfc prevent potential (but unlikely) NULLnpointer dereference.,CVE-2022-48646,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet/smc: Fix possible access to freed memory in link clearnnAfter modifying the QP to the Error state all RX WR would be completednwith WC in IB_WC_WR_FLUSH_ERR status. Current implementation does notnwait for it is done but destroy the QP and free the link group directly.nSo there is a risk that accessing the freed memory in tasklet context.nnHere is a crash example:nn BUG: unable to handle page fault for address: ffffffff8f220860n #PF: supervisor write access in kernel moden #PF: error_code(0x0002) - not-present pagen PGD f7300e067 P4D f7300e067 PUD f7300f063 PMD 8c4e45063 PTE 800ffff08c9df060n Oops: 0002 [#1] SMP PTIn CPU: 1 PID: 0 Comm: swapper/1 Kdump: loaded Tainted: G S OE 5.10.0-0607+ #23n Hardware name: Inspur NF5280M4/YZMB-00689-101 BIOS 4.1.20 07/09/2018n RIP: 0010:native_queued_spin_lock_slowpath+0x176/0x1b0n Code: f3 90 48 8b 32 48 85 f6 74 f6 eb d5 c1 ee 12 83 e0 03 83 ee 01 48 c1 e0 05 48 63 f6 48 05 00 c8 02 00 48 03 04 f5 00 09 98 8e <48> 89 10 8b 42 08 85 c0 75 09 f3 90 8b 42 08 85 c0 74 f7 48 8b 32n RSP: 0018:ffffb3b6c001ebd8 EFLAGS: 00010086n RAX: ffffffff8f220860 RBX: 0000000000000246 RCX: 0000000000080000n RDX: ffff91db1f86c800 RSI: 000000000000173c RDI: ffff91db62bace00n RBP: ffff91db62bacc00 R08: 0000000000000000 R09: c00000010000028bn R10: 0000000000055198 R11: ffffb3b6c001ea58 R12: ffff91db80e05010n R13: 000000000000000a R14: 0000000000000006 R15: 0000000000000040n FS: 0000000000000000(0000) GS:ffff91db1f840000(0000) knlGS:0000000000000000n CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033n CR2: ffffffff8f220860 CR3: 00000001f9580004 CR4: 00000000003706e0n DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000n DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400n Call Trace:n <IRQ>n _raw_spin_lock_irqsave+0x30/0x40n mlx5_ib_poll_cq+0x4c/0xc50 [mlx5_ib]n smc_wr_rx_tasklet_fn+0x56/0xa0 [smc]n tasklet_action_common.isra.21+0x66/0x100n __do_softirq+0xd5/0x29cn asm_call_irq_on_stack+0x12/0x20n </IRQ>n do_softirq_own_stack+0x37/0x40n irq_exit_rcu+0x9d/0xa0n sysvec_call_function_single+0x34/0x80n asm_sysvec_call_function_single+0x12/0x20,CVE-2022-48673,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnerofs: fix pcluster use-after-free on UP platformsnnDuring stress testing with CONFIG_SMP disabled KASAN reports as below:nn==================================================================nBUG: KASAN: use-after-free in __mutex_lock+0xe5/0xc30nRead of size 8 at addr ffff8881094223f8 by task stress/7789nnCPU: 0 PID: 7789 Comm: stress Not tainted 6.0.0-rc1-00002-g0d53d2e882f9 #3nHardware name: Red Hat KVM BIOS 0.5.1 01/01/2011nCall Trace:n <TASK>n..n __mutex_lock+0xe5/0xc30n..n z_erofs_do_read_page+0x8ce/0x1560n..n z_erofs_readahead+0x31c/0x580n..nFreed by task 7787n kasan_save_stack+0x1e/0x40n kasan_set_track+0x20/0x30n kasan_set_free_info+0x20/0x40n __kasan_slab_free+0x10c/0x190n kmem_cache_free+0xed/0x380n rcu_core+0x3d5/0xc90n __do_softirq+0x12d/0x389nnLast potentially related work creation:n kasan_save_stack+0x1e/0x40n __kasan_record_aux_stack+0x97/0xb0n call_rcu+0x3d/0x3f0n erofs_shrink_workstation+0x11f/0x210n erofs_shrink_scan+0xdc/0x170n shrink_slab.constprop.0+0x296/0x530n drop_slab+0x1c/0x70n drop_caches_sysctl_handler+0x70/0x80n proc_sys_call_handler+0x20a/0x2f0n vfs_write+0x555/0x6c0n ksys_write+0xbe/0x160n do_syscall_64+0x3b/0x90nnThe root cause is that erofs_workgroup_unfreeze() doesn't reset tonorig_val thus it causes a race that the pcluster reuses unexpectedlynbefore freeing.nnSince UP platforms are quite rare now such path becomes unnecessary.nLet's drop such specific-designed path directly instead.,CVE-2022-48674,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: fix memory leak when using debugfs_lookup()nnWhen calling debugfs_lookup() the result must have dput() called on itnotherwise the memory will leak over time. Fix this up by properlyncalling dput().,CVE-2022-48698,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnsched/debug: fix dentry leak in update_sched_domain_debugfsnnKuyo reports that the pattern of using debugfs_remove(debugfs_lookup())nleaks a dentry and with a hotplug stress test the machine eventuallynruns out of memory.nnFix this up by using the newly created debugfs_lookup_and_remove() callninstead which properly handles the dentry reference counting logic.,CVE-2022-48699,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnthermal/int340x_thermal: handle data_vault when the value is ZERO_SIZE_PTRnnIn some case the GDDV returns a package with a buffer which hasnzero length. It causes that kmemdup() returns ZERO_SIZE_PTR (0x10).nnThen the data_vault_read() got NULL point dereference problem whennaccessing the 0x10 value in data_vault.nn[ 71.024560] BUG: kernel NULL pointer dereference address:n0000000000000010nnThis patch uses ZERO_OR_NULL_PTR() for checking ZERO_SIZE_PTR ornNULL value in data_vault.,CVE-2022-48703,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnvdpa: ifcvf: Do proper cleanup if IFCVF init failsnnifcvf_mgmt_dev leaks memory if it is not freed beforenreturning. Call is made to correct return statementnso memory does not leak. ifcvf_init_hw does not takencare of this so it is needed to do it here.,CVE-2022-48706,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet/smc: Forward wakeup to smc socket waitqueue after fallbacknnWhen we replace TCP with SMC and a fallback occurs there may bensome socket waitqueue entries remaining in smc socket->wq suchnas eppoll_entries inserted by userspace applications.nnAfter the fallback data flows over TCP/IP and only clcsocket->wqnwill be woken up. Applications can't be notified by the entriesnwhich were inserted in smc socket->wq before fallback. So we needna mechanism to wake up smc socket->wq at the same time if somenentries remaining in it.nnThe current workaround is to transfer the entries from smc socket->wqnto clcsock->wq during the fallback. But this may cause a crashnlike this:nn general protection fault probably for non-canonical address 0xdead000000000100: 0000 [#1] PREEMPT SMP PTIn CPU: 3 PID: 0 Comm: swapper/3 Kdump: loaded Tainted: G E 5.16.0+ #107n RIP: 0010:__wake_up_common+0x65/0x170n Call Trace:n <IRQ>n __wake_up_common_lock+0x7a/0xc0n sock_def_readable+0x3c/0x70n tcp_data_queue+0x4a7/0xc40n tcp_rcv_established+0x32f/0x660n ? sk_filter_trim_cap+0xcb/0x2e0n tcp_v4_do_rcv+0x10b/0x260n tcp_v4_rcv+0xd2a/0xde0n ip_protocol_deliver_rcu+0x3b/0x1d0n ip_local_deliver_finish+0x54/0x60n ip_local_deliver+0x6a/0x110n ? tcp_v4_early_demux+0xa2/0x140n ? tcp_v4_early_demux+0x10d/0x140n ip_sublist_rcv_finish+0x49/0x60n ip_sublist_rcv+0x19d/0x230n ip_list_rcv+0x13e/0x170n __netif_receive_skb_list_core+0x1c2/0x240n netif_receive_skb_list_internal+0x1e6/0x320n napi_complete_done+0x11d/0x190n mlx5e_napi_poll+0x163/0x6b0 [mlx5_core]n __napi_poll+0x3c/0x1b0n net_rx_action+0x27c/0x300n __do_softirq+0x114/0x2d2n irq_exit_rcu+0xb4/0xe0n common_interrupt+0xba/0xe0n </IRQ>n <TASK>nnThe crash is caused by privately transferring waitqueue entries fromnsmc socket->wq to clcsock->wq. The owners of these entries such asnepoll have no idea that the entries have been transferred to andifferent socket wait queue and still use original waitqueue spinlockn(smc socket->wq.wait.lock) to make the entries operation exclusivenbut it doesn't work. The operations to the entries such as removingnfrom the waitqueue (now is clcsock->wq after fallback) may cause ancrash when clcsock waitqueue is being iterated over at the moment.nnThis patch tries to fix this by no longer transferring wait queuenentries privately but introducing own implementations of clcsock'sncallback functions in fallback situation. The callback functions willnforward the wakeup to smc socket->wq if clcsock->wq is actually wokennup and smc socket->wq has remaining entries.,CVE-2022-48721,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet/mlx5e: Avoid field-overflowing memcpy()nnIn preparation for FORTIFY_SOURCE performing compile-time and run-timenfield bounds checking for memcpy() memmove() and memset() avoidnintentionally writing across neighboring fields.nnUse flexible arrays instead of zero-element arrays (which look like theynare always overflowing) and split the cross-field memcpy() into two halvesnthat can be appropriately bounds-checked by the compiler.nnWe were doing:nnt#define ETH_HLEN 14nt#define VLAN_HLEN 4nt...nt#define MLX5E_XDP_MIN_INLINE (ETH_HLEN + VLAN_HLEN)nt...n struct mlx5e_tx_wqe *wqe = mlx5_wq_cyc_get_wqe(wq pi);nt...n struct mlx5_wqe_eth_seg *eseg = &wqe->eth;n struct mlx5_wqe_data_seg *dseg = wqe->data;nt...ntmemcpy(eseg->inline_hdr.start xdptxd->data MLX5E_XDP_MIN_INLINE);nntarget is wqe->eth.inline_hdr.start (which the compiler sees as beingn2 bytes in size) but copying 18 intending to write across startn(really vlan_tci 2 bytes). The remaining 16 bytes get written intonwqe->data[0] covering byte_count (4 bytes) lkey (4 bytes) and addrn(8 bytes).nnstruct mlx5e_tx_wqe {n struct mlx5_wqe_ctrl_seg ctrl; /bin /boot /config /dev /etc /home /lib /media /mnt /opt /proc /root /run /sbin /shared /srv /sys /tmp /usr /utils /var 0 16 */n struct mlx5_wqe_eth_seg eth; /bin /boot /config /dev /etc /home /lib /media /mnt /opt /proc /root /run /sbin /shared /srv /sys /tmp /usr /utils /var 16 16 */n struct mlx5_wqe_data_seg data[]; /bin /boot /config /dev /etc /home /lib /media /mnt /opt /proc /root /run /sbin /shared /srv /sys /tmp /usr /utils /var 32 0 */nn /bin /boot /config /dev /etc /home /lib /media /mnt /opt /proc /root /run /sbin /shared /srv /sys /tmp /usr /utils /var size: 32 cachelines: 1 members: 3 */n /bin /boot /config /dev /etc /home /lib /media /mnt /opt /proc /root /run /sbin /shared /srv /sys /tmp /usr /utils /var last cacheline: 32 bytes */n};nnstruct mlx5_wqe_eth_seg {n u8 swp_outer_l4_offset; /bin /boot /config /dev /etc /home /lib /media /mnt /opt /proc /root /run /sbin /shared /srv /sys /tmp /usr /utils /var 0 1 */n u8 swp_outer_l3_offset; /bin /boot /config /dev /etc /home /lib /media /mnt /opt /proc /root /run /sbin /shared /srv /sys /tmp /usr /utils /var 1 1 */n u8 swp_inner_l4_offset; /bin /boot /config /dev /etc /home /lib /media /mnt /opt /proc /root /run /sbin /shared /srv /sys /tmp /usr /utils /var 2 1 */n u8 swp_inner_l3_offset; /bin /boot /config /dev /etc /home /lib /media /mnt /opt /proc /root /run /sbin /shared /srv /sys /tmp /usr /utils /var 3 1 */n u8 cs_flags; /bin /boot /config /dev /etc /home /lib /media /mnt /opt /proc /root /run /sbin /shared /srv /sys /tmp /usr /utils /var 4 1 */n u8 swp_flags; /bin /boot /config /dev /etc /home /lib /media /mnt /opt /proc /root /run /sbin /shared /srv /sys /tmp /usr /utils /var 5 1 */n __be16 mss; /bin /boot /config /dev /etc /home /lib /media /mnt /opt /proc /root /run /sbin /shared /srv /sys /tmp /usr /utils /var 6 2 */n __be32 flow_table_metadata; /bin /boot /config /dev /etc /home /lib /media /mnt /opt /proc /root /run /sbin /shared /srv /sys /tmp /usr /utils /var 8 4 */n union {n struct {n __be16 sz; /bin /boot /config /dev /etc /home /lib /media /mnt /opt /proc /root /run /sbin /shared /srv /sys /tmp /usr /utils /var 12 2 */n u8 start[2]; /bin /boot /config /dev /etc /home /lib /media /mnt /opt /proc /root /run /sbin /shared /srv /sys /tmp /usr /utils /var 14 2 */n } inline_hdr; /bin /boot /config /dev /etc /home /lib /media /mnt /opt /proc /root /run /sbin /shared /srv /sys /tmp /usr /utils /var 12 4 */n struct {n __be16 type; /bin /boot /config /dev /etc /home /lib /media /mnt /opt /proc /root /run /sbin /shared /srv /sys /tmp /usr /utils /var 12 2 */n __be16 vlan_tci; /bin /boot /config /dev /etc /home /lib /media /mnt /opt /proc /root /run /sbin /shared /srv /sys /tmp /usr /utils /var 14 2 */n } insert; /bin /boot /config /dev /etc /home /lib /media /mnt /opt /proc /root /run /sbin /shared /srv /sys /tmp /usr /utils /var 12 4 */n __be32 trailer; /bin /boot /config /dev /etc /home /lib /media /mnt /opt /proc /root /run /sbin /shared /srv /sys /tmp /usr /utils /var 12 4 */n }; /bin /boot /config /dev /etc /home /lib /media /mnt /opt /proc /root /run /sbin /shared /srv /sys /tmp /usr /utils /var 12 4 */nn /bin /boot /config /dev /etc /home /lib /media /mnt /opt /proc /root /run /sbin /shared /srv /sys /tmp /usr /utils /var size: 16 cachelines: 1 members: 9 */n /bin /boot /config /dev /etc /home /lib /media /mnt /opt /proc /root /run /sbin /shared /srv /sys /tmp /usr /utils /var last cacheline: 16 bytes */n};nnstruct mlx5_wqe_data_seg {n __be32 byte_count; /bin /boot /config /dev /etc /home /lib /media /mnt /opt /proc /root /run /sbin /shared /srv /sys /tmp /usr /utils /var 0 4 */n __be32 lkey; /bin /boot /config /dev /etc /home /lib /media /mnt /opt /proc /root /run /sbin /shared /srv /sys /tmp /usr /utils /var 4 4 */n __be64 addr; /bin /boot /config /dev /etc /home /lib /media /mnt /opt /proc /root /run /sbin /shared /srv /sys /tmp /usr /utils /var 8 8 */nn /bin /boot /config /dev /etc /home /lib /media /mnt /opt /proc /root /run /sbin /shared /srv /sys /tmp /usr /utils /var size: 16 cachelines: 1 members: 3 */n /bin /boot /config /dev /etc /home /lib /media /mnt /opt /proc /root /run /sbin /shared /srv /sys /tmp /usr /utils /var last cacheline: 16 bytes */n};nnSo split the memcpy() so the compiler can reason about the buffernsizes.nnpahole shows no size nor member offset changes to struct mlx5e_tx_wqennor struct mlx5e_umr_wqe. objdump -d shows no meaningful objectncode changes (i.e. only source line number induced differences andnoptimizations).,CVE-2022-48744,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet/smc: Transitional solution for clcsock race issuennWe encountered a crash in smc_setsockopt() and it is caused bynaccessing smc->clcsock after clcsock was released.nn BUG: kernel NULL pointer dereference address: 0000000000000020n #PF: supervisor read access in kernel moden #PF: error_code(0x0000) - not-present pagen PGD 0 P4D 0n Oops: 0000 [#1] PREEMPT SMP PTIn CPU: 1 PID: 50309 Comm: nginx Kdump: loaded Tainted: G E 5.16.0-rc4+ #53n RIP: 0010:smc_setsockopt+0x59/0x280 [smc]n Call Trace:n <TASK>n __sys_setsockopt+0xfc/0x190n __x64_sys_setsockopt+0x20/0x30n do_syscall_64+0x34/0x90n entry_SYSCALL_64_after_hwframe+0x44/0xaen RIP: 0033:0x7f16ba83918en </TASK>nnThis patch tries to fix it by holding clcsock_release_lock andnchecking whether clcsock has already been released before access.nnIn case that a crash of the same reason happens in smc_getsockopt()nor smc_switch_to_fallback() this patch also checkes smc->clcsocknin them too. And the caller of smc_switch_to_fallback() will identifynwhether fallback succeeds according to the return value.,CVE-2022-48751,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnKVM: LAPIC: Also cancel preemption timer during SET_LAPICnnThe below warning is splatting during guest reboot.nn ------------[ cut here ]------------n WARNING: CPU: 0 PID: 1931 at arch/x86/kvm/x86.c:10322 kvm_arch_vcpu_ioctl_run+0x874/0x880 [kvm]n CPU: 0 PID: 1931 Comm: qemu-system-x86 Tainted: G I 5.17.0-rc1+ #5n RIP: 0010:kvm_arch_vcpu_ioctl_run+0x874/0x880 [kvm]n Call Trace:n <TASK>n kvm_vcpu_ioctl+0x279/0x710 [kvm]n __x64_sys_ioctl+0x83/0xb0n do_syscall_64+0x3b/0xc0n entry_SYSCALL_64_after_hwframe+0x44/0xaen RIP: 0033:0x7fd39797350bnnThis can be triggered by not exposing tsc-deadline mode and doing a reboot innthe guest. The lapic_shutdown() function which is called in sys_reboot pathnwill not disarm the flying timer it just masks LVTT. lapic_shutdown() clearsnAPIC state w/ LVT_MASKED and timer-mode bit is 0 this can trigger timer-modenswitch between tsc-deadline and oneshot/periodic which can result in preemptionntimer be cancelled in apic_update_lvtt(). However We can't depend on this whennnot exposing tsc-deadline mode and oneshot/periodic modes emulated by preemptionntimer. Qemu will synchronise states around reset let's cancel preemption timernunder KVM_SET_LAPIC.,CVE-2022-48765,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Wrap dcn301_calculate_wm_and_dlg for FPU.nnMirrors the logic for dcn30. Cue lots of WARNs and somenkernel panics without this fix.,CVE-2022-48766,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnibmvnic: don't release napi in __ibmvnic_open()nnIf __ibmvnic_open() encounters an error such as when setting link statenit calls release_resources() which frees the napi structures needlessly.nInstead have __ibmvnic_open() only clean up the work it did so far (i.e.ndisable napi and irqs) and leave the rest to the callers.nnIf caller of __ibmvnic_open() is ibmvnic_open() it should release thenresources immediately. If the caller is do_reset() or do_hard_reset()nthey will release the resources on the next reset.nnThis fixes following crash that occurred when running the drmgr commandnseveral times to add/remove a vnic interface:nnt[102056] ibmvnic 30000003 env3: Disabling rx_scrq[6] irqnt[102056] ibmvnic 30000003 env3: Disabling rx_scrq[7] irqnt[102056] ibmvnic 30000003 env3: Replenished 8 poolsntKernel attempted to read user page (10) - exploit attempt? (uid: 0)ntBUG: Kernel NULL pointer dereference on read at 0x00000010ntFaulting instruction address: 0xc000000000a3c840ntOops: Kernel access of bad area sig: 11 [#1]ntLE PAGE_SIZE=64K MMU=Radix SMP NR_CPUS=2048 NUMA pSeriesnt...ntCPU: 9 PID: 102056 Comm: kworker/9:2 Kdump: loaded Not tainted 5.16.0-rc5-autotest-g6441998e2e37 #1ntWorkqueue: events_long __ibmvnic_reset [ibmvnic]ntNIP: c000000000a3c840 LR: c0080000029b5378 CTR: c000000000a3c820ntREGS: c0000000548e37e0 TRAP: 0300 Not tainted (5.16.0-rc5-autotest-g6441998e2e37)ntMSR: 8000000000009033 <SFEEMEIRDRRILE> CR: 28248484 XER: 00000004ntCFAR: c0080000029bdd24 DAR: 0000000000000010 DSISR: 40000000 IRQMASK: 0ntGPR00: c0080000029b55d0 c0000000548e3a80 c0000000028f0200 0000000000000000nt...ntNIP [c000000000a3c840] napi_enable+0x20/0xc0ntLR [c0080000029b5378] __ibmvnic_open+0xf0/0x430 [ibmvnic]ntCall Trace:nt[c0000000548e3a80] [0000000000000006] 0x6 (unreliable)nt[c0000000548e3ab0] [c0080000029b55d0] __ibmvnic_open+0x348/0x430 [ibmvnic]nt[c0000000548e3b40] [c0080000029bcc28] __ibmvnic_reset+0x500/0xdf0 [ibmvnic]nt[c0000000548e3c60] [c000000000176228] process_one_work+0x288/0x570nt[c0000000548e3d00] [c000000000176588] worker_thread+0x78/0x660nt[c0000000548e3da0] [c0000000001822f0] kthread+0x1c0/0x1d0nt[c0000000548e3e10] [c00000000000cf64] ret_from_kernel_thread+0x5c/0x64ntInstruction dump:nt7d2948f8 792307e0 4e800020 60000000 3c4c01eb 384239e0 f821ffd1 39430010nt38a0fff6 e92d1100 f9210028 39200000 <e9030010> f9010020 60420000 e9210020nt---[ end trace 5f8033b08fd27706 ]---,CVE-2022-48811,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet: dsa: seville: register the mdiobus under devresnnAs explained in commits:n74b6d7d13307 (net: dsa: realtek: register the MDIO bus under devres)n5135e96a3dd2 (net: dsa: don't allocate the slave_mii_bus using devres)nnmdiobus_free() will panic when called from devm_mdiobus_free() <-ndevres_release_all() <- __device_release_driver() and that mdiobus wasnnot previously unregistered.nnThe Seville VSC9959 switch is a platform device so the initial set ofnconstraints that I thought would cause this (I2C or SPI buses which calln->remove on ->shutdown) do not apply. But there is one more whichnapplies here.nnIf the DSA master itself is on a bus that calls ->remove from ->shutdownn(like dpaa2-eth which is on the fsl-mc bus) there is a device linknbetween the switch and the DSA master and device_links_unbind_consumers()nwill unbind the seville switch driver on shutdown.nnSo the same treatment must be applied to all DSA switch drivers whichnis: either use devres for both the mdiobus allocation and registrationnor don't use devres at all.nnThe seville driver has a code structure that could accommodate both thenmdiobus_unregister and mdiobus_free calls but it has an externalndependency upon mscc_miim_setup() from mdio-mscc-miim.c which callsndevm_mdiobus_alloc_size() on its behalf. So rather than restructuringnthat and exporting yet one more symbol mscc_miim_teardown() let's worknwith devres and replace of_mdiobus_register with the devres variant.nWhen we use all-devres we can ensure that devres doesn't free anstill-registered bus (it either runs both callbacks or none).,CVE-2022-48814,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnSUNRPC: lock against ->sock changing during sysfs readnn->sock can be set to NULL asynchronously unless ->recv_mutex is held.nSo it is important to hold that mutex. Otherwise a sysfs read canntrigger an oops.nCommit 17f09d3f619a (SUNRPC: Check if the xprt is connected beforenhandling sysfs reads) appears to attempt to fix this problem but itnonly narrows the race window.,CVE-2022-48816,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/vc4: Fix deadlock on DSI device attach errornnDSI device attach to DSI host will be done with host device's locknheld.nnUn-registering host in device attach error path (ex: probe retry)nwill result in deadlock with below call trace and non operationalnDSI display.nnStartup Call trace:n[ 35.043036] rt_mutex_slowlock.constprop.21+0x184/0x1b8n[ 35.043048] mutex_lock_nested+0x7c/0xc8n[ 35.043060] device_del+0x4c/0x3e8n[ 35.043075] device_unregister+0x20/0x40n[ 35.043082] mipi_dsi_remove_device_fn+0x18/0x28n[ 35.043093] device_for_each_child+0x68/0xb0n[ 35.043105] mipi_dsi_host_unregister+0x40/0x90n[ 35.043115] vc4_dsi_host_attach+0xf0/0x120 [vc4]n[ 35.043199] mipi_dsi_attach+0x30/0x48n[ 35.043209] tc358762_probe+0x128/0x164 [tc358762]n[ 35.043225] mipi_dsi_drv_probe+0x28/0x38n[ 35.043234] really_probe+0xc0/0x318n[ 35.043244] __driver_probe_device+0x80/0xe8n[ 35.043254] driver_probe_device+0xb8/0x118n[ 35.043263] __device_attach_driver+0x98/0xe8n[ 35.043273] bus_for_each_drv+0x84/0xd8n[ 35.043281] __device_attach+0xf0/0x150n[ 35.043290] device_initial_probe+0x1c/0x28n[ 35.043300] bus_probe_device+0xa4/0xb0n[ 35.043308] deferred_probe_work_func+0xa0/0xe0n[ 35.043318] process_one_work+0x254/0x700n[ 35.043330] worker_thread+0x4c/0x448n[ 35.043339] kthread+0x19c/0x1a8n[ 35.043348] ret_from_fork+0x10/0x20nnShutdown Call trace:n[ 365.565417] Call trace:n[ 365.565423] __switch_to+0x148/0x200n[ 365.565452] __schedule+0x340/0x9c8n[ 365.565467] schedule+0x48/0x110n[ 365.565479] schedule_timeout+0x3b0/0x448n[ 365.565496] wait_for_completion+0xac/0x138n[ 365.565509] __flush_work+0x218/0x4e0n[ 365.565523] flush_work+0x1c/0x28n[ 365.565536] wait_for_device_probe+0x68/0x158n[ 365.565550] device_shutdown+0x24/0x348n[ 365.565561] kernel_restart_prepare+0x40/0x50n[ 365.565578] kernel_restart+0x20/0x70n[ 365.565591] __do_sys_reboot+0x10c/0x220n[ 365.565605] __arm64_sys_reboot+0x2c/0x38n[ 365.565619] invoke_syscall+0x4c/0x110n[ 365.565634] el0_svc_common.constprop.3+0xfc/0x120n[ 365.565648] do_el0_svc+0x2c/0x90n[ 365.565661] el0_svc+0x4c/0xf0n[ 365.565671] el0t_64_sync_handler+0x90/0xb8n[ 365.565682] el0t_64_sync+0x180/0x184,CVE-2022-48826,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbtrfs: skip reserved bytes warning on unmount after log cleanup failurennAfter the recent changes made by commit c2e39305299f01 (btrfs: clearnextent buffer uptodate when we fail to write it) and its followup fixncommit 651740a5024117 (btrfs: check WRITE_ERR when trying to read annextent buffer) we can now end up not cleaning up space reservations ofnlog tree extent buffers after a transaction abort happens as well as notncleaning up still dirty extent buffers.nnThis happens because if writeback for a log tree extent buffer failednthen we have cleared the bit EXTENT_BUFFER_UPTODATE from the extent buffernand we have also set the bit EXTENT_BUFFER_WRITE_ERR on it. Later onnwhen trying to free the log tree with free_log_tree() which iteratesnover the tree we can end up getting an -EIO error when trying to readna node or a leaf since read_extent_buffer_pages() returns -EIO if annextent buffer does not have EXTENT_BUFFER_UPTODATE set and has thenEXTENT_BUFFER_WRITE_ERR bit set. Getting that -EIO means that we returnnimmediately as we can not iterate over the entire tree.nnIn that case we never update the reserved space for an extent buffer innthe respective block group and space_info object.nnWhen this happens we get the following traces when unmounting the fs:nn[174957.284509] BTRFS: error (device dm-0) in cleanup_transaction:1913: errno=-5 IO failuren[174957.286497] BTRFS: error (device dm-0) in free_log_tree:3420: errno=-5 IO failuren[174957.399379] ------------[ cut here ]------------n[174957.402497] WARNING: CPU: 2 PID: 3206883 at fs/btrfs/block-group.c:127 btrfs_put_block_group+0x77/0xb0 [btrfs]n[174957.407523] Modules linked in: btrfs overlay dm_zero (...)n[174957.424917] CPU: 2 PID: 3206883 Comm: umount Tainted: G W 5.16.0-rc5-btrfs-next-109 #1n[174957.426689] Hardware name: QEMU Standard PC (i440FX + PIIX 1996) BIOS rel-1.14.0-0-g155821a1990b-prebuilt.qemu.org 04/01/2014n[174957.428716] RIP: 0010:btrfs_put_block_group+0x77/0xb0 [btrfs]n[174957.429717] Code: 21 48 8b bd (...)n[174957.432867] RSP: 0018:ffffb70d41cffdd0 EFLAGS: 00010206n[174957.433632] RAX: 0000000000000001 RBX: ffff8b09c3848000 RCX: ffff8b0758edd1c8n[174957.434689] RDX: 0000000000000001 RSI: ffffffffc0b467e7 RDI: ffff8b0758edd000n[174957.436068] RBP: ffff8b0758edd000 R08: 0000000000000000 R09: 0000000000000000n[174957.437114] R10: 0000000000000246 R11: 0000000000000000 R12: ffff8b09c3848148n[174957.438140] R13: ffff8b09c3848198 R14: ffff8b0758edd188 R15: dead000000000100n[174957.439317] FS: 00007f328fb82800(0000) GS:ffff8b0a2d200000(0000) knlGS:0000000000000000n[174957.440402] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033n[174957.441164] CR2: 00007fff13563e98 CR3: 0000000404f4e005 CR4: 0000000000370ee0n[174957.442117] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000n[174957.443076] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400n[174957.443948] Call Trace:n[174957.444264] <TASK>n[174957.444538] btrfs_free_block_groups+0x255/0x3c0 [btrfs]n[174957.445238] close_ctree+0x301/0x357 [btrfs]n[174957.445803] ? call_rcu+0x16c/0x290n[174957.446250] generic_shutdown_super+0x74/0x120n[174957.446832] kill_anon_super+0x14/0x30n[174957.447305] btrfs_kill_super+0x12/0x20 [btrfs]n[174957.447890] deactivate_locked_super+0x31/0xa0n[174957.448440] cleanup_mnt+0x147/0x1c0n[174957.448888] task_work_run+0x5c/0xa0n[174957.449336] exit_to_user_mode_prepare+0x1e5/0x1f0n[174957.449934] syscall_exit_to_user_mode+0x16/0x40n[174957.450512] do_syscall_64+0x48/0xc0n[174957.450980] entry_SYSCALL_64_after_hwframe+0x44/0xaen[174957.451605] RIP: 0033:0x7f328fdc4a97n[174957.452059] Code: 03 0c 00 f7 (...)n[174957.454320] RSP: 002b:00007fff13564ec8 EFLAGS: 00000246 ORIG_RAX: 00000000000000a6n[174957.455262] RAX: 0000000000000000 RBX: 00007f328feea264 RCX: 00007f328fdc4a97n[174957.456131] RDX: 0000000000000000 RSI: 00000000000000n---truncated---,CVE-2022-48833,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnice: Fix race condition during interface enslavennCommit 5dbbbd01cbba83 (ice: Avoid RTNL lock when re-creatingnauxiliary device) changes a process of re-creation of aux devicenso ice_plug_aux_dev() is called from ice_service_task() context.nThis unfortunately opens a race window that can result in dead-locknwhen interface has left LAG and immediately enters LAG again.nnReproducer:n```n#!/bin/shnnip link add lag0 type bond mode 1 miimon 100nip link set lag0nnfor n in {1..10}; don echo Cycle: $nn ip link set ens7f0 master lag0n sleep 1n ip link set ens7f0 nomasterndonen```nnThis results in:n[20976.208697] Workqueue: ice ice_service_task [ice]n[20976.213422] Call Trace:n[20976.215871] __schedule+0x2d1/0x830n[20976.219364] schedule+0x35/0xa0n[20976.222510] schedule_preempt_disabled+0xa/0x10n[20976.227043] __mutex_lock.isra.7+0x310/0x420n[20976.235071] enum_all_gids_of_dev_cb+0x1c/0x100 [ib_core]n[20976.251215] ib_enum_roce_netdev+0xa4/0xe0 [ib_core]n[20976.256192] ib_cache_setup_one+0x33/0xa0 [ib_core]n[20976.261079] ib_register_device+0x40d/0x580 [ib_core]n[20976.266139] irdma_ib_register_device+0x129/0x250 [irdma]n[20976.281409] irdma_probe+0x2c1/0x360 [irdma]n[20976.285691] auxiliary_bus_probe+0x45/0x70n[20976.289790] really_probe+0x1f2/0x480n[20976.298509] driver_probe_device+0x49/0xc0n[20976.302609] bus_for_each_drv+0x79/0xc0n[20976.306448] __device_attach+0xdc/0x160n[20976.310286] bus_probe_device+0x9d/0xb0n[20976.314128] device_add+0x43c/0x890n[20976.321287] __auxiliary_device_add+0x43/0x60n[20976.325644] ice_plug_aux_dev+0xb2/0x100 [ice]n[20976.330109] ice_service_task+0xd0c/0xed0 [ice]n[20976.342591] process_one_work+0x1a7/0x360n[20976.350536] worker_thread+0x30/0x390n[20976.358128] kthread+0x10a/0x120n[20976.365547] ret_from_fork+0x1f/0x40n...n[20976.438030] task:ip state:D stack: 0 pid:213658 ppid:213627 flags:0x00004084n[20976.446469] Call Trace:n[20976.448921] __schedule+0x2d1/0x830n[20976.452414] schedule+0x35/0xa0n[20976.455559] schedule_preempt_disabled+0xa/0x10n[20976.460090] __mutex_lock.isra.7+0x310/0x420n[20976.464364] device_del+0x36/0x3c0n[20976.467772] ice_unplug_aux_dev+0x1a/0x40 [ice]n[20976.472313] ice_lag_event_handler+0x2a2/0x520 [ice]n[20976.477288] notifier_call_chain+0x47/0x70n[20976.481386] __netdev_upper_dev_link+0x18b/0x280n[20976.489845] bond_enslave+0xe05/0x1790 [bonding]n[20976.494475] do_setlink+0x336/0xf50n[20976.502517] __rtnl_newlink+0x529/0x8b0n[20976.543441] rtnl_newlink+0x43/0x60n[20976.546934] rtnetlink_rcv_msg+0x2b1/0x360n[20976.559238] netlink_rcv_skb+0x4c/0x120n[20976.563079] netlink_unicast+0x196/0x230n[20976.567005] netlink_sendmsg+0x204/0x3d0n[20976.570930] sock_sendmsg+0x4c/0x50n[20976.574423] ____sys_sendmsg+0x1eb/0x250n[20976.586807] ___sys_sendmsg+0x7c/0xc0n[20976.606353] __sys_sendmsg+0x57/0xa0n[20976.609930] do_syscall_64+0x5b/0x1a0n[20976.613598] entry_SYSCALL_64_after_hwframe+0x65/0xcann1. Command 'ip link ... set nomaster' causes that ice_plug_aux_dev()n is called from ice_service_task() context aux device is createdn and associated device->lock is taken.n2. Command 'ip link ... set master...' calls ice's notifier undern RTNL lock and that notifier calls ice_unplug_aux_dev(). Thatn function tries to take aux device->lock but this is already takenn by ice_plug_aux_dev() in step 1n3. Later ice_plug_aux_dev() tries to take RTNL lock but this is alreadyn taken in step 2n4. Dead-locknnThe patch fixes this issue by following changes:n- Bit ICE_FLAG_PLUG_AUX_DEV is kept to be set during ice_plug_aux_dev()n call in ice_service_task()n- The bit is checked in ice_clear_rdma_cap() and only if it is not setn then ice_unplug_aux_dev() is called. If it is set (in other wordsn plugging of aux device was requested and ice_plug_aux_dev() isn potentially running) then the function only clears then---truncated---,CVE-2022-48842,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnBluetooth: hci_core: Fix leaking sent_cmd skbnnsent_cmd memory is not freed before freeing hci_dev causing it to leaknit contents.,CVE-2022-48844,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amdgpu: bypass tiling flag check in virtual display case (v2)nnvkms leverages common amdgpu framebuffer creation andnalso as it does not support FB modifier there is no neednto check tiling flags when initing framebuffer when virtualndisplay is enabled.nnThis can fix below calltrace:nnamdgpu 0000:00:08.0: GFX9+ requires FB check based on format modifiernWARNING: CPU: 0 PID: 1023 at drivers/gpu/drm/amd/amdgpu/amdgpu_display.c:1150 amdgpu_display_framebuffer_init+0x8e7/0xb40 [amdgpu]nnv2: check adev->enable_virtual_display instead as vkms can bentenabled in bare metal as well.,CVE-2022-48849,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/vc4: hdmi: Unregister codec device on unbindnnOn bind we will register the HDMI codec device but we don't unregisternit on unbind leading to a device leakage. Unregister our device atnunbind.,CVE-2022-48852,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet: marvell: prestera: Add missing of_node_put() in prestera_switch_set_base_mac_addrnnThis node pointer is returned by of_find_compatible_node() withnrefcount incremented. Calling of_node_put() to aovid the refcount leak.,CVE-2022-48859,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnvhost: fix hung thread due to erroneous iotlb entriesnnIn vhost_iotlb_add_range_ctx() range size can overflow to 0 whennstart is 0 and last is ULONG_MAX. One instance where it can happennis when userspace sends an IOTLB message with iova=size=uaddr=0n(vhost_process_iotlb_msg). So an entry with size = 0 start = 0nlast = ULONG_MAX ends up in the iotlb. Next time a packet is sentniotlb_access_ok() loops indefinitely due to that erroneous entry.nntCall Trace:nt <TASK>nt iotlb_access_ok+0x21b/0x3e0 drivers/vhost/vhost.c:1340nt vq_meta_prefetch+0xbc/0x280 drivers/vhost/vhost.c:1366nt vhost_transport_do_send_pkt+0xe0/0xfd0 drivers/vhost/vsock.c:104nt vhost_worker+0x23d/0x3d0 drivers/vhost/vhost.c:372nt kthread+0x2e9/0x3a0 kernel/kthread.c:377nt ret_from_fork+0x1f/0x30 arch/x86/entry/entry_64.S:295nt </TASK>nnReported by syzbot at:nthttps://syzkaller.appspot.com/bug?extid=0abd373e2e50d704db87nnTo fix this do two things:nn1. Return -EINVAL in vhost_chr_write_iter() when userspace asks to mapn a range with size 0.n2. Fix vhost_iotlb_add_range_ctx() to handle the range [0 ULONG_MAX]n by splitting it into two entries.,CVE-2022-48862,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/vmwgfx: Remove rcu locks from user resourcesnnUser resource lookups used rcu to avoid two extra atomics. Unfortunatelynthe rcu paths were buggy and it was easy to make the driver crash bynsubmitting command buffers from two different threads. Because thenlookups never show up in performance profiles replace them with anregular spin lock which fixes the races in accesses to those sharednresources.nnFixes kernel oops'es in IGT's vmwgfx execution_buffer stress test andnseen crashes with apps using shared resources.,CVE-2022-48887,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/i915/gt: Cleanup partial engine discovery failuresnnIf we abort driver initialisation in the middle of gt/engine discoverynsome engines will be fully setup and some not. Those incompletely setupnengines only have 'engine->release == NULL' and so will leak any of thencommon objects allocated.nnv2:n - Drop the destroy_pinned_context() helper for now. It's not reallyn worth it with just a single callsite at the moment. (Janusz),CVE-2022-48893,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbtrfs: do not start relocation until in progress drops are donennWe hit a bug with a recovering relocation on mount for one of our filensystems in production. I reproduced this locally by injecting errorsninto snapshot delete with balance running at the same time. Thisnpresented as an error while looking up an extent itemnn WARNING: CPU: 5 PID: 1501 at fs/btrfs/extent-tree.c:866 lookup_inline_extent_backref+0x647/0x680n CPU: 5 PID: 1501 Comm: btrfs-balance Not tainted 5.16.0-rc8+ #8n RIP: 0010:lookup_inline_extent_backref+0x647/0x680n RSP: 0018:ffffae0a023ab960 EFLAGS: 00010202n RAX: 0000000000000001 RBX: 0000000000000000 RCX: 0000000000000000n RDX: 0000000000000000 RSI: 000000000000000c RDI: 0000000000000000n RBP: ffff943fd2a39b60 R08: 0000000000000000 R09: 0000000000000001n R10: 0001434088152de0 R11: 0000000000000000 R12: 0000000001d05000n R13: ffff943fd2a39b60 R14: ffff943fdb96f2a0 R15: ffff9442fc923000n FS: 0000000000000000(0000) GS:ffff944e9eb40000(0000) knlGS:0000000000000000n CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033n CR2: 00007f1157b1fca8 CR3: 000000010f092000 CR4: 0000000000350ee0n Call Trace:n <TASK>n insert_inline_extent_backref+0x46/0xd0n __btrfs_inc_extent_ref.isra.0+0x5f/0x200n ? btrfs_merge_delayed_refs+0x164/0x190n __btrfs_run_delayed_refs+0x561/0xfa0n ? btrfs_search_slot+0x7b4/0xb30n ? btrfs_update_root+0x1a9/0x2c0n btrfs_run_delayed_refs+0x73/0x1f0n ? btrfs_update_root+0x1a9/0x2c0n btrfs_commit_transaction+0x50/0xa50n ? btrfs_update_reloc_root+0x122/0x220n prepare_to_merge+0x29f/0x320n relocate_block_group+0x2b8/0x550n btrfs_relocate_block_group+0x1a6/0x350n btrfs_relocate_chunk+0x27/0xe0n btrfs_balance+0x777/0xe60n balance_kthread+0x35/0x50n ? btrfs_balance+0xe60/0xe60n kthread+0x16b/0x190n ? set_kthread_struct+0x40/0x40n ret_from_fork+0x22/0x30n </TASK>nnNormally snapshot deletion and relocation are excluded from running atnthe same time by the fs_info->cleaner_mutex. However if we had anpending balance waiting to get the ->cleaner_mutex and a snapshotndeletion was running and then the box crashed we would come up in anstate where we have a half deleted snapshot.nnAgain in the normal case the snapshot deletion needs to complete beforenrelocation can start but in this case relocation could very well startnbefore the snapshot deletion completes as we simply add the root to thendead roots list and wait for the next time the cleaner runs to clean upnthe snapshot.nnFix this by setting a bit on the fs_info if we have any DEAD_ROOT's thatnhad a pending drop_progress key. If they do then we know we were in thenmiddle of the drop operation and set a flag on the fs_info. Thennbalance can wait until this flag is cleared to start up again.nnIf there are DEAD_ROOT's that don't have a drop_progress set then we'rensafe to start balance right away as we'll be properly protected by thencleaner_mutex.,CVE-2022-48901,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbtrfs: do not WARN_ON() if we have PageError setnnWhenever we do any extent buffer operations we callnassert_eb_page_uptodate() to complain loudly if we're operating on annnon-uptodate page. Our overnight tests caught this warning earlier thisnweeknn WARNING: CPU: 1 PID: 553508 at fs/btrfs/extent_io.c:6849 assert_eb_page_uptodate+0x3f/0x50n CPU: 1 PID: 553508 Comm: kworker/u4:13 Tainted: G W 5.17.0-rc3+ #564n Hardware name: QEMU Standard PC (Q35 + ICH9 2009) BIOS 1.13.0-2.fc32 04/01/2014n Workqueue: btrfs-cache btrfs_work_helpern RIP: 0010:assert_eb_page_uptodate+0x3f/0x50n RSP: 0018:ffffa961440a7c68 EFLAGS: 00010246n RAX: 0017ffffc0002112 RBX: ffffe6e74453f9c0 RCX: 0000000000001000n RDX: ffffe6e74467c887 RSI: ffffe6e74453f9c0 RDI: ffff8d4c5efc2fc0n RBP: 0000000000000d56 R08: ffff8d4d4a224000 R09: 0000000000000000n R10: 00015817fa9d1ef0 R11: 000000000000000c R12: 00000000000007b1n R13: ffff8d4c5efc2fc0 R14: 0000000001500000 R15: 0000000001cb1000n FS: 0000000000000000(0000) GS:ffff8d4dbbd00000(0000) knlGS:0000000000000000n CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033n CR2: 00007ff31d3448d8 CR3: 0000000118be8004 CR4: 0000000000370ee0n Call Trace:nn extent_buffer_test_bit+0x3f/0x70n free_space_test_bit+0xa6/0xc0n load_free_space_tree+0x1f6/0x470n caching_thread+0x454/0x630n ? rcu_read_lock_sched_held+0x12/0x60n ? rcu_read_lock_sched_held+0x12/0x60n ? rcu_read_lock_sched_held+0x12/0x60n ? lock_release+0x1f0/0x2d0n btrfs_work_helper+0xf2/0x3e0n ? lock_release+0x1f0/0x2d0n ? finish_task_switch.isra.0+0xf9/0x3a0n process_one_work+0x26d/0x580n ? process_one_work+0x580/0x580n worker_thread+0x55/0x3b0n ? process_one_work+0x580/0x580n kthread+0xf0/0x120n ? kthread_complete_and_exit+0x20/0x20n ret_from_fork+0x1f/0x30nnThis was partially fixed by c2e39305299f01 (btrfs: clear extent buffernuptodate when we fail to write it) however all that fix did was keepnus from finding extent buffers after a failed writeout. It didn't keepnus from continuing to use a buffer that we already had found.nnIn this case we're searching the commit root to cache the block groupnso we can start committing the transaction and switch the commit rootnand then start writing. After the switch we can look up an extentnbuffer that hasn't been written yet and start processing that blockngroup. Then we fail to write that block out and clear Uptodate on thenpage and then we start spewing these errors.nnNormally we're protected by the tree lock to a certain degree here. Ifnwe read a block we have that block read locked and we block the writernfrom locking the block before we submit it for the write. However thisnisn't necessarily fool proof because the read could happen before we donthe submit_bio and after we locked and unlocked the extent buffer.nnAlso in this particular case we have path->skip_locking set so thatnwon't save us here. We'll simply get a block that was valid when wenread it but became invalid while we were using it.nnWhat we really want is to catch the case where we've read a block butnit's not marked Uptodate. On read we ClearPageError() so if we'ren!Uptodate and !Error we know we didn't do the right thing for readingnthe page.nnFix this by checking !Uptodate && !Error this way we will not complainnif our buffer gets invalidated while we're using it and we'll maintainnthe spirit of the check which is to make sure we have a fully in-cachenblock while we're messing with it.,CVE-2022-48902,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbtrfs: get rid of warning on transaction commit when using flushoncommitnnWhen using the flushoncommit mount option during almost every transactionncommit we trigger a warning from __writeback_inodes_sb_nr():nn $ cat fs/fs-writeback.c:n (...)n static void __writeback_inodes_sb_nr(struct super_block *sb ...n {n (...)n WARN_ON(!rwsem_is_locked(&sb->s_umount));n (...)n }n (...)nnThe trace produced in dmesg looks like the following:nn [947.473890] WARNING: CPU: 5 PID: 930 at fs/fs-writeback.c:2610 __writeback_inodes_sb_nr+0x7e/0xb3n [947.481623] Modules linked in: nfsd nls_cp437 cifs asn1_decoder cifs_arc4 fscache cifs_md4 ipmi_ssifn [947.489571] CPU: 5 PID: 930 Comm: btrfs-transacti Not tainted 95.16.3-srb-asrock-00001-g36437ad63879 #186n [947.497969] RIP: 0010:__writeback_inodes_sb_nr+0x7e/0xb3n [947.502097] Code: 24 10 4c 89 44 24 18 c6 (...)n [947.519760] RSP: 0018:ffffc90000777e10 EFLAGS: 00010246n [947.523818] RAX: 0000000000000000 RBX: 0000000000963300 RCX: 0000000000000000n [947.529765] RDX: 0000000000000000 RSI: 000000000000fa51 RDI: ffffc90000777e50n [947.535740] RBP: ffff888101628a90 R08: ffff888100955800 R09: ffff888100956000n [947.541701] R10: 0000000000000002 R11: 0000000000000001 R12: ffff888100963488n [947.547645] R13: ffff888100963000 R14: ffff888112fb7200 R15: ffff888100963460n [947.553621] FS: 0000000000000000(0000) GS:ffff88841fd40000(0000) knlGS:0000000000000000n [947.560537] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033n [947.565122] CR2: 0000000008be50c4 CR3: 000000000220c000 CR4: 00000000001006e0n [947.571072] Call Trace:n [947.572354] <TASK>n [947.573266] btrfs_commit_transaction+0x1f1/0x998n [947.576785] ? start_transaction+0x3ab/0x44en [947.579867] ? schedule_timeout+0x8a/0xddn [947.582716] transaction_kthread+0xe9/0x156n [947.585721] ? btrfs_cleanup_transaction.isra.0+0x407/0x407n [947.590104] kthread+0x131/0x139n [947.592168] ? set_kthread_struct+0x32/0x32n [947.595174] ret_from_fork+0x22/0x30n [947.597561] </TASK>n [947.598553] ---[ end trace 644721052755541c ]---nnThis is because we started using writeback_inodes_sb() to flush delallocnwhen committing a transaction (when using -o flushoncommit) in order tonavoid deadlocks with filesystem freeze operations. This change was madenby commit ce8ea7cc6eb313 (btrfs: don't call btrfs_start_delalloc_rootsnin flushoncommit). After that change we started producing that warningnand every now and then a user reports this since the warning happens toonoften it spams dmesg/syslog and a user is unsure if this reflects anynproblem that might compromise the filesystem's reliability.nnWe can not just lock the sb->s_umount semaphore before callingnwriteback_inodes_sb() because that would at least deadlock withnfilesystem freezing since at fs/super.c:freeze_super() sync_filesystem()nis called while we are holding that semaphore in write mode and that canntrigger a transaction commit resulting in a deadlock. It would alsontrigger the same type of deadlock in the unmount path. Possibly it couldnalso introduce some other locking dependencies that lockdep would report.nnTo fix this call try_to_writeback_inodes_sb() instead ofnwriteback_inodes_sb() because that will try to read lock sb->s_umountnand then will only call writeback_inodes_sb() if it was able to lock it.nThis is fine because the cases where it can't read lock sb->s_umountnare during a filesystem unmount or during a filesystem freeze - in thosencases sb->s_umount is write locked and sync_filesystem() is called whichncalls writeback_inodes_sb(). In other words in all cases where we can'tntake a read lock on sb->s_umount writeback is already being triggerednelsewhere.nnAn alternative would be to call btrfs_start_delalloc_roots() with annumber of pages different from LONG_MAX for example matching the numbernof delalloc bytes we currently have in n---truncated---,CVE-2022-48920,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbtrfs: prevent copying too big compressed lzo segmentnnCompressed length can be corrupted to be a lot larger than memorynwe have allocated for buffer.nThis will cause memcpy in copy_compressed_segment to write outsidenof allocated memory.nnThis mostly results in stuck read syscall but sometimes when usingnbtrfs send can get #GPnn kernel: general protection fault probably for non-canonical address 0x841551d5c1000: 0000 [#1] PREEMPT SMP NOPTIn kernel: CPU: 17 PID: 264 Comm: kworker/u256:7 Tainted: P OE 5.17.0-rc2-1 #12n kernel: Workqueue: btrfs-endio btrfs_work_helper [btrfs]n kernel: RIP: 0010:lzo_decompress_bio (./include/linux/fortify-string.h:225 fs/btrfs/lzo.c:322 fs/btrfs/lzo.c:394) btrfsn Code starting with the faulting instructionn ===========================================n 0:* 48 8b 06 mov (%rsi)%rax <-- trapping instructionn 3: 48 8d 79 08 lea 0x8(%rcx)%rdin 7: 48 83 e7 f8 and $0xfffffffffffffff8%rdin b: 48 89 01 mov %rax(%rcx)n e: 44 89 f0 mov %r14d%eaxn 11: 48 8b 54 06 f8 mov -0x8(%rsi%rax1)%rdxn kernel: RSP: 0018:ffffb110812efd50 EFLAGS: 00010212n kernel: RAX: 0000000000001000 RBX: 000000009ca264c8 RCX: ffff98996e6d8ff8n kernel: RDX: 0000000000000064 RSI: 000841551d5c1000 RDI: ffffffff9500435dn kernel: RBP: ffff989a3be856c0 R08: 0000000000000000 R09: 0000000000000000n kernel: R10: 0000000000000000 R11: 0000000000001000 R12: ffff98996e6d8000n kernel: R13: 0000000000000008 R14: 0000000000001000 R15: 000841551d5c1000n kernel: FS: 0000000000000000(0000) GS:ffff98a09d640000(0000) knlGS:0000000000000000n kernel: CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033n kernel: CR2: 00001e9f984d9ea8 CR3: 000000014971a000 CR4: 00000000003506e0n kernel: Call Trace:n kernel: <TASK>n kernel: end_compressed_bio_read (fs/btrfs/compression.c:104 fs/btrfs/compression.c:1363 fs/btrfs/compression.c:323) btrfsn kernel: end_workqueue_fn (fs/btrfs/disk-io.c:1923) btrfsn kernel: btrfs_work_helper (fs/btrfs/async-thread.c:326) btrfsn kernel: process_one_work (./arch/x86/include/asm/jump_label.h:27 ./include/linux/jump_label.h:212 ./include/trace/events/workqueue.h:108 kernel/workqueue.c:2312)n kernel: worker_thread (./include/linux/list.h:292 kernel/workqueue.c:2455)n kernel: ? process_one_work (kernel/workqueue.c:2397)n kernel: kthread (kernel/kthread.c:377)n kernel: ? kthread_complete_and_exit (kernel/kthread.c:332)n kernel: ret_from_fork (arch/x86/entry/entry_64.S:301)n kernel: </TASK>,CVE-2022-48923,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbpf: Fix crash due to out of bounds access into reg2btf_ids.nnWhen commit e6ac2450d6de (bpf: Support bpf program calling kernel function) addednkfunc support it defined reg2btf_ids as a cheap way to translate the verifiernreg type to the appropriate btf_vmlinux BTF ID howeverncommit c25b2ae13603 (bpf: Replace PTR_TO_XXX_OR_NULL with PTR_TO_XXX | PTR_MAYBE_NULL)nmoved the __BPF_REG_TYPE_MAX from the last member of bpf_reg_type enum to afternthe base register types and defined other variants using type flagncomposition. However now the direct usage of reg->type to index intonreg2btf_ids may no longer fall into __BPF_REG_TYPE_MAX range and hence lead tonout of bounds access and kernel crash on dereference of bad pointer.,CVE-2022-48929,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnsched: Fix yet more sched_fork() racesnnWhere commit 4ef0c5c6b5ba (kernel/sched: Fix sched_fork() access anninvalid sched_task_group) fixed a fork race vs cgroup it opened up anrace vs syscalls by not placing the task on the runqueue before itngets exposed through the pidhash.nnCommit 13765de8148f (sched/fair: Fix fault in reweight_entity) isntrying to fix a single instance of this instead fix the whole classnof issues effectively reverting this commit.,CVE-2022-48944,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnperf: Fix perf_pending_task() UaFnnPer syzbot it is possible for perf_pending_task() to run after thenevent is free()'d. There are two related but distinct cases:nn - the task_work was already queued before destroying the event;n - destroying the event itself queues the task_work.nnThe first cannot be solved using task_work_cancel() sincenperf_release() itself might be called from a task_work (____fput)nwhich means the current->task_works list is already empty andntask_work_cancel() won't be able to find the perf_pending_task()nentry.nnThe simplest alternative is extending the perf_event lifetime to covernthe task_work.nnThe second is just silly queueing a task_work while you know thenevent is going away makes no sense and is easily avoided bynre-arranging how the event is marked STATE_DEAD and ensuring it goesnthrough STATE_OFF on the way down.,CVE-2022-48950,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnPCI: mt7621: Add sentinel to quirks tablennCurrent driver is missing a sentinel in the struct soc_device_attributenarray which causes an oops when assessed by thensoc_device_match(mt7621_pcie_quirks_match) call.nnThis was only exposed once the CONFIG_SOC_MT7621 mt7621 soc_dev_attrnwas fixed to register the SOC as a device in:nncommit 7c18b64bba3b (mips: ralink: mt7621: do not use kzalloc too early)nnFix it by adding the required sentinel.,CVE-2022-48952,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet: mdio: fix unbalanced fwnode reference count in mdio_device_release()nnThere is warning report about of_node refcount leaknwhile probing mdio device:nnOF: ERROR: memory leak expected refcount 1 instead of 2nof_node_get()/of_node_put() unbalanced - destroy cset entry:nattach overlay node /spi/soc@0/mdio@710700c0/ethernet@4nnIn of_mdiobus_register_device() we increase fwnode refcountnby fwnode_handle_get() before associating the of_node withnmdio device but it has never been decreased in normal path.nSince that in mdio_device_release() it needs to callnfwnode_handle_put() in addition instead of calling kfree()ndirectly.nnAfter above just calling mdio_device_free() in the error handlenpath of of_mdiobus_register_device() is enough to keep thenrefcount balanced.,CVE-2022-48961,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nngpiolib: fix memory leak in gpiochip_setup_dev()nnHere is a backtrace report about memory leak detected inngpiochip_setup_dev():nnunreferenced object 0xffff88810b406400 (size 512):n comm python3 pid 1682 jiffies 4295346908 (age 24.090s)n backtrace:n kmalloc_tracen device_addttdevice_private_init at drivers/base/core.c:3361nttt(inlined by) device_add at drivers/base/core.c:3411n cdev_device_addn gpiolib_cdev_registern gpiochip_setup_devn gpiochip_add_data_with_keynngcdev_register() & gcdev_unregister() would call device_add() &ndevice_del() (no matter CONFIG_GPIO_CDEV is enabled or not) tonregister/unregister device.nnHowever if device_add() succeeds some resource (likenstruct device_private allocated by device_private_init())nis not released by device_del().nnTherefore after device_add() succeeds by gcdev_register() itnneeds to call put_device() to release resource in the error handlenpath.nnHere we move forward the register of release function and let itnrelease every piece of resource by put_device() instead of kfree().nnWhile at it fix another subtle issue i.e. when gc->ngpio is equalnto 0 we still call kcalloc() and in case of further error kfree()non the ZERO_PTR pointer which is not NULL. It's not a bug per senbut rather waste of the resources and potentially wrong expectationnabout contents of the gdev->descs variable.,CVE-2022-48975,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: fix array index out of bound error in DCN32 DMLnn[Why&How]nLinkCapacitySupport array is indexed with the number of voltage states andnnot the number of max DPPs. Fix the error by changing the arrayndeclaration to use the correct (larger) array size of total number ofnvoltage states.,CVE-2022-48979,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amdgpu: fix use-after-free during gpu recoverynn[Why]n [ 754.862560] refcount_t: underflow; use-after-free.n [ 754.862898] Call Trace:n [ 754.862903] <TASK>n [ 754.862913] amdgpu_job_free_cb+0xc2/0xe1 [amdgpu]n [ 754.863543] drm_sched_main.cold+0x34/0x39 [amd_sched]nn[How]n The fw_fence may be not init check whether dma_fence_initn is performed before job free,CVE-2022-48990,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnriscv: Sync efi page table's kernel mappings before switchingnnThe EFI page table is initially created as a copy of the kernel page table.nWith VMAP_STACK enabled kernel stacks are allocated in the vmalloc area:nif the stack is allocated in a new PGD (one that was not present at thenmoment of the efi page table creation or not synced in a previous vmallocnfault) the kernel will take a trap when switching to the efi page tablenwhen the vmalloc kernel stack is accessed resulting in a kernel panic.nnFix that by updating the efi kernel mappings before switching to the efinpage table.,CVE-2022-49004,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnsh: cpuinfo: Fix a warning for CONFIG_CPUMASK_OFFSTACKnnWhen CONFIG_CPUMASK_OFFSTACK and CONFIG_DEBUG_PER_CPU_MAPS are selectedncpu_max_bits_warn() generates a runtime warning similar as below whennshowing /proc/cpuinfo. Fix this by using nr_cpu_ids (the runtime limit)ninstead of NR_CPUS to iterate CPUs.nn[ 3.052463] ------------[ cut here ]------------n[ 3.059679] WARNING: CPU: 3 PID: 1 at include/linux/cpumask.h:108 show_cpuinfo+0x5e8/0x5f0n[ 3.070072] Modules linked in: efivarfs autofs4n[ 3.076257] CPU: 0 PID: 1 Comm: systemd Not tainted 5.19-rc5+ #1052n[ 3.099465] Stack : 9000000100157b08 9000000000f18530 9000000000cf846c 9000000100154000n[ 3.109127] 9000000100157a50 0000000000000000 9000000100157a58 9000000000ef7430n[ 3.118774] 90000001001578e8 0000000000000040 0000000000000020 ffffffffffffffffn[ 3.128412] 0000000000aaaaaa 1ab25f00eec96a37 900000010021de80 900000000101c890n[ 3.138056] 0000000000000000 0000000000000000 0000000000000000 0000000000aaaaaan[ 3.147711] ffff8000339dc220 0000000000000001 0000000006ab4000 0000000000000000n[ 3.157364] 900000000101c998 0000000000000004 9000000000ef7430 0000000000000000n[ 3.167012] 0000000000000009 000000000000006c 0000000000000000 0000000000000000n[ 3.176641] 9000000000d3de08 9000000001639390 90000000002086d8 00007ffff0080286n[ 3.186260] 00000000000000b0 0000000000000004 0000000000000000 0000000000071c1cn[ 3.195868] ...n[ 3.199917] Call Trace:n[ 3.203941] [<90000000002086d8>] show_stack+0x38/0x14cn[ 3.210666] [<9000000000cf846c>] dump_stack_lvl+0x60/0x88n[ 3.217625] [<900000000023d268>] __warn+0xd0/0x100n[ 3.223958] [<9000000000cf3c90>] warn_slowpath_fmt+0x7c/0xccn[ 3.231150] [<9000000000210220>] show_cpuinfo+0x5e8/0x5f0n[ 3.238080] [<90000000004f578c>] seq_read_iter+0x354/0x4b4n[ 3.245098] [<90000000004c2e90>] new_sync_read+0x17c/0x1c4n[ 3.252114] [<90000000004c5174>] vfs_read+0x138/0x1d0n[ 3.258694] [<90000000004c55f8>] ksys_read+0x70/0x100n[ 3.265265] [<9000000000cfde9c>] do_syscall+0x7c/0x94n[ 3.271820] [<9000000000202fe4>] handle_syscall+0xc4/0x160n[ 3.281824] ---[ end trace 8b484262b4b8c24c ]---,CVE-2022-49034,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nni2c: dev: check return value when calling dev_set_name()nnIf dev_set_name() fails the dev_name() is null check the returnnvalue of dev_set_name() to avoid the null-ptr-deref.,CVE-2022-49046,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnDrivers: hv: vmbus: Deactivate sysctl_record_panic_msg by default in isolated guestsnnhv_panic_page might contain guest-sensitive information do not dump itnover to Hyper-V by default in isolated guests.nnWhile at it update some comments in hyperv_{panicdie}_event().,CVE-2022-49054,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnice: arfs: fix use-after-free when freeing @rx_cpu_rmapnnThe CI testing bots triggered the following splat:nn[ 718.203054] BUG: KASAN: use-after-free in free_irq_cpu_rmap+0x53/0x80n[ 718.206349] Read of size 4 at addr ffff8881bd127e00 by task sh/20834n[ 718.212852] CPU: 28 PID: 20834 Comm: sh Kdump: loaded Tainted: G S W IOE 5.17.0-rc8_nextqueue-devqueue-02643-g23f3121aca93 #1n[ 718.219695] Hardware name: Intel Corporation S2600WFT/S2600WFT BIOS SE5C620.86B.02.01.0012.070720200218 07/07/2020n[ 718.223418] Call Trace:n[ 718.227139]n[ 718.230783] dump_stack_lvl+0x33/0x42n[ 718.234431] print_address_description.constprop.9+0x21/0x170n[ 718.238177] ? free_irq_cpu_rmap+0x53/0x80n[ 718.241885] ? free_irq_cpu_rmap+0x53/0x80n[ 718.245539] kasan_report.cold.18+0x7f/0x11bn[ 718.249197] ? free_irq_cpu_rmap+0x53/0x80n[ 718.252852] free_irq_cpu_rmap+0x53/0x80n[ 718.256471] ice_free_cpu_rx_rmap.part.11+0x37/0x50 [ice]n[ 718.260174] ice_remove_arfs+0x5f/0x70 [ice]n[ 718.263810] ice_rebuild_arfs+0x3b/0x70 [ice]n[ 718.267419] ice_rebuild+0x39c/0xb60 [ice]n[ 718.270974] ? asm_sysvec_apic_timer_interrupt+0x12/0x20n[ 718.274472] ? ice_init_phy_user_cfg+0x360/0x360 [ice]n[ 718.278033] ? delay_tsc+0x4a/0xb0n[ 718.281513] ? preempt_count_sub+0x14/0xc0n[ 718.284984] ? delay_tsc+0x8f/0xb0n[ 718.288463] ice_do_reset+0x92/0xf0 [ice]n[ 718.292014] ice_pci_err_resume+0x91/0xf0 [ice]n[ 718.295561] pci_reset_function+0x53/0x80n<...>n[ 718.393035] Allocated by task 690:n[ 718.433497] Freed by task 20834:n[ 718.495688] Last potentially related work creation:n[ 718.568966] The buggy address belongs to the object at ffff8881bd127e00n which belongs to the cache kmalloc-96 of size 96n[ 718.574085] The buggy address is located 0 bytes inside ofn 96-byte region [ffff8881bd127e00 ffff8881bd127e60)n[ 718.579265] The buggy address belongs to the page:n[ 718.598905] Memory state around the buggy address:n[ 718.601809] ffff8881bd127d00: fa fb fb fb fb fb fb fb fb fb fb fb fc fc fc fcn[ 718.604796] ffff8881bd127d80: 00 00 00 00 00 00 00 00 00 00 fc fc fc fc fc fcn[ 718.607794] >ffff8881bd127e00: fa fb fb fb fb fb fb fb fb fb fb fb fc fc fc fcn[ 718.610811] ^n[ 718.613819] ffff8881bd127e80: 00 00 00 00 00 00 00 00 00 00 00 00 fc fc fc fcn[ 718.617107] ffff8881bd127f00: fa fb fb fb fb fb fb fb fb fb fb fb fc fc fc fcnnThis is due to that free_irq_cpu_rmap() is always being calledn*after* (devm_)free_irq() and thus it tries to work with IRQ descsnalready freed. For example on device reset the driver frees thenrmap right before allocating a new one (the splat above).nMake rmap creation and freeing function symmetrical withn{requestfree}_irq() calls i.e. do that on ifup/ifdown insteadnof device probe/remove/resume. These operations can be performednindependently from the actual device aRFS configuration.nAlso make sure ice_vsi_free_irq() clears IRQ affinity notifiersnonly when aRFS is disabled -- otherwise CPU rmap sets and clearsnits own and they must not be touched manually.,CVE-2022-49063,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Fix by adding FPU protection for dcn30_internal_validate_bwnn[Why]nBelow general protection fault observed when WebGL Aquarium is run fornlonger duration. If drm debug logs are enabled and set to 0x1f then thenissue is observed within 10 minutes of run.nn[ 100.717056] general protection fault probably for non-canonical address 0x2d33302d32323032: 0000 [#1] PREEMPT SMP NOPTIn[ 100.727921] CPU: 3 PID: 1906 Comm: DrmThread Tainted: G W 5.15.30 #12 d726c6a2d6ebe5cf9223931cbca6892f916fe18bn[ 100.754419] RIP: 0010:CalculateSwathWidth+0x1f7/0x44fn[ 100.767109] Code: 00 00 00 f2 42 0f 11 04 f0 48 8b 85 88 00 00 00 f2 42 0f 10 04 f0 48 8b 85 98 00 00 00 f2 42 0f 11 04 f0 48 8b 45 10 0f 57 c0 <f3> 42 0f 2a 04 b0 0f 57 c9 f3 43 0f 2a 0c b4 e8 8c e2 f3 ff 48 8bn[ 100.781269] RSP: 0018:ffffa9230079eeb0 EFLAGS: 00010246n[ 100.812528] RAX: 2d33302d32323032 RBX: 0000000000000500 RCX: 0000000000000000n[ 100.819656] RDX: 0000000000000001 RSI: ffff99deb712c49c RDI: 0000000000000000n[ 100.826781] RBP: ffffa9230079ef50 R08: ffff99deb712460c R09: ffff99deb712462cn[ 100.833907] R10: ffff99deb7124940 R11: ffff99deb7124d70 R12: ffff99deb712ae44n[ 100.841033] R13: 0000000000000001 R14: 0000000000000000 R15: ffffa9230079f0a0n[ 100.848159] FS: 00007af121212640(0000) GS:ffff99deba780000(0000) knlGS:0000000000000000n[ 100.856240] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033n[ 100.861980] CR2: 0000209000fe1000 CR3: 000000011b18c000 CR4: 0000000000350ee0n[ 100.869106] Call Trace:n[ 100.871555] <TASK>n[ 100.873655] ? asm_sysvec_reschedule_ipi+0x12/0x20n[ 100.878449] CalculateSwathAndDETConfiguration+0x1a3/0x6ddn[ 100.883937] dml31_ModeSupportAndSystemConfigurationFull+0x2ce4/0x76dan[ 100.890467] ? kallsyms_lookup_buildid+0xc8/0x163n[ 100.895173] ? kallsyms_lookup_buildid+0xc8/0x163n[ 100.899874] ? __sprint_symbol+0x80/0x135n[ 100.903883] ? dm_update_plane_state+0x3f9/0x4d2n[ 100.908500] ? symbol_string+0xb7/0xden[ 100.912250] ? number+0x145/0x29bn[ 100.915566] ? vsnprintf+0x341/0x5ffn[ 100.919141] ? desc_read_finalized_seq+0x39/0x87n[ 100.923755] ? update_load_avg+0x1b9/0x607n[ 100.927849] ? compute_mst_dsc_configs_for_state+0x7d/0xd5bn[ 100.933416] ? fetch_pipe_params+0xa4d/0xd0cn[ 100.937686] ? dc_fpu_end+0x3d/0xa8n[ 100.941175] dml_get_voltage_level+0x16b/0x180n[ 100.945619] dcn30_internal_validate_bw+0x10e/0x89bn[ 100.950495] ? dcn31_validate_bandwidth+0x68/0x1fcn[ 100.955285] ? resource_build_scaling_params+0x98b/0xb8cn[ 100.960595] ? dcn31_validate_bandwidth+0x68/0x1fcn[ 100.965384] dcn31_validate_bandwidth+0x9a/0x1fcn[ 100.970001] dc_validate_global_state+0x238/0x295n[ 100.974703] amdgpu_dm_atomic_check+0x9c1/0xbcen[ 100.979235] ? _printk+0x59/0x73n[ 100.982467] drm_atomic_check_only+0x403/0x78bn[ 100.986912] drm_mode_atomic_ioctl+0x49b/0x546n[ 100.991358] ? drm_ioctl+0x1c1/0x3b3n[ 100.994936] ? drm_atomic_set_property+0x92a/0x92an[ 100.999725] drm_ioctl_kernel+0xdc/0x149n[ 101.003648] drm_ioctl+0x27f/0x3b3n[ 101.007051] ? drm_atomic_set_property+0x92a/0x92an[ 101.011842] amdgpu_drm_ioctl+0x49/0x7dn[ 101.015679] __se_sys_ioctl+0x7c/0xb8n[ 101.015685] do_syscall_64+0x5f/0xb8n[ 101.015690] ? __irq_exit_rcu+0x34/0x96nn[How]nIt calles populate_dml_pipes which uses doubles to initialize.nAdding FPU protection avoids context switch and probable loss of vba contextnas there is potential contention while drm debug logs are enabled.,CVE-2022-49069,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet: sfc: add missing xdp queue reinitializationnnAfter rx/tx ring buffer size is changed kernel panic occurs whennit acts XDP_TX or XDP_REDIRECT.nnWhen tx/rx ring buffer size is changed(ethtool -G) sfc drivernreallocates and reinitializes rx and tx queues and their buffern(tx_queue->buffer).nBut it misses reinitializing xdp queues(efx->xdp_tx_queues).nSo while it is acting XDP_TX or XDP_REDIRECT it uses the uninitializedntx_queue->buffer.nnA new function efx_set_xdp_channels() is separated from efx_set_channels()nto handle only xdp queues.nnSplat looks like:n BUG: kernel NULL pointer dereference address: 000000000000002an #PF: supervisor write access in kernel moden #PF: error_code(0x0002) - not-present pagen PGD 0 P4D 0n Oops: 0002 [#4] PREEMPT SMP NOPTIn RIP: 0010:efx_tx_map_chunk+0x54/0x90 [sfc]n CPU: 2 PID: 0 Comm: swapper/2 Tainted: G D 5.17.0+ #55 e8beeee8289528f11357029357cfn Code: 48 8b 8d a8 01 00 00 48 8d 14 52 4c 8d 2c d0 44 89 e0 48 85 c9 74 0e 44 89 e2 4c 89 f6 48 80n RSP: 0018:ffff92f121e45c60 EFLAGS: 00010297n RIP: 0010:efx_tx_map_chunk+0x54/0x90 [sfc]n RAX: 0000000000000040 RBX: ffff92ea506895c0 RCX: ffffffffc0330870n RDX: 0000000000000001 RSI: 00000001139b10ce RDI: ffff92ea506895c0n RBP: ffffffffc0358a80 R08: 00000001139b110d R09: 0000000000000000n R10: 0000000000000001 R11: ffff92ea414c0088 R12: 0000000000000040n R13: 0000000000000018 R14: 00000001139b10ce R15: ffff92ea506895c0n FS: 0000000000000000(0000) GS:ffff92f121ec0000(0000) knlGS:0000000000000000n CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033n Code: 48 8b 8d a8 01 00 00 48 8d 14 52 4c 8d 2c d0 44 89 e0 48 85 c9 74 0e 44 89 e2 4c 89 f6 48 80n CR2: 000000000000002a CR3: 00000003e6810004 CR4: 00000000007706e0n RSP: 0018:ffff92f121e85c60 EFLAGS: 00010297n PKRU: 55555554n RAX: 0000000000000040 RBX: ffff92ea50689700 RCX: ffffffffc0330870n RDX: 0000000000000001 RSI: 00000001145a90ce RDI: ffff92ea50689700n RBP: ffffffffc0358a80 R08: 00000001145a910d R09: 0000000000000000n R10: 0000000000000001 R11: ffff92ea414c0088 R12: 0000000000000040n R13: 0000000000000018 R14: 00000001145a90ce R15: ffff92ea50689700n FS: 0000000000000000(0000) GS:ffff92f121e80000(0000) knlGS:0000000000000000n CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033n CR2: 000000000000002a CR3: 00000003e6810005 CR4: 00000000007706e0n PKRU: 55555554n Call Trace:n <IRQ>n efx_xdp_tx_buffers+0x12b/0x3d0 [sfc 84c94b8e32d44d296c17e10a634d3ad454de4ba5]n __efx_rx_packet+0x5c3/0x930 [sfc 84c94b8e32d44d296c17e10a634d3ad454de4ba5]n efx_rx_packet+0x28c/0x2e0 [sfc 84c94b8e32d44d296c17e10a634d3ad454de4ba5]n efx_ef10_ev_process+0x5f8/0xf40 [sfc 84c94b8e32d44d296c17e10a634d3ad454de4ba5]n ? enqueue_task_fair+0x95/0x550n efx_poll+0xc4/0x360 [sfc 84c94b8e32d44d296c17e10a634d3ad454de4ba5],CVE-2022-49096,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnhabanalabs: fix possible memory leak in MMU DR fininnThis patch fixes what seems to be copy paste error.nnWe will have a memory leak if the host-resident shadow is NULL (whichnwill likely happen as the DR and HR are not dependent).,CVE-2022-49102,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnstaging: vchiq_arm: Avoid NULL ptr deref in vchiq_dump_platform_instancesnnvchiq_get_state() can return a NULL pointer. So handle this cases andnavoid a NULL pointer derefence in vchiq_dump_platform_instances.,CVE-2022-49106,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnceph: fix inode reference leakage in ceph_get_snapdir()nnThe ceph_get_inode() will search for or insert a new inode into thenhash for the given vino and return a reference to it. If new isnnon-NULL its reference is consumed.nnWe should release the reference when in error handing cases.,CVE-2022-49109,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnetfilter: conntrack: revisit gc autotuningnnas of commit 4608fdfc07e1n(netfilter: conntrack: collect all entries in one cycle)nconntrack gc was changed to run every 2 minutes.nnOn systems where conntrack hash table is set to large value most evictionsnhappen from gc worker rather than the packet path due to hash tablendistribution.nnThis causes netlink event overflows when events are collected.nnThis change collects average expiry of scanned entries andnreschedules to the average remaining value within 1 to 60 second interval.nnTo avoid event overflows reschedule after each bucket and add anlimit for both run time and number of evictions per run.nnIf more entries have to be evicted reschedule and restart 1 jiffyninto the future.,CVE-2022-49110,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnmt76: fix monitor mode crash with sdio drivernnmt7921s driver may receive frames with fragment buffers. If there is anCTS packet received in monitor mode the payload is 10 bytes only andnneed 6 bytes header padding after RXD buffer. However only RXD in thenfirst linear buffer if we pull buffer size RXD-size+6 bytes withnskb_pull() that would trigger BUG_ON(skb->len < skb->data_len) inn__skb_pull().nnTo avoid the nonlinear buffer issue enlarge the RXD size from 128 ton256 to make sure all MCU operation in linear buffer.nn[ 52.007562] kernel BUG at include/linux/skbuff.h:2313!n[ 52.007578] Internal error: Oops - BUG: 0 [#1] PREEMPT SMPn[ 52.007987] pc : skb_pull+0x48/0x4cn[ 52.008015] lr : mt7921_queue_rx_skb+0x494/0x890 [mt7921_common]n[ 52.008361] Call trace:n[ 52.008377] skb_pull+0x48/0x4cn[ 52.008400] mt76s_net_worker+0x134/0x1b0 [mt76_sdio 35339a92c6eb7d4bbcc806a1d22f56365565135c]n[ 52.008431] __mt76_worker_fn+0xe8/0x170 [mt76 ef716597d11a77150bc07e3fdd68eeb0f9b56917]n[ 52.008449] kthread+0x148/0x3acn[ 52.008466] ret_from_fork+0x10/0x30,CVE-2022-49112,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnath11k: Fix frames flush failure caused by deadlocknnWe are seeing below warnings:nnkernel: [25393.301506] ath11k_pci 0000:01:00.0: failed to flush mgmt transmit queue 0nkernel: [25398.421509] ath11k_pci 0000:01:00.0: failed to flush mgmt transmit queue 0nkernel: [25398.421831] ath11k_pci 0000:01:00.0: dropping mgmt frame for vdev 0 is_started 0nnthis means ath11k fails to flush mgmt. frames because wmi_mgmt_tx_worknhas no chance to run in 5 seconds.nnBy setting /proc/sys/kernel/hung_task_timeout_secs to 20 and increasingnATH11K_FLUSH_TIMEOUT to 50 we get below warnings:nnkernel: [ 120.763160] INFO: task wpa_supplicant:924 blocked for more than 20 seconds.nkernel: [ 120.763169] Not tainted 5.10.90 #12nkernel: [ 120.763177] echo 0 > /proc/sys/kernel/hung_task_timeout_secs disables this message.nkernel: [ 120.763186] task:wpa_supplicant state:D stack: 0 pid: 924 ppid: 1 flags:0x000043a0nkernel: [ 120.763201] Call Trace:nkernel: [ 120.763214] __schedule+0x785/0x12fankernel: [ 120.763224] ? lockdep_hardirqs_on_prepare+0xe2/0x1bbnkernel: [ 120.763242] schedule+0x7e/0xa1nkernel: [ 120.763253] schedule_timeout+0x98/0xfenkernel: [ 120.763266] ? run_local_timers+0x4a/0x4ankernel: [ 120.763291] ath11k_mac_flush_tx_complete+0x197/0x2b1 [ath11k 13c3a9bf37790f4ac8103b3decf7ab4008ac314a]nkernel: [ 120.763306] ? init_wait_entry+0x2e/0x2enkernel: [ 120.763343] __ieee80211_flush_queues+0x167/0x21f [mac80211 335da900954f1c5ea7f1613d92088ce83342042c]nkernel: [ 120.763378] __ieee80211_recalc_idle+0x105/0x125 [mac80211 335da900954f1c5ea7f1613d92088ce83342042c]nkernel: [ 120.763411] ieee80211_recalc_idle+0x14/0x27 [mac80211 335da900954f1c5ea7f1613d92088ce83342042c]nkernel: [ 120.763441] ieee80211_free_chanctx+0x77/0xa2 [mac80211 335da900954f1c5ea7f1613d92088ce83342042c]nkernel: [ 120.763473] __ieee80211_vif_release_channel+0x100/0x131 [mac80211 335da900954f1c5ea7f1613d92088ce83342042c]nkernel: [ 120.763540] ieee80211_vif_release_channel+0x66/0x81 [mac80211 335da900954f1c5ea7f1613d92088ce83342042c]nkernel: [ 120.763572] ieee80211_destroy_auth_data+0xa3/0xe6 [mac80211 335da900954f1c5ea7f1613d92088ce83342042c]nkernel: [ 120.763612] ieee80211_mgd_deauth+0x178/0x29b [mac80211 335da900954f1c5ea7f1613d92088ce83342042c]nkernel: [ 120.763654] cfg80211_mlme_deauth+0x1a8/0x22c [cfg80211 8945aa5bc2af5f6972336665d8ad6f9c191ad5be]nkernel: [ 120.763697] nl80211_deauthenticate+0xfa/0x123 [cfg80211 8945aa5bc2af5f6972336665d8ad6f9c191ad5be]nkernel: [ 120.763715] genl_rcv_msg+0x392/0x3c2nkernel: [ 120.763750] ? nl80211_associate+0x432/0x432 [cfg80211 8945aa5bc2af5f6972336665d8ad6f9c191ad5be]nkernel: [ 120.763782] ? nl80211_associate+0x432/0x432 [cfg80211 8945aa5bc2af5f6972336665d8ad6f9c191ad5be]nkernel: [ 120.763802] ? genl_rcv+0x36/0x36nkernel: [ 120.763814] netlink_rcv_skb+0x89/0xf7nkernel: [ 120.763829] genl_rcv+0x28/0x36nkernel: [ 120.763840] netlink_unicast+0x179/0x24bnkernel: [ 120.763854] netlink_sendmsg+0x393/0x401nkernel: [ 120.763872] sock_sendmsg+0x72/0x76nkernel: [ 120.763886] ____sys_sendmsg+0x170/0x1e6nkernel: [ 120.763897] ? copy_msghdr_from_user+0x7a/0xa2nkernel: [ 120.763914] ___sys_sendmsg+0x95/0xd1nkernel: [ 120.763940] __sys_sendmsg+0x85/0xbfnkernel: [ 120.763956] do_syscall_64+0x43/0x55nkernel: [ 120.763966] entry_SYSCALL_64_after_hwframe+0x44/0xa9nkernel: [ 120.763977] RIP: 0033:0x79089f3fcc83nkernel: [ 120.763986] RSP: 002b:00007ffe604f0508 EFLAGS: 00000246 ORIG_RAX: 000000000000002enkernel: [ 120.763997] RAX: ffffffffffffffda RBX: 000059b40e987690 RCX: 000079089f3fcc83nkernel: [ 120.764006] RDX: 0000000000000000 RSI: 00007ffe604f0558 RDI: 0000000000000009nkernel: [ 120.764014] RBP: 00007ffe604f0540 R08: 0000000000000004 R09: 0000000000400000nkernel: [ 120.764023] R10: 00007ffe604f0638 R11: 0000000000000246 R12: 000059b40ea04980nkernel: [ 120.764032] R13: 00007ffe604n---truncated---,CVE-2022-49123,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnx86/mce: Work around an erratum on fast string copy instructionsnnA rare kernel panic scenario can happen when the following conditionsnare met due to an erratum on fast string copy instructions:nn1) An uncorrected error.n2) That error must be in first cache line of a page.n3) Kernel must execute page_copy from the page immediately before thatnpage.nnThe fast string copy instructions (REP; MOVS*) could consume annuncorrectable memory error in the cache line _right after_ the desirednregion to copy and raise an MCE.nnBit 0 of MSR_IA32_MISC_ENABLE can be cleared to disable fast stringncopy and will avoid such spurious machine checks. However that is lessnpreferable due to the permanent performance impact. Considering memorynpoison is rare it's desirable to keep fast string copy enabled until annMCE is seen.nnIntel has confirmed the following:n1. The CPU erratum of fast string copy only applies to SkylakenCascade Lake and Cooper Lake generations.nnDirectly return from the MCE handler:n2. Will result in complete execution of the REP; MOVS* with no datanloss or corruption.n3. Will not result in another MCE firing on the next poisoned cache linendue to REP; MOVS*.n4. Will resume execution from a correct point in code.n5. Will result in the same instruction that triggered the MCE firing ansecond MCE immediately for any other software recoverable data fetchnerrors.n6. Is not safe without disabling the fast string copy as the next fastnstring copy of the same buffer on the same CPU would result in a PANICnMCE.nnThis should mitigate the erratum completely with the only caveat thatnthe fast string copy is disabled on the affected hyper thread thusnperformance degradation.nnThis is still better than the OS crashing on MCEs raised on annirrelevant process due to REP; MOVS*' accesses in a kernel contextne.g. copy_page.nnnInjected errors on 1st cache line of 8 anonymous pages of processn'proc1' and observed MCE consumption from 'proc2' with no panicn(directly returned).nnWithout the fix the host panicked within a few minutes on anrandom 'proc2' process due to kernel access from copy_page.nn [ bp: Fix comment style + touch ups zap an unlikely() improve then quirk function's readability. ],CVE-2022-49124,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/bridge: Add missing pm_runtime_put_syncnnpm_runtime_get_sync() will increase the rumtime PM counterneven when it returns an error. Thus a pairing decrement is needednto prevent refcount leak. Fix this by replacing this API withnpm_runtime_resume_and_get() which will not change the runtimenPM counter on error. Besides a matching decrement is needednon the error handling path to keep the counter balanced.,CVE-2022-49128,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnmt76: mt7921: fix crash when startup fails.nnIf the nic fails to start it is possible that thenreset_work has already been scheduled. Ensure thenwork item is canceled so we do not have use-after-freencrash in case cleanup is called before the work itemnis executed.nnThis fixes crash on my x86_64 apu2 when mt7921k radionfails to work. Radio still fails but OS does notncrash.,CVE-2022-49129,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnath11k: pci: fix crash on suspend if board file is not foundnnMario reported that the kernel was crashing on suspend if ath11k was not ablento find a board file:nn[ 473.693286] PM: Suspending system (s2idle)n[ 473.693291] printk: Suspending console(s) (use no_console_suspend to debug)n[ 474.407787] BUG: unable to handle page fault for address: 0000000000002070n[ 474.407791] #PF: supervisor read access in kernel moden[ 474.407794] #PF: error_code(0x0000) - not-present pagen[ 474.407798] PGD 0 P4D 0n[ 474.407801] Oops: 0000 [#1] PREEMPT SMP NOPTIn[ 474.407805] CPU: 2 PID: 2350 Comm: kworker/u32:14 Tainted: G W 5.16.0 #248n[...]n[ 474.407868] Call Trace:n[ 474.407870] <TASK>n[ 474.407874] ? _raw_spin_lock_irqsave+0x2a/0x60n[ 474.407882] ? lock_timer_base+0x72/0xa0n[ 474.407889] ? _raw_spin_unlock_irqrestore+0x29/0x3dn[ 474.407892] ? try_to_del_timer_sync+0x54/0x80n[ 474.407896] ath11k_dp_rx_pktlog_stop+0x49/0xc0 [ath11k]n[ 474.407912] ath11k_core_suspend+0x34/0x130 [ath11k]n[ 474.407923] ath11k_pci_pm_suspend+0x1b/0x50 [ath11k_pci]n[ 474.407928] pci_pm_suspend+0x7e/0x170n[ 474.407935] ? pci_pm_freeze+0xc0/0xc0n[ 474.407939] dpm_run_callback+0x4e/0x150n[ 474.407947] __device_suspend+0x148/0x4c0n[ 474.407951] async_suspend+0x20/0x90ndmesg-efi-164255130401001:nOops#1 Part1n[ 474.407955] async_run_entry_fn+0x33/0x120n[ 474.407959] process_one_work+0x220/0x3f0n[ 474.407966] worker_thread+0x4a/0x3d0n[ 474.407971] kthread+0x17a/0x1a0n[ 474.407975] ? process_one_work+0x3f0/0x3f0n[ 474.407979] ? set_kthread_struct+0x40/0x40n[ 474.407983] ret_from_fork+0x22/0x30n[ 474.407991] </TASK>nnThe issue here is that board file loading happens after ath11k_pci_probe()nsuccesfully returns (ath11k initialisation happends asynchronously) and thensuspend handler is still enabled of course failing as ath11k is not properlyninitialised. Fix this by checking ATH11K_FLAG_QMI_FAIL during both suspend andnresume.nnTested-on: WCN6855 hw2.0 PCI WLAN.HSP.1.1-03003-QCAHSPSWPL_V1_V2_SILICONZ_LITE-2,CVE-2022-49132,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnmlxsw: spectrum: Guard against invalid local portsnnWhen processing events generated by the device's firmware the drivernprotects itself from events reported for non-existent local ports butnnot for the CPU port (local port 0) which exists but does not have allnthe fields as any local port.nnThis can result in a NULL pointer dereference when trying accessn'struct mlxsw_sp_port' fields which are not initialized for CPU port.nnCommit 63b08b1f6834 (mlxsw: spectrum: Protect driver from buggy firmware)nalready handled such issue by bailing early when processing a PUDE eventnreported for the CPU port.nnGeneralize the approach by moving the check to a common function andnmaking use of it in all relevant places.,CVE-2022-49134,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Fix memory leaknn[why]nResource release is needed on the error handling pathnto prevent memory leak.nn[how]nFix this by adding kfree on the error handling path.,CVE-2022-49135,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnBluetooth: hci_event: Ignore multiple conn complete eventsnnWhen one of the three connection complete events is received multiplentimes for the same handle the device is registered multiple times whichnleads to memory corruptions. Therefore consequent events for a singlenconnection are ignored.nnThe conn->state can hold different values therefore HCI_CONN_HANDLE_UNSETnis introduced to identify new connections. To make sure the events do notncontain this or another invalid handle HCI_CONN_HANDLE_MAX and checksnare introduced.nnBuglink: https://bugzilla.kernel.org/show_bug.cgi?id=215497,CVE-2022-49138,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet: preserve skb_end_offset() in skb_unclone_keeptruesize()nnsyzbot found another way to trigger the infamous WARN_ON_ONCE(delta < len)nin skb_try_coalesce() [1]nnI was able to root cause the issue to kfence.nnWhen kfence is in action the following assertion is no longer true:nnint size = xxxx;nvoid *ptr1 = kmalloc(size gfp);nvoid *ptr2 = kmalloc(size gfp);nnif (ptr1 && ptr2)ntASSERT(ksize(ptr1) == ksize(ptr2));nnWe attempted to fix these issues in the blamed commits but forgotnthat TCP was possibly shifting data after skb_unclone_keeptruesize()nhas been used notably from tcp_retrans_try_collapse().nnSo we not only need to keep same skb->truesize valuenwe also need to make sure TCP wont fill new tailroomnthat pskb_expand_head() was able to get from anaddr = kmalloc(...) followed by ksize(addr)nnSplit skb_unclone_keeptruesize() into two parts:nn1) Inline skb_unclone_keeptruesize() for the common casen when skb is not cloned.nn2) Out of line __skb_unclone_keeptruesize() for the 'slow path'.nnWARNING: CPU: 1 PID: 6490 at net/core/skbuff.c:5295 skb_try_coalesce+0x1235/0x1560 net/core/skbuff.c:5295nModules linked in:nCPU: 1 PID: 6490 Comm: syz-executor161 Not tainted 5.17.0-rc4-syzkaller-00229-g4f12b742eb2b #0nHardware name: Google Google Compute Engine/Google Compute Engine BIOS Google 01/01/2011nRIP: 0010:skb_try_coalesce+0x1235/0x1560 net/core/skbuff.c:5295nCode: bf 01 00 00 00 0f b7 c0 89 c6 89 44 24 20 e8 62 24 4e fa 8b 44 24 20 83 e8 01 0f 85 e5 f0 ff ff e9 87 f4 ff ff e8 cb 20 4e fa <0f> 0b e9 06 f9 ff ff e8 af b2 95 fa e9 69 f0 ff ff e8 95 b2 95 fanRSP: 0018:ffffc900063af268 EFLAGS: 00010293nRAX: 0000000000000000 RBX: 00000000ffffffd5 RCX: 0000000000000000nRDX: ffff88806fc05700 RSI: ffffffff872abd55 RDI: 0000000000000003nRBP: ffff88806e675500 R08: 00000000ffffffd5 R09: 0000000000000000nR10: ffffffff872ab659 R11: 0000000000000000 R12: ffff88806dd554e8nR13: ffff88806dd9bac0 R14: ffff88806dd9a2c0 R15: 0000000000000155nFS: 00007f18014f9700(0000) GS:ffff8880b9c00000(0000) knlGS:0000000000000000nCS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033nCR2: 0000000020002000 CR3: 000000006be7a000 CR4: 00000000003506f0nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400nCall Trace:n <TASK>n tcp_try_coalesce net/ipv4/tcp_input.c:4651 [inline]n tcp_try_coalesce+0x393/0x920 net/ipv4/tcp_input.c:4630n tcp_queue_rcv+0x8a/0x6e0 net/ipv4/tcp_input.c:4914n tcp_data_queue+0x11fd/0x4bb0 net/ipv4/tcp_input.c:5025n tcp_rcv_established+0x81e/0x1ff0 net/ipv4/tcp_input.c:5947n tcp_v4_do_rcv+0x65e/0x980 net/ipv4/tcp_ipv4.c:1719n sk_backlog_rcv include/net/sock.h:1037 [inline]n __release_sock+0x134/0x3b0 net/core/sock.c:2779n release_sock+0x54/0x1b0 net/core/sock.c:3311n sk_wait_data+0x177/0x450 net/core/sock.c:2821n tcp_recvmsg_locked+0xe28/0x1fd0 net/ipv4/tcp.c:2457n tcp_recvmsg+0x137/0x610 net/ipv4/tcp.c:2572n inet_recvmsg+0x11b/0x5e0 net/ipv4/af_inet.c:850n sock_recvmsg_nosec net/socket.c:948 [inline]n sock_recvmsg net/socket.c:966 [inline]n sock_recvmsg net/socket.c:962 [inline]n ____sys_recvmsg+0x2c4/0x600 net/socket.c:2632n ___sys_recvmsg+0x127/0x200 net/socket.c:2674n __sys_recvmsg+0xe2/0x1a0 net/socket.c:2704n do_syscall_x64 arch/x86/entry/common.c:50 [inline]n do_syscall_64+0x35/0xb0 arch/x86/entry/common.c:80n entry_SYSCALL_64_after_hwframe+0x44/0xae,CVE-2022-49142,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnscsi: qla2xxx: Fix premature hw access after PCI errornnAfter a recoverable PCI error has been detected and recovered qla drivernneeds to check to see if the error condition still persist and/or waitnfor the OS to give the resume signal.nnSep 8 22:26:03 localhost kernel: WARNING: CPU: 9 PID: 124606 at qla_tmpl.c:440nqla27xx_fwdt_entry_t266+0x55/0x60 [qla2xxx]nSep 8 22:26:03 localhost kernel: RIP: 0010:qla27xx_fwdt_entry_t266+0x55/0x60n[qla2xxx]nSep 8 22:26:03 localhost kernel: Call Trace:nSep 8 22:26:03 localhost kernel: ? qla27xx_walk_template+0xb1/0x1b0 [qla2xxx]nSep 8 22:26:03 localhost kernel: ? qla27xx_execute_fwdt_template+0x12a/0x160n[qla2xxx]nSep 8 22:26:03 localhost kernel: ? qla27xx_fwdump+0xa0/0x1c0 [qla2xxx]nSep 8 22:26:03 localhost kernel: ? qla2xxx_pci_mmio_enabled+0xfb/0x120n[qla2xxx]nSep 8 22:26:03 localhost kernel: ? report_mmio_enabled+0x44/0x80nSep 8 22:26:03 localhost kernel: ? report_slot_reset+0x80/0x80nSep 8 22:26:03 localhost kernel: ? pci_walk_bus+0x70/0x90nSep 8 22:26:03 localhost kernel: ? aer_dev_correctable_show+0xc0/0xc0nSep 8 22:26:03 localhost kernel: ? pcie_do_recovery+0x1bb/0x240nSep 8 22:26:03 localhost kernel: ? aer_recover_work_func+0xaa/0xd0nSep 8 22:26:03 localhost kernel: ? process_one_work+0x1a7/0x360n..nSep 8 22:26:03 localhost kernel: qla2xxx [0000:42:00.2]-8041:22: detected PCIndisconnect.nSep 8 22:26:03 localhost kernel: qla2xxx [0000:42:00.2]-107ff:22:nqla27xx_fwdt_entry_t262: dump ram MB failed. Area 5h start 198013h end 198013hnSep 8 22:26:03 localhost kernel: qla2xxx [0000:42:00.2]-107ff:22: Unable toncapture FW dumpnSep 8 22:26:03 localhost kernel: qla2xxx [0000:42:00.2]-1015:22: cmd=0x0nwaited 5221 msecsnSep 8 22:26:03 localhost kernel: qla2xxx [0000:42:00.2]-680d:22: mmionenabled returning.nSep 8 22:26:03 localhost kernel: qla2xxx [0000:42:00.2]-d04c:22: MBXnCommand timeout for cmd 0 iocontrol=ffffffff jiffies=10140f2e5nmb[0-3]=[0xffff 0xffff 0xffff 0xffff],CVE-2022-49157,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnscsi: qla2xxx: Fix warning message due to adisc being flushednnFix warning message due to adisc being flushed. Linux kernel triggered anwarning message where a different error code type is not matching up withnthe expected type. Add additional translation of one error code type tonanother.nnWARNING: CPU: 2 PID: 1131623 at drivers/scsi/qla2xxx/qla_init.c:498nqla2x00_async_adisc_sp_done+0x294/0x2b0 [qla2xxx]nCPU: 2 PID: 1131623 Comm: drmgr Not tainted 5.13.0-rc1-autotest #1n..nGPR28: c000000aaa9c8890 c0080000079ab678 c00000140a104800 c00000002bd19000nNIP [c00800000790857c] qla2x00_async_adisc_sp_done+0x294/0x2b0 [qla2xxx]nLR [c008000007908578] qla2x00_async_adisc_sp_done+0x290/0x2b0 [qla2xxx]nCall Trace:n[c00000001cdc3620] [c008000007908578] qla2x00_async_adisc_sp_done+0x290/0x2b0 [qla2xxx] (unreliable)n[c00000001cdc3710] [c0080000078f3080] __qla2x00_abort_all_cmds+0x1b8/0x580 [qla2xxx]n[c00000001cdc3840] [c0080000078f589c] qla2x00_abort_all_cmds+0x34/0xd0 [qla2xxx]n[c00000001cdc3880] [c0080000079153d8] qla2x00_abort_isp_cleanup+0x3f0/0x570 [qla2xxx]n[c00000001cdc3920] [c0080000078fb7e8] qla2x00_remove_one+0x3d0/0x480 [qla2xxx]n[c00000001cdc39b0] [c00000000071c274] pci_device_remove+0x64/0x120n[c00000001cdc39f0] [c0000000007fb818] device_release_driver_internal+0x168/0x2a0n[c00000001cdc3a30] [c00000000070e304] pci_stop_bus_device+0xb4/0x100n[c00000001cdc3a70] [c00000000070e4f0] pci_stop_and_remove_bus_device+0x20/0x40n[c00000001cdc3aa0] [c000000000073940] pci_hp_remove_devices+0x90/0x130n[c00000001cdc3b30] [c0080000070704d0] disable_slot+0x38/0x90 [rpaphp] [nc00000001cdc3b60] [c00000000073eb4c] power_write_file+0xcc/0x180n[c00000001cdc3be0] [c0000000007354bc] pci_slot_attr_store+0x3c/0x60n[c00000001cdc3c00] [c00000000055f820] sysfs_kf_write+0x60/0x80 [c00000001cdc3c20]n[c00000000055df10] kernfs_fop_write_iter+0x1a0/0x290n[c00000001cdc3c70] [c000000000447c4c] new_sync_write+0x14c/0x1d0n[c00000001cdc3d10] [c00000000044b134] vfs_write+0x224/0x330n[c00000001cdc3d60] [c00000000044b3f4] ksys_write+0x74/0x130n[c00000001cdc3db0] [c00000000002df70] system_call_exception+0x150/0x2d0n[c00000001cdc3e10] [c00000000000d45c] system_call_common+0xec/0x278,CVE-2022-49158,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnscsi: qla2xxx: Fix crash during module load unload testnnDuring purex packet handling the driver was incorrectly freeing anpre-allocated structure. Fix this by skipping that entry.nnSystem crashed with the following stack during a module unload test.nnCall Trace:ntsbitmap_init_node+0x7f/0x1e0ntsbitmap_queue_init_node+0x24/0x150ntblk_mq_init_bitmaps+0x3d/0xa0ntblk_mq_init_tags+0x68/0x90ntblk_mq_alloc_map_and_rqs+0x44/0x120ntblk_mq_alloc_set_map_and_rqs+0x63/0x150ntblk_mq_alloc_tag_set+0x11b/0x230ntscsi_add_host_with_dma.cold+0x3f/0x245ntqla2x00_probe_one+0xd5a/0x1b80 [qla2xxx]nnCall Trace with slub_debug and debug kernel:ntkasan_report_invalid_free+0x50/0x80nt__kasan_slab_free+0x137/0x150ntslab_free_freelist_hook+0xc6/0x190ntkfree+0xe8/0x2e0ntqla2x00_free_device+0x3bb/0x5d0 [qla2xxx]ntqla2x00_remove_one+0x668/0xcf0 [qla2xxx],CVE-2022-49160,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnASoC: mediatek: Fix error handling in mt8183_da7219_max98357_dev_probennThe device_node pointer is returned by of_parse_phandle() with refcountnincremented. We should use of_node_put() on it when done.nnThis function only calls of_node_put() in the regular path.nAnd it will cause refcount leak in error paths.nFix this by calling of_node_put() in error handling too.,CVE-2022-49161,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnpowerpc/tm: Fix more userspace r13 corruptionnnCommit cf13435b730a (powerpc/tm: Fix userspace r13 corruption) fixes anproblem in treclaim where a SLB miss can occur on thenthread_struct->ckpt_regs while SCRATCH0 is live with the saved user r13nvalue clobbering it with the kernel r13 and ultimately resulting innkernel r13 being stored in ckpt_regs.nnThere is an equivalent problem in trechkpt where the user r13 value isnloaded into r13 from chkpt_regs to be recheckpointed but a SLB missncould occur on ckpt_regs accesses after that which will result in r13nbeing clobbered with a kernel value and that will get recheckpointed andnthen restored to user registers.nnThe same memory page is accessed right before this critical window wherena SLB miss could cause corruption so hitting the bug requires the SLBnentry be removed within a small window of instructions which isnpossible if a SLB related MCE hits there. PAPR also permits thenhypervisor to discard this SLB entry (because slb_shadow->persistent isnonly set to SLB_NUM_BOLTED) although it's not known whether anynimplementations would do this (KVM does not). So this is an extremelynunlikely bug only found by inspection.nnFix this by also storing user r13 in a temporary location on the kernelnstack and don't change the r13 register from kernel r13 until the RI=0ncritical section that does not fault.nnThe SCRATCH0 change is not strictly part of the fix it's only used innthe RI=0 section so it does not have the same problem as the previousnSCRATCH0 bug.,CVE-2022-49164,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbtrfs: do not double complete bio on errors during compressed readsnnI hit some weird panics while fixing up the error handling fromnbtrfs_lookup_bio_sums(). Turns out the compression path will completenthe bio we use if we set up any of the compression bios and then returnnan error and then btrfs_submit_data_bio() will also call bio_endio() onnthe bio.nnFix this by making btrfs_submit_compressed_read() responsible forncalling bio_endio() on the bio if there are any errors. Currently itnwas only doing it if we created the compression bios otherwise it wasndepending on btrfs_submit_data_bio() to do the right thing. Thisncreates the above problem so fix up btrfs_submit_compressed_read() tonalways call bio_endio() in case of an error and then simply return fromnbtrfs_submit_data_bio() if we had to callnbtrfs_submit_compressed_read().,CVE-2022-49167,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbtrfs: do not clean up repair bio if submit failsnnThe submit helper will always run bio_endio() on the bio if it fails tonsubmit so cleaning up the bio just leads to a variety of use-after-freenand NULL pointer dereference bugs because we race with the endionfunction that is cleaning up the bio. Instead just return BLK_STS_OK asnthe repair function has to continue to process the rest of the pagesnand the endio for the repair bio will do the appropriate cleanup for thenpage that it was given.,CVE-2022-49168,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnf2fs: use spin_lock to avoid hangnn[14696.634553] task:cat state:D stack: 0 pid:1613738 ppid:1613735 flags:0x00000004n[14696.638285] Call Trace:n[14696.639038] <TASK>n[14696.640032] __schedule+0x302/0x930n[14696.640969] schedule+0x58/0xd0n[14696.641799] schedule_preempt_disabled+0x18/0x30n[14696.642890] __mutex_lock.constprop.0+0x2fb/0x4f0n[14696.644035] ? mod_objcg_state+0x10c/0x310n[14696.645040] ? obj_cgroup_charge+0xe1/0x170n[14696.646067] __mutex_lock_slowpath+0x13/0x20n[14696.647126] mutex_lock+0x34/0x40n[14696.648070] stat_show+0x25/0x17c0 [f2fs]n[14696.649218] seq_read_iter+0x120/0x4b0n[14696.650289] ? aa_file_perm+0x12a/0x500n[14696.651357] ? lru_cache_add+0x1c/0x20n[14696.652470] seq_read+0xfd/0x140n[14696.653445] full_proxy_read+0x5c/0x80n[14696.654535] vfs_read+0xa0/0x1a0n[14696.655497] ksys_read+0x67/0xe0n[14696.656502] __x64_sys_read+0x1a/0x20n[14696.657580] do_syscall_64+0x3b/0xc0n[14696.658671] entry_SYSCALL_64_after_hwframe+0x44/0xaen[14696.660068] RIP: 0033:0x7efe39df1cb2n[14696.661133] RSP: 002b:00007ffc8badd948 EFLAGS: 00000246 ORIG_RAX: 0000000000000000n[14696.662958] RAX: ffffffffffffffda RBX: 0000000000020000 RCX: 00007efe39df1cb2n[14696.664757] RDX: 0000000000020000 RSI: 00007efe399df000 RDI: 0000000000000003n[14696.666542] RBP: 00007efe399df000 R08: 00007efe399de010 R09: 00007efe399de010n[14696.668363] R10: 0000000000000022 R11: 0000000000000246 R12: 0000000000000000n[14696.670155] R13: 0000000000000003 R14: 0000000000020000 R15: 0000000000020000n[14696.671965] </TASK>n[14696.672826] task:umount state:D stack: 0 pid:1614985 ppid:1614984 flags:0x00004000n[14696.674930] Call Trace:n[14696.675903] <TASK>n[14696.676780] __schedule+0x302/0x930n[14696.677927] schedule+0x58/0xd0n[14696.679019] schedule_preempt_disabled+0x18/0x30n[14696.680412] __mutex_lock.constprop.0+0x2fb/0x4f0n[14696.681783] ? destroy_inode+0x65/0x80n[14696.683006] __mutex_lock_slowpath+0x13/0x20n[14696.684305] mutex_lock+0x34/0x40n[14696.685442] f2fs_destroy_stats+0x1e/0x60 [f2fs]n[14696.686803] f2fs_put_super+0x158/0x390 [f2fs]n[14696.688238] generic_shutdown_super+0x7a/0x120n[14696.689621] kill_block_super+0x27/0x50n[14696.690894] kill_f2fs_super+0x7f/0x100 [f2fs]n[14696.692311] deactivate_locked_super+0x35/0xa0n[14696.693698] deactivate_super+0x40/0x50n[14696.694985] cleanup_mnt+0x139/0x190n[14696.696209] __cleanup_mnt+0x12/0x20n[14696.697390] task_work_run+0x64/0xa0n[14696.698587] exit_to_user_mode_prepare+0x1b7/0x1c0n[14696.700053] syscall_exit_to_user_mode+0x27/0x50n[14696.701418] do_syscall_64+0x48/0xc0n[14696.702630] entry_SYSCALL_64_after_hwframe+0x44/0xae,CVE-2022-49169,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnparisc: Fix non-access data TLB cache flush faultsnnWhen a page is not present we get non-access data TLB faults fromnthe fdc and fic instructions in flush_user_dcache_range_asm andnflush_user_icache_range_asm. When these occur the cache line isnnot invalidated and potentially we get memory corruption. Thenproblem was hidden by the nullification of the flush instructions.nnThese faults also affect performance. With pa8800/pa8900 processorsnthere will be 32 faults per 4 KB page since the cache line is 128nbytes. There will be more faults with earlier processors.nnThe problem is fixed by using flush_cache_pages(). It does the flushnusing a tmp alias mapping.nnThe flush_cache_pages() call in flush_cache_range() flushed toonlarge a range.nnV2: Remove unnecessary preempt_disable() and preempt_enable() calls.,CVE-2022-49172,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnspi: fsi: Implement a timeout for polling statusnnThe data transfer routines must poll the status register tondetermine when more data can be shifted in or out. If the hardwarengets into a bad state these polling loops may never exit. Preventnthis by returning an error if a timeout is exceeded.,CVE-2022-49173,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnhwrng: cavium - fix NULL but dereferenced coccicheck errornnFix following coccicheck warning:n./drivers/char/hw_random/cavium-rng-vf.c:182:17-20: ERROR:npdev is NULL but dereferenced.,CVE-2022-49177,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnmemstick/mspro_block: fix handling of read-only devicesnnUse set_disk_ro to propagate the read-only state to the block layerninstead of checking for it in ->open and leaking a reference in casenof a read-only device.,CVE-2022-49178,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet: hns3: add vlan list lock to protect vlan listnnWhen adding port base VLAN vf VLAN need to remove from HW and modifynthe vlan state in vf VLAN list as false. If the periodicity task isnfreeing the same node it may cause use after free error.nThis patch adds a vlan list lock to protect the vlan list.,CVE-2022-49182,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet/sched: act_ct: fix ref leak when switching zonesnnWhen switching zones or network namespaces without doing a ct clear innbetween it is now leaking a reference to the old ct entry. That'snbecause tcf_ct_skb_nfct_cached() returns false andntcf_ct_flow_table_lookup() may simply overwrite it.nnThe fix is to as the ct entry is not reusable free it already atntcf_ct_skb_nfct_cached().,CVE-2022-49183,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnkernel/resource: fix kfree() of bootmem memory againnnSince commit ebff7d8f270d (mem hotunplug: fix kfree() of bootmemnmemory) we could get a resource allocated during boot vianalloc_resource(). And it's required to release the resource usingnfree_resource(). Howerver many people use kfree directly which willnresult in kernel BUG. In order to fix this without fixing every callnsite just leak a couple of bytes in such corner case.,CVE-2022-49190,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnpowerpc/pseries: Fix use after free in remove_phb_dynamic()nnIn remove_phb_dynamic() we use &phb->io_resource after we've calledndevice_unregister(&host_bridge->dev). But the unregister may have freednphb because pcibios_free_controller_deferred() is the release functionnfor the host_bridge.nnIf there are no outstanding references when we call device_unregister()nthen phb will be freed out from under us.nnThis has gone mainly unnoticed but with slub_debug and page_poisonnenabled it can lead to a crash:nn PID: 7574 TASK: c0000000d492cb80 CPU: 13 COMMAND: drmgrn #0 [c0000000e4f075a0] crash_kexec at c00000000027d7dcn #1 [c0000000e4f075d0] oops_end at c000000000029608n #2 [c0000000e4f07650] __bad_page_fault at c0000000000904b4n #3 [c0000000e4f076c0] do_bad_slb_fault at c00000000009a5a8n #4 [c0000000e4f076f0] data_access_slb_common_virt at c000000000008b30n Data SLB Access [380] exception frame:n R0: c000000000167250 R1: c0000000e4f07a00 R2: c000000002a46100n R3: c000000002b39ce8 R4: 00000000000000c0 R5: 00000000000000a9n R6: 3894674d000000c0 R7: 0000000000000000 R8: 00000000000000ffn R9: 0000000000000100 R10: 6b6b6b6b6b6b6b6b R11: 0000000000008000n R12: c00000000023da80 R13: c0000009ffd38b00 R14: 0000000000000000n R15: 000000011c87f0f0 R16: 0000000000000006 R17: 0000000000000003n R18: 0000000000000002 R19: 0000000000000004 R20: 0000000000000005n R21: 000000011c87ede8 R22: 000000011c87c5a8 R23: 000000011c87d3a0n R24: 0000000000000000 R25: 0000000000000001 R26: c0000000e4f07cc8n R27: c00000004d1cc400 R28: c0080000031d00e8 R29: c00000004d23d800n R30: c00000004d1d2400 R31: c00000004d1d2540n NIP: c000000000167258 MSR: 8000000000009033 OR3: c000000000e9f474n CTR: 0000000000000000 LR: c000000000167250 XER: 0000000020040003n CCR: 0000000024088420 MQ: 0000000000000000 DAR: 6b6b6b6b6b6b6ba3n DSISR: c0000000e4f07920 Syscall Result: fffffffffffffff2n [NIP : release_resource+56]n [LR : release_resource+48]n #5 [c0000000e4f07a00] release_resource at c000000000167258 (unreliable)n #6 [c0000000e4f07a30] remove_phb_dynamic at c000000000105648n #7 [c0000000e4f07ab0] dlpar_remove_slot at c0080000031a09e8 [rpadlpar_io]n #8 [c0000000e4f07b50] remove_slot_store at c0080000031a0b9c [rpadlpar_io]n #9 [c0000000e4f07be0] kobj_attr_store at c000000000817d8cn #10 [c0000000e4f07c00] sysfs_kf_write at c00000000063e504n #11 [c0000000e4f07c20] kernfs_fop_write_iter at c00000000063d868n #12 [c0000000e4f07c70] new_sync_write at c00000000054339cn #13 [c0000000e4f07d10] vfs_write at c000000000546624n #14 [c0000000e4f07d60] ksys_write at c0000000005469f4n #15 [c0000000e4f07db0] system_call_exception at c000000000030840n #16 [c0000000e4f07e10] system_call_vectored_common at c00000000000c168nnTo avoid it we can take a reference to the host_bridge->dev until we'rendone using phb. Then when we drop the reference the phb will be freed.,CVE-2022-49196,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnibmvnic: fix race between xmit and resetnnThere is a race between reset and the transmit paths that can lead tonibmvnic_xmit() accessing an scrq after it has been freed in the resetnpath. It can result in a crash like:nntKernel attempted to read user page (0) - exploit attempt? (uid: 0)ntBUG: Kernel NULL pointer dereference on read at 0x00000000ntFaulting instruction address: 0xc0080000016189f8ntOops: Kernel access of bad area sig: 11 [#1]nt...ntNIP [c0080000016189f8] ibmvnic_xmit+0x60/0xb60 [ibmvnic]ntLR [c000000000c0046c] dev_hard_start_xmit+0x11c/0x280ntCall Trace:nt[c008000001618f08] ibmvnic_xmit+0x570/0xb60 [ibmvnic] (unreliable)nt[c000000000c0046c] dev_hard_start_xmit+0x11c/0x280nt[c000000000c9cfcc] sch_direct_xmit+0xec/0x330nt[c000000000bfe640] __dev_xmit_skb+0x3a0/0x9d0nt[c000000000c00ad4] __dev_queue_xmit+0x394/0x730nt[c008000002db813c] __bond_start_xmit+0x254/0x450 [bonding]nt[c008000002db8378] bond_start_xmit+0x40/0xc0 [bonding]nt[c000000000c0046c] dev_hard_start_xmit+0x11c/0x280nt[c000000000c00ca4] __dev_queue_xmit+0x564/0x730nt[c000000000cf97e0] neigh_hh_output+0xd0/0x180nt[c000000000cfa69c] ip_finish_output2+0x31c/0x5c0nt[c000000000cfd244] __ip_queue_xmit+0x194/0x4f0nt[c000000000d2a3c4] __tcp_transmit_skb+0x434/0x9b0nt[c000000000d2d1e0] __tcp_retransmit_skb+0x1d0/0x6a0nt[c000000000d2d984] tcp_retransmit_skb+0x34/0x130nt[c000000000d310e8] tcp_retransmit_timer+0x388/0x6d0nt[c000000000d315ec] tcp_write_timer_handler+0x1bc/0x330nt[c000000000d317bc] tcp_write_timer+0x5c/0x200nt[c000000000243270] call_timer_fn+0x50/0x1c0nt[c000000000243704] __run_timers.part.0+0x324/0x460nt[c000000000243894] run_timer_softirq+0x54/0xa0nt[c000000000ea713c] __do_softirq+0x15c/0x3e0nt[c000000000166258] __irq_exit_rcu+0x158/0x190nt[c000000000166420] irq_exit+0x20/0x40nt[c00000000002853c] timer_interrupt+0x14c/0x2b0nt[c000000000009a00] decrementer_common_virt+0x210/0x220nt--- interrupt: 900 at plpar_hcall_norets_notrace+0x18/0x2cnnThe immediate cause of the crash is the access of tx_scrq in the followingnsnippet during a reset where the tx_scrq can be either NULL or an addressnthat will soon be invalid:nntibmvnic_xmit()nt{ntt...ntttx_scrq = adapter->tx_scrq[queue_num];ntttxq = netdev_get_tx_queue(netdev queue_num);nttind_bufp = &tx_scrq->ind_buf;nnttif (test_bit(0 &adapter->resetting)) {ntt...nt}nnBut beyond that the call to ibmvnic_xmit() itself is not safe during anreset and the reset path attempts to avoid this by stopping the queue innibmvnic_cleanup(). However just after the queue was stopped an in-flightnibmvnic_complete_tx() could have restarted the queue even as the reset isnprogressing.nnSince the queue was restarted we could get a call to ibmvnic_xmit() whichncan then access the bad tx_scrq (or other fields).nnWe cannot however simply have ibmvnic_complete_tx() check the ->resettingnbit and skip starting the queue. This can race at the back-end of a goodnreset which just restarted the queue but has not cleared the ->resettingnbit yet. If we skip restarting the queue due to ->resetting being truenthe queue would remain stopped indefinitely potentially leading to transmitntimeouts.nnIOW ->resetting is too broad for this purpose. Instead use a new flagnthat indicates whether or not the queues are active. Only the open/nreset paths control when the queues are active. ibmvnic_complete_tx()nand others wake up the queue only if the queue is marked active.nnSo we will have:ntA. reset/open thread in ibmvnic_cleanup() and __ibmvnic_open()nntt->resetting = truentt->tx_queues_active = falsenttdisable tx queuesntt...ntt->tx_queues_active = truenttstart tx queuesnntB. Tx interrupt in ibmvnic_complete_tx():nnttif (->tx_queues_active)ntttnetif_wake_subqueue();nnTo ensure that ->tx_queues_active and state of the queues are consistentnwe need a lock which:nnt- must also be taken in the interrupt path (ibmvnic_complete_tx())nt- shared across the multiplen---truncated---,CVE-2022-49201,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnpowerpc/64s: Don't use DSISR for SLB faultsnnSince commit 46ddcb3950a2 (powerpc/mm: Show if a bad page fault on datanis read or write.) we use page_fault_is_write(regs->dsisr) inn__bad_page_fault() to determine if the fault is for a read or write andnchange the message printed accordingly.nnBut SLB faults aka Data Segment Interrupts don't set DSISR (DatanStorage Interrupt Status Register) to a useful value. All ISA versionsnfrom v2.03 through v3.1 specify that the Data Segment Interrupt setsnDSISR to an undefined value. As far as I can see there's no mention ofnSLB faults setting DSISR in any BookIV content either.nnThis manifests as accesses that should be a read being incorrectlynreported as writes for example using the xmon dump command:nn 0:mon> d 0x5deadbeef0000000n 5deadbeef0000000n [359526.415354][ C6] BUG: Unable to handle kernel data access on write at 0x5deadbeef0000000n [359526.415611][ C6] Faulting instruction address: 0xc00000000010a300n cpu 0x6: Vector: 380 (Data SLB Access) at [c00000000ffbf400]n pc: c00000000010a300: mread+0x90/0x190nnIf we disassemble the PC we see a load instruction:nn 0:mon> di c00000000010a300n c00000000010a300 89490000 lbz r100(r9)nnWe can also see in exceptions-64s.S that the data_access_slb blockndoesn't set IDSISR=1 which means it doesn't load DSISR into pt_regs. Sonthe value we're using to determine if the fault is a read/write is somenstale value in pt_regs from a previous page fault.nnRework the printing logic to separate the SLB fault case out and onlynprint read/write in the cases where we can determine it.nnThe result looks like eg:nn 0:mon> d 0x5deadbeef0000000n 5deadbeef0000000n [ 721.779525][ C6] BUG: Unable to handle kernel data access at 0x5deadbeef0000000n [ 721.779697][ C6] Faulting instruction address: 0xc00000000014cbe0n cpu 0x6: Vector: 380 (Data SLB Access) at [c00000000ffbf390]nn 0:mon> d 0n 0000000000000000n [ 742.793242][ C6] BUG: Kernel NULL pointer dereference at 0x00000000n [ 742.793316][ C6] Faulting instruction address: 0xc00000000014cbe0n cpu 0x6: Vector: 380 (Data SLB Access) at [c00000000ffbf390],CVE-2022-49214,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnxsk: Fix race at socket teardownnnFix a race in the xsk socket teardown code that can lead to a NULL pointerndereference splat. The current xsk unbind code in xsk_unbind_dev() starts bynsetting xs->state to XSK_UNBOUND sets xs->dev to NULL and then waits for anynNAPI processing to terminate using synchronize_net(). After that the releasencode starts to tear down the socket state and free allocated memory.nn BUG: kernel NULL pointer dereference address: 00000000000000c0n PGD 8000000932469067 P4D 8000000932469067 PUD 0n Oops: 0000 [#1] PREEMPT SMP PTIn CPU: 25 PID: 69132 Comm: grpcpp_sync_ser Tainted: G I 5.16.0+ #2n Hardware name: Dell Inc. PowerEdge R730/0599V5 BIOS 1.2.10 03/09/2015n RIP: 0010:__xsk_sendmsg+0x2c/0x690n [...]n RSP: 0018:ffffa2348bd13d50 EFLAGS: 00010246n RAX: 0000000000000000 RBX: 0000000000000040 RCX: ffff8d5fc632d258n RDX: 0000000000400000 RSI: ffffa2348bd13e10 RDI: ffff8d5fc5489800n RBP: ffffa2348bd13db0 R08: 0000000000000000 R09: 00007ffffffff000n R10: 0000000000000000 R11: 0000000000000000 R12: ffff8d5fc5489800n R13: ffff8d5fcb0f5140 R14: ffff8d5fcb0f5140 R15: 0000000000000000n FS: 00007f991cff9400(0000) GS:ffff8d6f1f700000(0000) knlGS:0000000000000000n CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033n CR2: 00000000000000c0 CR3: 0000000114888005 CR4: 00000000001706e0n Call Trace:n <TASK>n ? aa_sk_perm+0x43/0x1b0n xsk_sendmsg+0xf0/0x110n sock_sendmsg+0x65/0x70n __sys_sendto+0x113/0x190n ? debug_smp_processor_id+0x17/0x20n ? fpregs_assert_state_consistent+0x23/0x50n ? exit_to_user_mode_prepare+0xa5/0x1d0n __x64_sys_sendto+0x29/0x30n do_syscall_64+0x3b/0xc0n entry_SYSCALL_64_after_hwframe+0x44/0xaennThere are two problems with the current code. First setting xs->dev to NULLnbefore waiting for all users to stop using the socket is not correct. Thenentry to the data plane functions xsk_poll() xsk_sendmsg() and xsk_recvmsg()nare all guarded by a test that xs->state is in the state XSK_BOUND and if notnit returns right away. But one process might have passed this test but stillnhave not gotten to the point in which it uses xs->dev in the code. In thisninterim a second process executing xsk_unbind_dev() might have set xs->dev tonNULL which will lead to a crash for the first process. The solution here isnjust to get rid of this NULL assignment since it is not used anymore. Beforencommit 42fddcc7c64b (xsk: use state member for socket synchronization)nxs->dev was the gatekeeper to admit processes into the data plane functionsnbut it was replaced with the state variable xs->state in the aforementionedncommit.nnThe second problem is that synchronize_net() does not wait for any process innxsk_poll() xsk_sendmsg() or xsk_recvmsg() to complete which means that thenstate they rely on might be cleaned up prematurely. This can happen when thennotifier gets called (at driver unload for example) as it uses xsk_unbind_dev().nSolve this by extending the RCU critical region from just the ndo_xsk_wakeupnto the whole functions mentioned above so that both the test of xs->state ==nXSK_BOUND and the last use of any member of xs is covered by the RCU criticalnsection. This will guarantee that when synchronize_net() completes there willnbe no processes left executing xsk_poll() xsk_sendmsg() or xsk_recvmsg() andnstate can be cleaned up safely. Note that we need to drop the RCU lock for thenskb xmit path as it uses functions that might sleep. Due to this we have tonretest the xs->state after we grab the mutex that protects the skb xmit codenfrom among a number of things an xsk_unbind_dev() being executed from thennotifier at the same time.,CVE-2022-49215,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/dp: Fix OOB read when handling Post Cursor2 registernnThe link_status array was not large enough to read the Adjust RequestnPost Cursor2 register so remove the common helper function to avoidnan OOB read found with a -Warray-bounds build:nndrivers/gpu/drm/drm_dp_helper.c: In function 'drm_dp_get_adjust_request_post_cursor':ndrivers/gpu/drm/drm_dp_helper.c:59:27: error: array subscript 10 is outside array bounds of 'const u8[6]' {aka 'const unsigned char[6]'} [-Werror=array-bounds]n 59 | return link_status[r - DP_LANE0_1_STATUS];n | ~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~ndrivers/gpu/drm/drm_dp_helper.c:147:51: note: while referencing 'link_status'n 147 | u8 drm_dp_get_adjust_request_post_cursor(const u8 link_status[DP_LINK_STATUS_SIZE]n | ~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~nnReplace the only user of the helper with an open-coded fetch and decodensimilar to drivers/gpu/drm/amd/display/dc/core/dc_link_dp.c.,CVE-2022-49218,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnvfio/pci: fix memory leak during D3hot to D0 transitionnnIf 'vfio_pci_core_device::needs_pm_restore' is set (PCI device doesnnot have No_Soft_Reset bit set in its PMCSR config register) thennthe current PCI state will be saved locally inn'vfio_pci_core_device::pm_save' during D0->D3hot transition and samenwill be restored back during D3hot->D0 transition.nFor saving the PCI state locally pci_store_saved_state() is beingnused and the pci_load_and_free_saved_state() will free the allocatednmemory.nnBut for reset related IOCTLs vfio driver calls PCI reset-relatednAPI's which will internally change the PCI power state back to D0. Sonwhen the guest resumes then it will get the current state as D0 and itnwill skip the call to vfio_pci_set_power_state() for changing thenpower state to D0 explicitly. In this case the memory pointed byn'pm_save' will never be freed. In a malicious sequence the state changingnto D3hot followed by VFIO_DEVICE_RESET/VFIO_DEVICE_PCI_HOT_RESET can benrun in a loop and it can cause an OOM situation.nnThis patch frees the earlier allocated memory first before overwritingn'pm_save' to prevent the mentioned memory leak.,CVE-2022-49219,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet: asix: add proper error handling of usb read errorsnnSyzbot once again hit uninit value in asix driver. The problem still thensame -- asix_read_cmd() reads less bytes than was requested by caller.nnSince all read requests are performed via asix_read_cmd() let's catchnusb related error there and add __must_check notation to be sure allncallers actually check return value.nnSo this patch adds sanity check inside asix_read_cmd() that simplynchecks if bytes read are not less than was requested and adds missingnerror handling of asix_read_cmd() all across the driver code.,CVE-2022-49226,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet: dsa: Avoid cross-chip syncing of VLAN filteringnnChanges to VLAN filtering are not applicable to cross-chipnnotifications.nnOn a system like this:nn.-----. .-----. .-----.n| sw1 +---+ sw2 +---+ sw3 |n'-1-2-' '-1-2-' '-1-2-'nnBefore this change upon sw1p1 leaving a bridge a call tondsa_port_vlan_filtering would also be made to sw2p1 and sw3p1.nnIn this scenario:nn.---------. .-----. .-----.n| sw1 +---+ sw2 +---+ sw3 |n'-1-2-3-4-' '-1-2-' '-1-2-'nnWhen sw1p4 would leave a bridge dsa_port_vlan_filtering would bencalled for sw2 and sw3 with a non-existing port - leading to arraynout-of-bounds accesses and crashes on mv88e6xxx.,CVE-2022-49234,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnASoC: atmel: Fix error handling in snd_proto_probennThe device_node pointer is returned by of_parse_phandle() with refcountnincremented. We should use of_node_put() on it when done.nnThis function only calls of_node_put() in the regular path.nAnd it will cause refcount leak in error paths.nFix this by calling of_node_put() in error handling too.,CVE-2022-49246,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnmmc: core: use sysfs_emit() instead of sprintf()nnsprintf() (still used in the MMC core for the sysfs output) is vulnerablento the buffer overflow. Use the new-fangled sysfs_emit() instead.nnFound by Linux Verification Center (linuxtesting.org) with the SVACE staticnanalysis tool.,CVE-2022-49267,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nncifs: fix handlecache and multiusernnIn multiuser each individual user has their own tcon structure for thenshare and thus their own handle for a cached directory.nWhen we umount such a share we much make sure to release the pinned down dentrynfor each such tcon and not just the master tcon.nnOtherwise we will get nasty warnings on umount that dentries are still in use:n[ 3459.590047] BUG: Dentry 00000000115c6f41{i=12000000019d95n=/} still in usen (2) [unmount of cifs cifs]n...n[ 3459.590492] Call Trace:n[ 3459.590500] d_walk+0x61/0x2a0n[ 3459.590518] ? shrink_lock_dentry.part.0+0xe0/0xe0n[ 3459.590526] shrink_dcache_for_umount+0x49/0x110n[ 3459.590535] generic_shutdown_super+0x1a/0x110n[ 3459.590542] kill_anon_super+0x14/0x30n[ 3459.590549] cifs_kill_sb+0xf5/0x104 [cifs]n[ 3459.590773] deactivate_locked_super+0x36/0xa0n[ 3459.590782] cleanup_mnt+0x131/0x190n[ 3459.590789] task_work_run+0x5c/0x90n[ 3459.590798] exit_to_user_mode_loop+0x151/0x160n[ 3459.590809] exit_to_user_mode_prepare+0x83/0xd0n[ 3459.590818] syscall_exit_to_user_mode+0x12/0x30n[ 3459.590828] do_syscall_64+0x48/0x90n[ 3459.590833] entry_SYSCALL_64_after_hwframe+0x44/0xae,CVE-2022-49281,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nniio: accel: mma8452: use the correct logic to get mma8452_datannThe original logic to get mma8452_data is wrong the *dev point tonthe device belong to iio_dev. we can't use this dev to find thencorrect i2c_client. The original logic happen to work because itnfinally use dev->driver_data to get iio_dev. Here use the APInto_i2c_client() is wrong and make reader confuse. To correct thenlogic it should be like thisnn struct mma8452_data *data = iio_priv(dev_get_drvdata(dev));nnBut after commit 8b7651f25962 (iio: iio_device_alloc(): Removenunnecessary self drvdata) the upper logic also can't work.nWhen try to show the avialable scale in userspace will meet kernelndump kernel handle NULL pointer dereference.nnSo use dev_to_iio_dev() to correct the logic.nnDual fixes tags as the second reflects when the bug was exposed whilstnthe first reflects when the original bug was introduced.,CVE-2022-49285,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnuaccess: fix integer overflow on access_ok()nnThree architectures check the end of a user access against thenaddress limit without taking a possible overflow into account.nPassing a negative length or another overflow in here returnsnsuccess when it should not.nnUse the most common correct implementation here which optimizesnfor a constant 'size' argument and turns the common case into ansingle comparison.,CVE-2022-49289,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Check if modulo is 0 before dividing.nn[How & Why]nIf a value of 0 is read then this will cause a divide-by-0 panic.,CVE-2022-49294,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnceph: fix possible deadlock when holding Fwb to get inline_datann1 mount with wsync.n2 create a file with O_RDWR and the request was sent to mds.0:nn ceph_atomic_open()-->n ceph_mdsc_do_request(openc)n finish_open(file dentry ceph_open)-->n ceph_open()-->n ceph_init_file()-->n ceph_init_file_info()-->n ceph_uninline_data()-->n {n ...n if (inline_version == 1 || /bin /boot /config /dev /etc /home /lib /media /mnt /opt /proc /root /run /sbin /shared /srv /sys /tmp /usr /utils /var initial version no data */n inline_version == CEPH_INLINE_NONE)n goto out_unlock;n ...n }nnThe inline_version will be 1 which is the initial version for thennew create file. And here the ci->i_inline_version will keep with 1nit's buggy.nn3 buffer write to the file immediately:nn ceph_write_iter()-->n ceph_get_caps(file need=Fw want=Fb ...);n generic_perform_write()-->n a_ops->write_begin()-->n ceph_write_begin()-->n netfs_write_begin()-->n netfs_begin_read()-->n netfs_rreq_submit_slice()-->n netfs_read_from_server()-->n rreq->netfs_ops->issue_read()-->n ceph_netfs_issue_read()-->n {n ...n if (ci->i_inline_version != CEPH_INLINE_NONE &&n ceph_netfs_issue_op_inline(subreq))n return;n ...n }n ceph_put_cap_refs(ci Fwb);nnThe ceph_netfs_issue_op_inline() will send a getattr(Fsr) request tonmds.1.nn4 then the mds.1 will request the rd lock for CInode::filelock fromnthe auth mds.0 the mds.0 will do the CInode::filelock state transationnfrom excl --> sync but it need to revoke the Fxwb caps back from thenclients.nnWhile the kernel client has aleady held the Fwb caps and waiting fornthe getattr(Fsr).nnIt's deadlock!nnURL: https://tracker.ceph.com/issues/55377,CVE-2022-49296,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrivers: staging: rtl8192eu: Fix deadlock in rtw_joinbss_event_prehandlennThere is a deadlock in rtw_joinbss_event_prehandle() which is shown below:nn (Thread 1) | (Thread 2)n | _set_timer()nrtw_joinbss_event_prehandle()| mod_timer()n spin_lock_bh() //(1) | (wait a time)n ... | rtw_join_timeout_handler()n | _rtw_join_timeout_handler()n del_timer_sync() | spin_lock_bh() //(2)n (wait timer to stop) | ...nnWe hold pmlmepriv->lock in position (1) of thread 1 andnuse del_timer_sync() to wait timer to stop but timer handlernalso need pmlmepriv->lock in position (2) of thread 2.nAs a result rtw_joinbss_event_prehandle() will block forever.nnThis patch extracts del_timer_sync() from the protection ofnspin_lock_bh() which could let timer handler to obtainnthe needed lock. What`s more we change spin_lock_bh() tonspin_lock_irq() in _rtw_join_timeout_handler() in order tonprevent deadlock.,CVE-2022-49303,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnusb: dwc3: host: Stop setting the ACPI companionnnIt is no longer needed. The sysdev pointer is now used whennassigning the ACPI companions to the xHCI ports and USBndevices.nnAssigning the ACPI companion here resulted in thenfwnode->secondary pointer to be replaced also for the parentndwc3 device since the primary fwnode (the ACPI companion)nwas shared. That was unintentional and it created potentialnside effects like resource leaks.,CVE-2022-49306,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrivers: staging: rtl8723bs: Fix deadlock in rtw_surveydone_event_callback()nnThere is a deadlock in rtw_surveydone_event_callback()nwhich is shown below:nn (Thread 1) | (Thread 2)n | _set_timer()nrtw_surveydone_event_callback()| mod_timer()n spin_lock_bh() //(1) | (wait a time)n ... | rtw_scan_timeout_handler()n del_timer_sync() | spin_lock_bh() //(2)n (wait timer to stop) | ...nnWe hold pmlmepriv->lock in position (1) of thread 1 and usendel_timer_sync() to wait timer to stop but timer handlernalso need pmlmepriv->lock in position (2) of thread 2.nAs a result rtw_surveydone_event_callback() will block forever.nnThis patch extracts del_timer_sync() from the protection ofnspin_lock_bh() which could let timer handler to obtainnthe needed lock. What`s more we change spin_lock_bh() innrtw_scan_timeout_handler() to spin_lock_irq(). Otherwisenspin_lock_bh() will also cause deadlock() in timer handler.,CVE-2022-49309,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrivers: staging: rtl8192bs: Fix deadlock in rtw_joinbss_event_prehandle()nnThere is a deadlock in rtw_joinbss_event_prehandle() which is shownnbelow:nn (Thread 1) | (Thread 2)n | _set_timer()nrtw_joinbss_event_prehandle()| mod_timer()n spin_lock_bh() //(1) | (wait a time)n ... | _rtw_join_timeout_handler()n del_timer_sync() | spin_lock_bh() //(2)n (wait timer to stop) | ...nnWe hold pmlmepriv->lock in position (1) of thread 1 andnuse del_timer_sync() to wait timer to stop but timer handlernalso need pmlmepriv->lock in position (2) of thread 2.nAs a result rtw_joinbss_event_prehandle() will block forever.nnThis patch extracts del_timer_sync() from the protection ofnspin_lock_bh() which could let timer handler to obtainnthe needed lock. What`s more we change spin_lock_bh() tonspin_lock_irq() in _rtw_join_timeout_handler() in order tonprevent deadlock.,CVE-2022-49311,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnf2fs: avoid infinite loop to flush node pagesnnxfstests/generic/475 can give EIO all the time which give an infinite loopnto flush node page like below. Let's avoid it.nn[16418.518551] Call Trace:n[16418.518553] ? dm_submit_bio+0x48/0x400n[16418.518574] ? submit_bio_checks+0x1ac/0x5a0n[16418.525207] __submit_bio+0x1a9/0x230n[16418.525210] ? kmem_cache_alloc+0x29e/0x3c0n[16418.525223] submit_bio_noacct+0xa8/0x2b0n[16418.525226] submit_bio+0x4d/0x130n[16418.525238] __submit_bio+0x49/0x310 [f2fs]n[16418.525339] ? bio_add_page+0x6a/0x90n[16418.525344] f2fs_submit_page_bio+0x134/0x1f0 [f2fs]n[16418.525365] read_node_page+0x125/0x1b0 [f2fs]n[16418.525388] __get_node_page.part.0+0x58/0x3f0 [f2fs]n[16418.525409] __get_node_page+0x2f/0x60 [f2fs]n[16418.525431] f2fs_get_dnode_of_data+0x423/0x860 [f2fs]n[16418.525452] ? asm_sysvec_apic_timer_interrupt+0x12/0x20n[16418.525458] ? __mod_memcg_state.part.0+0x2a/0x30n[16418.525465] ? __mod_memcg_lruvec_state+0x27/0x40n[16418.525467] ? __xa_set_mark+0x57/0x70n[16418.525472] f2fs_do_write_data_page+0x10e/0x7b0 [f2fs]n[16418.525493] f2fs_write_single_data_page+0x555/0x830 [f2fs]n[16418.525514] ? sysvec_apic_timer_interrupt+0x4e/0x90n[16418.525518] ? asm_sysvec_apic_timer_interrupt+0x12/0x20n[16418.525523] f2fs_write_cache_pages+0x303/0x880 [f2fs]n[16418.525545] ? blk_flush_plug_list+0x47/0x100n[16418.525548] f2fs_write_data_pages+0xfd/0x320 [f2fs]n[16418.525569] do_writepages+0xd5/0x210n[16418.525648] filemap_fdatawrite_wbc+0x7d/0xc0n[16418.525655] filemap_fdatawrite+0x50/0x70n[16418.525658] f2fs_sync_dirty_inodes+0xa4/0x230 [f2fs]n[16418.525679] f2fs_write_checkpoint+0x16d/0x1720 [f2fs]n[16418.525699] ? ttwu_do_wakeup+0x1c/0x160n[16418.525709] ? ttwu_do_activate+0x6d/0xd0n[16418.525711] ? __wait_for_common+0x11d/0x150n[16418.525715] kill_f2fs_super+0xca/0x100 [f2fs]n[16418.525733] deactivate_locked_super+0x3b/0xb0n[16418.525739] deactivate_super+0x40/0x50n[16418.525741] cleanup_mnt+0x139/0x190n[16418.525747] __cleanup_mnt+0x12/0x20n[16418.525749] task_work_run+0x6d/0xa0n[16418.525765] exit_to_user_mode_prepare+0x1ad/0x1b0n[16418.525771] syscall_exit_to_user_mode+0x27/0x50n[16418.525774] do_syscall_64+0x48/0xc0n[16418.525776] entry_SYSCALL_64_after_hwframe+0x44/0xae,CVE-2022-49317,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nntcp: add accessors to read/set tp->snd_cwndnnWe had various bugs over the years with codenbreaking the assumption that tp->snd_cwnd is greaternthan zero.nnLately syzbot reported the WARN_ON_ONCE(!tp->prior_cwnd) addednin commit 8b8a321ff72c (tcp: fix zero cwnd in tcp_cwnd_reduction)ncan trigger and without a repro we would have to spendnconsiderable time finding the bug.nnInstead of complaining too late we want to catch wherenand when tp->snd_cwnd is set to an illegal value.,CVE-2022-49325,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnmt76: fix use-after-free by removing a non-RCU wcid pointernnFixes an issue caught by KASAN about use-after-free in mt76_txq_schedulenby protecting mtxq->wcid with rcu_lock between mt76_txq_schedule andnsta_info_[alloc free].nn[18853.876689] ==================================================================n[18853.876751] BUG: KASAN: use-after-free in mt76_txq_schedule+0x204/0xaf8 [mt76]n[18853.876773] Read of size 8 at addr ffffffaf989a2138 by task mt76-tx phy0/883n[18853.876786]n[18853.876810] CPU: 5 PID: 883 Comm: mt76-tx phy0 Not tainted 5.10.100-fix-510-56778d365941-kasan #5 0b01fbbcf41a530f52043508fec2e31a4215nn[18853.876840] Call trace:n[18853.876861] dump_backtrace+0x0/0x3ecn[18853.876878] show_stack+0x20/0x2cn[18853.876899] dump_stack+0x11c/0x1acn[18853.876918] print_address_description+0x74/0x514n[18853.876934] kasan_report+0x134/0x174n[18853.876948] __asan_report_load8_noabort+0x44/0x50n[18853.876976] mt76_txq_schedule+0x204/0xaf8 [mt76 074e03e4640e97fe7405ee1fab547b81c4fa45d2]n[18853.877002] mt76_txq_schedule_all+0x2c/0x48 [mt76 074e03e4640e97fe7405ee1fab547b81c4fa45d2]n[18853.877030] mt7921_tx_worker+0xa0/0x1cc [mt7921_common f0875ebac9d7b4754e1010549e7db50fbd90a047]n[18853.877054] __mt76_worker_fn+0x190/0x22c [mt76 074e03e4640e97fe7405ee1fab547b81c4fa45d2]n[18853.877071] kthread+0x2f8/0x3b8n[18853.877087] ret_from_fork+0x10/0x30n[18853.877098]n[18853.877112] Allocated by task 941:n[18853.877131] kasan_save_stack+0x38/0x68n[18853.877147] __kasan_kmalloc+0xd4/0xfcn[18853.877163] kasan_kmalloc+0x10/0x1cn[18853.877177] __kmalloc+0x264/0x3c4n[18853.877294] sta_info_alloc+0x460/0xf88 [mac80211]n[18853.877410] ieee80211_prep_connection+0x204/0x1ee0 [mac80211]n[18853.877523] ieee80211_mgd_auth+0x6c4/0xa4c [mac80211]n[18853.877635] ieee80211_auth+0x20/0x2c [mac80211]n[18853.877733] rdev_auth+0x7c/0x438 [cfg80211]n[18853.877826] cfg80211_mlme_auth+0x26c/0x390 [cfg80211]n[18853.877919] nl80211_authenticate+0x6d4/0x904 [cfg80211]n[18853.877938] genl_rcv_msg+0x748/0x93cn[18853.877954] netlink_rcv_skb+0x160/0x2a8n[18853.877969] genl_rcv+0x3c/0x54n[18853.877985] netlink_unicast_kernel+0x104/0x1ecn[18853.877999] netlink_unicast+0x178/0x268n[18853.878015] netlink_sendmsg+0x3cc/0x5f0n[18853.878030] sock_sendmsg+0xb4/0xd8n[18853.878043] ____sys_sendmsg+0x2f8/0x53cn[18853.878058] ___sys_sendmsg+0xe8/0x150n[18853.878071] __sys_sendmsg+0xc4/0x1f4n[18853.878087] __arm64_compat_sys_sendmsg+0x88/0x9cn[18853.878101] el0_svc_common+0x1b4/0x390n[18853.878115] do_el0_svc_compat+0x8c/0xdcn[18853.878131] el0_svc_compat+0x10/0x1cn[18853.878146] el0_sync_compat_handler+0xa8/0xccn[18853.878161] el0_sync_compat+0x188/0x1c0n[18853.878171]n[18853.878183] Freed by task 10927:n[18853.878200] kasan_save_stack+0x38/0x68n[18853.878215] kasan_set_track+0x28/0x3cn[18853.878228] kasan_set_free_info+0x24/0x48n[18853.878244] __kasan_slab_free+0x11c/0x154n[18853.878259] kasan_slab_free+0x14/0x24n[18853.878273] slab_free_freelist_hook+0xac/0x1b0n[18853.878287] kfree+0x104/0x390n[18853.878402] sta_info_free+0x198/0x210 [mac80211]n[18853.878515] __sta_info_destroy_part2+0x230/0x2d4 [mac80211]n[18853.878628] __sta_info_flush+0x300/0x37c [mac80211]n[18853.878740] ieee80211_set_disassoc+0x2cc/0xa7c [mac80211]n[18853.878851] ieee80211_mgd_deauth+0x4a4/0x10a0 [mac80211]n[18853.878962] ieee80211_deauth+0x20/0x2c [mac80211]n[18853.879057] rdev_deauth+0x7c/0x438 [cfg80211]n[18853.879150] cfg80211_mlme_deauth+0x274/0x414 [cfg80211]n[18853.879243] cfg80211_mlme_down+0xe4/0x118 [cfg80211]n[18853.879335] cfg80211_disconnect+0x218/0x2d8 [cfg80211]n[18853.879427] __cfg80211_leave+0x17c/0x240 [cfg80211]n[18853.879519] cfg80211_leave+0x3c/0x58 [cfg80211]n[18853.879611] wiphy_suspend+0xdc/0x200 [cfg80211]n[18853.879628] dpm_run_callback+0x58/0x408n[18853.879642] __device_suspend+0x4cc/0x864n[18853.879658] async_suspend+0x34/0xf4n[18n---truncated---,CVE-2022-49328,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet: ethernet: bgmac: Fix refcount leak in bcma_mdio_mii_registernnof_get_child_by_name() returns a node pointer with refcountnincremented we should use of_node_put() on it when not need anymore.nAdd missing of_node_put() to avoid refcount leak.,CVE-2022-49342,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/panfrost: Job should reference MMU not file_privnnFor a while now it's been allowed for a MMU context to outlive it'sncorresponding panfrost_priv however the job structure still referencesnpanfrost_priv to get hold of the MMU context. If panfrost_priv has beennfreed this is a use-after-free which I've been able to trigger resultingnin a splat.nnTo fix this drop the reference to panfrost_priv in the job structurenand add a direct reference to the MMU structure which is what's actuallynneeded.,CVE-2022-49359,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnmacsec: fix UAF bug for real_devnnCreate a new macsec device but not get reference to real_dev. That cannnot ensure that real_dev is freed after macsec. That will trigger thenUAF bug for real_dev as following:nn==================================================================nBUG: KASAN: use-after-free in macsec_get_iflink+0x5f/0x70 drivers/net/macsec.c:3662nCall Trace:n ...n macsec_get_iflink+0x5f/0x70 drivers/net/macsec.c:3662n dev_get_iflink+0x73/0xe0 net/core/dev.c:637n default_operstate net/core/link_watch.c:42 [inline]n rfc2863_policy+0x233/0x2d0 net/core/link_watch.c:54n linkwatch_do_dev+0x2a/0x150 net/core/link_watch.c:161nnAllocated by task 22209:n ...n alloc_netdev_mqs+0x98/0x1100 net/core/dev.c:10549n rtnl_create_link+0x9d7/0xc00 net/core/rtnetlink.c:3235n veth_newlink+0x20e/0xa90 drivers/net/veth.c:1748nnFreed by task 8:n ...n kfree+0xd6/0x4d0 mm/slub.c:4552n kvfree+0x42/0x50 mm/util.c:615n device_release+0x9f/0x240 drivers/base/core.c:2229n kobject_cleanup lib/kobject.c:673 [inline]n kobject_release lib/kobject.c:704 [inline]n kref_put include/linux/kref.h:65 [inline]n kobject_put+0x1c8/0x540 lib/kobject.c:721n netdev_run_todo+0x72e/0x10b0 net/core/dev.c:10327nnAfter commit faab39f63c1f (net: allow out-of-order netdev unregistration)nand commit e5f80fcf869a (ipv6: give an IPv6 dev to blackhole_netdev) wencan add dev_hold_track() in macsec_dev_init() and dev_put_track() innmacsec_free_netdev() to fix the problem.,CVE-2022-49390,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnusb: dwc3: gadget: Replace list_for_each_entry_safe() if using givebacknnThe list_for_each_entry_safe() macro saves the current item (n) andnthe item after (n+1) so that n can be safely removed withoutncorrupting the list. However when traversing the list and removingnitems using gadget giveback the DWC3 lock is briefly releasednallowing other routines to execute. There is a situation where whilenitems are being removed from the cancelled_list usingndwc3_gadget_ep_cleanup_cancelled_requests() the pullup disablenroutine is running in parallel (due to UDC unbind). As the cleanupnroutine removes n and the pullup disable removes n+1 once thencleanup retakes the DWC3 lock it references a request who was alreadynremoved/handled. With list debug enabled this leads to a panic.nEnsure all instances of the macro are replaced where gadget givebacknis used.nnExample call stack:nnThread#1:n__dwc3_gadget_ep_set_halt() - CLEAR HALTn -> dwc3_gadget_ep_cleanup_cancelled_requests()n ->list_for_each_entry_safe()n ->dwc3_gadget_giveback(n)n ->dwc3_gadget_del_and_unmap_request()- n deleted[cancelled_list]n ->spin_unlockn ->Thread#2 executesn ...n ->dwc3_gadget_giveback(n+1)n ->Already removed!nnThread#2:ndwc3_gadget_pullup()n ->waiting for dwc3 spin_lockn ...n ->Thread#1 released lockn ->dwc3_stop_active_transfers()n ->dwc3_remove_requests()n ->fetches n+1 item from cancelled_list (n removed by Thread#1)n ->dwc3_gadget_giveback()n ->dwc3_gadget_del_and_unmap_request()- n+1 deleted[cancelled_list]n ->spin_unlock,CVE-2022-49398,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet: annotate races around sk->sk_bound_dev_ifnnUDP sendmsg() is lockless and reads sk->sk_bound_dev_if whilenthis field can be changed by another thread.nnAdds minimal annotations to avoid KCSAN splats for UDP.nFollowing patches will add more annotations to potential lockless readers.nnBUG: KCSAN: data-race in __ip6_datagram_connect / udpv6_sendmsgnnwrite to 0xffff888136d47a94 of 4 bytes by task 7681 on cpu 0:n __ip6_datagram_connect+0x6e2/0x930 net/ipv6/datagram.c:221n ip6_datagram_connect+0x2a/0x40 net/ipv6/datagram.c:272n inet_dgram_connect+0x107/0x190 net/ipv4/af_inet.c:576n __sys_connect_file net/socket.c:1900 [inline]n __sys_connect+0x197/0x1b0 net/socket.c:1917n __do_sys_connect net/socket.c:1927 [inline]n __se_sys_connect net/socket.c:1924 [inline]n __x64_sys_connect+0x3d/0x50 net/socket.c:1924n do_syscall_x64 arch/x86/entry/common.c:50 [inline]n do_syscall_64+0x2b/0x50 arch/x86/entry/common.c:80n entry_SYSCALL_64_after_hwframe+0x44/0xaennread to 0xffff888136d47a94 of 4 bytes by task 7670 on cpu 1:n udpv6_sendmsg+0xc60/0x16e0 net/ipv6/udp.c:1436n inet6_sendmsg+0x5f/0x80 net/ipv6/af_inet6.c:652n sock_sendmsg_nosec net/socket.c:705 [inline]n sock_sendmsg net/socket.c:725 [inline]n ____sys_sendmsg+0x39a/0x510 net/socket.c:2413n ___sys_sendmsg net/socket.c:2467 [inline]n __sys_sendmmsg+0x267/0x4c0 net/socket.c:2553n __do_sys_sendmmsg net/socket.c:2582 [inline]n __se_sys_sendmmsg net/socket.c:2579 [inline]n __x64_sys_sendmmsg+0x53/0x60 net/socket.c:2579n do_syscall_x64 arch/x86/entry/common.c:50 [inline]n do_syscall_64+0x2b/0x50 arch/x86/entry/common.c:80n entry_SYSCALL_64_after_hwframe+0x44/0xaennvalue changed: 0x00000000 -> 0xffffff9bnnReported by Kernel Concurrency Sanitizer on:nCPU: 1 PID: 7670 Comm: syz-executor.3 Tainted: G W 5.18.0-rc1-syzkaller-dirty #0nHardware name: Google Google Compute Engine/Google Compute Engine BIOS Google 01/01/2011nnI chose to not add Fixes: tag because race has minor consequencesnand stable teams busy enough.,CVE-2022-49420,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnf2fs: fix to do sanity check on inline_dots inodennAs Wenqing reported in bugzilla:nnhttps://bugzilla.kernel.org/show_bug.cgi?id=215765nnIt will cause a kernel panic with steps:n- mkdir mntn- mount tmp40.img mntn- ls mntnnfolio_mark_dirty+0x33/0x50nf2fs_add_regular_entry+0x541/0xad0 [f2fs]nf2fs_add_dentry+0x6c/0xb0 [f2fs]nf2fs_do_add_link+0x182/0x230 [f2fs]n__recover_dot_dentries+0x2d6/0x470 [f2fs]nf2fs_lookup+0x5af/0x6a0 [f2fs]n__lookup_slow+0xac/0x200nlookup_slow+0x45/0x70nwalk_component+0x16c/0x250npath_lookupat+0x8b/0x1f0nfilename_lookup+0xef/0x250nuser_path_at_empty+0x46/0x70nvfs_statx+0x98/0x190n__do_sys_newlstat+0x41/0x90n__x64_sys_newlstat+0x1a/0x30ndo_syscall_64+0x37/0xb0nentry_SYSCALL_64_after_hwframe+0x44/0xaennThe root cause is for special file: e.g. character block fifo ornsocket file f2fs doesn't assign address space operations pointer arraynfor mapping->a_ops field so in a fuzzed image if inline_dots flag wasntagged in special file during lookup() when f2fs runs inton__recover_dot_dentries() it will cause NULL pointer access oncenf2fs_add_regular_entry() calls a_ops->set_dirty_page().,CVE-2022-49428,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnInput: gpio-keys - cancel delayed work only in case of GPIOnngpio_keys module can either accept gpios or interrupts. The moduleninitializes delayed work in case of gpios only and is only used ifndebounce timer is not used so make sure cancel_delayed_work_sync()nis called only when its gpio-backed and debounce_use_hrtimer is false.nnThis fixes the issue seen below when the gpio_keys module is unloaded andnan interrupt pin is used instead of GPIO:nn[ 360.297569] ------------[ cut here ]------------n[ 360.302303] WARNING: CPU: 0 PID: 237 at kernel/workqueue.c:3066 __flush_work+0x414/0x470n[ 360.310531] Modules linked in: gpio_keys(-)n[ 360.314797] CPU: 0 PID: 237 Comm: rmmod Not tainted 5.18.0-rc5-arm64-renesas-00116-g73636105874d-dirty #166n[ 360.324662] Hardware name: Renesas SMARC EVK based on r9a07g054l2 (DT)n[ 360.331270] pstate: 60400005 (nZCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)n[ 360.338318] pc : __flush_work+0x414/0x470n[ 360.342385] lr : __cancel_work_timer+0x140/0x1b0n[ 360.347065] sp : ffff80000a7fba00n[ 360.350423] x29: ffff80000a7fba00 x28: ffff000012b9c5c0 x27: 0000000000000000n[ 360.357664] x26: ffff80000a7fbb80 x25: ffff80000954d0a8 x24: 0000000000000001n[ 360.364904] x23: ffff800009757000 x22: 0000000000000000 x21: ffff80000919b000n[ 360.372143] x20: ffff00000f5974e0 x19: ffff00000f5974e0 x18: ffff8000097fcf48n[ 360.379382] x17: 0000000000000000 x16: 0000000000000000 x15: 0000000000053f40n[ 360.386622] x14: ffff800009850e88 x13: 0000000000000002 x12: 000000000000a60cn[ 360.393861] x11: 000000000000a610 x10: 0000000000000000 x9 : 0000000000000008n[ 360.401100] x8 : 0101010101010101 x7 : 00000000a473c394 x6 : 0080808080808080n[ 360.408339] x5 : 0000000000000001 x4 : 0000000000000000 x3 : ffff80000919b458n[ 360.415578] x2 : ffff8000097577f0 x1 : 0000000000000001 x0 : 0000000000000000n[ 360.422818] Call trace:n[ 360.425299] __flush_work+0x414/0x470n[ 360.429012] __cancel_work_timer+0x140/0x1b0n[ 360.433340] cancel_delayed_work_sync+0x10/0x18n[ 360.437931] gpio_keys_quiesce_key+0x28/0x58 [gpio_keys]n[ 360.443327] devm_action_release+0x10/0x18n[ 360.447481] release_nodes+0x8c/0x1a0n[ 360.451194] devres_release_all+0x90/0x100n[ 360.455346] device_unbind_cleanup+0x14/0x60n[ 360.459677] device_release_driver_internal+0xe8/0x168n[ 360.464883] driver_detach+0x4c/0x90n[ 360.468509] bus_remove_driver+0x54/0xb0n[ 360.472485] driver_unregister+0x2c/0x58n[ 360.476462] platform_driver_unregister+0x10/0x18n[ 360.481230] gpio_keys_exit+0x14/0x828 [gpio_keys]n[ 360.486088] __arm64_sys_delete_module+0x1e0/0x270n[ 360.490945] invoke_syscall+0x40/0xf8n[ 360.494661] el0_svc_common.constprop.3+0xf0/0x110n[ 360.499515] do_el0_svc+0x20/0x78n[ 360.502877] el0_svc+0x48/0xf8n[ 360.505977] el0t_64_sync_handler+0x88/0xb0n[ 360.510216] el0t_64_sync+0x148/0x14cn[ 360.513930] irq event stamp: 4306n[ 360.517288] hardirqs last enabled at (4305): [<ffff8000080b0300>] __cancel_work_timer+0x130/0x1b0n[ 360.526359] hardirqs last disabled at (4306): [<ffff800008d194fc>] el1_dbg+0x24/0x88n[ 360.534204] softirqs last enabled at (4278): [<ffff8000080104a0>] _stext+0x4a0/0x5e0n[ 360.542133] softirqs last disabled at (4267): [<ffff8000080932ac>] irq_exit_rcu+0x18c/0x1b0n[ 360.550591] ---[ end trace 0000000000000000 ]---,CVE-2022-49430,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnpowerpc/xive: Fix refcount leak in xive_spapr_initnnof_find_compatible_node() returns a node pointer with refcountnincremented we should use of_node_put() on it when done.nAdd missing of_node_put() to avoid refcount leak.,CVE-2022-49437,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnpowerpc/rtas: Keep MSR[RI] set when calling RTASnnRTAS runs in real mode (MSR[DR] and MSR[IR] unset) and in 32-bit bignendian mode (MSR[SFLE] unset).nnThe change in MSR is done in enter_rtas() in a relatively complex waynsince the MSR value could be hardcoded.nnFurthermore a panic has been reported when hitting the watchdog interruptnwhile running in RTAS this leads to the following stack trace:nn watchdog: CPU 24 Hard LOCKUPn watchdog: CPU 24 TB:997512652051031 last heartbeat TB:997504470175378 (15980ms ago)n ...n Supported: No Unreleased kerneln CPU: 24 PID: 87504 Comm: drmgr Kdump: loaded Tainted: G E X 5.14.21-150400.71.1.bz196362_2-default #1 SLE15-SP4 (unreleased) 0d821077ef4faa8dfaf370efb5fdca1fa35f4e2cn NIP: 000000001fb41050 LR: 000000001fb4104c CTR: 0000000000000000n REGS: c00000000fc33d60 TRAP: 0100 Tainted: G E X (5.14.21-150400.71.1.bz196362_2-default)n MSR: 8000000002981000 <SFVECVSXME> CR: 48800002 XER: 20040020n CFAR: 000000000000011c IRQMASK: 1n GPR00: 0000000000000003 ffffffffffffffff 0000000000000001 00000000000050dcn GPR04: 000000001ffb6100 0000000000000020 0000000000000001 000000001fb09010n GPR08: 0000000020000000 0000000000000000 0000000000000000 0000000000000000n GPR12: 80040000072a40a8 c00000000ff8b680 0000000000000007 0000000000000034n GPR16: 000000001fbf6e94 000000001fbf6d84 000000001fbd1db0 000000001fb3f008n GPR20: 000000001fb41018 ffffffffffffffff 000000000000017f fffffffffffff68fn GPR24: 000000001fb18fe8 000000001fb3e000 000000001fb1adc0 000000001fb1cf40n GPR28: 000000001fb26000 000000001fb460f0 000000001fb17f18 000000001fb17000n NIP [000000001fb41050] 0x1fb41050n LR [000000001fb4104c] 0x1fb4104cn Call Trace:n Instruction dump:n XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXXn XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXXn Oops: Unrecoverable System Reset sig: 6 [#1]n LE PAGE_SIZE=64K MMU=Hash SMP NR_CPUS=2048 NUMA pSeriesn ...n Supported: No Unreleased kerneln CPU: 24 PID: 87504 Comm: drmgr Kdump: loaded Tainted: G E X 5.14.21-150400.71.1.bz196362_2-default #1 SLE15-SP4 (unreleased) 0d821077ef4faa8dfaf370efb5fdca1fa35f4e2cn NIP: 000000001fb41050 LR: 000000001fb4104c CTR: 0000000000000000n REGS: c00000000fc33d60 TRAP: 0100 Tainted: G E X (5.14.21-150400.71.1.bz196362_2-default)n MSR: 8000000002981000 <SFVECVSXME> CR: 48800002 XER: 20040020n CFAR: 000000000000011c IRQMASK: 1n GPR00: 0000000000000003 ffffffffffffffff 0000000000000001 00000000000050dcn GPR04: 000000001ffb6100 0000000000000020 0000000000000001 000000001fb09010n GPR08: 0000000020000000 0000000000000000 0000000000000000 0000000000000000n GPR12: 80040000072a40a8 c00000000ff8b680 0000000000000007 0000000000000034n GPR16: 000000001fbf6e94 000000001fbf6d84 000000001fbd1db0 000000001fb3f008n GPR20: 000000001fb41018 ffffffffffffffff 000000000000017f fffffffffffff68fn GPR24: 000000001fb18fe8 000000001fb3e000 000000001fb1adc0 000000001fb1cf40n GPR28: 000000001fb26000 000000001fb460f0 000000001fb17f18 000000001fb17000n NIP [000000001fb41050] 0x1fb41050n LR [000000001fb4104c] 0x1fb4104cn Call Trace:n Instruction dump:n XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXXn XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXXn ---[ end trace 3ddec07f638c34a2 ]---nnThis happens because MSR[RI] is unset when entering RTAS but there is nonvalid reason to not set it here.nnRTAS is expected to be called with MSR[RI] as specified in PAPR+ sectionn7.2.1 Machine State:nn R17.2.19. If called with MSR[RI] equal to 1 then RTAS must protectn its own critical regions from recursion by setting the MSR[RI] bit ton 0 when in the critical regions.nnFixing this by reviewing the way MSR is compute before calling RTAS. Now anhardcoded value meaning real n---truncated---,CVE-2022-49440,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnlist: fix a data-race around ep->rdllistnnep_poll() first calls ep_events_available() with no lock held and checksnif ep->rdllist is empty by list_empty_careful() which readsnrdllist->prev. Thus all accesses to it need some protection to avoidnstore/load-tearing.nnNote INIT_LIST_HEAD_RCU() already has the annotation for both prevnand next.nnCommit bf3b9f6372c4 (epoll: Add busy poll support to epoll with socketnfds.) added the first lockless ep_events_available() and commitnc5a282e9635e (fs/epoll: reduce the scope of wq lock in epoll_wait())nmade some ep_events_available() calls lockless and added single call underna lock finally commit e59d3c64cba6 (epoll: eliminate unnecessary locknfor zero timeout) made the last ep_events_available() lockless.nnBUG: KCSAN: data-race in do_epoll_wait / do_epoll_waitnnwrite to 0xffff88810480c7d8 of 8 bytes by task 1802 on cpu 0:n INIT_LIST_HEAD include/linux/list.h:38 [inline]n list_splice_init include/linux/list.h:492 [inline]n ep_start_scan fs/eventpoll.c:622 [inline]n ep_send_events fs/eventpoll.c:1656 [inline]n ep_poll fs/eventpoll.c:1806 [inline]n do_epoll_wait+0x4eb/0xf40 fs/eventpoll.c:2234n do_epoll_pwait fs/eventpoll.c:2268 [inline]n __do_sys_epoll_pwait fs/eventpoll.c:2281 [inline]n __se_sys_epoll_pwait+0x12b/0x240 fs/eventpoll.c:2275n __x64_sys_epoll_pwait+0x74/0x80 fs/eventpoll.c:2275n do_syscall_x64 arch/x86/entry/common.c:50 [inline]n do_syscall_64+0x44/0xd0 arch/x86/entry/common.c:80n entry_SYSCALL_64_after_hwframe+0x44/0xaennread to 0xffff88810480c7d8 of 8 bytes by task 1799 on cpu 1:n list_empty_careful include/linux/list.h:329 [inline]n ep_events_available fs/eventpoll.c:381 [inline]n ep_poll fs/eventpoll.c:1797 [inline]n do_epoll_wait+0x279/0xf40 fs/eventpoll.c:2234n do_epoll_pwait fs/eventpoll.c:2268 [inline]n __do_sys_epoll_pwait fs/eventpoll.c:2281 [inline]n __se_sys_epoll_pwait+0x12b/0x240 fs/eventpoll.c:2275n __x64_sys_epoll_pwait+0x74/0x80 fs/eventpoll.c:2275n do_syscall_x64 arch/x86/entry/common.c:50 [inline]n do_syscall_64+0x44/0xd0 arch/x86/entry/common.c:80n entry_SYSCALL_64_after_hwframe+0x44/0xaennvalue changed: 0xffff88810480c7d0 -> 0xffff888103c15098nnReported by Kernel Concurrency Sanitizer on:nCPU: 1 PID: 1799 Comm: syz-fuzzer Tainted: G W 5.17.0-rc7-syzkaller-dirty #0nHardware name: Google Google Compute Engine/Google Compute Engine BIOS Google 01/01/2011,CVE-2022-49443,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnmodule: fix [e_shstrndx].sh_size=0 OOB accessnnIt is trivial to craft a module to trigger OOB access in this line:nntif (info->secstrings[strhdr->sh_size - 1] != '0') {nnBUG: unable to handle page fault for address: ffffc90000aa0fffnPGD 100000067 P4D 100000067 PUD 100066067 PMD 10436f067 PTE 0nOops: 0000 [#1] PREEMPT SMP PTInCPU: 7 PID: 1215 Comm: insmod Not tainted 5.18.0-rc5-00007-g9bf578647087-dirty #10nHardware name: QEMU Standard PC (i440FX + PIIX 1996) BIOS 1.14.0-4.fc34 04/01/2014nRIP: 0010:load_module+0x19b/0x2391nn[rebased patch onto modules-next],CVE-2022-49444,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnblk-throttle: Set BIO_THROTTLED when bio has been throttlednn1.In current process all bio will set the BIO_THROTTLED flagnafter __blk_throtl_bio().nn2.If bio needs to be throttled it will start the timer andnstop submit bio directly. Bio will submit innblk_throtl_dispatch_work_fn() when the timer expires.But innthe current process if bio is throttled. The BIO_THROTTLEDnwill be set to bio after timer start. If the bio has beenncompleted it may cause use-after-free blow.nnBUG: KASAN: use-after-free in blk_throtl_bio+0x12f0/0x2c70nRead of size 2 at addr ffff88801b8902d4 by task fio/26380nn dump_stack+0x9b/0xcen print_address_description.constprop.6+0x3e/0x60n kasan_report.cold.9+0x22/0x3an blk_throtl_bio+0x12f0/0x2c70n submit_bio_checks+0x701/0x1550n submit_bio_noacct+0x83/0xc80n submit_bio+0xa7/0x330n mpage_readahead+0x380/0x500n read_pages+0x1c1/0xbf0n page_cache_ra_unbounded+0x471/0x6f0n do_page_cache_ra+0xda/0x110n ondemand_readahead+0x442/0xae0n page_cache_async_ra+0x210/0x300n generic_file_buffered_read+0x4d9/0x2130n generic_file_read_iter+0x315/0x490n blkdev_read_iter+0x113/0x1b0n aio_read+0x2ad/0x450n io_submit_one+0xc8e/0x1d60n __se_sys_io_submit+0x125/0x350n do_syscall_64+0x2d/0x40n entry_SYSCALL_64_after_hwframe+0x44/0xa9nnAllocated by task 26380:n kasan_save_stack+0x19/0x40n __kasan_kmalloc.constprop.2+0xc1/0xd0n kmem_cache_alloc+0x146/0x440n mempool_alloc+0x125/0x2f0n bio_alloc_bioset+0x353/0x590n mpage_alloc+0x3b/0x240n do_mpage_readpage+0xddf/0x1ef0n mpage_readahead+0x264/0x500n read_pages+0x1c1/0xbf0n page_cache_ra_unbounded+0x471/0x6f0n do_page_cache_ra+0xda/0x110n ondemand_readahead+0x442/0xae0n page_cache_async_ra+0x210/0x300n generic_file_buffered_read+0x4d9/0x2130n generic_file_read_iter+0x315/0x490n blkdev_read_iter+0x113/0x1b0n aio_read+0x2ad/0x450n io_submit_one+0xc8e/0x1d60n __se_sys_io_submit+0x125/0x350n do_syscall_64+0x2d/0x40n entry_SYSCALL_64_after_hwframe+0x44/0xa9nnFreed by task 0:n kasan_save_stack+0x19/0x40n kasan_set_track+0x1c/0x30n kasan_set_free_info+0x1b/0x30n __kasan_slab_free+0x111/0x160n kmem_cache_free+0x94/0x460n mempool_free+0xd6/0x320n bio_free+0xe0/0x130n bio_put+0xab/0xe0n bio_endio+0x3a6/0x5d0n blk_update_request+0x590/0x1370n scsi_end_request+0x7d/0x400n scsi_io_completion+0x1aa/0xe50n scsi_softirq_done+0x11b/0x240n blk_mq_complete_request+0xd4/0x120n scsi_mq_done+0xf0/0x200n virtscsi_vq_done+0xbc/0x150n vring_interrupt+0x179/0x390n __handle_irq_event_percpu+0xf7/0x490n handle_irq_event_percpu+0x7b/0x160n handle_irq_event+0xcc/0x170n handle_edge_irq+0x215/0xb20n common_interrupt+0x60/0x120n asm_common_interrupt+0x1e/0x40nnFix this by move BIO_THROTTLED set into the queue_lock.,CVE-2022-49465,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbtrfs: fix anon_dev leak in create_subvol()nnWhen btrfs_qgroup_inherit() btrfs_alloc_tree_block ornbtrfs_insert_root() fail in create_subvol() we return without freeingnanon_dev. Reorganize the error handling in create_subvol() to fix this.,CVE-2022-49469,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnBluetooth: btmtksdio: fix use-after-free at btmtksdio_recv_eventnnWe should not access skb buffer data anymore after hci_recv_frame wasncalled.nn[ 39.634809] BUG: KASAN: use-after-free in btmtksdio_recv_event+0x1b0n[ 39.634855] Read of size 1 at addr ffffff80cf28a60d by task kworkern[ 39.634962] Call trace:n[ 39.634974] dump_backtrace+0x0/0x3b8n[ 39.634999] show_stack+0x20/0x2cn[ 39.635016] dump_stack_lvl+0x60/0x78n[ 39.635040] print_address_description+0x70/0x2f0n[ 39.635062] kasan_report+0x154/0x194n[ 39.635079] __asan_report_load1_noabort+0x44/0x50n[ 39.635099] btmtksdio_recv_event+0x1b0/0x1c4n[ 39.635129] btmtksdio_txrx_work+0x6cc/0xac4n[ 39.635157] process_one_work+0x560/0xc5cn[ 39.635177] worker_thread+0x7ec/0xcc0n[ 39.635195] kthread+0x2d0/0x3d0n[ 39.635215] ret_from_fork+0x10/0x20n[ 39.635247] Allocated by task 0:n[ 39.635260] (stack is not available)n[ 39.635281] Freed by task 2392:n[ 39.635295] kasan_save_stack+0x38/0x68n[ 39.635319] kasan_set_track+0x28/0x3cn[ 39.635338] kasan_set_free_info+0x28/0x4cn[ 39.635357] ____kasan_slab_free+0x104/0x150n[ 39.635374] __kasan_slab_free+0x18/0x28n[ 39.635391] slab_free_freelist_hook+0x114/0x248n[ 39.635410] kfree+0xf8/0x2b4n[ 39.635427] skb_free_head+0x58/0x98n[ 39.635447] skb_release_data+0x2f4/0x410n[ 39.635464] skb_release_all+0x50/0x60n[ 39.635481] kfree_skb+0xc8/0x25cn[ 39.635498] hci_event_packet+0x894/0xca4 [bluetooth]n[ 39.635721] hci_rx_work+0x1c8/0x68c [bluetooth]n[ 39.635925] process_one_work+0x560/0xc5cn[ 39.635951] worker_thread+0x7ec/0xcc0n[ 39.635970] kthread+0x2d0/0x3d0n[ 39.635990] ret_from_fork+0x10/0x20n[ 39.636021] The buggy address belongs to the object at ffffff80cf28a600n which belongs to the cache kmalloc-512 of size 512n[ 39.636039] The buggy address is located 13 bytes inside ofn 512-byte region [ffffff80cf28a600 ffffff80cf28a800),CVE-2022-49470,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnmedia: mediatek: vcodec: prevent kernel crash when rmmod mtk-vcodec-dec.konnIf the driver support subdev mode the parameter dev->pm.dev will benNULL in mtk_vcodec_dec_remove. Kernel will crash when try to rmmodnmtk-vcodec-dec.ko.nn[ 4380.702726] pc : do_raw_spin_trylock+0x4/0x80n[ 4380.707075] lr : _raw_spin_lock_irq+0x90/0x14cn[ 4380.711509] sp : ffff80000819bc10n[ 4380.714811] x29: ffff80000819bc10 x28: ffff3600c03e4000 x27: 0000000000000000n[ 4380.721934] x26: 0000000000000000 x25: 0000000000000000 x24: 0000000000000000n[ 4380.729057] x23: ffff3600c0f34930 x22: ffffd5e923549000 x21: 0000000000000220n[ 4380.736179] x20: 0000000000000208 x19: ffffd5e9213e8ebc x18: 0000000000000020n[ 4380.743298] x17: 0000002000000000 x16: ffffd5e9213e8e90 x15: 696c346f65646976n[ 4380.750420] x14: 0000000000000000 x13: 0000000000000001 x12: 0000000000000040n[ 4380.757542] x11: 0000000000000000 x10: 0000000000000000 x9 : 0000000000000000n[ 4380.764664] x8 : 0000000000000000 x7 : ffff3600c7273ae8 x6 : ffffd5e9213e8ebcn[ 4380.771786] x5 : 0000000000000000 x4 : 0000000000000001 x3 : 0000000000000000n[ 4380.778908] x2 : 0000000000000000 x1 : ffff3600c03e4000 x0 : 0000000000000208n[ 4380.786031] Call trace:n[ 4380.788465] do_raw_spin_trylock+0x4/0x80n[ 4380.792462] __pm_runtime_disable+0x2c/0x1b0n[ 4380.796723] mtk_vcodec_dec_remove+0x5c/0xa0 [mtk_vcodec_dec]n[ 4380.802466] platform_remove+0x2c/0x60n[ 4380.806204] __device_release_driver+0x194/0x250n[ 4380.810810] driver_detach+0xc8/0x15cn[ 4380.814462] bus_remove_driver+0x5c/0xb0n[ 4380.818375] driver_unregister+0x34/0x64n[ 4380.822288] platform_driver_unregister+0x18/0x24n[ 4380.826979] mtk_vcodec_dec_driver_exit+0x1c/0x888 [mtk_vcodec_dec]n[ 4380.833240] __arm64_sys_delete_module+0x190/0x224n[ 4380.838020] invoke_syscall+0x48/0x114n[ 4380.841760] el0_svc_common.constprop.0+0x60/0x11cn[ 4380.846540] do_el0_svc+0x28/0x90n[ 4380.849844] el0_svc+0x4c/0x100n[ 4380.852975] el0t_64_sync_handler+0xec/0xf0n[ 4380.857148] el0t_64_sync+0x190/0x194n[ 4380.860801] Code: 94431515 17ffffca d503201f d503245f (b9400004),CVE-2022-49496,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnusbnet: Run unregister_netdev() before unbind() againnnCommit 2c9d6c2b871d (usbnet: run unbind() before unregister_netdev())nsought to fix a use-after-free on disconnect of USB Ethernet adapters.nnIt turns out that a different fix is necessary to address the issue:nhttps://lore.kernel.org/netdev/18b3541e5372bc9b9fc733d422f4e698c089077c.1650177997.git.lukas@wunner.de/nnSo the commit was not necessary.nnThe commit made binding and unbinding of USB Ethernet asymmetrical:nBefore usbnet_probe() first invoked the ->bind() callback and thennregister_netdev(). usbnet_disconnect() mirrored that by first invokingnunregister_netdev() and then ->unbind().nnSince the commit the order in usbnet_disconnect() is reversed and nonlonger mirrors usbnet_probe().nnOne consequence is that a PHY disconnected (and stopped) in ->unbind()nis afterwards stopped once more by unregister_netdev() as it closes thennetdev before unregistering. That necessitates a contortion in ->stop()nbecause the PHY may only be stopped if it hasn't already beenndisconnected.nnReverting the commit allows making the call to phy_stop() unconditionalnin ->stop().,CVE-2022-49501,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnscsi: lpfc: Inhibit aborts if external loopback plug is insertednnAfter running a short external loopback test when the external loopback isnremoved and a normal cable inserted that is directly connected to a targetndevice the system oops in the llpfc_set_rrq_active() routine.nnWhen the loopback was inserted an FLOGI was transmit. As we're looped backnwe receive the FLOGI request. The FLOGI is ABTS'd as we recognize the samenwppn thus understand it's a loopback. However as the ABTS sends addressninformation the port is not set to (fffffe) the ABTS is dropped on thenwire. A short 1 frame loopback test is run and completes before the ABTSntimes out. The looback is unplugged and the new cable plugged in and thenan FLOGI to the new device occurs and completes. Due to a mixup in refncounting the completion of the new FLOGI releases the fabric ndlp. Then thenoriginal ABTS completes and references the released ndlp generating thenoops.nnCorrect by no-op'ing the ABTS when in loopback mode (it will be droppednanyway). Added a flag to track the mode to recognize when it should benno-op'd.,CVE-2022-49504,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnmedia: i2c: max9286: fix kernel oops when removing modulennWhen removing the max9286 module we get a kernel oops:nnUnable to handle kernel paging request at virtual address 000000aa00000094nMem abort info:n ESR = 0x96000004n EC = 0x25: DABT (current EL) IL = 32 bitsn SET = 0 FnV = 0n EA = 0 S1PTW = 0n FSC = 0x04: level 0 translation faultnData abort info:n ISV = 0 ISS = 0x00000004n CM = 0 WnR = 0nuser pgtable: 4k pages 48-bit VAs pgdp=0000000880d85000n[000000aa00000094] pgd=0000000000000000 p4d=0000000000000000nInternal error: Oops: 96000004 [#1] PREEMPT SMPnModules linked in: fsl_jr_uio caam_jr rng_core libdes caamkeyblob_desc caamhash_desc caamalg_desc crypto_engine max9271 authenc crct10dif_ce mxc_jpeg_encdecnCPU: 2 PID: 713 Comm: rmmod Tainted: G C 5.15.5-00057-gaebcd29c8ed7-dirty #5nHardware name: Freescale i.MX8QXP MEK (DT)npstate: 80000005 (Nzcv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)npc : i2c_mux_del_adapters+0x24/0xf0nlr : max9286_remove+0x28/0xd0 [max9286]nsp : ffff800013a9bbf0nx29: ffff800013a9bbf0 x28: ffff00080b6da940 x27: 0000000000000000nx26: 0000000000000000 x25: 0000000000000000 x24: 0000000000000000nx23: ffff000801a5b970 x22: ffff0008048b0890 x21: ffff800009297000nx20: ffff0008048b0f70 x19: 000000aa00000064 x18: 0000000000000000nx17: 0000000000000000 x16: 0000000000000000 x15: 0000000000000000nx14: 0000000000000014 x13: 0000000000000000 x12: ffff000802da49e8nx11: ffff000802051918 x10: ffff000802da4920 x9 : ffff000800030098nx8 : 0101010101010101 x7 : 7f7f7f7f7f7f7f7f x6 : fefefeff6364626dnx5 : 8080808000000000 x4 : 0000000000000000 x3 : 0000000000000000nx2 : ffffffffffffffff x1 : ffff00080b6da940 x0 : 0000000000000000nCall trace:n i2c_mux_del_adapters+0x24/0xf0n max9286_remove+0x28/0xd0 [max9286]n i2c_device_remove+0x40/0x110n __device_release_driver+0x188/0x234n driver_detach+0xc4/0x150n bus_remove_driver+0x60/0xe0n driver_unregister+0x34/0x64n i2c_del_driver+0x58/0xa0n max9286_i2c_driver_exit+0x1c/0x490 [max9286]n __arm64_sys_delete_module+0x194/0x260n invoke_syscall+0x48/0x114n el0_svc_common.constprop.0+0xd4/0xfcn do_el0_svc+0x2c/0x94n el0_svc+0x28/0x80n el0t_64_sync_handler+0xa8/0x130n el0t_64_sync+0x1a0/0x1a4nnThe Oops happens because the I2C client data does not point tonmax9286_priv anymore but to v4l2_subdev. The change happened innmax9286_init() which calls v4l2_i2c_subdev_init() later on...nnBesides fixing the max9286_remove() function remove the call toni2c_set_clientdata() in max9286_probe() to avoid confusion and makenthe necessary changes to max9286_init() so that it doesn't have to useni2c_get_clientdata() in order to fetch the pointer to priv.,CVE-2022-49509,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nncpufreq: governor: Use kobject release() method to free dbs_datannThe struct dbs_data embeds a struct gov_attr_set andnthe struct gov_attr_set embeds a kobject. Since every kobject must havena release() method and we can't use kfree() to free it directlynso introduce cpufreq_dbs_data_release() to release the dbs_data vianthe kobject::release() method. This fixes the calltrace like below:nn ODEBUG: free active (active state 0) object type: timer_list hint: delayed_work_timer_fn+0x0/0x34n WARNING: CPU: 12 PID: 810 at lib/debugobjects.c:505 debug_print_object+0xb8/0x100n Modules linked in:n CPU: 12 PID: 810 Comm: sh Not tainted 5.16.0-next-20220120-yocto-standard+ #536n Hardware name: Marvell OcteonTX CN96XX board (DT)n pstate: 60400009 (nZCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)n pc : debug_print_object+0xb8/0x100n lr : debug_print_object+0xb8/0x100n sp : ffff80001dfcf9a0n x29: ffff80001dfcf9a0 x28: 0000000000000001 x27: ffff0001464f0000n x26: 0000000000000000 x25: ffff8000090e3f00 x24: ffff80000af60210n x23: ffff8000094dfb78 x22: ffff8000090e3f00 x21: ffff0001080b7118n x20: ffff80000aeb2430 x19: ffff800009e8f5e0 x18: 0000000000000000n x17: 0000000000000002 x16: 00004d62e58be040 x15: 013590470523aff8n x14: ffff8000090e1828 x13: 0000000001359047 x12: 00000000f5257d14n x11: 0000000000040591 x10: 0000000066c1ffea x9 : ffff8000080d15e0n x8 : ffff80000a1765a8 x7 : 0000000000000000 x6 : 0000000000000001n x5 : ffff800009e8c000 x4 : ffff800009e8c760 x3 : 0000000000000000n x2 : 0000000000000000 x1 : 0000000000000000 x0 : ffff0001474ed040n Call trace:n debug_print_object+0xb8/0x100n __debug_check_no_obj_freed+0x1d0/0x25cn debug_check_no_obj_freed+0x24/0xa0n kfree+0x11c/0x440n cpufreq_dbs_governor_exit+0xa8/0xacn cpufreq_exit_governor+0x44/0x90n cpufreq_set_policy+0x29c/0x570n store_scaling_governor+0x110/0x154n store+0xb0/0xe0n sysfs_kf_write+0x58/0x84n kernfs_fop_write_iter+0x12c/0x1c0n new_sync_write+0xf0/0x18cn vfs_write+0x1cc/0x220n ksys_write+0x74/0x100n __arm64_sys_write+0x28/0x3cn invoke_syscall.constprop.0+0x58/0xf0n do_el0_svc+0x70/0x170n el0_svc+0x54/0x190n el0t_64_sync_handler+0xa4/0x130n el0t_64_sync+0x1a0/0x1a4n irq event stamp: 189006n hardirqs last enabled at (189005): [<ffff8000080849d0>] finish_task_switch.isra.0+0xe0/0x2c0n hardirqs last disabled at (189006): [<ffff8000090667a4>] el1_dbg+0x24/0xa0n softirqs last enabled at (188966): [<ffff8000080106d0>] __do_softirq+0x4b0/0x6a0n softirqs last disabled at (188957): [<ffff80000804a618>] __irq_exit_rcu+0x108/0x1a4nn[ rjw: Because can be freed by the gov_attr_set_put() inn cpufreq_dbs_governor_exit() now it is also necessary to put then invocation of the governor ->exit() callback into the newn cpufreq_dbs_data_release() function. ],CVE-2022-49513,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnmedia: i2c: dw9714: Disable the regulator when the driver fails to probennWhen the driver fails to probe we will get the following splat:nn[ 59.305988] ------------[ cut here ]------------n[ 59.306417] WARNING: CPU: 2 PID: 395 at drivers/regulator/core.c:2257 _regulator_put+0x3ec/0x4e0n[ 59.310345] RIP: 0010:_regulator_put+0x3ec/0x4e0n[ 59.318362] Call Trace:n[ 59.318582] <TASK>n[ 59.318765] regulator_put+0x1f/0x30n[ 59.319058] devres_release_group+0x319/0x3d0n[ 59.319420] i2c_device_probe+0x766/0x940nnFix this by disabling the regulator in error handling.,CVE-2022-49528,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amdgpu/pm: fix the null pointer while the smu is disablednnIt needs to check if the pp_funcs is initialized while release thencontext otherwise it will trigger null pointer panic while the softwarensmu is not enabled.nn[ 1109.404555] BUG: kernel NULL pointer dereference address: 0000000000000078n[ 1109.404609] #PF: supervisor read access in kernel moden[ 1109.404638] #PF: error_code(0x0000) - not-present pagen[ 1109.404657] PGD 0 P4D 0n[ 1109.404672] Oops: 0000 [#1] PREEMPT SMP NOPTIn[ 1109.404701] CPU: 7 PID: 9150 Comm: amdgpu_test Tainted: G OEL 5.16.0-custom #1n[ 1109.404732] Hardware name: innotek GmbH VirtualBox/VirtualBox BIOS VirtualBox 12/01/2006n[ 1109.404765] RIP: 0010:amdgpu_dpm_force_performance_level+0x1d/0x170 [amdgpu]n[ 1109.405109] Code: 5d c3 44 8b a3 f0 80 00 00 eb e5 66 90 0f 1f 44 00 00 55 48 89 e5 41 57 41 56 41 55 41 54 53 48 83 ec 08 4c 8b b7 f0 7d 00 00 <49> 83 7e 78 00 0f 84 f2 00 00 00 80 bf 87 80 00 00 00 48 89 fb 0fn[ 1109.405176] RSP: 0018:ffffaf3083ad7c20 EFLAGS: 00010282n[ 1109.405203] RAX: 0000000000000000 RBX: ffff9796b1c14600 RCX: 0000000002862007n[ 1109.405229] RDX: ffff97968591c8c0 RSI: 0000000000000001 RDI: ffff9796a3700000n[ 1109.405260] RBP: ffffaf3083ad7c50 R08: ffffffff9897de00 R09: ffff979688d9db60n[ 1109.405286] R10: 0000000000000000 R11: ffff979688d9db90 R12: 0000000000000001n[ 1109.405316] R13: ffff9796a3700000 R14: 0000000000000000 R15: ffff9796a3708fc0n[ 1109.405345] FS: 00007ff055cff180(0000) GS:ffff9796bfdc0000(0000) knlGS:0000000000000000n[ 1109.405378] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033n[ 1109.405400] CR2: 0000000000000078 CR3: 000000000a394000 CR4: 00000000000506e0n[ 1109.405434] Call Trace:n[ 1109.405445] <TASK>n[ 1109.405456] ? delete_object_full+0x1d/0x20n[ 1109.405480] amdgpu_ctx_set_stable_pstate+0x7c/0xa0 [amdgpu]n[ 1109.405698] amdgpu_ctx_fini.part.0+0xcb/0x100 [amdgpu]n[ 1109.405911] amdgpu_ctx_do_release+0x71/0x80 [amdgpu]n[ 1109.406121] amdgpu_ctx_ioctl+0x52d/0x550 [amdgpu]n[ 1109.406327] ? _raw_spin_unlock+0x1a/0x30n[ 1109.406354] ? drm_gem_handle_delete+0x81/0xb0 [drm]n[ 1109.406400] ? amdgpu_ctx_get_entity+0x2c0/0x2c0 [amdgpu]n[ 1109.406609] drm_ioctl_kernel+0xb6/0x140 [drm],CVE-2022-49529,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnloop: implement ->free_disknnEnsure that the lo_device which is stored in the gendisk privatendata is valid until the gendisk is freed. Currently the loop drivernuses a lot of effort to make sure a device is not freed when it isnstill in use but to to fix a potential deadlock this will be relaxedna bit soon.,CVE-2022-49531,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnath11k: Change max no of active probe SSID and BSSID to fw capabilitynnThe maximum number of SSIDs in a for active probe requests is currentlynreported as 16 (WLAN_SCAN_PARAMS_MAX_SSID) when registering the driver.nThe scan_req_params structure only has the capacity to hold 10 SSIDs.nThis leads to a buffer overflow which can be triggered fromnwpa_supplicant in userspace. When copying the SSIDs into thenscan_req_params structure in the ath11k_mac_op_hw_scan route it cannoverwrite the extraie pointer.nnFirmware supports 16 ssid output.log scan_tyk_dockerimages.sh vulnerabilities.csv 4 bssid for each ssid 4 bssid combo probenrequest will be sent so totally 64 probe requests supported. Sonset both max ssid and bssid to 16 and 4 respectively. Remove thenredundant macros of ssid and bssid.nnTested-on: IPQ8074 hw2.0 AHB WLAN.HK.2.7.0.1-01300-QCAHKSWPL_SILICONZ-1,CVE-2022-49533,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnscsi: lpfc: Protect memory leak for NPIV ports sending PLOGI_RJTnnThere is a potential memory leak in lpfc_ignore_els_cmpl() andnlpfc_els_rsp_reject() that was allocated from NPIV PLOGI_RJTn(lpfc_rcv_plogi()'s login_mbox).nnCheck if cmdiocb->context_un.mbox was allocated in lpfc_ignore_els_cmpl()nand then free it back to phba->mbox_mem_pool along with mbox->ctx_buf fornservice parameters.nnFor lpfc_els_rsp_reject() failure free both the ctx_buf for servicenparameters and the login_mbox.,CVE-2022-49534,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnscsi: lpfc: Fix null pointer dereference after failing to issue FLOGI and PLOGInnIf lpfc_issue_els_flogi() fails and returns non-zero status the nodenreference count is decremented to trigger the release of the nodelistnstructure. However if there is a prior registration or dev-loss-evt worknpending the node may be released prematurely. When dev-loss-evtncompletes the released node is referenced causing a use-after-free nullnpointer dereference.nnSimilarly when processing non-zero ELS PLOGI completion status innlpfc_cmpl_els_plogi() the ndlp flags are checked for a transportnregistration before triggering node removal. If dev-loss-evt work isnpending the node may be released prematurely and a subsequent call tonlpfc_dev_loss_tmo_handler() results in a use after free ndlp dereference.nnAdd test for pending dev-loss before decrementing the node reference countnfor FLOGI PLOGI PRLI and ADISC handling.,CVE-2022-49535,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnscsi: lpfc: Fix SCSI I/O completion and abort handler deadlocknnDuring stress I/O tests with 500+ vports hard LOCKUP call traces arenobserved.nnCPU A:n native_queued_spin_lock_slowpath+0x192n _raw_spin_lock_irqsave+0x32n lpfc_handle_fcp_err+0x4c6n lpfc_fcp_io_cmd_wqe_cmpl+0x964n lpfc_sli4_fp_handle_cqe+0x266n __lpfc_sli4_process_cq+0x105n __lpfc_sli4_hba_process_cq+0x3cn lpfc_cq_poll_hdler+0x16n irq_poll_softirq+0x76n __softirqentry_text_start+0xe4n irq_exit+0xf7n do_IRQ+0x7fnnCPU B:n native_queued_spin_lock_slowpath+0x5bn _raw_spin_lock+0x1cn lpfc_abort_handler+0x13en scmd_eh_abort_handler+0x85n process_one_work+0x1a7n worker_thread+0x30n kthread+0x112n ret_from_fork+0x1fnnDiagram of lockup:nnCPUA CPUBn---- ----nlpfc_cmd->buf_lockn phba->hbalockn lpfc_cmd->buf_locknphba->hbalocknnFix by reordering the taking of the lpfc_cmd->buf_lock and phba->hbalock innlpfc_abort_handler routine so that it tries to take the lpfc_cmd->buf_locknfirst before phba->hbalock.,CVE-2022-49536,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnscsi: lpfc: Fix call trace observed during I/O with CMF enablednnThe following was seen with CMF enabled:nnBUG: using smp_processor_id() in preemptiblencode: systemd-udevd/31711nkernel: caller is lpfc_update_cmf_cmd+0x214/0x420 [lpfc]nkernel: CPU: 12 PID: 31711 Comm: systemd-udevdnkernel: Call Trace:nkernel: <TASK>nkernel: dump_stack_lvl+0x44/0x57nkernel: check_preemption_disabled+0xbf/0xe0nkernel: lpfc_update_cmf_cmd+0x214/0x420 [lpfc]nkernel: lpfc_nvme_fcp_io_submit+0x23b4/0x4df0 [lpfc]nnthis_cpu_ptr() calls smp_processor_id() in a preemptible context.nnFix by using per_cpu_ptr() with raw_smp_processor_id() instead.,CVE-2022-49537,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nncifs: fix potential double free during failed mountnnRHBZ: https://bugzilla.redhat.com/show_bug.cgi?id=2088799,CVE-2022-49541,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnscsi: lpfc: Move cfg_log_verbose check before calling lpfc_dmp_dbg()nnIn an attempt to log message 0126 with LOG_TRACE_EVENT the following hardnlockup call trace hangs the system.nnCall Trace:n _raw_spin_lock_irqsave+0x32/0x40n lpfc_dmp_dbg.part.32+0x28/0x220 [lpfc]n lpfc_cmpl_els_fdisc+0x145/0x460 [lpfc]n lpfc_sli_cancel_jobs+0x92/0xd0 [lpfc]n lpfc_els_flush_cmd+0x43c/0x670 [lpfc]n lpfc_els_flush_all_cmd+0x37/0x60 [lpfc]n lpfc_sli4_async_event_proc+0x956/0x1720 [lpfc]n lpfc_do_work+0x1485/0x1d70 [lpfc]n kthread+0x112/0x130n ret_from_fork+0x1f/0x40nKernel panic - not syncing: Hard LOCKUPnnThe same CPU tries to claim the phba->port_list_lock twice.nnMove the cfg_log_verbose checks as part of the lpfc_printf_vlog() andnlpfc_printf_log() macros before calling lpfc_dmp_dbg(). There is no neednto take the phba->port_list_lock within lpfc_dmp_dbg().,CVE-2022-49542,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnath11k: fix the warning of dev_wake in mhi_pm_disable_transition()nnWhen test device recovery with below command it has warning in messagenas below.necho assert > /sys/kernel/debug/ath11k/wcn6855 hw2.0/simulate_fw_crashnecho assert > /sys/kernel/debug/ath11k/qca6390 hw2.0/simulate_fw_crashnnwarning message:n[ 1965.642121] ath11k_pci 0000:06:00.0: simulating firmware assert crashn[ 1968.471364] ieee80211 phy0: Hardware restart was requestedn[ 1968.511305] ------------[ cut here ]------------n[ 1968.511368] WARNING: CPU: 3 PID: 1546 at drivers/bus/mhi/core/pm.c:505 mhi_pm_disable_transition+0xb37/0xda0 [mhi]n[ 1968.511443] Modules linked in: ath11k_pci ath11k mac80211 libarc4 cfg80211 qmi_helpers qrtr_mhi mhi qrtr nvme nvme_coren[ 1968.511563] CPU: 3 PID: 1546 Comm: kworker/u17:0 Kdump: loaded Tainted: G W 5.17.0-rc3-wt-ath+ #579n[ 1968.511629] Hardware name: Intel(R) Client Systems NUC8i7HVK/NUC8i7HVB BIOS HNKBLi70.86A.0067.2021.0528.1339 05/28/2021n[ 1968.511704] Workqueue: mhi_hiprio_wq mhi_pm_st_worker [mhi]n[ 1968.511787] RIP: 0010:mhi_pm_disable_transition+0xb37/0xda0 [mhi]n[ 1968.511870] Code: a9 fe ff ff 4c 89 ff 44 89 04 24 e8 03 46 f6 e5 44 8b 04 24 41 83 f8 01 0f 84 21 fe ff ff e9 4c fd ff ff 0f 0b e9 af f8 ff ff <0f> 0b e9 5c f8 ff ff 48 89 df e8 da 9e ee e3 e9 12 fd ff ff 4c 89n[ 1968.511923] RSP: 0018:ffffc900024efbf0 EFLAGS: 00010286n[ 1968.511969] RAX: 00000000ffffffff RBX: ffff88811d241250 RCX: ffffffffc0176922n[ 1968.512014] RDX: 0000000000000000 RSI: 0000000000000004 RDI: ffff888118a90a24n[ 1968.512059] RBP: ffff888118a90800 R08: 0000000000000000 R09: ffff888118a90a27n[ 1968.512102] R10: ffffed1023152144 R11: 0000000000000001 R12: ffff888118a908acn[ 1968.512229] R13: ffff888118a90928 R14: dffffc0000000000 R15: ffff888118a90a24n[ 1968.512310] FS: 0000000000000000(0000) GS:ffff888234200000(0000) knlGS:0000000000000000n[ 1968.512405] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033n[ 1968.512493] CR2: 00007f5538f443a8 CR3: 000000016dc28001 CR4: 00000000003706e0n[ 1968.512587] Call Trace:n[ 1968.512672] <TASK>n[ 1968.512751] ? _raw_spin_unlock_irq+0x1f/0x40n[ 1968.512859] mhi_pm_st_worker+0x3ac/0x790 [mhi]n[ 1968.512959] ? mhi_pm_mission_mode_transition.isra.0+0x7d0/0x7d0 [mhi]n[ 1968.513063] process_one_work+0x86a/0x1400n[ 1968.513184] ? pwq_dec_nr_in_flight+0x230/0x230n[ 1968.513312] ? move_linked_works+0x125/0x290n[ 1968.513416] worker_thread+0x6db/0xf60n[ 1968.513536] ? process_one_work+0x1400/0x1400n[ 1968.513627] kthread+0x241/0x2d0n[ 1968.513733] ? kthread_complete_and_exit+0x20/0x20n[ 1968.513821] ret_from_fork+0x22/0x30n[ 1968.513924] </TASK>nnReason is mhi_deassert_dev_wake() from mhi_device_put() is callednbut mhi_assert_dev_wake() from __mhi_device_get_sync() is not callednin progress of recovery. Commit 8e0559921f9a (bus: mhi: core:nSkip device wake in error or shutdown state) add check for thenpm_state of mhi in __mhi_device_get_sync() and the pm_state is notnthe normal state untill recovery is completed so it leads thendev_wake is not 0 and above warning print in mhi_pm_disable_transition()nwhile checking mhi_cntrl->dev_wake.nnAdd check in ath11k_pci_write32()/ath11k_pci_read32() to skip callnmhi_device_put() if mhi_device_get_sync() does not really do wakenthen the warning gone.nnTested-on: WCN6855 hw2.0 PCI WLAN.HSP.1.1-03003-QCAHSPSWPL_V1_V2_SILICONZ_LITE-2,CVE-2022-49543,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnx86/kexec: fix memory leak of elf header buffernnThis is reported by kmemleak detector:nnunreferenced object 0xffffc900002a9000 (size 4096):n comm kexec pid 14950 jiffies 4295110793 (age 373.951s)n hex dump (first 32 bytes):n 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 .ELF............n 04 00 3e 00 01 00 00 00 00 00 00 00 00 00 00 00 ..>.............n backtrace:n [<0000000016a8ef9f>] __vmalloc_node_range+0x101/0x170n [<000000002b66b6c0>] __vmalloc_node+0xb4/0x160n [<00000000ad40107d>] crash_prepare_elf64_headers+0x8e/0xcd0n [<0000000019afff23>] crash_load_segments+0x260/0x470n [<0000000019ebe95c>] bzImage64_load+0x814/0xad0n [<0000000093e16b05>] arch_kexec_kernel_image_load+0x1be/0x2a0n [<000000009ef2fc88>] kimage_file_alloc_init+0x2ec/0x5a0n [<0000000038f5a97a>] __do_sys_kexec_file_load+0x28d/0x530n [<0000000087c19992>] do_syscall_64+0x3b/0x90n [<0000000066e063a4>] entry_SYSCALL_64_after_hwframe+0x44/0xaennIn crash_prepare_elf64_headers() a buffer is allocated via vmalloc() tonstore elf headers. While it's not freed back to system correctly whennkdump kernel is reloaded or unloaded. Then memory leak is caused. Fix itnby introducing x86 specific function arch_kimage_file_post_load_cleanup()nand freeing the buffer there.nnAnd also remove the incorrect elf header buffer freeing code. Beforencalling arch specific kexec_file loading function the image instance hasnbeen initialized. So 'image->elf_headers' must be NULL. It doesn't makensense to free the elf header buffer in the place.nnThree different people have reported three bugs about the memory leak onnx86_64 inside Redhat.,CVE-2022-49546,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnKVM: x86: Use __try_cmpxchg_user() to update guest PTE A/D bitsnnUse the recently introduced __try_cmpxchg_user() to update guest PTE A/Dnbits instead of mapping the PTE into kernel address space. The VM_PFNMAPnpath is broken as it assumes that vm_pgoff is the base pfn of the mappednVMA range which is conceptually wrong as vm_pgoff is the offset relativento the file and has nothing to do with the pfn. The horrific hack workednfor the original use case (backing guest memory with /dev/mem) but leadsnto accessing random pfns for pretty much any other VM_PFNMAP case.,CVE-2022-49562,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nncrypto: qat - add param check for RSAnnReject requests with a source buffer that is bigger than the size of thenkey. This is to prevent a possible integer underflow that might happennwhen copying the source scatterlist into a linear buffer.,CVE-2022-49563,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nncrypto: qat - add param check for DHnnReject requests with a source buffer that is bigger than the size of thenkey. This is to prevent a possible integer underflow that might happennwhen copying the source scatterlist into a linear buffer.,CVE-2022-49564,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nncrypto: qat - fix memory leak in RSAnnWhen an RSA key represented in form 2 (as defined in PKCS #1 V2.1) isnused some components of the private key persist even after the TFM isnreleased.nReplace the explicit calls to free the buffers in qat_rsa_exit_tfm()nwith a call to qat_rsa_clear_ctx() which frees all buffers referenced innthe TFM context.,CVE-2022-49566,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnipv4: Fix data-races around sysctl_fib_multipath_hash_policy.nnWhile reading sysctl_fib_multipath_hash_policy it can be changednconcurrently. Thus we need to add READ_ONCE() to its readers.,CVE-2022-49579,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nntcp: Fix data-races around sysctl_tcp_migrate_req.nnWhile reading sysctl_tcp_migrate_req it can be changed concurrently.nThus we need to add READ_ONCE() to its readers.,CVE-2022-49588,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet: dsa: microchip: ksz_common: Fix refcount leak bugnnIn ksz_switch_register() we should call of_node_put() for thenreference returned by of_get_child_by_name() which has increasednthe refcount.,CVE-2022-49591,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnKVM: VMX: Prevent RSB underflow before vmenternnOn VMX there are some balanced returns between the time the guest'snSPEC_CTRL value is written and the vmenter.nnBalanced returns (matched by a preceding call) are usually ok but it'snat least theoretically possible an NMI with a deep call stack couldnempty the RSB before one of the returns.nnFor maximum paranoia don't allow *any* returns (balanced or otherwise)nbetween the SPEC_CTRL write and the vmenter.nn [ bp: Fix 32-bit build. ],CVE-2022-49610,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnASoC: rt7*-sdw: harden jack_detect_handlernnRealtek headset codec drivers typically check if the card isninstantiated before proceeding with the jack detection.nnThe rt700 rt711 and rt711-sdca are however missing a check on thencard pointer which can lead to NULL dereferences encountered inndriver bind/unbind tests.,CVE-2022-49616,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnASoC: Intel: sof_sdw: handle errors on card registrationnnIf the card registration fails typically because of deferred probesnthe device properties added for headset codecs are not removed whichnleads to kernel oopses in driver bind/unbind tests.nnWe already clean-up the device properties when the card is removednthis code can be moved as a helper and called upon card registrationnerrors.,CVE-2022-49617,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnetfilter: nf_tables: avoid skb access on nf_stolennnWhen verdict is NF_STOLEN the skb might have been freed.nnWhen tracing is enabled this can result in a use-after-free:n1. access to skb->nf_tracen2. access to skb->markn3. computation of trace idn4. dump of packet payloadnnTo avoid 1 keep a cached copy of skb->nf_trace in thentrace state struct.nRefresh this copy whenever verdict is != STOLEN.nnAvoid 2 by skipping skb->mark access if verdict is STOLEN.nn3 is avoided by precomputing the trace id.nnOnly dump the packet when verdict is not STOLEN.,CVE-2022-49622,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnpowerpc/xive/spapr: correct bitmap allocation sizennkasan detects access beyond the end of the xibm->bitmap allocation:nnBUG: KASAN: slab-out-of-bounds in _find_first_zero_bit+0x40/0x140nRead of size 8 at addr c00000001d1d0118 by task swapper/0/1nnCPU: 0 PID: 1 Comm: swapper/0 Not tainted 5.19.0-rc2-00001-g90df023b36dd #28nCall Trace:n[c00000001d98f770] [c0000000012baab8] dump_stack_lvl+0xac/0x108 (unreliable)n[c00000001d98f7b0] [c00000000068faac] print_report+0x37c/0x710n[c00000001d98f880] [c0000000006902c0] kasan_report+0x110/0x354n[c00000001d98f950] [c000000000692324] __asan_load8+0xa4/0xe0n[c00000001d98f970] [c0000000011c6ed0] _find_first_zero_bit+0x40/0x140n[c00000001d98f9b0] [c0000000000dbfbc] xive_spapr_get_ipi+0xcc/0x260n[c00000001d98fa70] [c0000000000d6d28] xive_setup_cpu_ipi+0x1e8/0x450n[c00000001d98fb30] [c000000004032a20] pSeries_smp_probe+0x5c/0x118n[c00000001d98fb60] [c000000004018b44] smp_prepare_cpus+0x944/0x9acn[c00000001d98fc90] [c000000004009f9c] kernel_init_freeable+0x2d4/0x640n[c00000001d98fd90] [c0000000000131e8] kernel_init+0x28/0x1d0n[c00000001d98fe10] [c00000000000cd54] ret_from_kernel_thread+0x5c/0x64nnAllocated by task 0:n kasan_save_stack+0x34/0x70n __kasan_kmalloc+0xb4/0xf0n __kmalloc+0x268/0x540n xive_spapr_init+0x4d0/0x77cn pseries_init_irq+0x40/0x27cn init_IRQ+0x44/0x84n start_kernel+0x2a4/0x538n start_here_common+0x1c/0x20nnThe buggy address belongs to the object at c00000001d1d0118n which belongs to the cache kmalloc-8 of size 8nThe buggy address is located 0 bytes inside ofn 8-byte region [c00000001d1d0118 c00000001d1d0120)nnThe buggy address belongs to the physical page:npage:c00c000000074740 refcount:1 mapcount:0 mapping:0000000000000000 index:0xc00000001d1d0558 pfn:0x1d1dnflags: 0x7ffff000000200(slab|node=0|zone=0|lastcpupid=0x7ffff)nraw: 007ffff000000200 c00000001d0003c8 c00000001d0003c8 c00000001d010480nraw: c00000001d1d0558 0000000001e1000a 00000001ffffffff 0000000000000000npage dumped because: kasan: bad access detectednnMemory state around the buggy address:n c00000001d1d0000: fc 00 fc fc fc fc fc fc fc fc fc fc fc fc fc fcn c00000001d1d0080: fc fc 00 fc fc fc fc fc fc fc fc fc fc fc fc fcn>c00000001d1d0100: fc fc fc 02 fc fc fc fc fc fc fc fc fc fc fc fcn ^n c00000001d1d0180: fc fc fc fc 04 fc fc fc fc fc fc fc fc fc fc fcn c00000001d1d0200: fc fc fc fc fc 04 fc fc fc fc fc fc fc fc fc fcnnThis happens because the allocation uses the wrong unit (bits) when itnshould pass (BITS_TO_LONGS(count) output.log scan_tyk_dockerimages.sh vulnerabilities.csv sizeof(long)) or equivalent. With smallnnumbers of bits the allocated object can be smaller than sizeof(long)nwhich results in invalid accesses.nnUse bitmap_zalloc() to allocate and initialize the irq bitmap paired withnbitmap_free() for consistency.,CVE-2022-49623,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nntcp: Fix a data-race around sysctl_tcp_ecn_fallback.nnWhile reading sysctl_tcp_ecn_fallback it can be changed concurrently.nThus we need to add READ_ONCE() to its reader.,CVE-2022-49630,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnicmp: Fix a data-race around sysctl_icmp_errors_use_inbound_ifaddr.nnWhile reading sysctl_icmp_errors_use_inbound_ifaddr it can be changednconcurrently. Thus we need to add READ_ONCE() to its reader.,CVE-2022-49632,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/i915/selftests: fix subtraction overflow bugnnOn some machines hole_end can be small enough to cause subtractionnoverflow. On the other side (addr + 2 output.log scan_tyk_dockerimages.sh vulnerabilities.csv min_alignment) can overflownin case of mock tests. This patch should handle both cases.nn(cherry picked from commit ab3edc679c552a466e4bf0b11af3666008bd65a2),CVE-2022-49635,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndmaengine: qcom: bam_dma: fix runtime PM underflownnCommit dbad41e7bb5f (dmaengine: qcom: bam_dma: check if the runtime pm enabled)ncaused unbalanced pm_runtime_get/put() calls when the bam isncontrolled remotely. This commit reverts it and just enables pm_runtimenin all cases the clk_* functions already just nop when the clock is NULL.nnAlso clean up a bit by removing unnecessary bamclk null checks.,CVE-2022-49650,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnsrcu: Tighten cleanup_srcu_struct() GP checksnnCurrently cleanup_srcu_struct() checks for a grace period in progressnbut it does not check for a grace period that has not yet started butnwhich might start at any time. Such a situation could result in anuse-after-free bug so this commit adds a check for a grace period thatnis needed but not yet started to cleanup_srcu_struct().,CVE-2022-49651,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet: dsa: qca8k: reset cpu port on MTU changennIt was discovered that the Documentation lacks of a fundamental detailnon how to correctly change the MAX_FRAME_SIZE of the switch.nnIn fact if the MAX_FRAME_SIZE is changed while the cpu port is on thenswitch panics and cease to send any packet. This cause the mgmt ethernetnsystem to not receive any packet (the slow fallback still works) andnmakes the device not reachable. To recover from this a switch reset isnrequired.nnTo correctly handle this turn off the cpu ports before changing thenMAX_FRAME_SIZE and turn on again after the value is applied.,CVE-2022-49654,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnpowerpc/memhotplug: Add add_pages override for PPCnnWith commit ffa0b64e3be5 (powerpc: Fix virt_addr_valid() for 64-bit Book3E & 32-bit)nthe kernel now validate the addr against high_memory value. This resultsnin the below BUG_ON with dax pfns.nn[ 635.798741][T26531] kernel BUG at mm/page_alloc.c:5521!n1:mon> encpu 0x1: Vector: 700 (Program Check) at [c000000007287630]n pc: c00000000055ed48: free_pages.part.0+0x48/0x110n lr: c00000000053ca70: tlb_finish_mmu+0x80/0xd0n sp: c0000000072878d0n msr: 800000000282b033n current = 0xc00000000afabe00n paca = 0xc00000037ffff300 irqmask: 0x03 irq_happened: 0x05n pid = 26531 comm = 50-landscape-synkernel BUG at :5521!nLinux version 5.19.0-rc3-14659-g4ec05be7c2e1 (kvaneesh@ltc-boston8) (gcc (Ubuntu 9.4.0-1ubuntu1~20.04.1) 9.4.0 GNU ld (GNU Binutils for Ubuntu) 2.34) #625 SMP Thu Jun 23 00:35:43 CDT 2022n1:mon> tn[link register ] c00000000053ca70 tlb_finish_mmu+0x80/0xd0n[c0000000072878d0] c00000000053ca54 tlb_finish_mmu+0x64/0xd0 (unreliable)n[c000000007287900] c000000000539424 exit_mmap+0xe4/0x2a0n[c0000000072879e0] c00000000019fc1c mmput+0xcc/0x210n[c000000007287a20] c000000000629230 begin_new_exec+0x5e0/0xf40n[c000000007287ae0] c00000000070b3cc load_elf_binary+0x3ac/0x1e00n[c000000007287c10] c000000000627af0 bprm_execve+0x3b0/0xaf0n[c000000007287cd0] c000000000628414 do_execveat_common.isra.0+0x1e4/0x310n[c000000007287d80] c00000000062858c sys_execve+0x4c/0x60n[c000000007287db0] c00000000002c1b0 system_call_exception+0x160/0x2c0n[c000000007287e10] c00000000000c53c system_call_common+0xec/0x250nnThe fix is to make sure we update high_memory on memory hotplug.nThis is similar to what x86 does in commit 3072e413e305 (mm/memory_hotplug: introduce add_pages),CVE-2022-49666,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbus: fsl-mc-bus: fix KASAN use-after-free in fsl_mc_bus_remove()nnIn fsl_mc_bus_remove() mc->root_mc_bus_dev->mc_io is passed tonfsl_destroy_mc_io(). However mc->root_mc_bus_dev is already freed innfsl_mc_device_remove(). Then reference to mc->root_mc_bus_dev->mc_iontriggers KASAN use-after-free. To avoid the use-after-free keep thenreference to mc->root_mc_bus_dev->mc_io in a local variable and pass tonfsl_destroy_mc_io().nnThis patch needs rework to apply to kernels older than v5.15.,CVE-2022-49711,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnice: Fix memory corruption in VF drivernnDisable VF's RX/TX queues when it's disabled. VF can have queues enablednwhen it requests a reset. If PF driver assumes that VF is disablednwhile VF still has queues configured VF may unmap DMA resources.nIn such scenario device still can map packets to memory which ends upnsilently corrupting it.nPreviously VF driver could experience memory corruption which lead toncrash:n[ 5119.170157] BUG: unable to handle kernel paging request at 00001b9780003237n[ 5119.170166] PGD 0 P4D 0n[ 5119.170173] Oops: 0002 [#1] PREEMPT_RT SMP PTIn[ 5119.170181] CPU: 30 PID: 427592 Comm: kworker/u96:2 Kdump: loaded Tainted: G W I --------- - - 4.18.0-372.9.1.rt7.166.el8.x86_64 #1n[ 5119.170189] Hardware name: Dell Inc. PowerEdge R740/014X06 BIOS 2.3.10 08/15/2019n[ 5119.170193] Workqueue: iavf iavf_adminq_task [iavf]n[ 5119.170219] RIP: 0010:__page_frag_cache_drain+0x5/0x30n[ 5119.170238] Code: 0f 0f b6 77 51 85 f6 74 07 31 d2 e9 05 df ff ff e9 90 fe ff ff 48 8b 05 49 db 33 01 eb b4 0f 1f 80 00 00 00 00 0f 1f 44 00 00 <f0> 29 77 34 74 01 c3 48 8b 07 f6 c4 80 74 0f 0f b6 77 51 85 f6 74n[ 5119.170244] RSP: 0018:ffffa43b0bdcfd78 EFLAGS: 00010282n[ 5119.170250] RAX: ffffffff896b3e40 RBX: ffff8fb282524000 RCX: 0000000000000002n[ 5119.170254] RDX: 0000000049000000 RSI: 0000000000000000 RDI: 00001b9780003203n[ 5119.170259] RBP: ffff8fb248217b00 R08: 0000000000000022 R09: 0000000000000009n[ 5119.170262] R10: 2b849d6300000000 R11: 0000000000000020 R12: 0000000000000000n[ 5119.170265] R13: 0000000000001000 R14: 0000000000000009 R15: 0000000000000000n[ 5119.170269] FS: 0000000000000000(0000) GS:ffff8fb1201c0000(0000) knlGS:0000000000000000n[ 5119.170274] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033n[ 5119.170279] CR2: 00001b9780003237 CR3: 00000008f3e1a003 CR4: 00000000007726e0n[ 5119.170283] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000n[ 5119.170286] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400n[ 5119.170290] PKRU: 55555554n[ 5119.170292] Call Trace:n[ 5119.170298] iavf_clean_rx_ring+0xad/0x110 [iavf]n[ 5119.170324] iavf_free_rx_resources+0xe/0x50 [iavf]n[ 5119.170342] iavf_free_all_rx_resources.part.51+0x30/0x40 [iavf]n[ 5119.170358] iavf_virtchnl_completion+0xd8a/0x15b0 [iavf]n[ 5119.170377] ? iavf_clean_arq_element+0x210/0x280 [iavf]n[ 5119.170397] iavf_adminq_task+0x126/0x2e0 [iavf]n[ 5119.170416] process_one_work+0x18f/0x420n[ 5119.170429] worker_thread+0x30/0x370n[ 5119.170437] ? process_one_work+0x420/0x420n[ 5119.170445] kthread+0x151/0x170n[ 5119.170452] ? set_kthread_struct+0x40/0x40n[ 5119.170460] ret_from_fork+0x35/0x40n[ 5119.170477] Modules linked in: iavf sctp ip6_udp_tunnel udp_tunnel mlx4_en mlx4_core nfp tls vhost_net vhost vhost_iotlb tap tun xt_CHECKSUM ipt_MASQUERADE xt_conntrack ipt_REJECT nf_reject_ipv4 nft_compat nft_counter nft_chain_nat nf_nat nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 nf_tables nfnetlink bridge stp llc rpcsec_gss_krb5 auth_rpcgss nfsv4 dns_resolver nfs lockd grace fscache sunrpc intel_rapl_msr iTCO_wdt iTCO_vendor_support dell_smbios wmi_bmof dell_wmi_descriptor dcdbas kvm_intel kvm irqbypass intel_rapl_common isst_if_common skx_edac irdma nfit libnvdimm x86_pkg_temp_thermal i40e intel_powerclamp coretemp crct10dif_pclmul crc32_pclmul ghash_clmulni_intel ib_uverbs rapl ipmi_ssif intel_cstate intel_uncore mei_me pcspkr acpi_ipmi ib_core mei lpc_ich i2c_i801 ipmi_si ipmi_devintf wmi ipmi_msghandler acpi_power_meter xfs libcrc32c sd_mod t10_pi sg mgag200 drm_kms_helper syscopyarea sysfillrect sysimgblt fb_sys_fops ice ahci drm libahci crc32c_intel libata tg3 megaraid_sasn[ 5119.170613] i2c_algo_bit dm_mirror dm_region_hash dm_log dm_mod fuse [last unloaded: iavf]n[ 5119.170627] CR2: 00001b9780003237,CVE-2022-49722,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnipv6: Fix signed integer overflow in __ip6_append_datannResurrect ubsan overflow checks and ubsan report this warningnfix it by change the variable [length] type to size_t.nnUBSAN: signed-integer-overflow in net/ipv6/ip6_output.c:1489:19n2147479552 + 8567 cannot be represented in type 'int'nCPU: 0 PID: 253 Comm: err Not tainted 5.16.0+ #1nHardware name: linuxdummy-virt (DT)nCall trace:n dump_backtrace+0x214/0x230n show_stack+0x30/0x78n dump_stack_lvl+0xf8/0x118n dump_stack+0x18/0x30n ubsan_epilogue+0x18/0x60n handle_overflow+0xd0/0xf0n __ubsan_handle_add_overflow+0x34/0x44n __ip6_append_data.isra.48+0x1598/0x1688n ip6_append_data+0x128/0x260n udpv6_sendmsg+0x680/0xdd0n inet6_sendmsg+0x54/0x90n sock_sendmsg+0x70/0x88n ____sys_sendmsg+0xe8/0x368n ___sys_sendmsg+0x98/0xe0n __sys_sendmmsg+0xf4/0x3b8n __arm64_sys_sendmmsg+0x34/0x48n invoke_syscall+0x64/0x160n el0_svc_common.constprop.4+0x124/0x300n do_el0_svc+0x44/0xc8n el0_svc+0x3c/0x1e8n el0t_64_sync_handler+0x88/0xb0n el0t_64_sync+0x16c/0x170nnChanges since v1:n-Change the variable [length] type to unsigned as Eric Dumazet suggested.nChanges since v2:n-Don't change exthdrlen type in ip6_make_skb as Paolo Abeni suggested.nChanges since v3:n-Don't change ulen type in udpv6_sendmsg and l2tp_ip6_sendmsg asnJakub Kicinski suggested.,CVE-2022-49728,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnscsi: lpfc: Resolve NULL ptr dereference after an ELS LOGO is abortednnA use-after-free crash can occur after an ELS LOGO is aborted.nnSpecifically a nodelist structure is freed and thennndlp->vport->cfg_log_verbose is dereferenced in lpfc_nlp_get() when thendiscovery state machine is mistakenly called a second time withnNLP_EVT_DEVICE_RM argument.nnRework lpfc_cmpl_els_logo() to prevent the duplicate calls to release annodelist structure.,CVE-2022-49730,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnf2fs: initialize locks earlier in f2fs_fill_super()nnsyzbot is reporting lockdep warning at f2fs_handle_error() [1] fornspin_lock(&sbi->error_lock) is called before spin_lock_init() is called.nFor safe locking in error handling move initialization of locks (andnobvious structures) in f2fs_fill_super() to immediately after memorynallocation.,CVE-2022-49742,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnovl: Use buf flexible array for memcpy() destinationnnThe buf flexible array needs to be the memcpy() destination to avoidnfalse positive run-time warning from the recent FORTIFY_SOURCEnhardening:nn memcpy: detected field-spanning write (size 93) of single field &fh->fbn at fs/overlayfs/export.c:799 (size 21),CVE-2022-49743,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nncpufreq: CPPC: Add u64 casts to avoid overflowingnnThe fields of the _CPC object are unsigned 32-bits values.nTo avoid overflows while using _CPC's values add 'u64' casts.,CVE-2022-49750,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnreset: uniphier-glue: Fix possible null-ptr-derefnnIt will cause null-ptr-deref when resource_size(res) invokednif platform_get_resource() returns NULL.,CVE-2022-49758,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbpf: Prevent bpf program recursion for raw tracepoint probesnnWe got report from sysbot [1] about warnings that were caused bynbpf program attached to contention_begin raw tracepoint triggeringnthe same tracepoint by using bpf_trace_printk helper that takesntrace_printk_lock lock.nn Call Trace:n <TASK>n ? trace_event_raw_event_bpf_trace_printk+0x5f/0x90n bpf_trace_printk+0x2b/0xe0n bpf_prog_a9aec6167c091eef_prog+0x1f/0x24n bpf_trace_run2+0x26/0x90n native_queued_spin_lock_slowpath+0x1c6/0x2b0n _raw_spin_lock_irqsave+0x44/0x50n bpf_trace_printk+0x3f/0xe0n bpf_prog_a9aec6167c091eef_prog+0x1f/0x24n bpf_trace_run2+0x26/0x90n native_queued_spin_lock_slowpath+0x1c6/0x2b0n _raw_spin_lock_irqsave+0x44/0x50n bpf_trace_printk+0x3f/0xe0n bpf_prog_a9aec6167c091eef_prog+0x1f/0x24n bpf_trace_run2+0x26/0x90n native_queued_spin_lock_slowpath+0x1c6/0x2b0n _raw_spin_lock_irqsave+0x44/0x50n bpf_trace_printk+0x3f/0xe0n bpf_prog_a9aec6167c091eef_prog+0x1f/0x24n bpf_trace_run2+0x26/0x90n native_queued_spin_lock_slowpath+0x1c6/0x2b0n _raw_spin_lock_irqsave+0x44/0x50n __unfreeze_partials+0x5b/0x160n ...nnThe can be reproduced by attaching bpf program as raw tracepoint onncontention_begin tracepoint. The bpf prog calls bpf_trace_printknhelper. Then by running perf bench the spin lock code is forced tontake slow path and call contention_begin tracepoint.nnFixing this by skipping execution of the bpf program if it'snalready running Using bpf prog 'active' field which is beingncurrently used by trampoline programs for the same reason.nnMoving bpf_prog_inc_misses_counter to syscall.c becausentrampoline.c is compiled in just for CONFIG_BPF_JIT option.nn[1] https://lore.kernel.org/bpf/YxhFe3EwqchC%2FfYf@krava/T/#t,CVE-2022-49764,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet/9p: use a dedicated spinlock for trans_fdnnShamelessly copying the explanation from Tetsuo Handa's suggestednpatch[1] (slightly reworded):nsyzbot is reporting inconsistent lock state in p9_req_put()[2]nfor p9_tag_remove() from p9_req_put() from IRQ context is usingnspin_lock_irqsave() on struct p9_client->lock but trans_fdn(not from IRQ context) is using spin_lock().nnSince the locks actually protect different things in client.c and inntrans_fd.c just replace trans_fd.c's lock by a new one specific to thentransport (client.c's protect the idr for fid/tag allocationsnwhile trans_fd.c's protects its own req list and request status fieldnthat acts as the transport's state machine),CVE-2022-49765,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnetlink: Bounds-check struct nlmsgerr creationnnIn preparation for FORTIFY_SOURCE doing bounds-check on memcpy()nswitch from __nlmsg_put to nlmsg_put() and explain the bounds checknfor dealing with the memcpy() across a composite flexible array struct.nAvoids this future run-time warning:nn memcpy: detected field-spanning write (size 32) of single field &errmsg->msg at net/netlink/af_netlink.c:2447 (size 16),CVE-2022-49766,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Fix optc2_configure warning on dcn314nn[Why]ndcn314 uses optc2_configure_crc() that wrapsnoptc1_configure_crc() + set additional registersnnot applicable to dcn314.nIt's not critical but when used leads to warning like:nWARNING: drivers/gpu/drm/amd/amdgpu/../display/dc/dc_helper.cnCall Trace:n<TASK>ngeneric_reg_set_ex+0x6d/0xe0 [amdgpu]noptc2_configure_crc+0x60/0x80 [amdgpu]ndc_stream_configure_crc+0x129/0x150 [amdgpu]namdgpu_dm_crtc_configure_crc_source+0x5d/0xe0 [amdgpu]nn[How]nUse optc1_configure_crc() directly,CVE-2022-49773,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nntracing: Fix memory leak in tracing_read_pipe()nnkmemleak reports this issue:nnunreferenced object 0xffff888105a18900 (size 128):n comm test_progs pid 18933 jiffies 4336275356 (age 22801.766s)n hex dump (first 32 bytes):n 25 73 00 90 81 88 ff ff 26 05 00 00 42 01 58 04 %s......&...B.X.n 03 00 00 00 02 00 00 00 00 00 00 00 00 00 00 00 ................n backtrace:n [<00000000560143a1>] __kmalloc_node_track_caller+0x4a/0x140n [<000000006af00822>] krealloc+0x8d/0xf0n [<00000000c309be6a>] trace_iter_expand_format+0x99/0x150n [<000000005a53bdb6>] trace_check_vprintf+0x1e0/0x11d0n [<0000000065629d9d>] trace_event_printf+0xb6/0xf0n [<000000009a690dc7>] trace_raw_output_bpf_trace_printk+0x89/0xc0n [<00000000d22db172>] print_trace_line+0x73c/0x1480n [<00000000cdba76ba>] tracing_read_pipe+0x45c/0x9f0n [<0000000015b58459>] vfs_read+0x17b/0x7c0n [<000000004aeee8ed>] ksys_read+0xed/0x1c0n [<0000000063d3d898>] do_syscall_64+0x3b/0x90n [<00000000a06dda7f>] entry_SYSCALL_64_after_hwframe+0x63/0xcdnniter->fmt alloced inn tracing_read_pipe() -> .. ->trace_iter_expand_format() but notnfreed to fix add free in tracing_release_pipe(),CVE-2022-49801,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnetdevsim: Fix memory leak of nsim_dev->fa_cookiennkmemleak reports this issue:nnunreferenced object 0xffff8881bac872d0 (size 8):n comm sh pid 58603 jiffies 4481524462 (age 68.065s)n hex dump (first 8 bytes):n 04 00 00 00 de ad be ef ........n backtrace:n [<00000000c80b8577>] __kmalloc+0x49/0x150n [<000000005292b8c6>] nsim_dev_trap_fa_cookie_write+0xc1/0x210 [netdevsim]n [<0000000093d78e77>] full_proxy_write+0xf3/0x180n [<000000005a662c16>] vfs_write+0x1c5/0xaf0n [<000000007aabf84a>] ksys_write+0xed/0x1c0n [<000000005f1d2e47>] do_syscall_64+0x3b/0x90n [<000000006001c6ec>] entry_SYSCALL_64_after_hwframe+0x63/0xcdnnThe issue occurs in the following scenarios:nnnsim_dev_trap_fa_cookie_write()n kmalloc() fa_cookien nsim_dev->fa_cookie = fa_cookien..nnsim_drv_remove()nnThe fa_cookie allocked in nsim_dev_trap_fa_cookie_write() is not freed. Tonfix add kfree(nsim_dev->fa_cookie) to nsim_drv_remove().,CVE-2022-49803,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nncifs: Fix connections leak when tlink setup failednnIf the tlink setup failed lost to put the connections thennthe module refcnt leak since the cifsd kthread not exit.nnAlso leak the fscache info and for next mount with fsc it willnprint the follow errors:n CIFS: Cache volume key already in use (cifs127.0.0.1:445TEST)nnLet's check the result of tlink setup and do some cleanup.,CVE-2022-49822,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnhugetlbfs: don't delete error page from pagecachennThis change is very similar to the change that was made for shmem [1] andnit solves the same problem but for HugeTLBFS instead.nnCurrently when poison is found in a HugeTLB page the page is removednfrom the page cache. That means that attempting to map or read thatnhugepage in the future will result in a new hugepage being allocatedninstead of notifying the user that the page was poisoned. As [1] statesnthis is effectively memory corruption.nnThe fix is to leave the page in the page cache. If the user attempts tonuse a poisoned HugeTLB page with a syscall the syscall will fail withnEIO the same error code that shmem uses. For attempts to map the pagenthe thread will get a BUS_MCEERR_AR SIGBUS.nn[1]: commit a76054266661 (mm: shmem: don't truncate page if memory failure happens),CVE-2022-49828,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/scheduler: fix fence ref countingnnWe leaked dependency fences when processes were beeing killed.nnAdditional to that grab a reference to the last scheduled fence.,CVE-2022-49829,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbtrfs: zoned: initialize device's zone info for seedingnnWhen performing seeding on a zoned filesystem it is necessary toninitialize each zoned device's btrfs_zoned_device_info structurenotherwise mounting the filesystem will cause a NULL pointer dereference.nnThis was uncovered by fstests' testcase btrfs/163.,CVE-2022-49831,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbtrfs: zoned: clone zoned device info when cloning a devicennWhen cloning a btrfs_device we're not cloning the associatednbtrfs_zoned_device_info structure of the device in case of a zonednfilesystem.nnLater on this leads to a NULL pointer dereference when accessing thendevice's zone_info for instance when setting a zone as active.nnThis was uncovered by fstests' testcase btrfs/161.,CVE-2022-49833,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbpf: Fix memory leaks in __check_func_callnnkmemleak reports this issue:nnunreferenced object 0xffff88817139d000 (size 2048):n comm test_progs pid 33246 jiffies 4307381979 (age 45851.820s)n hex dump (first 32 bytes):n 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................n 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................n backtrace:n [<0000000045f075f0>] kmalloc_trace+0x27/0xa0n [<0000000098b7c90a>] __check_func_call+0x316/0x1230n [<00000000b4c3c403>] check_helper_call+0x172e/0x4700n [<00000000aa3875b7>] do_check+0x21d8/0x45e0n [<000000001147357b>] do_check_common+0x767/0xaf0n [<00000000b5a595b4>] bpf_check+0x43e3/0x5bc0n [<0000000011e391b1>] bpf_prog_load+0xf26/0x1940n [<0000000007f765c0>] __sys_bpf+0xd2c/0x3650n [<00000000839815d6>] __x64_sys_bpf+0x75/0xc0n [<00000000946ee250>] do_syscall_64+0x3b/0x90n [<0000000000506b7f>] entry_SYSCALL_64_after_hwframe+0x63/0xcdnnThe root case here is: In function prepare_func_exit() the callee isnnot released in the abnormal scenario after state->curframe--;. Tonfix move state->curframe--; to the very bottom of the functionnright when we free callee and reset frame[] pointer to NULL as Andriinsuggested.nnIn addition function __check_func_call() has a similar problem. Innthe abnormal scenario before state->curframe++; the callee alsonshould be released by free_func_state().,CVE-2022-49837,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnocteontx2-pf: Fix SQE threshold checkingnnCurrent way of checking available SQE count which is based onnHW updated SQB count could result in driver submitting an SQEneven before CQE for the previously transmitted SQE at the samenindex is processed in NAPI resulting losing SKB pointersnhence a leak. Fix this by checking a consumer index whichnis updated once CQE is processed.,CVE-2022-49858,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amdkfd: Fix NULL pointer dereference in svm_migrate_to_ram()nn./drivers/gpu/drm/amd/amdkfd/kfd_migrate.c:985:58-62: ERROR: p is NULL but dereferenced.,CVE-2022-49864,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbtrfs: fix tree mod log mishandling of reallocated nodesnnWe have been seeing the following panic in productionnn kernel BUG at fs/btrfs/tree-mod-log.c:677!n invalid opcode: 0000 [#1] SMPn RIP: 0010:tree_mod_log_rewind+0x1b4/0x200n RSP: 0000:ffffc9002c02f890 EFLAGS: 00010293n RAX: 0000000000000003 RBX: ffff8882b448c700 RCX: 0000000000000000n RDX: 0000000000008000 RSI: 00000000000000a7 RDI: ffff88877d831c00n RBP: 0000000000000002 R08: 000000000000009f R09: 0000000000000000n R10: 0000000000000000 R11: 0000000000100c40 R12: 0000000000000001n R13: ffff8886c26d6a00 R14: ffff88829f5424f8 R15: ffff88877d831a00n FS: 00007fee1d80c780(0000) GS:ffff8890400c0000(0000) knlGS:0000000000000000n CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033n CR2: 00007fee1963a020 CR3: 0000000434f33002 CR4: 00000000007706e0n DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000n DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400n PKRU: 55555554n Call Trace:n btrfs_get_old_root+0x12b/0x420n btrfs_search_old_slot+0x64/0x2f0n ? tree_mod_log_oldest_root+0x3d/0xf0n resolve_indirect_ref+0xfd/0x660n ? ulist_alloc+0x31/0x60n ? kmem_cache_alloc_trace+0x114/0x2c0n find_parent_nodes+0x97a/0x17e0n ? ulist_alloc+0x30/0x60n btrfs_find_all_roots_safe+0x97/0x150n iterate_extent_inodes+0x154/0x370n ? btrfs_search_path_in_tree+0x240/0x240n iterate_inodes_from_logical+0x98/0xd0n ? btrfs_search_path_in_tree+0x240/0x240n btrfs_ioctl_logical_to_ino+0xd9/0x180n btrfs_ioctl+0xe2/0x2ec0n ? __mod_memcg_lruvec_state+0x3d/0x280n ? do_sys_openat2+0x6d/0x140n ? kretprobe_dispatcher+0x47/0x70n ? kretprobe_rethook_handler+0x38/0x50n ? rethook_trampoline_handler+0x82/0x140n ? arch_rethook_trampoline_callback+0x3b/0x50n ? kmem_cache_free+0xfb/0x270n ? do_sys_openat2+0xd5/0x140n __x64_sys_ioctl+0x71/0xb0n do_syscall_64+0x2d/0x40nnWhich is this code in tree_mod_log_rewind()nntswitch (tm->op) {n case BTRFS_MOD_LOG_KEY_REMOVE_WHILE_FREEING:nttBUG_ON(tm->slot < n);nnThis occurs because we replay the nodes in order that they happened andnwhen we do a REPLACE we will log a REMOVE_WHILE_FREEING for every slotnstarting at 0. 'n' here is the number of items in this block which innthis case was 1 but we had 2 REMOVE_WHILE_FREEING operations.nnThe actual root cause of this was that we were replaying operations forna block that shouldn't have been replayed. Consider the followingnsequence of eventsnn1. We have an already modified root and we do a btrfs_get_tree_mod_seq().n2. We begin removing items from this root triggering KEY_REPLACE forn it's child slots.n3. We remove one of the 2 children this root node points to thus triggeringn the root node promotion of the remaining child and freeing this node.n4. We modify a new root and re-allocate the above node to the root node ofn this other root.nnThe tree mod log looks something like thisnntlogical 0top KEY_REPLACE (slot 1)tttseq 2ntlogical 0top KEY_REMOVE (slot 1)tttseq 3ntlogical 0top KEY_REMOVE_WHILE_FREEING (slot 0)tseq 4ntlogical 4096top LOG_ROOT_REPLACE (old logical 0)tseq 5ntlogical 8192top KEY_REMOVE_WHILE_FREEING (slot 1)tseq 6ntlogical 8192top KEY_REMOVE_WHILE_FREEING (slot 0)tseq 7ntlogical 0top LOG_ROOT_REPLACE (old logical 8192)tseq 8nn>From here the bug is triggered by the following stepsnn1. Call btrfs_get_old_root() on the new_root.n2. We call tree_mod_log_oldest_root(btrfs_root_node(new_root)) which isn currently logical 0.n3. tree_mod_log_oldest_root() calls tree_mod_log_search_oldest() whichn gives us the KEY_REPLACE seq 2 and since that's not an LOG_ROOT_REPLACE we incorrectly believe that we don't have an oldn root because we expect that the most recent change should be an LOG_ROOT_REPLACE.n4. Back in tree_mod_log_oldest_root() we don't have a LOG_ROOT_REPLACEn so we don't set old_root we simply use our en---truncated---,CVE-2022-49898,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnblk-mq: Fix kmemleak in blk_mq_init_allocated_queuennThere is a kmemleak caused by modprobe null_blk.konnunreferenced object 0xffff8881acb1f000 (size 1024):n comm modprobe pid 836 jiffies 4294971190 (age 27.068s)n hex dump (first 32 bytes):n 00 00 00 00 ad 4e ad de ff ff ff ff 00 00 00 00 .....N..........n ff ff ff ff ff ff ff ff 00 53 99 9e ff ff ff ff .........S......n backtrace:n [<000000004a10c249>] kmalloc_node_trace+0x22/0x60n [<00000000648f7950>] blk_mq_alloc_and_init_hctx+0x289/0x350n [<00000000af06de0e>] blk_mq_realloc_hw_ctxs+0x2fe/0x3d0n [<00000000e00c1872>] blk_mq_init_allocated_queue+0x48c/0x1440n [<00000000d16b4e68>] __blk_mq_alloc_disk+0xc8/0x1c0n [<00000000d10c98c3>] 0xffffffffc450d69dn [<00000000b9299f48>] 0xffffffffc4538392n [<0000000061c39ed6>] do_one_initcall+0xd0/0x4f0n [<00000000b389383b>] do_init_module+0x1a4/0x680n [<0000000087cf3542>] load_module+0x6249/0x7110n [<00000000beba61b8>] __do_sys_finit_module+0x140/0x200n [<00000000fdcfff51>] do_syscall_64+0x35/0x80n [<000000003c0f1f71>] entry_SYSCALL_64_after_hwframe+0x46/0xb0nnThat is because q->ma_ops is set to NULL before blk_release_queue isncalled.nnblk_mq_init_queue_datan blk_mq_init_allocated_queuen blk_mq_realloc_hw_ctxsn for (i = 0; i < set->nr_hw_queues; i++) {n old_hctx = xa_load(&q->hctx_table i);n if (!blk_mq_alloc_and_init_hctx(.. i ..))tt[1]n if (!old_hctx)nt break;nn xa_for_each_start(&q->hctx_table j hctx j)n blk_mq_exit_hctx(q set hctx j); ttt[2]nn if (!q->nr_hw_queues)ttttt[3]n goto err_hctxs;nn err_exit:n q->mq_ops = NULL;ttt ttt[4]nn blk_put_queuen blk_release_queuen if (queue_is_mq(q))ttttt[5]n blk_mq_release(q);nn[1]: blk_mq_alloc_and_init_hctx failed at i != 0.n[2]: The hctxs allocated by [1] are moved to q->unused_hctx_list andnwill be cleaned up in blk_mq_release.n[3]: q->nr_hw_queues is 0.n[4]: Set q->mq_ops to NULL.n[5]: queue_is_mq returns false due to [4]. And blk_mq_releasenwill not be called. The hctxs in q->unused_hctx_list are leaked.nnTo fix it call blk_release_queue in exception path.,CVE-2022-49901,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnKVM: VMX: Do _all_ initialization before exposing /dev/kvm to userspacennCall kvm_init() only after _all_ setup is complete as kvm_init() exposesn/dev/kvm to userspace and thus allows userspace to create VMs (and callnother ioctls). E.g. KVM will encounter a NULL pointer when attempting tonadd a vCPU to the per-CPU loaded_vmcss_on_cpu list if userspace is able toncreate a VM before vmx_init() configures said list.nn BUG: kernel NULL pointer dereference address: 0000000000000008n #PF: supervisor write access in kernel moden #PF: error_code(0x0002) - not-present pagen PGD 0 P4D 0n Oops: 0002 [#1] SMPn CPU: 6 PID: 1143 Comm: stable Not tainted 6.0.0-rc7+ #988n Hardware name: QEMU Standard PC (Q35 + ICH9 2009) BIOS 0.0.0 02/06/2015n RIP: 0010:vmx_vcpu_load_vmcs+0x68/0x230 [kvm_intel]n <TASK>n vmx_vcpu_load+0x16/0x60 [kvm_intel]n kvm_arch_vcpu_load+0x32/0x1f0 [kvm]n vcpu_load+0x2f/0x40 [kvm]n kvm_arch_vcpu_create+0x231/0x310 [kvm]n kvm_vm_ioctl+0x79f/0xe10 [kvm]n ? handle_mm_fault+0xb1/0x220n __x64_sys_ioctl+0x80/0xb0n do_syscall_64+0x2b/0x50n entry_SYSCALL_64_after_hwframe+0x46/0xb0n RIP: 0033:0x7f5a6b05743bn </TASK>n Modules linked in: vhost_net vhost vhost_iotlb tap kvm_intel(+) kvm irqbypass,CVE-2022-49932,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnKVM: VMX: Reset eVMCS controls in VP assist page during hardware disablingnnReset the eVMCS controls in the per-CPU VP assist page during hardwarendisabling instead of waiting until kvm-intel's module exit. The controlsnare activated if and only if KVM creates a VM i.e. don't need to benreset if hardware is never enabled.nnDoing the reset during hardware disabling will naturally fix a potentialnNULL pointer deref bug once KVM disables CPU hotplug while enabling andndisabling hardware (which is necessary to fix a variety of bugs). If thenkernel is running as the root partition the VP assist page is unmappednduring CPU hot unplug and so KVM's clearing of the eVMCS controls needsnto occur with CPU hot(un)plug disabled otherwise KVM could attempt tonwrite to a CPU's VP assist page after it's unmapped.,CVE-2022-49933,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,A flaw possibility of memory leak in the Linux kernel cpu_entry_area mapping of X86 CPU data to memory was found in the way user can guess location of exception stack(s) or other important data. A local user could use this flaw to get access to some important data with expected location in memory.,CVE-2023-0597,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,A flaw was found in the Linux Kernel. The tls_is_tx_ready() incorrectly checks for list emptiness potentially accessing a type confused entry to the list_head leaking the last byte of the confused field that overlaps with rec->tx_ready.,CVE-2023-1075,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,A use-after-free flaw was found in smb2_is_status_io_timeout() in CIFS in the Linux Kernel. After CIFS transfers response data to a system call there are still local variable points to the memory region and if the system call frees it faster than CIFS uses it CIFS will access a free memory region leading to a denial of service.,CVE-2023-1192,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,In the Linux kernel before 5.17 an error path in dwc3_qcom_acpi_register_core in drivers/usb/dwc3/dwc3-qcom.c lacks certain platform_device_put and kfree calls.,CVE-2023-22995,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,In the Linux kernel before 5.17 drivers/phy/tegra/xusb.c mishandles the tegra_xusb_find_port_node return value. Callers expect NULL in the error case but an error pointer is used.,CVE-2023-23000,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,In the Linux kernel before 5.16 tools/perf/util/expr.c lacks a check for the hashmap__new return value.,CVE-2023-23003,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,An issue was discovered in the Linux kernel through 6.2.0-rc2. drivers/tty/vcc.c has a race condition and resultant use-after-free if a physically proximate attacker removes a VCC device while calling open() aka a race condition between vcc_open() and vcc_remove().,CVE-2023-23039,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,Bluetooth BR/EDR devices with Secure Simple Pairing and Secure Connections pairing in Bluetooth Core Specification 4.2 through 5.4 allow certain man-in-the-middle attacks that force a short key length and might lead to discovery of the encryption key and live injection aka BLUFFS.,CVE-2023-24023,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,afu_mmio_region_get_by_offset in drivers/fpga/dfl-afu-region.c in the Linux kernel through 6.1.12 has an integer overflow.,CVE-2023-26242,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,An issue was discovered in drivers/media/test-drivers/vidtv/vidtv_bridge.c in the Linux kernel 6.2. There is a NULL pointer dereference in vidtv_mux_stop_thread. In vidtv_stop_streaming after dvb->mux=NULL occurs it executes vidtv_mux_stop_thread(dvb->mux).,CVE-2023-31081,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,An issue was discovered in drivers/tty/n_gsm.c in the Linux kernel 6.2. There is a sleeping function called from an invalid context in gsmld_write which will block the kernel. Note: This has been disputed by 3rd parties as not a valid vulnerability.,CVE-2023-31082,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,An issue was discovered in drivers/mtd/ubi/cdev.c in the Linux kernel 6.2. There is a divide-by-zero error in do_div(szmtd->erasesize) used indirectly by ctrl_cdev_ioctl when mtd->erasesize is 0.,CVE-2023-31085,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,A race condition occurred between the functions lmLogClose and txEnd in JFS in the Linux Kernel executed in different threads. This flaw allows a local attacker with normal user privileges to crash the system or leak internal kernel information.,CVE-2023-3397,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,A possible unauthorized memory access flaw was found in the Linux kernel's cpu_entry_area mapping of X86 CPU data to memory where a user may guess the location of exception stacks or other important data. Based on the previous CVE-2023-0597 the 'Randomize per-cpu entry area' feature was implemented in /arch/x86/mm/cpu_entry_area.c which works through the init_cea_offsets() function when KASLR is enabled. However despite this feature there is still a risk of per-cpu entry area leaks. This issue could allow a local user to gain access to some important data with memory in an expected location and potentially escalate their privileges on the system.,CVE-2023-3640,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,An issue was discovered in the Linux kernel through 6.4.2. A crafted UDF filesystem image causes a use-after-free write operation in the udf_put_super and udf_close_lvid functions in fs/udf/super.c. NOTE: the suse.com reference has a different perspective about this.,CVE-2023-37454,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,A flaw was found in the USB Host Controller Driver framework in the Linux kernel. The usb_giveback_urb function has a logic loophole in its implementation. Due to the inappropriate judgment condition of the goto statement the function cannot return under the input of a specific malformed descriptor file so it falls into an endless loop resulting in a denial of service.,CVE-2023-4010,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,A use-after-free vulnerability was found in the cxgb4 driver in the Linux kernel. The bug occurs when the cxgb4 device is detaching due to a possible rearming of the flower_stats_timer from the work queue. This flaw allows a local user to crash the system causing a denial of service condition.,CVE-2023-4133,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,A use-after-free vulnerability was found in the cyttsp4_core driver in the Linux kernel. This issue occurs in the device cleanup routine due to a possible rearming of the watchdog_timer from the workqueue. This could allow a local user to crash the system causing a denial of service.,CVE-2023-4134,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,A memory leak flaw was found in nft_set_catchall_flush in net/netfilter/nf_tables_api.c in the Linux Kernel. This issue may allow a local attacker to cause double-deactivations of catchall elements which can result in a memory leak.,CVE-2023-4569,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbpf: Fix accesses to uninit stack slotsnnPrivileged programs are supposed to be able to read uninitialized stacknmemory (ever since 6715df8d5) but before this patch these accessesnwere permitted inconsistently. In particular accesses were permittednabove state->allocated_stack but not below it. In other words if thenstack was already large enough the access was permitted butnotherwise the access was rejected instead of being allowed to grow thenstack. This undesired rejection was happening in two places:n- in check_stack_slot_within_bounds()n- in check_stack_range_initialized()nThis patch arranges for these accesses to be permitted. A bunch of testsnthat were relying on the old rejection had to change; all of them werenchanged to add also run unprivileged in which case the old behaviornpersists. One tests couldn't be updated - global_func16 - because itncan't run unprivileged for other reasons.nnThis patch also fixes the tracking of the stack size for variable-offsetnreads. This second fix is bundled in the same commit as the first onenbecause they're inter-related. Before this patch writes to the stacknusing registers containing a variable offset (as opposed to registersnwith fixed known values) were not properly contributing to thenfunction's needed stack size. As a result it was possible for a programnto verify but then to attempt to read out-of-bounds data at runtimenbecause a too small stack had been allocated for it.nnEach function tracks the size of the stack it needs innbpf_subprog_info.stack_depth which is maintained bynupdate_stack_depth(). For regular memory accesses check_mem_access()nwas calling update_state_depth() but it was passing in only the fixednpart of the offset register ignoring the variable offset. This wasnincorrect; the minimum possible value of that register should be usedninstead.nnThis tracking is now fixed by centralizing the tracking of stack size inngrow_stack_state() and by lifting the calls to grow_stack_state() toncheck_stack_access_within_bounds() as suggested by Andrii. The code isnnow simpler and more convincingly tracks the correct maximum stack size.ncheck_stack_range_initialized() can now rely on enough stack having beennallocated for the access; this helps with the fix for the first issue.nnA few tests were changed to also check the stack depth computation. Thenone that fails without this patch is verifier_var_off:stack_write_priv_vs_unpriv.,CVE-2023-52452,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnperf/x86/lbr: Filter vsyscall addressesnnWe found that a panic can occur when a vsyscall is made while LBR samplingnis active. If the vsyscall is interrupted (NMI) for perf sampling thisncall sequence can occur (most recent at top):nn __insn_get_emulate_prefix()n insn_get_emulate_prefix()n insn_get_prefixes()n insn_get_opcode()n decode_branch_type()n get_branch_type()n intel_pmu_lbr_filter()n intel_pmu_handle_irq()n perf_event_nmi_handler()nnWithin __insn_get_emulate_prefix() at frame 0 a macro is called:nn peek_nbyte_next(insn_byte_t insn i)nnWithin this macro this dereference occurs:nn (insn)->next_bytennInspecting registers at this point the value of the next_byte field is thenaddress of the vsyscall made for example the location of the vsyscallnversion of gettimeofday() at 0xffffffffff600000. The access to an addressnin the vsyscall region will trigger an oops due to an unhandled page fault.nnTo fix the bug filtering for vsyscalls can be done whenndetermining the branch type. This patch will returnna none branch if a kernel address if found to lie in thenvsyscall region.,CVE-2023-52476,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnarm64: errata: Add Cortex-A520 speculative unprivileged load workaroundnnImplement the workaround for ARM Cortex-A520 erratum 2966298. On annaffected Cortex-A520 core a speculatively executed unprivileged loadnmight leak data from a privileged load via a cache side channel. Thenissue only exists for loads within a translation regime with the samentranslation (e.g. same ASID and VMID). Therefore the issue only affectsnthe return to EL0.nnThe workaround is to execute a TLBI before returning to EL0 after allnloads of privileged data. A non-shareable TLBI to any address isnsufficient.nnThe workaround isn't necessary if page table isolation (KPTI) isnenabled but for simplicity it will be. Page table isolation shouldnnormally be disabled for Cortex-A520 as it supports the CSV3 featurenand the E0PD feature (used when KASLR is enabled).,CVE-2023-52481,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nniommu/arm-smmu-v3: Fix soft lockup triggered by arm_smmu_mm_invalidate_rangennWhen running an SVA case the following soft lockup is triggered:n--------------------------------------------------------------------nwatchdog: BUG: soft lockup - CPU#244 stuck for 26s!npstate: 83400009 (Nzcv daif +PAN -UAO +TCO +DIT -SSBS BTYPE=--)npc : arm_smmu_cmdq_issue_cmdlist+0x178/0xa50nlr : arm_smmu_cmdq_issue_cmdlist+0x150/0xa50nsp : ffff8000d83ef290nx29: ffff8000d83ef290 x28: 000000003b9aca00 x27: 0000000000000000nx26: ffff8000d83ef3c0 x25: da86c0812194a0e8 x24: 0000000000000000nx23: 0000000000000040 x22: ffff8000d83ef340 x21: ffff0000c63980c0nx20: 0000000000000001 x19: ffff0000c6398080 x18: 0000000000000000nx17: 0000000000000000 x16: 0000000000000000 x15: ffff3000b4a3bbb0nx14: ffff3000b4a30888 x13: ffff3000b4a3cf60 x12: 0000000000000000nx11: 0000000000000000 x10: 0000000000000000 x9 : ffffc08120e4d6bcnx8 : 0000000000000000 x7 : 0000000000000000 x6 : 0000000000048cfanx5 : 0000000000000000 x4 : 0000000000000001 x3 : 000000000000000anx2 : 0000000080000000 x1 : 0000000000000000 x0 : 0000000000000001nCall trace:n arm_smmu_cmdq_issue_cmdlist+0x178/0xa50n __arm_smmu_tlb_inv_range+0x118/0x254n arm_smmu_tlb_inv_range_asid+0x6c/0x130n arm_smmu_mm_invalidate_range+0xa0/0xa4n __mmu_notifier_invalidate_range_end+0x88/0x120n unmap_vmas+0x194/0x1e0n unmap_region+0xb4/0x144n do_mas_align_munmap+0x290/0x490n do_mas_munmap+0xbc/0x124n __vm_munmap+0xa8/0x19cn __arm64_sys_munmap+0x28/0x50n invoke_syscall+0x78/0x11cn el0_svc_common.constprop.0+0x58/0x1c0n do_el0_svc+0x34/0x60n el0_svc+0x2c/0xd4n el0t_64_sync_handler+0x114/0x140n el0t_64_sync+0x1a4/0x1a8n--------------------------------------------------------------------nnNote that since 6.6-rc1 the arm_smmu_mm_invalidate_range above is renamednto arm_smmu_mm_arch_invalidate_secondary_tlbs yet the problem remains.nnThe commit 06ff87bae8d3 (arm64: mm: remove unused functions and variablenprotoypes) fixed a similar lockup on the CPU MMU side. Yet it can occurnto SMMU too since arm_smmu_mm_arch_invalidate_secondary_tlbs() is calledntypically next to MMU tlb flush function e.g.nttlb_flush_mmu_tlbonly {ntttlb_flush {nttt__flush_tlb_range {ntttt// check MAX_TLBI_OPSnttt}ntt}nttmmu_notifier_arch_invalidate_secondary_tlbs {ntttarm_smmu_mm_arch_invalidate_secondary_tlbs {ntttt// does not check MAX_TLBI_OPSnttt}ntt}nt}nnClone a CMDQ_MAX_TLBI_OPS from the MAX_TLBI_OPS in tlbflush.h since in annSVA case SMMU uses the CPU page table so it makes sense to align with thentlbflush code. Then replace per-page TLBI commands with a single per-asidnTLBI command if the request size hits this threshold.,CVE-2023-52484,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Wake DMCUB before sending a commandnn[Why]nWe can hang in place trying to send commands when the DMCUB isn'tnpowered on.nn[How]nFor functions that execute within a DC context or DC lock we cannwrap the direct calls to dm_execute_dmub_cmd/list with code thatnexits idle power optimizations and reallows once we're done withnthe command submission on success.nnFor DM direct submissions the DM will need to manage the enter/exitnsequencing manually.nnWe cannot invoke a DMCUB command directly within the DM executionnhelper or we can deadlock.,CVE-2023-52485,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbus: mhi: host: Add alignment check for event ring read pointernnThough we do check the event ring read pointer by is_valid_ring_ptrnto make sure it is in the buffer range but there is another risk thenpointer may be not aligned. Since we are expecting event ring elementsnare 128 bits(struct mhi_ring_element) aligned an unaligned read pointerncould lead to multiple issues like DoS or ring buffer memory corruption.nnSo add a alignment check for event ring read pointer.,CVE-2023-52494,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnvme-fc: Prevent null pointer dereference in nvme_fc_io_getuuid()nnThe nvme_fc_fcp_op structure describing an AEN operation is initialized with annull request structure pointer. An FC LLDD may make a call tonnvme_fc_io_getuuid passing a pointer to an nvmefc_fcp_req for an AEN operation.nnAdd validation of the request structure pointer before dereference.,CVE-2023-52508,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnspi: sun6i: reduce DMA RX transfer width to single bytennThrough empirical testing it has been determined that sometimes RX SPIntransfers with DMA enabled return corrupted data. This is down to singlenor even multiple bytes lost during DMA transfer from SPI peripheral tonmemory. It seems the RX FIFO within the SPI peripheral can becomenconfused when performing bus read accesses wider than a single byte to itnduring an active SPI transfer.nnThis patch reduces the width of individual DMA read accesses to thenRX FIFO to a single byte to mitigate that issue.,CVE-2023-52511,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnspi: sun6i: fix race between DMA RX transfer completion and RX FIFO drainnnPreviously the transfer complete IRQ immediately drained to RX FIFO tonread any data remaining in FIFO to the RX buffer. This behaviour isncorrect when dealing with SPI in interrupt mode. However in DMA mode thentransfer complete interrupt still fires as soon as all bytes to bentransferred have been stored in the FIFO. At that point data in the FIFOnstill needs to be picked up by the DMA engine. Thus the drain procedurenand DMA engine end up racing to read from RX FIFO corrupting any datanread. Additionally the RX buffer pointer is never adjusted according tonDMA progress in DMA mode thus calling the RX FIFO drain procedure in DMAnmode is a bug.nFix corruptions in DMA RX mode by draining RX FIFO only in interrupt mode.nAlso wait for completion of RX DMA when in DMA mode before returning tonensure all data has been copied to the supplied memory buffer.,CVE-2023-52517,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnwifi: iwlwifi: mvm: Fix a memory corruption issuennA few lines above space is kzalloc()'ed for:ntsizeof(struct iwl_nvm_data) +ntsizeof(struct ieee80211_channel) +ntsizeof(struct ieee80211_rate)nn'mvm->nvm_data' is a 'struct iwl_nvm_data' so it is fine.nnAt the end of this structure there is the 'channels' flex array.nEach element is of type 'struct ieee80211_channel'.nSo only 1 element is allocated in this array.nnWhen doing:n mvm->nvm_data->bands[0].channels = mvm->nvm_data->channels;nWe point at the first element of the 'channels' flex array.nSo this is fine.nnHowever when doing:n mvm->nvm_data->bands[0].bitrates =nttt(void *)((u8 *)mvm->nvm_data->channels + 1);nbecause of the (u8 *) cast we add only 1 to the address of the beginningnof the flex array.nnIt is likely that we want point at the 'struct ieee80211_rate' allocatednjust after.nnRemove the spurious casting so that the pointer arithmetic works asnexpected.,CVE-2023-52531,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnarm64: dts: qcom: sdm845-db845c: Mark cont splash memory region as reservednnAdding a reserved memory region for the framebuffer memoryn(the splash memory region set up by the bootloader).nnIt fixes a kernel panic (arm-smmu: Unhandled context faultnat this particular memory region) reported on DB845c runningnv5.10.y.,CVE-2023-52561,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbtrfs: remove BUG() after failure to insert delayed dir index itemnnInstead of calling BUG() when we fail to insert a delayed dir index itemninto the delayed node's tree we can just release all the resources wenhave allocated/acquired before and return the error to the caller. This isnfine because all existing call chains undo anything they have done beforencalling btrfs_insert_delayed_dir_index() or BUG_ON (when creating pendingnsnapshots in the transaction commit path).nnSo remove the BUG() call and do proper error handling.nnThis relates to a syzbot report linked below but does not fix it becausenit only prevents hitting a BUG() it does not fix the issue where somehownwe attempt to use twice the same index number for different index items.,CVE-2023-52569,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nncifs: Fix UAF in cifs_demultiplex_thread()nnThere is a UAF when xfstests on cifs:nn BUG: KASAN: use-after-free in smb2_is_network_name_deleted+0x27/0x160n Read of size 4 at addr ffff88810103fc08 by task cifsd/923nn CPU: 1 PID: 923 Comm: cifsd Not tainted 6.1.0-rc4+ #45n ...n Call Trace:n <TASK>n dump_stack_lvl+0x34/0x44n print_report+0x171/0x472n kasan_report+0xad/0x130n kasan_check_range+0x145/0x1a0n smb2_is_network_name_deleted+0x27/0x160n cifs_demultiplex_thread.cold+0x172/0x5a4n kthread+0x165/0x1a0n ret_from_fork+0x1f/0x30n </TASK>nn Allocated by task 923:n kasan_save_stack+0x1e/0x40n kasan_set_track+0x21/0x30n __kasan_slab_alloc+0x54/0x60n kmem_cache_alloc+0x147/0x320n mempool_alloc+0xe1/0x260n cifs_small_buf_get+0x24/0x60n allocate_buffers+0xa1/0x1c0n cifs_demultiplex_thread+0x199/0x10d0n kthread+0x165/0x1a0n ret_from_fork+0x1f/0x30nn Freed by task 921:n kasan_save_stack+0x1e/0x40n kasan_set_track+0x21/0x30n kasan_save_free_info+0x2a/0x40n ____kasan_slab_free+0x143/0x1b0n kmem_cache_free+0xe3/0x4d0n cifs_small_buf_release+0x29/0x90n SMB2_negotiate+0x8b7/0x1c60n smb2_negotiate+0x51/0x70n cifs_negotiate_protocol+0xf0/0x160n cifs_get_smb_ses+0x5fa/0x13c0n mount_get_conns+0x7a/0x750n cifs_mount+0x103/0xd00n cifs_smb3_do_mount+0x1dd/0xcb0n smb3_get_tree+0x1d5/0x300n vfs_get_tree+0x41/0xf0n path_mount+0x9b3/0xdd0n __x64_sys_mount+0x190/0x1d0n do_syscall_64+0x35/0x80n entry_SYSCALL_64_after_hwframe+0x46/0xb0nnThe UAF is because:nn mount(pid: 921) | cifsd(pid: 923)n-------------------------------|-------------------------------n | cifs_demultiplex_threadnSMB2_negotiate |n cifs_send_recv |n compound_send_recv |n smb_send_rqst |n wait_for_response |n wait_event_state [1] |n | standard_receive3n | cifs_handle_standardn | handle_midn | mid->resp_buf = buf; [2]n | dequeue_mid [3]n KILL the process [4] |n resp_iov[i].iov_base = buf |n free_rsp_buf [5] |n | is_network_name_deleted [6]n | callbacknn1. After send request to server wait the response untiln mid->mid_state != SUBMITTED;n2. Receive response from server and set it to mid;n3. Set the mid state to RECEIVED;n4. Kill the process the mid state already RECEIVED get 0;n5. Handle and release the negotiate response;n6. UAF.nnIt can be easily reproduce with add some delay in [3] - [6].nnOnly sync call has the problem since async call's callback isnexecuted in cifsd process.nnAdd an extra state to mark the mid state to READY before wakeup thenwaitter then it can get the resp safely.,CVE-2023-52572,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnspmi: mediatek: Fix UAF on device removennThe pmif driver data that contains the clocks is allocated along withnspmi_controller.nOn device remove spmi_controller will be freed first and then devresn including the clocks will be cleanup.nThis leads to UAF because putting the clocks will access the clocks innthe pmif driver data which is already freed along with spmi_controller.nnThis can be reproduced by enabling DEBUG_TEST_DRIVER_REMOVE andnbuilding the kernel with KASAN.nnFix the UAF issue by using unmanaged clk_bulk_get() and putting thenclocks before freeing spmi_controller.,CVE-2023-52584,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/msm/dpu: Add mutex lock in control vblank irqnnAdd a mutex lock to control vblank irq to synchronize vblanknenable/disable operations happening from different threads to preventnrace conditions while registering/unregistering the vblank irq callback.nnv4: -Removed vblank_ctl_lock from dpu_encoder_virt so it is only an parameter of dpu_encoder_phys.n -Switch from atomic refcnt to a simple int counter as mutex hasn now been addednv3: Mistakenly did not change wording in last version. It is done now.nv2: Slightly changed wording of commit messagennPatchwork: https://patchwork.freedesktop.org/patch/571854/,CVE-2023-52586,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnf2fs: fix to tag gcing flag on page during block migrationnnIt needs to add missing gcing flag on page during block migrationnin order to garantee migrated data be persisted during checkpointnotherwise out-of-order persistency between data and node may causendata corruption after SPOR.nnSimilar issue was fixed by commit 2d1fe8a86bf5 (f2fs: fix to tagngcing flag on page during file defragment).,CVE-2023-52588,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnmedia: rkisp1: Fix IRQ disable race issuennIn rkisp1_isp_stop() and rkisp1_csi_disable() the driver masks theninterrupts and then apparently assumes that the interrupt handler won'tnbe running and proceeds in the stop procedure. This is not the case asnthe interrupt handler can already be running which would lead to thenISP being disabled while the interrupt handler handling a capturednframe.nnThis brings up two issues: 1) the ISP could be powered off while theninterrupt handler is still running and accessing registers leading tonboard lockup and 2) the interrupt handler code and the code thatndisables the streaming might do things that conflict.nnIt is not clear to me if 2) causes a real issue but 1) can be seen withna suitable delay (or printk in my case) in the interrupt handlernleading to board lockup.,CVE-2023-52589,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnocfs2: Avoid touching renamed directory if parent does not changennThe VFS will not be locking moved directory if its parent does notnchange. Change ocfs2 rename code to avoid touching renamed directory ifnits parent does not change as without locking that can corrupt thenfilesystem.,CVE-2023-52590,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnreiserfs: Avoid touching renamed directory if parent does not changennThe VFS will not be locking moved directory if its parent does notnchange. Change reiserfs rename code to avoid touching renamed directorynif its parent does not change as without locking that can corrupt thenfilesystem.,CVE-2023-52591,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnwifi: wfx: fix possible NULL pointer dereference in wfx_set_mfp_ap()nnSince 'ieee80211_beacon_get()' can return NULL 'wfx_set_mfp_ap()'nshould check the return value before examining skb data. So convertnthe latter to return an appropriate error code and propagate it tonreturn from 'wfx_start_ap()' as well. Compile tested only.,CVE-2023-52593,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnsysctl: Fix out of bounds access for empty sysctl registersnnWhen registering tables to the sysctl subsystem there is a check to seenif header is a permanently empty directory (used for mounts). This checknevaluates the first element of the ctl_table. This results in an out ofnbounds evaluation when registering empty directories.nnThe function register_sysctl_mount_point now passes a ctl_table of sizen1 instead of size 0. It now relies solely on the type to identifyna permanently empty register.nnMake sure that the ctl_table has at least one element before testing fornpermanent emptiness.,CVE-2023-52596,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnfirmware: arm_scmi: Check mailbox/SMT channel for consistencynnOn reception of a completion interrupt the shared memory area is accessednto retrieve the message header at first and then if the message sequencennumber identifies a transaction which is still pending the relatednpayload is fetched too.nnWhen an SCMI command times out the channel ownership remains with thenplatform until eventually a late reply is received and as a consequencenany further transmission attempt remains pending waiting for the channelnto be relinquished by the platform.nnOnce that late reply is received the channel ownership is given backnto the agent and any pending request is then allowed to proceed andnoverwrite the SMT area of the just delivered late reply; then the waitnfor the reply to the new request starts.nnIt has been observed that the spurious IRQ related to the late reply cannbe wrongly associated with the freshly enqueued request: when that happensnthe SCMI stack in-flight lookup procedure is fooled by the fact that thenmessage header now present in the SMT area is related to the new pendingntransaction even though the real reply has still to arrive.nnThis race-condition on the A2P channel can be detected by looking at thenchannel status bits: a genuine reply from the platform will have set thenchannel free bit before triggering the completion IRQ.nnAdd a consistency check to validate such condition in the A2P ISR.,CVE-2023-52608,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet/sched: act_ct: fix skb leak and crash on ooo fragsnnact_ct adds skb->users before defragmentation. If frags arrive in ordernthe last frag's reference is reset in:nn inet_frag_reasm_preparen skb_morphnnwhich is not straightforward.nnHowever when frags arrive out of order nobody unref the last frag andnall frags are leaked. The situation is even worse as initiating packetncapture can lead to a crash[0] when skb has been cloned and shared at thensame time.nnFix the issue by removing skb_get() before defragmentation. act_ctnreturns TC_ACT_CONSUMED when defrag failed or in progress.nn[0]:n[ 843.804823] ------------[ cut here ]------------n[ 843.809659] kernel BUG at net/core/skbuff.c:2091!n[ 843.814516] invalid opcode: 0000 [#1] PREEMPT SMPn[ 843.819296] CPU: 7 PID: 0 Comm: swapper/7 Kdump: loaded Tainted: G S 6.7.0-rc3 #2n[ 843.824107] Hardware name: XFUSION 1288H V6/BC13MBSBD BIOS 1.29 11/25/2022n[ 843.828953] RIP: 0010:pskb_expand_head+0x2ac/0x300n[ 843.833805] Code: 8b 70 28 48 85 f6 74 82 48 83 c6 08 bf 01 00 00 00 e8 38 bd ff ff 8b 83 c0 00 00 00 48 03 83 c8 00 00 00 e9 62 ff ff ff 0f 0b <0f> 0b e8 8d d0 ff ff e9 b3 fd ff ff 81 7c 24 14 40 01 00 00 4c 89n[ 843.843698] RSP: 0018:ffffc9000cce07c0 EFLAGS: 00010202n[ 843.848524] RAX: 0000000000000002 RBX: ffff88811a211d00 RCX: 0000000000000820n[ 843.853299] RDX: 0000000000000640 RSI: 0000000000000000 RDI: ffff88811a211d00n[ 843.857974] RBP: ffff888127d39518 R08: 00000000bee97314 R09: 0000000000000000n[ 843.862584] R10: 0000000000000000 R11: ffff8881109f0000 R12: 0000000000000880n[ 843.867147] R13: ffff888127d39580 R14: 0000000000000640 R15: ffff888170f7b900n[ 843.871680] FS: 0000000000000000(0000) GS:ffff889ffffc0000(0000) knlGS:0000000000000000n[ 843.876242] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033n[ 843.880778] CR2: 00007fa42affcfb8 CR3: 000000011433a002 CR4: 0000000000770ef0n[ 843.885336] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000n[ 843.889809] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400n[ 843.894229] PKRU: 55555554n[ 843.898539] Call Trace:n[ 843.902772] <IRQ>n[ 843.906922] ? __die_body+0x1e/0x60n[ 843.911032] ? die+0x3c/0x60n[ 843.915037] ? do_trap+0xe2/0x110n[ 843.918911] ? pskb_expand_head+0x2ac/0x300n[ 843.922687] ? do_error_trap+0x65/0x80n[ 843.926342] ? pskb_expand_head+0x2ac/0x300n[ 843.929905] ? exc_invalid_op+0x50/0x60n[ 843.933398] ? pskb_expand_head+0x2ac/0x300n[ 843.936835] ? asm_exc_invalid_op+0x1a/0x20n[ 843.940226] ? pskb_expand_head+0x2ac/0x300n[ 843.943580] inet_frag_reasm_prepare+0xd1/0x240n[ 843.946904] ip_defrag+0x5d4/0x870n[ 843.950132] nf_ct_handle_fragments+0xec/0x130 [nf_conntrack]n[ 843.953334] tcf_ct_act+0x252/0xd90 [act_ct]n[ 843.956473] ? tcf_mirred_act+0x516/0x5a0 [act_mirred]n[ 843.959657] tcf_action_exec+0xa1/0x160n[ 843.962823] fl_classify+0x1db/0x1f0 [cls_flower]n[ 843.966010] ? skb_clone+0x53/0xc0n[ 843.969173] tcf_classify+0x24d/0x420n[ 843.972333] tc_run+0x8f/0xf0n[ 843.975465] __netif_receive_skb_core+0x67a/0x1080n[ 843.978634] ? dev_gro_receive+0x249/0x730n[ 843.981759] __netif_receive_skb_list_core+0x12d/0x260n[ 843.984869] netif_receive_skb_list_internal+0x1cb/0x2f0n[ 843.987957] ? mlx5e_handle_rx_cqe_mpwrq_rep+0xfa/0x1a0 [mlx5_core]n[ 843.991170] napi_complete_done+0x72/0x1a0n[ 843.994305] mlx5e_napi_poll+0x28c/0x6d0 [mlx5_core]n[ 843.997501] __napi_poll+0x25/0x1b0n[ 844.000627] net_rx_action+0x256/0x330n[ 844.003705] __do_softirq+0xb3/0x29bn[ 844.006718] irq_exit_rcu+0x9e/0xc0n[ 844.009672] common_interrupt+0x86/0xa0n[ 844.012537] </IRQ>n[ 844.015285] <TASK>n[ 844.017937] asm_common_interrupt+0x26/0x40n[ 844.020591] RIP: 0010:acpi_safe_halt+0x1b/0x20n[ 844.023247] Code: ff 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 65 48 8b 04 25 00 18 03 00 48 8b 00 a8 08 75 0c 66 90 0f 00 2d 81 d0 44 00 fbn---truncated---,CVE-2023-52610,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbpf: Check rcu_read_lock_trace_held() before calling bpf map helpersnnThese three bpf_map_{lookupupdatedelete}_elem() helpers are alsonavailable for sleepable bpf program so add the corresponding locknassertion for sleepable bpf program otherwise the following warningnwill be reported when a sleepable bpf program manipulates bpf map underninterpreter mode (aka bpf_jit_enable=0):nn WARNING: CPU: 3 PID: 4985 at kernel/bpf/helpers.c:40 ......n CPU: 3 PID: 4985 Comm: test_progs Not tainted 6.6.0+ #2n Hardware name: QEMU Standard PC (i440FX + PIIX 1996) ......n RIP: 0010:bpf_map_lookup_elem+0x54/0x60n ......n Call Trace:n <TASK>n ? __warn+0xa5/0x240n ? bpf_map_lookup_elem+0x54/0x60n ? report_bug+0x1ba/0x1f0n ? handle_bug+0x40/0x80n ? exc_invalid_op+0x18/0x50n ? asm_exc_invalid_op+0x1b/0x20n ? __pfx_bpf_map_lookup_elem+0x10/0x10n ? rcu_lockdep_current_cpu_online+0x65/0xb0n ? rcu_is_watching+0x23/0x50n ? bpf_map_lookup_elem+0x54/0x60n ? __pfx_bpf_map_lookup_elem+0x10/0x10n ___bpf_prog_run+0x513/0x3b70n __bpf_prog_run32+0x9d/0xd0n ? __bpf_prog_enter_sleepable_recur+0xad/0x120n ? __bpf_prog_enter_sleepable_recur+0x3e/0x120n bpf_trampoline_6442580665+0x4d/0x1000n __x64_sys_getpgid+0x5/0x30n ? do_syscall_64+0x36/0xb0n entry_SYSCALL_64_after_hwframe+0x6e/0x76n </TASK>,CVE-2023-52621,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Wake DMCUB before executing GPINT commandsnn[Why]nDMCUB can be in idle when we attempt to interface with the HW throughnthe GPINT mailbox resulting in a system hang.nn[How]nAdd dc_wake_and_execute_gpint() to wrap the wake execute sleepnsequence.nnIf the GPINT executes successfully then DMCUB will be put back intonsleep after the optional response is returned.nnIt functions similar to the inbox command interface.,CVE-2023-52624,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Refactor DMCUB enter/exit idle interfacenn[Why]nWe can hang in place trying to send commands when the DMCUB isn'tnpowered on.nn[How]nWe need to exit out of the idle state prior to sending a commandnbut the process that performs the exit also invokes a command itself.nnFixing this issue involves the following:nn1. Using a software state to track whether or not we need to startn the process to exit idle or notify idle.nnIt's possible for the hardware to have exited an idle state withoutndriver knowledge but entering one is always restricted to a drivernallow - which makes the SW state vs HW state mismatch issue purely onenof optimization which should seldomly be hit if at all.nn2. Refactor any instances of exit/notify idle to use a single wrappern that maintains this SW state.nnThis works simialr to dc_allow_idle_optimizations but works at thenDMCUB level and makes sure the state is marked prior to any notify/exitnidle so we don't enter an infinite loop.nn3. Make sure we exit out of idle prior to sending any commands orn waiting for DMCUB idle.nnThis patch takes care of 1/2. A future patch will take care of wrappingnDMCUB command submission with calls to this new interface.,CVE-2023-52625,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnsh: push-switch: Reorder cleanup operations to avoid use-after-free bugnnThe original code puts flush_work() before timer_shutdown_sync()nin switch_drv_remove(). Although we use flush_work() to stopnthe worker it could be rescheduled in switch_timer(). As a resultna use-after-free bug can occur. The details are shown below:nn (cpu 0) | (cpu 1)nswitch_drv_remove() |n flush_work() |n ... | switch_timer // timern | schedule_work(&psw->work)n timer_shutdown_sync() |n ... | switch_work_handler // workern kfree(psw) // free |n | psw->state = 0 // usennThis patch puts timer_shutdown_sync() before flush_work() tonmitigate the bugs. As a result the worker and timer will benstopped safely before the deallocate operations.,CVE-2023-52629,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnum: time-travel: fix time corruptionnnIn 'basic' time-travel mode (without =inf-cpu or =ext) wenstill get timer interrupts. These can happen at arbitrarynpoints in time i.e. while in timer_read() which pushesntime forward just a little bit. Then if we happen to getnthe interrupt after calculating the new time to push tonbut before actually finishing that the interrupt will setnthe time to a value that's incompatible with the forwardnand we'll crash because time goes backwards when we do thenforwarding.nnFix this by reading the time_travel_time calculating thenadjustment and doing the adjustment all with interruptsndisabled.,CVE-2023-52633,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nncan: j1939: prevent deadlock by changing j1939_socks_lock to rwlocknnThe following 3 locks would race against each other causing thendeadlock situation in the Syzbot bug report:nn- j1939_socks_lockn- active_session_list_lockn- sk_session_queue_locknnA reasonable fix is to change j1939_socks_lock to an rwlock since innthe rare situations where a write lock is required for the linked listnthat j1939_socks_lock is protecting the code does not attempt tonacquire any more locks. This would break the circular lock dependencynwhere for example the current thread already locks j1939_socks_locknand attempts to acquire sk_session_queue_lock and at the same timenanother thread attempts to acquire j1939_socks_lock while holdingnsk_session_queue_lock.nnNOTE: This patch along does not fix the unregister_netdevice bugnreported by Syzbot; instead it solves a deadlock situation to preparenfor one or more further patches to actually fix the Syzbot bug whichnappears to be a reference counting problem within the j1939 codebase.nn[mkl: remove unrelated newline change],CVE-2023-52638,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnKVM: s390: vsie: fix race during shadow creationnnRight now it is possible to see gmap->private being zero innkvm_s390_vsie_gmap_notifier resulting in a crash. This is due to thenfact that we add gmap->private == kvm after creation:nnstatic int acquire_gmap_shadow(struct kvm_vcpu *vcpun struct vsie_page *vsie_page)n{n[...]n gmap = gmap_shadow(vcpu->arch.gmap asce edat);n if (IS_ERR(gmap))n return PTR_ERR(gmap);n gmap->private = vcpu->kvm;nnLet children inherit the private field of the parent.,CVE-2023-52639,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnNTB: fix possible name leak in ntb_register_device()nnIf device_register() fails in ntb_register_device() the device namenallocated by dev_set_name() should be freed. As per the comment inndevice_register() callers should use put_device() to give up thenreference in the error path. So fix this by calling put_device() in thenerror path so that the name can be freed in kobject_cleanup().nnAs a result of this put_device() in the error path ofnntb_register_device() is removed and the actual error is returned.nn[mani: reworded commit message],CVE-2023-52652,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnSUNRPC: fix a memleak in gss_import_v2_contextnnThe ctx->mech_used.data allocated by kmemdup is not freed in neitherngss_import_v2_context nor it only caller gss_krb5_import_sec_contextnwhich frees ctx on error.nnThus this patch reform the last call of gss_import_v2_context to thengss_krb5_import_ctx_v2 preventing the memleak while keepping the returnnformation.,CVE-2023-52653,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnmedia: rkisp1: Fix IRQ handling due to shared interruptsnnThe driver requests the interrupts as IRQF_SHARED so the interruptnhandlers can be called at any time. If such a call happens while the ISPnis powered down the SoC will hang as the driver tries to access thenISP registers.nnThis can be reproduced even without the platform sharing the IRQ line:nEnable CONFIG_DEBUG_SHIRQ and unload the driver and the board willnhang.nnFix this by adding a new field 'irqs_enabled' which is used to bailnout from the interrupt handler when the ISP is not operational.,CVE-2023-52660,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet: atlantic: eliminate double free in error handling logicnnDriver has a logic leak in ring data allocation/freenwhere aq_ring_free could be called multiple times on same ringnif system is under stress and got memory allocation error.nnRing pointer was used as an indicator of failure but this isnnot correct since only ring data is allocated/deallocated.nRing itself is an array member.nnChanging ring allocation functions to return error code directly.nThis simplifies error handling and eliminates aq_ring_freenon higher layer.,CVE-2023-52664,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Fix hang/underflow when transitioning to ODM4:1nn[Why]nUnder some circumstances disabling an OPTC and attempting to reclaimnits OPP(s) for a different OPTC could cause a hang/underflow due to OPPsnnot being properly disconnected from the disabled OPTC.nn[How]nEnsure that all OPPs are unassigned from an OPTC when it gets disabled.,CVE-2023-52671,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Fix a debugfs null pointer errornn[WHY & HOW]nCheck whether get_subvp_en() callback exists before calling it.,CVE-2023-52673,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnALSA: scarlett2: Add clamp() in scarlett2_mixer_ctl_put()nnEnsure the value passed to scarlett2_mixer_ctl_put() is between 0 andnSCARLETT2_MIXER_MAX_VALUE so we don't attempt to access outsidenscarlett2_mixer_values[].,CVE-2023-52674,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbpf: Guard stack limits against 32bit overflownnThis patch promotes the arithmetic around checking stack bounds to bendone in the 64-bit domain instead of the current 32bit. The arithmeticnimplies adding together a 64-bit register with a int offset. Thenregister was checked to be below 1<<29 when it was variable but notnwhen it was fixed. The offset either comes from an instruction (in whichncase it is 16 bit) from another register (in which case the callernchecked it to be below 1<<29 [1]) or from the size of an argument to ankfunc (in which case it can be a u32 [2]). Between the register beingninconsistently checked to be below 1<<29 and the offset being up to annu32 it appears that we were open to overflowing the `int`s which werencurrently used for arithmetic.nn[1] https://github.com/torvalds/linux/blob/815fb87b753055df2d9e50f6cd80eb10235fe3e9/kernel/bpf/verifier.c#L7494-L7498n[2] https://github.com/torvalds/linux/blob/815fb87b753055df2d9e50f6cd80eb10235fe3e9/kernel/bpf/verifier.c#L11904,CVE-2023-52676,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnriscv: Check if the code to patch lies in the exit sectionnnOtherwise we fall through to vmalloc_to_page() which panics since thenaddress does not lie in the vmalloc region.,CVE-2023-52677,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnALSA: scarlett2: Add missing error checks to *_ctl_get()nnThe *_ctl_get() functions which call scarlett2_update_*() were notnchecking the return value. Fix to check the return value and pass tonthe caller.,CVE-2023-52680,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnf2fs: fix to wait on block writeback for post_read casennIf inode is compressed but not encrypted it missed to callnf2fs_wait_on_block_writeback() to wait for GCed page writebacknin IPU write path.nnThread AttttGC-Threadnttttt- f2fs_gcnttttt - do_garbage_collectnttttt - gc_data_segmentnttttt - move_data_blocknttttt - f2fs_submit_page_writenttttt migrate normal cluster's block vianttttt meta_inode's page cachen- f2fs_write_single_data_pagen - f2fs_do_write_data_pagen - f2fs_inplace_write_datan - f2fs_submit_page_bionnIRQn- f2fs_read_end_iontttttIRQntttttold data overrides new data due tontttttout-of-order GC and common IO.nttttt- f2fs_read_end_io,CVE-2023-52682,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nntipc: fix kernel warning when sending SYN messagennWhen sending a SYN message this kernel stack trace is observed:nn...n[ 13.396352] RIP: 0010:_copy_from_iter+0xb4/0x550n...n[ 13.398494] Call Trace:n[ 13.398630] <TASK>n[ 13.398630] ? __alloc_skb+0xed/0x1a0n[ 13.398630] tipc_msg_build+0x12c/0x670 [tipc]n[ 13.398630] ? shmem_add_to_page_cache.isra.71+0x151/0x290n[ 13.398630] __tipc_sendmsg+0x2d1/0x710 [tipc]n[ 13.398630] ? tipc_connect+0x1d9/0x230 [tipc]n[ 13.398630] ? __local_bh_enable_ip+0x37/0x80n[ 13.398630] tipc_connect+0x1d9/0x230 [tipc]n[ 13.398630] ? __sys_connect+0x9f/0xd0n[ 13.398630] __sys_connect+0x9f/0xd0n[ 13.398630] ? preempt_count_add+0x4d/0xa0n[ 13.398630] ? fpregs_assert_state_consistent+0x22/0x50n[ 13.398630] __x64_sys_connect+0x16/0x20n[ 13.398630] do_syscall_64+0x42/0x90n[ 13.398630] entry_SYSCALL_64_after_hwframe+0x63/0xcdnnIt is because commit a41dad905e5a (iov_iter: saner checks for attemptnto copy to/from iterator) has introduced sanity check for copyingnfrom/to iov iterator. Lacking of copy direction from the iteratornviewpoint would lead to kernel stack trace like above.nnThis commit fixes this issue by initializing the iov iterator withnthe correct copy direction when sending SYN or ACK without data.,CVE-2023-52700,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnceph: blocklist the kclient when receiving corrupted snap tracennWhen received corrupted snap trace we don't know what exactly hasnhappened in MDS side. And we shouldn't continue IOs and metadatasnaccess to MDS which may corrupt or get incorrect contents.nnThis patch will just block all the further IO/MDS requestsnimmediately and then evict the kclient itself.nnThe reason why we still need to evict the kclient just afternblocking all the further IOs is that the MDS could revoke the capsnfaster.,CVE-2023-52732,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbpf sockmap: Don't let sock_map_{closedestroyunhash} call itselfnnsock_map proto callbacks should never call themselves by design. Protectnagainst bugs like [1] and break out of the recursive loop to avoid a stacknoverflow in favor of a resource leak.nn[1] https://lore.kernel.org/all/00000000000073b14905ef2e7401@google.com/,CVE-2023-52735,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbtrfs: lock the inode in shared mode before starting fiemapnnCurrently fiemap does not take the inode's lock (VFS lock) it only locksna file range in the inode's io tree. This however can lead to a deadlocknif we have a concurrent fsync on the file and fiemap code triggers a faultnwhen accessing the user space buffer with fiemap_fill_next_extent(). Thendeadlock happens on the inode's i_mmap_lock semaphore which is taken bothnby fsync and btrfs_page_mkwrite(). This deadlock was recently reported bynsyzbot and triggers a trace like the following:nn task:syz-executor361 state:D stack:20264 pid:5668 ppid:5119 flags:0x00004004n Call Trace:n <TASK>n context_switch kernel/sched/core.c:5293 [inline]n __schedule+0x995/0xe20 kernel/sched/core.c:6606n schedule+0xcb/0x190 kernel/sched/core.c:6682n wait_on_state fs/btrfs/extent-io-tree.c:707 [inline]n wait_extent_bit+0x577/0x6f0 fs/btrfs/extent-io-tree.c:751n lock_extent+0x1c2/0x280 fs/btrfs/extent-io-tree.c:1742n find_lock_delalloc_range+0x4e6/0x9c0 fs/btrfs/extent_io.c:488n writepage_delalloc+0x1ef/0x540 fs/btrfs/extent_io.c:1863n __extent_writepage+0x736/0x14e0 fs/btrfs/extent_io.c:2174n extent_write_cache_pages+0x983/0x1220 fs/btrfs/extent_io.c:3091n extent_writepages+0x219/0x540 fs/btrfs/extent_io.c:3211n do_writepages+0x3c3/0x680 mm/page-writeback.c:2581n filemap_fdatawrite_wbc+0x11e/0x170 mm/filemap.c:388n __filemap_fdatawrite_range mm/filemap.c:421 [inline]n filemap_fdatawrite_range+0x175/0x200 mm/filemap.c:439n btrfs_fdatawrite_range fs/btrfs/file.c:3850 [inline]n start_ordered_ops fs/btrfs/file.c:1737 [inline]n btrfs_sync_file+0x4ff/0x1190 fs/btrfs/file.c:1839n generic_write_sync include/linux/fs.h:2885 [inline]n btrfs_do_write_iter+0xcd3/0x1280 fs/btrfs/file.c:1684n call_write_iter include/linux/fs.h:2189 [inline]n new_sync_write fs/read_write.c:491 [inline]n vfs_write+0x7dc/0xc50 fs/read_write.c:584n ksys_write+0x177/0x2a0 fs/read_write.c:637n do_syscall_x64 arch/x86/entry/common.c:50 [inline]n do_syscall_64+0x3d/0xb0 arch/x86/entry/common.c:80n entry_SYSCALL_64_after_hwframe+0x63/0xcdn RIP: 0033:0x7f7d4054e9b9n RSP: 002b:00007f7d404fa2f8 EFLAGS: 00000246 ORIG_RAX: 0000000000000001n RAX: ffffffffffffffda RBX: 00007f7d405d87a0 RCX: 00007f7d4054e9b9n RDX: 0000000000000090 RSI: 0000000020000000 RDI: 0000000000000006n RBP: 00007f7d405a51d0 R08: 0000000000000000 R09: 0000000000000000n R10: 0000000000000000 R11: 0000000000000246 R12: 61635f65646f6e69n R13: 65646f7475616f6e R14: 7261637369646f6e R15: 00007f7d405d87a8n </TASK>n INFO: task syz-executor361:5697 blocked for more than 145 seconds.n Not tainted 6.2.0-rc3-syzkaller-00376-g7c6984405241 #0n echo 0 > /proc/sys/kernel/hung_task_timeout_secs disables this message.n task:syz-executor361 state:D stack:21216 pid:5697 ppid:5119 flags:0x00004004n Call Trace:n <TASK>n context_switch kernel/sched/core.c:5293 [inline]n __schedule+0x995/0xe20 kernel/sched/core.c:6606n schedule+0xcb/0x190 kernel/sched/core.c:6682n rwsem_down_read_slowpath+0x5f9/0x930 kernel/locking/rwsem.c:1095n __down_read_common+0x54/0x2a0 kernel/locking/rwsem.c:1260n btrfs_page_mkwrite+0x417/0xc80 fs/btrfs/inode.c:8526n do_page_mkwrite+0x19e/0x5e0 mm/memory.c:2947n wp_page_shared+0x15e/0x380 mm/memory.c:3295n handle_pte_fault mm/memory.c:4949 [inline]n __handle_mm_fault mm/memory.c:5073 [inline]n handle_mm_fault+0x1b79/0x26b0 mm/memory.c:5219n do_user_addr_fault+0x69b/0xcb0 arch/x86/mm/fault.c:1428n handle_page_fault arch/x86/mm/fault.c:1519 [inline]n exc_page_fault+0x7a/0x110 arch/x86/mm/fault.c:1575n asm_exc_page_fault+0x22/0x30 arch/x86/include/asm/idtentry.h:570n RIP: 0010:copy_user_short_string+0xd/0x40 arch/x86/lib/copy_user_64.S:233n Code: 74 0a 89 (...)n RSP: 0018:ffffc9000570f330 EFLAGS: 000502n---truncated---,CVE-2023-52737,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnspi: Fix null dereference on suspendnnA race condition exists where a synchronous (noqueue) transfer can benactive during a system suspend. This can cause a null pointerndereference exception to occur when the system resumes.nnExample order of events leading to the exception:n1. spi_sync() calls __spi_transfer_message_noqueue() which setsn ctlr->cur_msgn2. Spi transfer begins via spi_transfer_one_message()n3. System is suspended interrupting the transfer contextn4. System is resumedn6. spi_controller_resume() calls spi_start_queue() which resets cur_msgn to NULLn7. Spi transfer context resumes and spi_finalize_current_message() isn called which dereferences cur_msg (which is now NULL)nnWait for synchronous transfers to complete before suspending bynacquiring the bus mutex and setting/checking a suspend flag.,CVE-2023-52749,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnsmb: client: fix use-after-free in smb2_query_info_compound()nnThe following UAF was triggered when running fstests generic/072 withnKASAN enabled against Windows Server 2022 and mount optionsn'multichannelmax_channels=2vers=3.1.1mfsymlinksnoperm'nn BUG: KASAN: slab-use-after-free in smb2_query_info_compound+0x423/0x6d0 [cifs]n Read of size 8 at addr ffff888014941048 by task xfs_io/27534nn CPU: 0 PID: 27534 Comm: xfs_io Not tainted 6.6.0-rc7 #1n Hardware name: QEMU Standard PC (Q35 + ICH9 2009) BIOSn rel-1.16.2-3-gd478f380-rebuilt.opensuse.org 04/01/2014n Call Trace:n dump_stack_lvl+0x4a/0x80n print_report+0xcf/0x650n ? srso_alias_return_thunk+0x5/0x7fn ? srso_alias_return_thunk+0x5/0x7fn ? __phys_addr+0x46/0x90n kasan_report+0xda/0x110n ? smb2_query_info_compound+0x423/0x6d0 [cifs]n ? smb2_query_info_compound+0x423/0x6d0 [cifs]n smb2_query_info_compound+0x423/0x6d0 [cifs]n ? __pfx_smb2_query_info_compound+0x10/0x10 [cifs]n ? srso_alias_return_thunk+0x5/0x7fn ? __stack_depot_save+0x39/0x480n ? kasan_save_stack+0x33/0x60n ? kasan_set_track+0x25/0x30n ? ____kasan_slab_free+0x126/0x170n smb2_queryfs+0xc2/0x2c0 [cifs]n ? __pfx_smb2_queryfs+0x10/0x10 [cifs]n ? __pfx___lock_acquire+0x10/0x10n smb311_queryfs+0x210/0x220 [cifs]n ? __pfx_smb311_queryfs+0x10/0x10 [cifs]n ? srso_alias_return_thunk+0x5/0x7fn ? __lock_acquire+0x480/0x26c0n ? lock_release+0x1ed/0x640n ? srso_alias_return_thunk+0x5/0x7fn ? do_raw_spin_unlock+0x9b/0x100n cifs_statfs+0x18c/0x4b0 [cifs]n statfs_by_dentry+0x9b/0xf0n fd_statfs+0x4e/0xb0n __do_sys_fstatfs+0x7f/0xe0n ? __pfx___do_sys_fstatfs+0x10/0x10n ? srso_alias_return_thunk+0x5/0x7fn ? lockdep_hardirqs_on_prepare+0x136/0x200n ? srso_alias_return_thunk+0x5/0x7fn do_syscall_64+0x3f/0x90n entry_SYSCALL_64_after_hwframe+0x6e/0xd8nn Allocated by task 27534:n kasan_save_stack+0x33/0x60n kasan_set_track+0x25/0x30n __kasan_kmalloc+0x8f/0xa0n open_cached_dir+0x71b/0x1240 [cifs]n smb2_query_info_compound+0x5c3/0x6d0 [cifs]n smb2_queryfs+0xc2/0x2c0 [cifs]n smb311_queryfs+0x210/0x220 [cifs]n cifs_statfs+0x18c/0x4b0 [cifs]n statfs_by_dentry+0x9b/0xf0n fd_statfs+0x4e/0xb0n __do_sys_fstatfs+0x7f/0xe0n do_syscall_64+0x3f/0x90n entry_SYSCALL_64_after_hwframe+0x6e/0xd8nn Freed by task 27534:n kasan_save_stack+0x33/0x60n kasan_set_track+0x25/0x30n kasan_save_free_info+0x2b/0x50n ____kasan_slab_free+0x126/0x170n slab_free_freelist_hook+0xd0/0x1e0n __kmem_cache_free+0x9d/0x1b0n open_cached_dir+0xff5/0x1240 [cifs]n smb2_query_info_compound+0x5c3/0x6d0 [cifs]n smb2_queryfs+0xc2/0x2c0 [cifs]nnThis is a race between open_cached_dir() and cached_dir_lease_break()nwhere the cache entry for the open directory handle receives a leasenbreak while creating it. And before returning from open_cached_dir()nwe put the last reference of the new @cfid because ofn!@cfid->has_lease.nnBesides the UAF while running xfstests a lot of missed lease breaksnhave been noticed in tests that run several concurrent statfs(2) callsnon those cached fidsnn CIFS: VFS: w22-root1.gandalf.test No task to wake unknown frame...n CIFS: VFS: w22-root1.gandalf.test Cmd: 18 Err: 0x0 Flags: 0x1...n CIFS: VFS: w22-root1.gandalf.test smb buf 00000000715bfe83 len 108n CIFS: VFS: Dump pending requests:n CIFS: VFS: w22-root1.gandalf.test No task to wake unknown frame...n CIFS: VFS: w22-root1.gandalf.test Cmd: 18 Err: 0x0 Flags: 0x1...n CIFS: VFS: w22-root1.gandalf.test smb buf 000000005aa7316e len 108n ...nnTo fix both in open_cached_dir() ensure that @cfid->has_lease is setnright before sending out compounded request so that any potentialnlease break will be get processed by demultiplex thread while we'renstill caching @cfid. And if open failed for some reason re-checkn@cfid->has_lease to decide whether or not put lease reference.,CVE-2023-52751,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnsmb: client: fix use-after-free bug in cifs_debug_data_proc_show()nnSkip SMB sessions that are being teared downn(e.g. @ses->ses_status == SES_EXITING) in cifs_debug_data_proc_show()nto avoid use-after-free in @ses.nnThis fixes the following GPF when reading from /proc/fs/cifs/DebugDatanwhile mounting and umountingnn [ 816.251274] general protection fault probably for non-canonicaln address 0x6b6b6b6b6b6b6d81: 0000 [#1] PREEMPT SMP NOPTIn ...n [ 816.260138] Call Trace:n [ 816.260329] <TASK>n [ 816.260499] ? die_addr+0x36/0x90n [ 816.260762] ? exc_general_protection+0x1b3/0x410n [ 816.261126] ? asm_exc_general_protection+0x26/0x30n [ 816.261502] ? cifs_debug_tcon+0xbd/0x240 [cifs]n [ 816.261878] ? cifs_debug_tcon+0xab/0x240 [cifs]n [ 816.262249] cifs_debug_data_proc_show+0x516/0xdb0 [cifs]n [ 816.262689] ? seq_read_iter+0x379/0x470n [ 816.262995] seq_read_iter+0x118/0x470n [ 816.263291] proc_reg_read_iter+0x53/0x90n [ 816.263596] ? srso_alias_return_thunk+0x5/0x7fn [ 816.263945] vfs_read+0x201/0x350n [ 816.264211] ksys_read+0x75/0x100n [ 816.264472] do_syscall_64+0x3f/0x90n [ 816.264750] entry_SYSCALL_64_after_hwframe+0x6e/0xd8n [ 816.265135] RIP: 0033:0x7fd5e669d381,CVE-2023-52752,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnsmb: client: fix potential deadlock when releasing midsnnAll release_mid() callers seem to hold a reference of @mid so there isnno need to call kref_put(&mid->refcount __release_mid) undern@server->mid_lock spinlock. If they don't then an use-after-free bugnwould have occurred anyways.nnBy getting rid of such spinlock also fixes a potential deadlock asnshown belownnCPU 0 CPU 1n------------------------------------------------------------------ncifs_demultiplex_thread() cifs_debug_data_proc_show()n release_mid()n spin_lock(&server->mid_lock);n spin_lock(&cifs_tcp_ses_lock)ntttt spin_lock(&server->mid_lock)n __release_mid()n smb2_find_smb_tcon()n spin_lock(&cifs_tcp_ses_lock) *deadlock*,CVE-2023-52757,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nngfs2: Fix slab-use-after-free in gfs2_qd_deallocnnIn gfs2_put_super() whether withdrawn or not the quota shouldnbe cleaned up by gfs2_quota_cleanup().nnOtherwise struct gfs2_sbd will be freed before gfs2_qd_dealloc (rcuncallback) has run for all gfs2_quota_data objects resulting innuse-after-free.nnAlso gfs2_destroy_threads() and gfs2_quota_cleanup() is already callednby gfs2_make_fs_ro() so in gfs2_put_super() after callingngfs2_make_fs_ro() there is no need to call them again.,CVE-2023-52760,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnriscv: VMAP_STACK overflow detection thread-safenncommit 31da94c25aea (riscv: add VMAP_STACK overflow detection) addednsupport for CONFIG_VMAP_STACK. If overflow is detected CPU switches ton`shadow_stack` temporarily before switching finally to per-cpun`overflow_stack`.nnIf two CPUs/harts are racing and end up in over flowing kernel stack onenor both will end up corrupting each other state because `shadow_stack` isnnot per-cpu. This patch optimizes per-cpu overflow stack switch byndirectly picking per-cpu `overflow_stack` and gets rid of `shadow_stack`.nnFollowing are the changes in this patchnn - Defines an asm macro to obtain per-cpu symbols in destinationn register.n - In entry.S when overflow is detected per-cpu overflow stack isn located using per-cpu asm macro. Computing per-cpu symbol requiresn a temporary register. x31 is saved away into CSR_SCRATCHn (CSR_SCRATCH is anyways zero since we're in kernel).nnPlease see Links for additional relevant disccussion and alternativensolution.nnTested by `echo EXHAUST_STACK > /sys/kernel/debug/provoke-crash/DIRECT`nKernel crash log belownn Insufficient stack space to handle exception!/debug/provoke-crash/DIRECTn Task stack: [0xff20000010a98000..0xff20000010a9c000]n Overflow stack: [0xff600001f7d98370..0xff600001f7d99370]n CPU: 1 PID: 205 Comm: bash Not tainted 6.1.0-rc2-00001-g328a1f96f7b9 #34n Hardware name: riscv-virtioqemu (DT)n epc : __memset+0x60/0xfcn ra : recursive_loop+0x48/0xc6 [lkdtm]n epc : ffffffff808de0e4 ra : ffffffff0163a752 sp : ff20000010a97e80n gp : ffffffff815c0330 tp : ff600000820ea280 t0 : ff20000010a97e88n t1 : 000000000000002e t2 : 3233206874706564 s0 : ff20000010a982b0n s1 : 0000000000000012 a0 : ff20000010a97e88 a1 : 0000000000000000n a2 : 0000000000000400 a3 : ff20000010a98288 a4 : 0000000000000000n a5 : 0000000000000000 a6 : fffffffffffe43f0 a7 : 00007fffffffffffn s2 : ff20000010a97e88 s3 : ffffffff01644680 s4 : ff20000010a9be90n s5 : ff600000842ba6c0 s6 : 00aaaaaac29e42b0 s7 : 00fffffff0aa3684n s8 : 00aaaaaac2978040 s9 : 0000000000000065 s10: 00ffffff8a7cad10n s11: 00ffffff8a76a4e0 t3 : ffffffff815dbaf4 t4 : ffffffff815dbaf4n t5 : ffffffff815dbab8 t6 : ff20000010a9bb48n status: 0000000200000120 badaddr: ff20000010a97e88 cause: 000000000000000fn Kernel panic - not syncing: Kernel stack overflown CPU: 1 PID: 205 Comm: bash Not tainted 6.1.0-rc2-00001-g328a1f96f7b9 #34n Hardware name: riscv-virtioqemu (DT)n Call Trace:n [<ffffffff80006754>] dump_backtrace+0x30/0x38n [<ffffffff808de798>] show_stack+0x40/0x4cn [<ffffffff808ea2a8>] dump_stack_lvl+0x44/0x5cn [<ffffffff808ea2d8>] dump_stack+0x18/0x20n [<ffffffff808dec06>] panic+0x126/0x2fen [<ffffffff800065ea>] walk_stackframe+0x0/0xf0n [<ffffffff0163a752>] recursive_loop+0x48/0xc6 [lkdtm]n SMP: stopping secondary CPUsn ---[ end Kernel panic - not syncing: Kernel stack overflow ]---,CVE-2023-52761,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnvirtio-blk: fix implicit overflow on virtio_max_dma_sizennThe following codes have an implicit conversion from size_t to u32:n(u32)max_size = (size_t)virtio_max_dma_size(vdev);nnThis may lead overflow Ex (size_t)4G -> (u32)0. Oncenvirtio_max_dma_size() has a larger size than U32_MAX use U32_MAXninstead.,CVE-2023-52762,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nni3c: master: mipi-i3c-hci: Fix a kernel panic for accessing DAT_data.nnThe `i3c_master_bus_init` function may attach the I2C devices before thenI3C bus initialization. In this flow the DAT `alloc_entry`` will be usednbefore the DAT `init`. Additionally if the `i3c_master_bus_init` failsnthe DAT `cleanup` will execute before the device is detached which willnexecue DAT `free_entry` function. The above scenario can cause the drivernto use DAT_data when it is NULL.,CVE-2023-52763,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nni3c: mipi-i3c-hci: Fix out of bounds access in hci_dma_irq_handlernnDo not loop over ring headers in hci_dma_irq_handler() that are notnallocated and enabled in hci_dma_init(). Otherwise out of bounds accessnwill occur from rings->headers[i] access when i >= number of allocatednring headers.,CVE-2023-52766,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnscsi: hisi_sas: Set debugfs_dir pointer to NULL after removing debugfsnnIf init debugfs failed during device registration due to memory allocationnfailure debugfs_remove_recursive() is called after which debugfs_dir isnnot set to NULL. debugfs_remove_recursive() will be called again duringndevice removal. As a result illegal pointer is accessed.nn[ 1665.467244] hisi_sas_v3_hw 0000:b4:02.0: failed to init debugfs!n...n[ 1669.836708] Unable to handle kernel NULL pointer dereference at virtual address 00000000000000a0n[ 1669.872669] pc : down_write+0x24/0x70n[ 1669.876315] lr : down_write+0x1c/0x70n[ 1669.879961] sp : ffff000036f53a30n[ 1669.883260] x29: ffff000036f53a30 x28: ffffa027c31549f8n[ 1669.888547] x27: ffffa027c3140000 x26: 0000000000000000n[ 1669.893834] x25: ffffa027bf37c270 x24: ffffa027bf37c270n[ 1669.899122] x23: ffff0000095406b8 x22: ffff0000095406a8n[ 1669.904408] x21: 0000000000000000 x20: ffffa027bf37c310n[ 1669.909695] x19: 00000000000000a0 x18: ffff8027dcd86f10n[ 1669.914982] x17: 0000000000000000 x16: 0000000000000000n[ 1669.920268] x15: 0000000000000000 x14: ffffa0274014f870n[ 1669.925555] x13: 0000000000000040 x12: 0000000000000228n[ 1669.930842] x11: 0000000000000020 x10: 0000000000000bb0n[ 1669.936129] x9 : ffff000036f537f0 x8 : ffff80273088ca10n[ 1669.941416] x7 : 000000000000001d x6 : 00000000ffffffffn[ 1669.946702] x5 : ffff000008a36310 x4 : ffff80273088be00n[ 1669.951989] x3 : ffff000009513e90 x2 : 0000000000000000n[ 1669.957276] x1 : 00000000000000a0 x0 : ffffffff00000001n[ 1669.962563] Call trace:n[ 1669.965000] down_write+0x24/0x70n[ 1669.968301] debugfs_remove_recursive+0x5c/0x1b0n[ 1669.972905] hisi_sas_debugfs_exit+0x24/0x30 [hisi_sas_main]n[ 1669.978541] hisi_sas_v3_remove+0x130/0x150 [hisi_sas_v3_hw]n[ 1669.984175] pci_device_remove+0x48/0xd8n[ 1669.988082] device_release_driver_internal+0x1b4/0x250n[ 1669.993282] device_release_driver+0x28/0x38n[ 1669.997534] pci_stop_bus_device+0x84/0xb8n[ 1670.001611] pci_stop_and_remove_bus_device_locked+0x24/0x40n[ 1670.007244] remove_store+0xfc/0x140n[ 1670.010802] dev_attr_store+0x44/0x60n[ 1670.014448] sysfs_kf_write+0x58/0x80n[ 1670.018095] kernfs_fop_write+0xe8/0x1f0n[ 1670.022000] __vfs_write+0x60/0x190n[ 1670.025472] vfs_write+0xac/0x1c0n[ 1670.028771] ksys_write+0x6c/0xd8n[ 1670.032071] __arm64_sys_write+0x24/0x30n[ 1670.035977] el0_svc_common+0x78/0x130n[ 1670.039710] el0_svc_handler+0x38/0x78n[ 1670.043442] el0_svc+0x8/0xcnnTo fix this set debugfs_dir to NULL after debugfs_remove_recursive().,CVE-2023-52808,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnscsi: ibmvfc: Remove BUG_ON in the case of an empty event poolnnIn practice the driver should never send more commands than are allocatednto a queue's event pool. In the unlikely event that this happens the codenasserts a BUG_ON and in the case that the kernel is not configured toncrash on panic returns a junk event pointer from the empty event listncausing things to spiral from there. This BUG_ON is a historical artifactnof the ibmvfc driver first being upstreamed and it is well known now thatnthe use of BUG_ON is bad practice except in the most unrecoverablenscenario. There is nothing about this scenario that prevents the drivernfrom recovering and carrying on.nnRemove the BUG_ON in question from ibmvfc_get_event() and return a NULLnpointer in the case of an empty event pool. Update all call sites tonibmvfc_get_event() to check for a NULL pointer and perfrom the appropriatenfailure or recovery action.,CVE-2023-52811,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd: check num of link levels when update pcie paramnnIn SR-IOV environment the value of pcie_table->num_of_link_levels willnbe 0 and num_of_levels - 1 will cause array index out of bounds,CVE-2023-52812,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amdgpu/vkms: fix a possible null pointer dereferencennIn amdgpu_vkms_conn_get_modes() the return value of drm_cvt_mode()nis assigned to mode which will lead to a NULL pointer dereferencenon failure of drm_cvt_mode(). Add a check to avoid null pointerndereference.,CVE-2023-52815,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nncpu/hotplug: Don't offline the last non-isolated CPUnnIf a system has isolated CPUs via the isolcpus= command line parameternthen an attempt to offline the last housekeeping CPU will result in anWARN_ON() when rebuilding the scheduler domains and a subsequent panic duento and unhandled empty CPU mas in partition_sched_domains_locked().nncpuset_hotplug_workfn()n rebuild_sched_domains_locked()n ndoms = generate_sched_domains(&doms &attr);n cpumask_and(doms[0] top_cpuset.effective_cpus housekeeping_cpumask(HK_FLAG_DOMAIN));nnThus results in an empty CPU mask which triggers the warning and then thensubsequent crash:nnWARNING: CPU: 4 PID: 80 at kernel/sched/topology.c:2366 build_sched_domains+0x120c/0x1408nCall trace:n build_sched_domains+0x120c/0x1408n partition_sched_domains_locked+0x234/0x880n rebuild_sched_domains_locked+0x37c/0x798n rebuild_sched_domains+0x30/0x58n cpuset_hotplug_workfn+0x2a8/0x930nnUnable to handle kernel paging request at virtual address fffe80027ab37080n partition_sched_domains_locked+0x318/0x880n rebuild_sched_domains_locked+0x37c/0x798nnAside of the resulting crash it does not make any sense to offline the lastnlast housekeeping CPU.nnPrevent this by masking out the non-housekeeping CPUs when selecting antarget CPU for initiating the CPU unplug operation via the work queue.,CVE-2023-52831,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnatl1c: Work around the DMA RX overflow issuennThis is based on alx driver commit 881d0327db37 (net: alx: Work aroundnthe DMA RX overflow issue).nnThe alx and atl1c drivers had RX overflow error which was why a customnallocator was created to avoid certain addresses. The simpler workaroundnthen created for alx driver but not for atl1c due to lack of tester.nnInstead of using a custom allocator check the allocated skb address andnuse skb_reserve() to move away from problematic 0x...fc0 address.nnTested on AR8131 on Acer 4540.,CVE-2023-52834,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nncan: dev: can_put_echo_skb(): don't crash kernel if can_priv::echo_skb is accessed out of boundsnnIf the struct can_priv::echoo_skb is accessed out of bounds thisnwould cause a kernel crash. Instead issue a meaningful warningnmessage and return with an error.,CVE-2023-52878,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnmedia: mediatek: vcodec: Only free buffer VA that is not NULLnnIn the MediaTek vcodec driver while mtk_vcodec_mem_free() is mostlyncalled only when the buffer to free exists there are some instancesnthat didn't do the check and triggered warnings in practice.nnWe believe those checks were forgotten unintentionally. Add the checksnback to fix the warnings.,CVE-2023-52888,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amdgpu: Fixed bug on error when unloading amdgpunnFixed bug on error when unloading amdgpu.nnThe error message is as follows:n[ 377.706202] kernel BUG at drivers/gpu/drm/drm_buddy.c:278!n[ 377.706215] invalid opcode: 0000 [#1] PREEMPT SMP NOPTIn[ 377.706222] CPU: 4 PID: 8610 Comm: modprobe Tainted: G IOE 6.0.0-thomas #1n[ 377.706231] Hardware name: ASUS System Product Name/PRIME Z390-A BIOS 2004 11/02/2021n[ 377.706238] RIP: 0010:drm_buddy_free_block+0x26/0x30 [drm_buddy]n[ 377.706264] Code: 00 00 00 90 0f 1f 44 00 00 48 8b 0e 89 c8 25 00 0c 00 00 3d 00 04 00 00 75 10 48 8b 47 18 48 d3 e0 48 01 47 28 e9 fa fe ff ff <0f> 0b 0f 1f 84 00 00 00 00 00 0f 1f 44 00 00 41 54 55 48 89 f5 53n[ 377.706282] RSP: 0018:ffffad2dc4683cb8 EFLAGS: 00010287n[ 377.706289] RAX: 0000000000000000 RBX: ffff8b1743bd5138 RCX: 0000000000000000n[ 377.706297] RDX: ffff8b1743bd5160 RSI: ffff8b1743bd5c78 RDI: ffff8b16d1b25f70n[ 377.706304] RBP: ffff8b1743bd59e0 R08: 0000000000000001 R09: 0000000000000001n[ 377.706311] R10: ffff8b16c8572400 R11: ffffad2dc4683cf0 R12: ffff8b16d1b25f70n[ 377.706318] R13: ffff8b16d1b25fd0 R14: ffff8b1743bd59c0 R15: ffff8b16d1b25f70n[ 377.706325] FS: 00007fec56c72c40(0000) GS:ffff8b1836500000(0000) knlGS:0000000000000000n[ 377.706334] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033n[ 377.706340] CR2: 00007f9b88c1ba50 CR3: 0000000110450004 CR4: 00000000003706e0n[ 377.706347] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000n[ 377.706354] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400n[ 377.706361] Call Trace:n[ 377.706365] <TASK>n[ 377.706369] drm_buddy_free_list+0x2a/0x60 [drm_buddy]n[ 377.706376] amdgpu_vram_mgr_fini+0xea/0x180 [amdgpu]n[ 377.706572] amdgpu_ttm_fini+0x12e/0x1a0 [amdgpu]n[ 377.706650] amdgpu_bo_fini+0x22/0x90 [amdgpu]n[ 377.706727] gmc_v11_0_sw_fini+0x26/0x30 [amdgpu]n[ 377.706821] amdgpu_device_fini_sw+0xa1/0x3c0 [amdgpu]n[ 377.706897] amdgpu_driver_release_kms+0x12/0x30 [amdgpu]n[ 377.706975] drm_dev_release+0x20/0x40 [drm]n[ 377.707006] release_nodes+0x35/0xb0n[ 377.707014] devres_release_all+0x8b/0xc0n[ 377.707020] device_unbind_cleanup+0xe/0x70n[ 377.707027] device_release_driver_internal+0xee/0x160n[ 377.707033] driver_detach+0x44/0x90n[ 377.707039] bus_remove_driver+0x55/0xe0n[ 377.707045] pci_unregister_driver+0x3b/0x90n[ 377.707052] amdgpu_exit+0x11/0x6c [amdgpu]n[ 377.707194] __x64_sys_delete_module+0x142/0x2b0n[ 377.707201] ? fpregs_assert_state_consistent+0x22/0x50n[ 377.707208] ? exit_to_user_mode_prepare+0x3e/0x190n[ 377.707215] do_syscall_64+0x38/0x90n[ 377.707221] entry_SYSCALL_64_after_hwframe+0x63/0xcd,CVE-2023-52912,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/i915: Fix potential context UAFsnngem_context_register() makes the context visible to userspace and whichnpoint a separate thread can trigger the I915_GEM_CONTEXT_DESTROY ioctl.nSo we need to ensure that nothing uses the ctx ptr after this. And wenneed to ensure that adding the ctx to the xarray is the *last* thingnthat gem_context_register() does with the ctx pointer.nn[tursulin: Stable and fixes tags add/tidy.]n(cherry picked from commit bed4b455cf5374e68879be56971c1da563bcd90c),CVE-2023-52913,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnmedia: aspeed: Fix memory overwrite if timing is 1600x900nnWhen capturing 1600x900 system could crash when system memory usage isntight.nnThe way to reproduce this issue:n1. Use 1600x900 to display on hostn2. Mount ISO through 'Virtual media' on OpenBMC's webn3. Run script as below on host to do sha continuouslyn #!/bin/bashn while [ [1] ];n dontfind /media -type f -printf '%h/%fn' | xargs sha256sumn donen4. Open KVM on OpenBMC's webnnThe size of macro block captured is 8x8. Therefore we should make surenthe height of src-buf is 8 aligned to fix this issue.,CVE-2023-52916,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnmedia: pci: cx23885: check cx23885_vdev_init() returnnncx23885_vdev_init() can return a NULL pointer but that pointernis used in the next line without a check.nnAdd a NULL pointer check and go to the error unwind if it is NULL.,CVE-2023-52918,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbpf: support non-r10 register spill/fill to/from stack in precision trackingnnUse instruction (jump) history to record instructions that performednregister spill/fill to/from stack regardless if this was done throughnread-only r10 register or any other register after copying r10 into itn*and* potentially adjusting offset.nnTo make this work reliably we push extra per-instruction flags intoninstruction history encoding stack slot index (spi) and stack framennumber in extra 10 bit flags we take away from prev_idx in instructionnhistory. We don't touch idx field for maximum performance as it'snchecked most frequently during backtracking.nnThis change removes basically the last remaining practical limitation ofnprecision backtracking logic in BPF verifier. It fixes knownndeficiencies but also opens up new opportunities to reduce number ofnverified states explored in the subsequent patches.nnThere are only three differences in selftests' BPF object filesnaccording to veristat all in the positive direction (less states).nnFile Program Insns (A) Insns (B) Insns (DIFF) States (A) States (B) States (DIFF)n-------------------------------------- ------------- --------- --------- ------------- ---------- ---------- -------------ntest_cls_redirect_dynptr.bpf.linked3.o cls_redirect 2987 2864 -123 (-4.12%) 240 231 -9 (-3.75%)nxdp_synproxy_kern.bpf.linked3.o syncookie_tc 82848 82661 -187 (-0.23%) 5107 5073 -34 (-0.67%)nxdp_synproxy_kern.bpf.linked3.o syncookie_xdp 85116 84964 -152 (-0.18%) 5162 5130 -32 (-0.62%)nnNote I avoided renaming jmp_history to more generic insn_hist tonminimize number of lines changed and potential merge conflicts betweennbpf and bpf-next trees.nnNotice also cur_hist_entry pointer reset to NULL at the beginning ofninstruction verification loop. This pointer avoids the problem ofnrelying on last jump history entry's insn_idx to determine whether wenalready have entry for current instruction or not. It can happen that wenadded jump history entry because current instruction is_jmp_point() butnalso we need to add instruction flags for stack access. In this case wendon't want to entries so we need to reuse last added entry if it isnpresent.nnRelying on insn_idx comparison has the same ambiguity problem as the onenthat was fixed recently in [0] so we avoid that.nn [0] https://patchwork.kernel.org/project/netdevbpf/patch/20231110002638.4168352-3-andrii@kernel.org/,CVE-2023-52920,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amdgpu: fix possible UAF in amdgpu_cs_pass1()nnSince the gang_size check is outside of chunk parsingnloop we need to reset i before we free the chunk data.nnSuggested by Ye Zhang (@VAR10CK) of Baidu Security.,CVE-2023-52921,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnIORING_OP_READ did not correctly consume the provided buffer list whennread i/o returned < 0 (except for -EAGAIN and -EIOCBQUEUED return).nThis can lead to a potential use-after-free when the completion vianio_rw_done runs at separate context.,CVE-2023-52926,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnetfilter: allow exp not to be removed in nf_ct_find_expectationnnCurrently nf_conntrack_in() calling nf_ct_find_expectation() willnremove the exp from the hash table. However in some scenario wenexpect the exp not to be removed when the created ct will not benconfirmed like in OVS and TC conntrack in the following patches.nnThis patch allows exp not to be removed by setting IPS_CONFIRMEDnin the status of the tmpl.,CVE-2023-52927,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbpf: Skip invalid kfunc call in backtrack_insnnnThe verifier skips invalid kfunc call in check_kfunc_call() whichnwould be captured in fixup_kfunc_call() if such insn is not eliminatednby dead code elimination. However this can lead to the followingnwarning in backtrack_insn() also see [1]:nn ------------[ cut here ]------------n verifier backtracking bugn WARNING: CPU: 6 PID: 8646 at kernel/bpf/verifier.c:2756 backtrack_insnn kernel/bpf/verifier.c:2756nt__mark_chain_precision kernel/bpf/verifier.c:3065ntmark_chain_precision kernel/bpf/verifier.c:3165ntadjust_reg_min_max_vals kernel/bpf/verifier.c:10715ntcheck_alu_op kernel/bpf/verifier.c:10928ntdo_check kernel/bpf/verifier.c:13821 [inline]ntdo_check_common kernel/bpf/verifier.c:16289n [...]nnSo make backtracking conservative with this by returning ENOTSUPP.nn [1] https://lore.kernel.org/bpf/CACkBjsaXNceR8ZjkLG=dT3P=4A8SBsg0Z5h5PWLryF5=ghKq=g@mail.gmail.com/,CVE-2023-52928,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnmm/khugepaged: fix ->anon_vma racennIf an ->anon_vma is attached to the VMA collapse_and_free_pmd() requiresnit to be locked.nnPage table traversal is allowed under any one of the mmap lock thenanon_vma lock (if the VMA is associated with an anon_vma) and thenmapping lock (if the VMA is associated with a mapping); and so to benable to remove page tables we must hold all three of them. nretract_page_tables() bails out if an ->anon_vma is attached but doesnthis check before holding the mmap lock (as the comment above the checknexplains).nnIf we racily merged an existing ->anon_vma (shared with a childnprocess) from a neighboring VMA subsequent rmap traversals on pagesnbelonging to the child will be able to see the page tables that we arenconcurrently removing while assuming that nothing else can access them.nnRepeat the ->anon_vma check once we hold the mmap lock to ensure thatnthere really is no concurrent page table access.nnHitting this bug causes a lockdep warning in collapse_and_free_pmd()nin the line lockdep_assert_held_write(&vma->anon_vma->root->rwsem). nIt can also lead to use-after-free access.,CVE-2023-52935,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnkernel/irq/irqdomain.c: fix memory leak with using debugfs_lookup()nnWhen calling debugfs_lookup() the result must have dput() called on itnotherwise the memory will leak over time. To make things simpler justncall debugfs_lookup_and_remove() instead which handles all of the logicnat once.,CVE-2023-52936,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnmm: memcg: fix NULL pointer in mem_cgroup_track_foreign_dirty_slowpath()nnAs commit 18365225f044 (hwpoison memcg: forcibly uncharge LRU pages)nhwpoison will forcibly uncharg a LRU hwpoisoned page the folio_memcgncould be NULl then mem_cgroup_track_foreign_dirty_slowpath() couldnoccurs a NULL pointer dereference let's do not record the foreignnwritebacks for folio memcg is null in mem_cgroup_track_foreign_dirty() tonfix it.,CVE-2023-52939,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnscsi: iscsi_tcp: Fix UAF during logout when accessing the shost ipaddressnnBug report and analysis from Ding Hui.nnDuring iSCSI session logout if another task accesses the shost ipaddressnattr we can get a KASAN UAF report like this:nn[ 276.942144] BUG: KASAN: use-after-free in _raw_spin_lock_bh+0x78/0xe0n[ 276.942535] Write of size 4 at addr ffff8881053b45b8 by task cat/4088n[ 276.943511] CPU: 2 PID: 4088 Comm: cat Tainted: G E 6.1.0-rc8+ #3n[ 276.943997] Hardware name: VMware Inc. VMware Virtual Platform/440BX Desktop Reference Platform BIOS 6.00 11/12/2020n[ 276.944470] Call Trace:n[ 276.944943] <TASK>n[ 276.945397] dump_stack_lvl+0x34/0x48n[ 276.945887] print_address_description.constprop.0+0x86/0x1e7n[ 276.946421] print_report+0x36/0x4fn[ 276.947358] kasan_report+0xad/0x130n[ 276.948234] kasan_check_range+0x35/0x1c0n[ 276.948674] _raw_spin_lock_bh+0x78/0xe0n[ 276.949989] iscsi_sw_tcp_host_get_param+0xad/0x2e0 [iscsi_tcp]n[ 276.951765] show_host_param_ISCSI_HOST_PARAM_IPADDRESS+0xe9/0x130 [scsi_transport_iscsi]n[ 276.952185] dev_attr_show+0x3f/0x80n[ 276.953005] sysfs_kf_seq_show+0x1fb/0x3e0n[ 276.953401] seq_read_iter+0x402/0x1020n[ 276.954260] vfs_read+0x532/0x7b0n[ 276.955113] ksys_read+0xed/0x1c0n[ 276.955952] do_syscall_64+0x38/0x90n[ 276.956347] entry_SYSCALL_64_after_hwframe+0x63/0xcdn[ 276.956769] RIP: 0033:0x7f5d3a679222n[ 276.957161] Code: c0 e9 b2 fe ff ff 50 48 8d 3d 32 c0 0b 00 e8 a5 fe 01 00 0f 1f 44 00 00 f3 0f 1e fa 64 8b 04 25 18 00 00 00 85 c0 75 10 0f 05 <48> 3d 00 f0 ff ff 77 56 c3 0f 1f 44 00 00 48 83 ec 28 48 89 54 24n[ 276.958009] RSP: 002b:00007ffc864d16a8 EFLAGS: 00000246 ORIG_RAX: 0000000000000000n[ 276.958431] RAX: ffffffffffffffda RBX: 0000000000020000 RCX: 00007f5d3a679222n[ 276.958857] RDX: 0000000000020000 RSI: 00007f5d3a4fe000 RDI: 0000000000000003n[ 276.959281] RBP: 00007f5d3a4fe000 R08: 00000000ffffffff R09: 0000000000000000n[ 276.959682] R10: 0000000000000022 R11: 0000000000000246 R12: 0000000000020000n[ 276.960126] R13: 0000000000000003 R14: 0000000000000000 R15: 0000557a26dada58n[ 276.960536] </TASK>n[ 276.961357] Allocated by task 2209:n[ 276.961756] kasan_save_stack+0x1e/0x40n[ 276.962170] kasan_set_track+0x21/0x30n[ 276.962557] __kasan_kmalloc+0x7e/0x90n[ 276.962923] __kmalloc+0x5b/0x140n[ 276.963308] iscsi_alloc_session+0x28/0x840 [scsi_transport_iscsi]n[ 276.963712] iscsi_session_setup+0xda/0xba0 [libiscsi]n[ 276.964078] iscsi_sw_tcp_session_create+0x1fd/0x330 [iscsi_tcp]n[ 276.964431] iscsi_if_create_session.isra.0+0x50/0x260 [scsi_transport_iscsi]n[ 276.964793] iscsi_if_recv_msg+0xc5a/0x2660 [scsi_transport_iscsi]n[ 276.965153] iscsi_if_rx+0x198/0x4b0 [scsi_transport_iscsi]n[ 276.965546] netlink_unicast+0x4d5/0x7b0n[ 276.965905] netlink_sendmsg+0x78d/0xc30n[ 276.966236] sock_sendmsg+0xe5/0x120n[ 276.966576] ____sys_sendmsg+0x5fe/0x860n[ 276.966923] ___sys_sendmsg+0xe0/0x170n[ 276.967300] __sys_sendmsg+0xc8/0x170n[ 276.967666] do_syscall_64+0x38/0x90n[ 276.968028] entry_SYSCALL_64_after_hwframe+0x63/0xcdn[ 276.968773] Freed by task 2209:n[ 276.969111] kasan_save_stack+0x1e/0x40n[ 276.969449] kasan_set_track+0x21/0x30n[ 276.969789] kasan_save_free_info+0x2a/0x50n[ 276.970146] __kasan_slab_free+0x106/0x190n[ 276.970470] __kmem_cache_free+0x133/0x270n[ 276.970816] device_release+0x98/0x210n[ 276.971145] kobject_cleanup+0x101/0x360n[ 276.971462] iscsi_session_teardown+0x3fb/0x530 [libiscsi]n[ 276.971775] iscsi_sw_tcp_session_destroy+0xd8/0x130 [iscsi_tcp]n[ 276.972143] iscsi_if_recv_msg+0x1bf1/0x2660 [scsi_transport_iscsi]n[ 276.972485] iscsi_if_rx+0x198/0x4b0 [scsi_transport_iscsi]n[ 276.972808] netlink_unicast+0x4d5/0x7b0n[ 276.973201] netlink_sendmsg+0x78d/0xc30n[ 276.973544] sock_sendmsg+0xe5/0x120n[ 276.973864] ____sys_sendmsg+0x5fe/0x860n[ 276.974248] ___sys_n---truncated---,CVE-2023-52975,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/drm_vma_manager: Add drm_vma_node_allow_once()nnCurrently there is no easy way for a drm driver to safely check and allowndrm_vma_offset_node for a drm file just once. Allow drm drivers to callnnon-refcounted version of drm_vma_node_allow() so that a driver doesn'tnneed to keep track of each drm_vma_node_allow() to call subsequentndrm_vma_node_revoke() to prevent memory leak.,CVE-2023-53001,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/i915: Fix a memory leak with reused mmap_offsetnndrm_vma_node_allow() and drm_vma_node_revoke() should be called innbalanced pairs. We call drm_vma_node_allow() once per-file everytime anuser calls mmap_offset but only call drm_vma_node_revoke once per-filenon each mmap_offset. As the mmap_offset is reused by the client thenper-file vm_count may remain non-zero and the rbtree leaked.nnCall drm_vma_node_allow_once() instead to prevent that memory leak.,CVE-2023-53002,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nncifs: fix potential memory leaks in session setupnnMake sure to free cifs_ses::auth_key.response before allocating it asnwe might end up leaking memory in reconnect or mounting.,CVE-2023-53008,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbnxt: Do not read past the end of test namesnnTest names were being concatenated based on a offset beyond the end ofnthe first name which tripped the buffer overflow detection logic:nn detected buffer overflow in strnlenn [...]n Call Trace:n bnxt_ethtool_init.cold+0x18/0x18nnRefactor struct hwrm_selftest_qlist_output to use an actual arraynand adjust the concatenation to use snprintf() rather than a series ofnstrncat() calls.,CVE-2023-53010,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnntb_hw_switchtec: Fix shift-out-of-bounds in switchtec_ntb_mw_set_transnnThere is a kernel API ntb_mw_clear_trans() would pass 0 to both addr andnsize. This would make xlate_pos negative.nn[ 23.734156] switchtec switchtec0: MW 0: part 0 addr 0x0000000000000000 size 0x0000000000000000n[ 23.734158] ================================================================================n[ 23.734172] UBSAN: shift-out-of-bounds in drivers/ntb/hw/mscc/ntb_hw_switchtec.c:293:7n[ 23.734418] shift exponent -1 is negativennEnsuring xlate_pos is a positive or zero before BIT.,CVE-2023-53034,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amdgpu: Fix call trace warning and hang when removing amdgpu devicennOn GPUs with RAS enabled below call trace and hang are observed whennshutting down device.nnv2: use DRM device unplugged flag instead of shutdown flag as the check tonprevent memory wipe in shutdown stage.nn[ +0.000000] RIP: 0010:amdgpu_vram_mgr_fini+0x18d/0x1c0 [amdgpu]n[ +0.000001] PKRU: 55555554n[ +0.000001] Call Trace:n[ +0.000001] <TASK>n[ +0.000002] amdgpu_ttm_fini+0x140/0x1c0 [amdgpu]n[ +0.000183] amdgpu_bo_fini+0x27/0xa0 [amdgpu]n[ +0.000184] gmc_v11_0_sw_fini+0x2b/0x40 [amdgpu]n[ +0.000163] amdgpu_device_fini_sw+0xb6/0x510 [amdgpu]n[ +0.000152] amdgpu_driver_release_kms+0x16/0x30 [amdgpu]n[ +0.000090] drm_dev_release+0x28/0x50 [drm]n[ +0.000016] devm_drm_dev_init_release+0x38/0x60 [drm]n[ +0.000011] devm_action_release+0x15/0x20n[ +0.000003] release_nodes+0x40/0xc0n[ +0.000001] devres_release_all+0x9e/0xe0n[ +0.000001] device_unbind_cleanup+0x12/0x80n[ +0.000003] device_release_driver_internal+0xff/0x160n[ +0.000001] driver_detach+0x4a/0x90n[ +0.000001] bus_remove_driver+0x6c/0xf0n[ +0.000001] driver_unregister+0x31/0x50n[ +0.000001] pci_unregister_driver+0x40/0x90n[ +0.000003] amdgpu_exit+0x15/0x120 [amdgpu],CVE-2023-53036,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnscsi: mpi3mr: Bad drive in topology results kernel crashnnWhen the SAS Transport Layer support is enabled and a device exposed tonthe OS by the driver fails INQUIRY commands the driver frees up the memorynallocated for an internal HBA port data structure. However in some placesnthe reference to the freed memory is not cleared. When the firmware sendsnthe Device Info change event for the same device again the freed memory isnaccessed and that leads to memory corruption and OS crash.,CVE-2023-53037,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnscsi: lpfc: Check kzalloc() in lpfc_sli4_cgn_params_read()nnIf kzalloc() fails in lpfc_sli4_cgn_params_read() then we rely onnlpfc_read_object()'s routine to NULL check pdata.nnCurrently an early return error is thrown from lpfc_read_object() tonprotect us from NULL ptr dereference but the errno code is -ENODEV.nnChange the errno code to a more appropriate -ENOMEM.,CVE-2023-53038,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnHID: intel-ish-hid: ipc: Fix potential use-after-free in work functionnnWhen a reset notify IPC message is received the ISR schedules a worknfunction and passes the ISHTP device to it via a global pointernishtp_dev. If ish_probe() fails the devm-managed device resourcesnincluding ishtp_dev are freed but the work is not cancelled causing anuse-after-free when the work function tries to access ishtp_dev. Usendevm_work_autocancel() instead so that the work is automaticallyncancelled if probe fails.,CVE-2023-53039,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Do not set DRR on pipe Commitnn[WHY]nWriting to DRR registers such as OTG_V_TOTAL_MIN on the same frame as anpipe commit can cause underflow.,CVE-2023-53042,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nncifs: fix use-after-free bug in refresh_cache_worker()nnThe UAF bug occurred because we were putting DFS root sessions inncifs_umount() while DFS cache refresher was being executed.nnMake DFS root sessions have same lifetime as DFS tcons so we can avoidnthe use-after-free bug is DFS cache refresher and other places thatnrequire IPCs to get new DFS referrals on. Also get rid of mountngroup handling in DFS cache as we no longer need it.nnThis fixes below use-after-free bug catched by KASANnn[ 379.946955] BUG: KASAN: use-after-free in __refresh_tcon.isra.0+0x10b/0xc10 [cifs]n[ 379.947642] Read of size 8 at addr ffff888018f57030 by task kworker/u4:3/56n[ 379.948096]n[ 379.948208] CPU: 0 PID: 56 Comm: kworker/u4:3 Not tainted 6.2.0-rc7-lku #23n[ 379.948661] Hardware name: QEMU Standard PC (Q35 + ICH9 2009) BIOSnrel-1.16.0-0-gd239552-rebuilt.opensuse.org 04/01/2014n[ 379.949368] Workqueue: cifs-dfscache refresh_cache_worker [cifs]n[ 379.949942] Call Trace:n[ 379.950113] <TASK>n[ 379.950260] dump_stack_lvl+0x50/0x67n[ 379.950510] print_report+0x16a/0x48en[ 379.950759] ? __virt_addr_valid+0xd8/0x160n[ 379.951040] ? __phys_addr+0x41/0x80n[ 379.951285] kasan_report+0xdb/0x110n[ 379.951533] ? __refresh_tcon.isra.0+0x10b/0xc10 [cifs]n[ 379.952056] ? __refresh_tcon.isra.0+0x10b/0xc10 [cifs]n[ 379.952585] __refresh_tcon.isra.0+0x10b/0xc10 [cifs]n[ 379.953096] ? __pfx___refresh_tcon.isra.0+0x10/0x10 [cifs]n[ 379.953637] ? __pfx___mutex_lock+0x10/0x10n[ 379.953915] ? lock_release+0xb6/0x720n[ 379.954167] ? __pfx_lock_acquire+0x10/0x10n[ 379.954443] ? refresh_cache_worker+0x34e/0x6d0 [cifs]n[ 379.954960] ? __pfx_wb_workfn+0x10/0x10n[ 379.955239] refresh_cache_worker+0x4ad/0x6d0 [cifs]n[ 379.955755] ? __pfx_refresh_cache_worker+0x10/0x10 [cifs]n[ 379.956323] ? __pfx_lock_acquired+0x10/0x10n[ 379.956615] ? read_word_at_a_time+0xe/0x20n[ 379.956898] ? lockdep_hardirqs_on_prepare+0x12/0x220n[ 379.957235] process_one_work+0x535/0x990n[ 379.957509] ? __pfx_process_one_work+0x10/0x10n[ 379.957812] ? lock_acquired+0xb7/0x5f0n[ 379.958069] ? __list_add_valid+0x37/0xd0n[ 379.958341] ? __list_add_valid+0x37/0xd0n[ 379.958611] worker_thread+0x8e/0x630n[ 379.958861] ? __pfx_worker_thread+0x10/0x10n[ 379.959148] kthread+0x17d/0x1b0n[ 379.959369] ? __pfx_kthread+0x10/0x10n[ 379.959630] ret_from_fork+0x2c/0x50n[ 379.959879] </TASK>,CVE-2023-53052,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnfscrypt: destroy keyring after security_sb_delete()nnfscrypt_destroy_keyring() must be called after all potentially-encryptedninodes were evicted; otherwise it cannot safely destroy the keyring.nSince inodes that are in-use by the Landlock LSM don't get evicted untilnsecurity_sb_delete() this means that fscrypt_destroy_keyring() must bencalled *after* security_sb_delete().nnThis fixes a WARN_ON followed by a NULL dereference only possible ifnLandlock was being used on encrypted files.,CVE-2023-53055,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet: usb: lan78xx: Limit packet length to skb->lennnPacket length retrieved from descriptor may be larger thannthe actual socket buffer length. In such case the clonednskb passed up the network stack will leak kernel memory contents.nnAdditionally prevent integer underflow when size is less thannETH_FCS_LEN.,CVE-2023-53068,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnmptcp: use the workqueue to destroy unaccepted socketsnnChristoph reported a UaF at token lookup time after havingnrefactored the passive socket initialization part:nn BUG: KASAN: use-after-free in __token_bucket_busy+0x253/0x260n Read of size 4 at addr ffff88810698d5b0 by task syz-executor653/3198nn CPU: 1 PID: 3198 Comm: syz-executor653 Not tainted 6.2.0-rc59af4eaa31c1f6c00c8f1e448ed99a45c66340dd5 #6n Hardware name: QEMU Standard PC (i440FX + PIIX 1996) BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014n Call Trace:n <TASK>n dump_stack_lvl+0x6e/0x91n print_report+0x16a/0x46fn kasan_report+0xad/0x130n __token_bucket_busy+0x253/0x260n mptcp_token_new_connect+0x13d/0x490n mptcp_connect+0x4ed/0x860n __inet_stream_connect+0x80e/0xd90n tcp_sendmsg_fastopen+0x3ce/0x710n mptcp_sendmsg+0xff1/0x1a20n inet_sendmsg+0x11d/0x140n __sys_sendto+0x405/0x490n __x64_sys_sendto+0xdc/0x1b0n do_syscall_64+0x3b/0x90n entry_SYSCALL_64_after_hwframe+0x72/0xdcnnWe need to properly clean-up all the paired MPTCP-levelnresources and be sure to release the msk last even whennthe unaccepted subflow is destroyed by the TCP internalsnvia inet_child_forget().nnWe can re-use the existing MPTCP_WORK_CLOSE_SUBFLOW infranexplicitly checking that for the critical scenario: thenclosed subflow is the MPC one the msk is not accepted andneventually going through full cleanup.nnWith such change __mptcp_destroy_sock() is always callednon msk sockets even on accepted ones. We don't need anymorento transiently drop one sk reference at msk clone time.nnPlease note this commit depends on the parent one:nn mptcp: refactor passive socket initialization,CVE-2023-53072,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amdgpu: fix ttm_bo calltrace warning in psp_hw_fininnThe call trace occurs when the amdgpu is removed afternthe mode1 reset. During mode1 reset from suspend to resumenthere is no need to reinitialize the ta firmware buffernwhich caused the bo pin_count increase redundantly.nn[ 489.885525] Call Trace:n[ 489.885525] <TASK>n[ 489.885526] amdttm_bo_put+0x34/0x50 [amdttm]n[ 489.885529] amdgpu_bo_free_kernel+0xe8/0x130 [amdgpu]n[ 489.885620] psp_free_shared_bufs+0xb7/0x150 [amdgpu]n[ 489.885720] psp_hw_fini+0xce/0x170 [amdgpu]n[ 489.885815] amdgpu_device_fini_hw+0x2ff/0x413 [amdgpu]n[ 489.885960] ? blocking_notifier_chain_unregister+0x56/0xb0n[ 489.885962] amdgpu_driver_unload_kms+0x51/0x60 [amdgpu]n[ 489.886049] amdgpu_pci_remove+0x5a/0x140 [amdgpu]n[ 489.886132] ? __pm_runtime_resume+0x60/0x90n[ 489.886134] pci_device_remove+0x3e/0xb0n[ 489.886135] __device_release_driver+0x1ab/0x2a0n[ 489.886137] driver_detach+0xf3/0x140n[ 489.886138] bus_remove_driver+0x6c/0xf0n[ 489.886140] driver_unregister+0x31/0x60n[ 489.886141] pci_unregister_driver+0x40/0x90n[ 489.886142] amdgpu_exit+0x15/0x451 [amdgpu],CVE-2023-53074,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnext4: update s_journal_inum if it changes after journal replaynnWhen mounting a crafted ext4 image s_journal_inum may change after journalnreplay which is obviously unreasonable because we have successfully loadednand replayed the journal through the old s_journal_inum. And the newns_journal_inum bypasses some of the checks in ext4_get_journal() whichnmay trigger a null pointer dereference problem. So if s_journal_inumnchanges after the journal replay we ignore the change and rewrite thencurrent journal_inum to the superblock.,CVE-2023-53091,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nntracing: Do not let histogram values have some modifiersnnHistogram values can not be strings stacktraces graphs symbolsnsyscalls or grouped in buckets or log. Give an error if a value is set tondo so.nnNote the histogram code was not prepared to handle these modifiers fornhistograms and caused a bug.nnMark Rutland reported:nn # echo 'p:copy_to_user __arch_copy_to_user n=$arg2' >> /sys/kernel/tracing/kprobe_eventsn # echo 'hist:keys=n:vals=hitcount.buckets=8:sort=hitcount' > /sys/kernel/tracing/events/kprobes/copy_to_user/triggern # cat /sys/kernel/tracing/events/kprobes/copy_to_user/histn[ 143.694628] Unable to handle kernel NULL pointer dereference at virtual address 0000000000000000n[ 143.695190] Mem abort info:n[ 143.695362] ESR = 0x0000000096000004n[ 143.695604] EC = 0x25: DABT (current EL) IL = 32 bitsn[ 143.695889] SET = 0 FnV = 0n[ 143.696077] EA = 0 S1PTW = 0n[ 143.696302] FSC = 0x04: level 0 translation faultn[ 143.702381] Data abort info:n[ 143.702614] ISV = 0 ISS = 0x00000004n[ 143.702832] CM = 0 WnR = 0n[ 143.703087] user pgtable: 4k pages 48-bit VAs pgdp=00000000448f9000n[ 143.703407] [0000000000000000] pgd=0000000000000000 p4d=0000000000000000n[ 143.704137] Internal error: Oops: 0000000096000004 [#1] PREEMPT SMPn[ 143.704714] Modules linked in:n[ 143.705273] CPU: 0 PID: 133 Comm: cat Not tainted 6.2.0-00003-g6fc512c10a7c #3n[ 143.706138] Hardware name: linuxdummy-virt (DT)n[ 143.706723] pstate: 80000005 (Nzcv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)n[ 143.707120] pc : hist_field_name.part.0+0x14/0x140n[ 143.707504] lr : hist_field_name.part.0+0x104/0x140n[ 143.707774] sp : ffff800008333a30n[ 143.707952] x29: ffff800008333a30 x28: 0000000000000001 x27: 0000000000400cc0n[ 143.708429] x26: ffffd7a653b20260 x25: 0000000000000000 x24: ffff10d303ee5800n[ 143.708776] x23: ffffd7a6539b27b0 x22: ffff10d303fb8c00 x21: 0000000000000001n[ 143.709127] x20: ffff10d303ec2000 x19: 0000000000000000 x18: 0000000000000000n[ 143.709478] x17: 0000000000000000 x16: 0000000000000000 x15: 0000000000000000n[ 143.709824] x14: 0000000000000000 x13: 203a6f666e692072 x12: 6567676972742023n[ 143.710179] x11: 0a230a6d6172676f x10: 000000000000002c x9 : ffffd7a6521e018cn[ 143.710584] x8 : 000000000000002c x7 : 7f7f7f7f7f7f7f7f x6 : 000000000000002cn[ 143.710915] x5 : ffff10d303b0103e x4 : ffffd7a653b20261 x3 : 000000000000003dn[ 143.711239] x2 : 0000000000020001 x1 : 0000000000000001 x0 : 0000000000000000n[ 143.711746] Call trace:n[ 143.712115] hist_field_name.part.0+0x14/0x140n[ 143.712642] hist_field_name.part.0+0x104/0x140n[ 143.712925] hist_field_print+0x28/0x140n[ 143.713125] event_hist_trigger_print+0x174/0x4d0n[ 143.713348] hist_show+0xf8/0x980n[ 143.713521] seq_read_iter+0x1bc/0x4b0n[ 143.713711] seq_read+0x8c/0xc4n[ 143.713876] vfs_read+0xc8/0x2a4n[ 143.714043] ksys_read+0x70/0xfcn[ 143.714218] __arm64_sys_read+0x24/0x30n[ 143.714400] invoke_syscall+0x50/0x120n[ 143.714587] el0_svc_common.constprop.0+0x4c/0x100n[ 143.714807] do_el0_svc+0x44/0xd0n[ 143.714970] el0_svc+0x2c/0x84n[ 143.715134] el0t_64_sync_handler+0xbc/0x140n[ 143.715334] el0t_64_sync+0x190/0x194n[ 143.715742] Code: a9bd7bfd 910003fd a90153f3 aa0003f3 (f9400000)n[ 143.716510] ---[ end trace 0000000000000000 ]---nSegmentation fault,CVE-2023-53093,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnpowerpc/iommu: fix memory leak with using debugfs_lookup()nnWhen calling debugfs_lookup() the result must have dput() called on itnotherwise the memory will leak over time. To make things simpler justncall debugfs_lookup_and_remove() instead which handles all of the logicnat once.,CVE-2023-53097,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbonding: restore bond's IFF_SLAVE flag if a non-eth dev enslave failsnnsyzbot reported a warning[1] where the bond device itself is a slave andnwe try to enslave a non-ethernet device as the first slave which failsnbut then in the error path when ether_setup() restores the bond devicenit also clears all flags. In my previous fix[2] I restored thenIFF_MASTER flag but I didn't consider the case that the bond devicenitself might also be a slave with IFF_SLAVE set so we need to restorenthat flag as well. Use the bond_ether_setup helper which does the rightnthing and restores the bond's flags properly.nnSteps to reproduce using a nlmon dev:n $ ip l add nlmon0 type nlmonn $ ip l add bond1 type bondn $ ip l add bond2 type bondn $ ip l set bond1 master bond2n $ ip l set dev nlmon0 master bond1n $ ip -d l sh dev bond1n 22: bond1: <BROADCASTMULTICASTMASTER> mtu 1500 qdisc noqueue master bond2 state DOWN mode DEFAULT group default qlen 1000n (now bond1's IFF_SLAVE flag is gone and we'll hit a warning[3] if wen try to delete it)nn[1] https://syzkaller.appspot.com/bug?id=391c7b1f6522182899efba27d891f1743e8eb3efn[2] commit 7d5cd2ce5292 (bonding: correctly handle bonding type change on enslave failure)n[3] example warning:n [ 27.008664] bond1: (slave nlmon0): The slave device specified does not support setting the MAC addressn [ 27.008692] bond1: (slave nlmon0): Error -95 calling set_mac_addressn [ 32.464639] bond1 (unregistering): Released all slavesn [ 32.464685] ------------[ cut here ]------------n [ 32.464686] WARNING: CPU: 1 PID: 2004 at net/core/dev.c:10829 unregister_netdevice_many+0x72a/0x780n [ 32.464694] Modules linked in: br_netfilter bridge bonding virtio_netn [ 32.464699] CPU: 1 PID: 2004 Comm: ip Kdump: loaded Not tainted 5.18.0-rc3+ #47n [ 32.464703] Hardware name: QEMU Standard PC (Q35 + ICH9 2009) BIOS 1.16.1-2.fc37 04/01/2014n [ 32.464704] RIP: 0010:unregister_netdevice_many+0x72a/0x780n [ 32.464707] Code: 99 fd ff ff ba 90 1a 00 00 48 c7 c6 f4 02 66 96 48 c7 c7 20 4d 35 96 c6 05 fa c7 2b 02 01 e8 be 6f 4a 00 0f 0b e9 73 fd ff ff <0f> 0b e9 5f fd ff ff 80 3d e3 c7 2b 02 00 0f 85 3b fd ff ff ba 59n [ 32.464710] RSP: 0018:ffffa006422d7820 EFLAGS: 00010206n [ 32.464712] RAX: ffff8f6e077140a0 RBX: ffffa006422d7888 RCX: 0000000000000000n [ 32.464714] RDX: ffff8f6e12edbe58 RSI: 0000000000000296 RDI: ffffffff96d4a520n [ 32.464716] RBP: ffff8f6e07714000 R08: ffffffff96d63600 R09: ffffa006422d7728n [ 32.464717] R10: 0000000000000ec0 R11: ffffffff9698c988 R12: ffff8f6e12edb140n [ 32.464719] R13: dead000000000122 R14: dead000000000100 R15: ffff8f6e12edb140n [ 32.464723] FS: 00007f297c2f1740(0000) GS:ffff8f6e5d900000(0000) knlGS:0000000000000000n [ 32.464725] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033n [ 32.464726] CR2: 00007f297bf1c800 CR3: 00000000115e8000 CR4: 0000000000350ee0n [ 32.464730] Call Trace:n [ 32.464763] <TASK>n [ 32.464767] rtnl_dellink+0x13e/0x380n [ 32.464776] ? cred_has_capability.isra.0+0x68/0x100n [ 32.464780] ? __rtnl_unlock+0x33/0x60n [ 32.464783] ? bpf_lsm_capset+0x10/0x10n [ 32.464786] ? security_capable+0x36/0x50n [ 32.464790] rtnetlink_rcv_msg+0x14e/0x3b0n [ 32.464792] ? _copy_to_iter+0xb1/0x790n [ 32.464796] ? post_alloc_hook+0xa0/0x160n [ 32.464799] ? rtnl_calcit.isra.0+0x110/0x110n [ 32.464802] netlink_rcv_skb+0x50/0xf0n [ 32.464806] netlink_unicast+0x216/0x340n [ 32.464809] netlink_sendmsg+0x23f/0x480n [ 32.464812] sock_sendmsg+0x5e/0x60n [ 32.464815] ____sys_sendmsg+0x22c/0x270n [ 32.464818] ? import_iovec+0x17/0x20n [ 32.464821] ? sendmsg_copy_msghdr+0x59/0x90n [ 32.464823] ? do_set_pte+0xa0/0xe0n [ 32.464828] ___sys_sendmsg+0x81/0xc0n [ 32.464832] ? mod_objcg_state+0xc6/0x300n [ 32.464835] ? refill_obj_stock+0xa9/0x160n [ 32.464838] ? memcg_slab_free_hook+0x1a5/0x1f0n [ 32.464842] __sys_sendmn---truncated---,CVE-2023-53103,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet/mlx5e: Fix cleanup null-ptr deref on encap locknnDuring module is unloaded while a peer tc flow is still offloadednfirst the peer uplink rep profile is changed to a nic profile and sonneigh encap lock is destroyed. Next during unload the VF reps netdevsnare unregistered which causes the original non-peer tc flow to be deletednwhich deletes the peer flow. The peer flow deletion detaches the encapnentry and try to take the already destroyed encap lock causing thenbelow trace.nnFix this by clearing peer flows during tc eswitch cleanupn(mlx5e_tc_esw_cleanup()).nnRelevant trace:n[ 4316.837128] BUG: kernel NULL pointer dereference address: 00000000000001d8n[ 4316.842239] RIP: 0010:__mutex_lock+0xb5/0xc40n[ 4316.851897] Call Trace:n[ 4316.852481] <TASK>n[ 4316.857214] mlx5e_rep_neigh_entry_release+0x93/0x790 [mlx5_core]n[ 4316.858258] mlx5e_rep_encap_entry_detach+0xa7/0xf0 [mlx5_core]n[ 4316.859134] mlx5e_encap_dealloc+0xa3/0xf0 [mlx5_core]n[ 4316.859867] clean_encap_dests.part.0+0x5c/0xe0 [mlx5_core]n[ 4316.860605] mlx5e_tc_del_fdb_flow+0x32a/0x810 [mlx5_core]n[ 4316.862609] __mlx5e_tc_del_fdb_peer_flow+0x1a2/0x250 [mlx5_core]n[ 4316.863394] mlx5e_tc_del_flow+0x(/0x630 [mlx5_core]n[ 4316.864090] mlx5e_flow_put+0x5f/0x100 [mlx5_core]n[ 4316.864771] mlx5e_delete_flower+0x4de/0xa40 [mlx5_core]n[ 4316.865486] tc_setup_cb_reoffload+0x20/0x80n[ 4316.865905] fl_reoffload+0x47c/0x510 [cls_flower]n[ 4316.869181] tcf_block_playback_offloads+0x91/0x1d0n[ 4316.869649] tcf_block_unbind+0xe7/0x1b0n[ 4316.870049] tcf_block_offload_cmd.isra.0+0x1ee/0x270n[ 4316.879266] tcf_block_offload_unbind+0x61/0xa0n[ 4316.879711] __tcf_block_put+0xa4/0x310,CVE-2023-53105,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnloop: Fix use-after-free issuesnndo_req_filebacked() calls blk_mq_complete_request() synchronously ornasynchronously when using asynchronous I/O unless memory allocation fails.nHence modify loop_handle_cmd() such that it does not dereference 'cmd' norn'rq' after do_req_filebacked() finished unless we are sure that the requestnhas not yet been completed. This patch fixes the following kernel crash:nnUnable to handle kernel NULL pointer dereference at virtual address 0000000000000054nCall trace:n css_put.42938+0x1c/0x1acn loop_process_work+0xc8c/0xfd4n loop_rootcg_workfn+0x24/0x34n process_one_work+0x244/0x558n worker_thread+0x400/0x8fcn kthread+0x16c/0x1e0n ret_from_fork+0x10/0x20,CVE-2023-53111,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbpf sockmap: Fix an infinite loop error when len is 0 in tcp_bpf_recvmsg_parser()nnWhen the buffer length of the recvmsg system call is 0 we got thenflollowing soft lockup problem:nnwatchdog: BUG: soft lockup - CPU#3 stuck for 27s! [a.out:6149]nCPU: 3 PID: 6149 Comm: a.out Kdump: loaded Not tainted 6.2.0+ #30nHardware name: QEMU Standard PC (Q35 + ICH9 2009) BIOS 1.15.0-1 04/01/2014nRIP: 0010:remove_wait_queue+0xb/0xc0nCode: 5e 41 5f c3 cc cc cc cc 0f 1f 80 00 00 00 00 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 f3 0f 1e fa 0f 1f 44 00 00 41 57 <41> 56 41 55 41 54 55 48 89 fd 53 48 89 f3 4c 8d 6b 18 4c 8d 73 20nRSP: 0018:ffff88811b5978b8 EFLAGS: 00000246nRAX: 0000000000000000 RBX: ffff88811a7d3780 RCX: ffffffffb7a4d768nRDX: dffffc0000000000 RSI: ffff88811b597908 RDI: ffff888115408040nRBP: 1ffff110236b2f1b R08: 0000000000000000 R09: ffff88811a7d37e7nR10: ffffed10234fa6fc R11: 0000000000000001 R12: ffff88811179b800nR13: 0000000000000001 R14: ffff88811a7d38a8 R15: ffff88811a7d37e0nFS: 00007f6fb5398740(0000) GS:ffff888237180000(0000) knlGS:0000000000000000nCS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033nCR2: 0000000020000000 CR3: 000000010b6ba002 CR4: 0000000000370ee0nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400nCall Trace:n <TASK>n tcp_msg_wait_data+0x279/0x2f0n tcp_bpf_recvmsg_parser+0x3c6/0x490n inet_recvmsg+0x280/0x290n sock_recvmsg+0xfc/0x120n ____sys_recvmsg+0x160/0x3d0n ___sys_recvmsg+0xf0/0x180n __sys_recvmsg+0xea/0x1a0n do_syscall_64+0x3f/0x90n entry_SYSCALL_64_after_hwframe+0x72/0xdcnnThe logic in tcp_bpf_recvmsg_parser is as follows:nnmsg_bytes_ready:ntcopied = sk_msg_recvmsg(sk psock msg len flags);ntif (!copied) {nttwait data;nttgoto msg_bytes_ready;nt}nnIn this case copied always is 0 the infinite loop occurs.nnAccording to the Linux system call man page 0 should be returned in thisncase. Therefore in tcp_bpf_recvmsg_parser() if the length is 0 directlynreturn. Also modify several other functions with the same problem.,CVE-2023-53133,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,A Marvin vulnerability side-channel leakage was found in the RSA decryption operation in the Linux Kernel. This issue may allow a network attacker to decrypt ciphertexts or forge signatures limiting the services that use that private key.,CVE-2023-6240,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,An out-of-bounds read vulnerability was found in smb2_dump_detail in fs/smb/client/smb2ops.c in the Linux Kernel. This issue could allow a local attacker to crash the system or leak internal kernel information.,CVE-2023-6610,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,A flaw was found in the Linux kernel's memory deduplication mechanism. The max page sharing of Kernel Samepage Merging (KSM) added in Linux kernel version 4.4.0-96.119 can create a side channel. When the attacker and the victim share the same host and the default setting of KSM is max page sharing=256 it is possible for the attacker to time the unmap to merge with the victim's page. The unmapping time depends on whether it merges with the victim's page and additional physical pages are created beyond the KSM's max page share. Through these operations the attacker can leak the victim's page.,CVE-2024-0564,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,Use After Free vulnerability in Linux Linux kernel kernel on Linux x86 ARM (bluetooth modules) allows Local Execution of Code. This vulnerability is associated with program files https://gitee.Com/anolis/cloud-kernel/blob/devel-5.10/net/bluetooth/af_bluetooth.C.nnThis issue affects Linux kernel: from v2.6.12-rc2 before v6.8-rc1.nn,CVE-2024-21803,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,Hardware logic with insecure de-synchronization in Intel(R) DSA and Intel(R) IAA for some Intel(R) 4th or 5th generation Xeon(R) processors may allow an authorized user to potentially enable escalation of privilege local access,CVE-2024-21823,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,A Speculative Race Condition (SRC) vulnerability that impacts modern CPU architectures supporting speculative execution (related to Spectre V1) has been disclosed. An unauthenticated attacker can exploit this vulnerability to disclose arbitrary data from the CPU using race conditions to access the speculative executable code paths.,CVE-2024-2193,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,A cross-privilege Spectre v2 vulnerability allows attackers to bypass all deployed mitigations including the recent Fine(IBT) and to leak arbitrary Linux kernel memory on Intel systems.,CVE-2024-2201,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,Integer Overflow or Wraparound vulnerability in Linux Linux kernel kernel on Linux x86 ARM (md raid raid5 modules) allows Forced Integer Overflow.,CVE-2024-23307,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,A race condition was found in the Linux kernel's scsi device driver in lpfc_unregister_fcf_rescan() function. This can result in a null pointer dereference issue possibly leading to a kernel panic or denial of service issue.nnnnn,CVE-2024-24855,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,A race condition was found in the Linux kernel's media/dvb-core in dvbdmx_write()function. This can result in a null pointer dereference issue possibly leading to a kernel panic or denial of service issue.nnnnn,CVE-2024-24864,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,A memory leak flaw was found in the UBI driver in drivers/mtd/ubi/attach.c in the Linux kernel through 6.7.4 for UBI_IOCATT because kobj->name is not released.,CVE-2024-25740,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel before 6.9 an untrusted hypervisor can inject virtual interrupt 29 (#VC) at any point in time and can trigger its handler. This affects AMD SEV-SNP and AMD SEV-ES.,CVE-2024-25742,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel through 6.9 an untrusted hypervisor can inject virtual interrupts 0 and 14 at any point in time and can trigger the SIGFPE signal handler in userspace applications. This affects AMD SEV-SNP and AMD SEV-ES.,CVE-2024-25743,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nntls: fix race between async notify and socket closennThe submitting thread (one which called recvmsg/sendmsg)nmay exit as soon as the async crypto handler calls complete()nso any code past that point risks touching already freed data.nnTry to avoid the locking and extra flags altogether.nHave the main thread hold an extra reference this waynwe can depend solely on the atomic ref counter fornsynchronization.nnDon't futz with reiniting the completion either we are nowntightly controlling when completion fires.,CVE-2024-26583,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet: tls: handle backlogging of crypto requestsnnSince we're setting the CRYPTO_TFM_REQ_MAY_BACKLOG flag on ournrequests to the crypto API crypto_aead_{encryptdecrypt} can returnn -EBUSY instead of -EINPROGRESS in valid situations. For example whennthe cryptd queue for AESNI is full (easy to trigger with annartificially low cryptd.cryptd_max_cpu_qlen) requests will be enqueuednto the backlog but still processed. In that case the async callbacknwill also be called twice: first with err == -EINPROGRESS which itnseems we can just ignore then with err == 0.nnCompared to Sabrina's original patch this version uses the newntls_*crypt_async_wait() helpers and converts the EBUSY tonEINPROGRESS to avoid having to modify all the error handlingnpaths. The handling is identical.,CVE-2024-26584,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nntls: fix race between tx work scheduling and socket closennSimilarly to previous commit the submitting thread (recvmsg/sendmsg)nmay exit as soon as the async crypto handler calls complete().nReorder scheduling the work before calling complete().nThis seems more logical in the first place as it'snthe inverse order of what the submitting thread will do.,CVE-2024-26585,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbpf: Reject variable offset alu on PTR_TO_FLOW_KEYSnnFor PTR_TO_FLOW_KEYS check_flow_keys_access() only uses fixed offnfor validation. However variable offset ptr alu is not prohibitednfor this ptr kind. So the variable offset is not checked.nnThe following prog is accepted:nn func#0 @0n 0: R1=ctx() R10=fp0n 0: (bf) r6 = r1 ; R1=ctx() R6_w=ctx()n 1: (79) r7 = *(u64 *)(r6 +144) ; R6_w=ctx() R7_w=flow_keys()n 2: (b7) r8 = 1024 ; R8_w=1024n 3: (37) r8 /= 1 ; R8_w=scalar()n 4: (57) r8 &= 1024 ; R8_w=scalar(smin=smin32=0n smax=umax=smax32=umax32=1024var_off=(0x0; 0x400))n 5: (0f) r7 += r8n mark_precise: frame0: last_idx 5 first_idx 0 subseq_idx -1n mark_precise: frame0: regs=r8 stack= before 4: (57) r8 &= 1024n mark_precise: frame0: regs=r8 stack= before 3: (37) r8 /= 1n mark_precise: frame0: regs=r8 stack= before 2: (b7) r8 = 1024n 6: R7_w=flow_keys(smin=smin32=0smax=umax=smax32=umax32=1024var_offn =(0x0; 0x400)) R8_w=scalar(smin=smin32=0smax=umax=smax32=umax32=1024n var_off=(0x0; 0x400))n 6: (79) r0 = *(u64 *)(r7 +0) ; R0_w=scalar()n 7: (95) exitnnThis prog loads flow_keys to r7 and adds the variable offset r8nto r7 and finally causes out-of-bounds access:nn BUG: unable to handle page fault for address: ffffc90014c80038n [...]n Call Trace:n <TASK>n bpf_dispatcher_nop_func include/linux/bpf.h:1231 [inline]n __bpf_prog_run include/linux/filter.h:651 [inline]n bpf_prog_run include/linux/filter.h:658 [inline]n bpf_prog_run_pin_on_cpu include/linux/filter.h:675 [inline]n bpf_flow_dissect+0x15f/0x350 net/core/flow_dissector.c:991n bpf_prog_test_run_flow_dissector+0x39d/0x620 net/bpf/test_run.c:1359n bpf_prog_test_run kernel/bpf/syscall.c:4107 [inline]n __sys_bpf+0xf8f/0x4560 kernel/bpf/syscall.c:5475n __do_sys_bpf kernel/bpf/syscall.c:5561 [inline]n __se_sys_bpf kernel/bpf/syscall.c:5559 [inline]n __x64_sys_bpf+0x73/0xb0 kernel/bpf/syscall.c:5559n do_syscall_x64 arch/x86/entry/common.c:52 [inline]n do_syscall_64+0x3f/0x110 arch/x86/entry/common.c:83n entry_SYSCALL_64_after_hwframe+0x63/0x6bnnFix this by rejecting ptr alu with variable offset on flow_keys.nApplying the patch rejects the program with R7 pointer arithmeticnon flow_keys prohibited.,CVE-2024-26589,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnmlxsw: spectrum_acl_tcam: Fix NULL pointer dereference in error pathnnWhen calling mlxsw_sp_acl_tcam_region_destroy() from an error path afternfailing to attach the region to an ACL group we hit a NULL pointerndereference upon 'region->group->tcam' [1].nnFix by retrieving the 'tcam' pointer using mlxsw_sp_acl_to_tcam().nn[1]nBUG: kernel NULL pointer dereference address: 0000000000000000n[...]nRIP: 0010:mlxsw_sp_acl_tcam_region_destroy+0xa0/0xd0n[...]nCall Trace:n mlxsw_sp_acl_tcam_vchunk_get+0x88b/0xa20n mlxsw_sp_acl_tcam_ventry_add+0x25/0xe0n mlxsw_sp_acl_rule_add+0x47/0x240n mlxsw_sp_flower_replace+0x1a9/0x1d0n tc_setup_cb_add+0xdc/0x1c0n fl_hw_replace_filter+0x146/0x1f0n fl_change+0xc17/0x1360n tc_new_tfilter+0x472/0xb90n rtnetlink_rcv_msg+0x313/0x3b0n netlink_rcv_skb+0x58/0x100n netlink_unicast+0x244/0x390n netlink_sendmsg+0x1e4/0x440n ____sys_sendmsg+0x164/0x260n ___sys_sendmsg+0x9a/0xe0n __sys_sendmsg+0x7a/0xc0n do_syscall_64+0x40/0xe0n entry_SYSCALL_64_after_hwframe+0x63/0x6b,CVE-2024-26595,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/bridge: sii902x: Fix probing race issuennA null pointer dereference crash has been observed rarely on TInplatforms using sii9022 bridge:nn[ 53.271356] sii902x_get_edid+0x34/0x70 [sii902x]n[ 53.276066] sii902x_bridge_get_edid+0x14/0x20 [sii902x]n[ 53.281381] drm_bridge_get_edid+0x20/0x34 [drm]n[ 53.286305] drm_bridge_connector_get_modes+0x8c/0xcc [drm_kms_helper]n[ 53.292955] drm_helper_probe_single_connector_modes+0x190/0x538 [drm_kms_helper]n[ 53.300510] drm_client_modeset_probe+0x1f0/0xbd4 [drm]n[ 53.305958] __drm_fb_helper_initial_config_and_unlock+0x50/0x510 [drm_kms_helper]n[ 53.313611] drm_fb_helper_initial_config+0x48/0x58 [drm_kms_helper]n[ 53.320039] drm_fbdev_dma_client_hotplug+0x84/0xd4 [drm_dma_helper]n[ 53.326401] drm_client_register+0x5c/0xa0 [drm]n[ 53.331216] drm_fbdev_dma_setup+0xc8/0x13c [drm_dma_helper]n[ 53.336881] tidss_probe+0x128/0x264 [tidss]n[ 53.341174] platform_probe+0x68/0xc4n[ 53.344841] really_probe+0x188/0x3c4n[ 53.348501] __driver_probe_device+0x7c/0x16cn[ 53.352854] driver_probe_device+0x3c/0x10cn[ 53.357033] __device_attach_driver+0xbc/0x158n[ 53.361472] bus_for_each_drv+0x88/0xe8n[ 53.365303] __device_attach+0xa0/0x1b4n[ 53.369135] device_initial_probe+0x14/0x20n[ 53.373314] bus_probe_device+0xb0/0xb4n[ 53.377145] deferred_probe_work_func+0xcc/0x124n[ 53.381757] process_one_work+0x1f0/0x518n[ 53.385770] worker_thread+0x1e8/0x3dcn[ 53.389519] kthread+0x11c/0x120n[ 53.392750] ret_from_fork+0x10/0x20nnThe issue here is as follows:nn- tidss probes but is deferred as sii902x is still missing.n- sii902x starts probing and enters sii902x_init().n- sii902x calls drm_bridge_add(). Now the sii902x bridge is ready fromn DRM's perspective.n- sii902x calls sii902x_audio_codec_init() andn platform_device_register_data()n- The registration of the audio platform device causes probing of then deferred devices.n- tidss probes which eventually causes sii902x_bridge_get_edid() to ben called.n- sii902x_bridge_get_edid() tries to use the i2c to read the edid.n However the sii902x driver has not set up the i2c part yet leadingn to the crash.nnFix this by moving the drm_bridge_add() to the end of thensii902x_init() which is also at the very end of sii902x_probe().,CVE-2024-26607,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnthermal: intel: hfi: Add syscore callbacks for system-wide PMnnThe kernel allocates a memory buffer and provides its location to thenhardware which uses it to update the HFI table. This allocation occursnduring boot and remains constant throughout runtime.nnWhen resuming from hibernation the restore kernel allocates a secondnmemory buffer and reprograms the HFI hardware with the new location asnpart of a normal boot. The location of the second memory buffer mayndiffer from the one allocated by the image kernel.nnWhen the restore kernel transfers control to the image kernel its HFInbuffer becomes invalid potentially leading to memory corruption if thenhardware writes to it (the hardware continues to use the buffer from thenrestore kernel).nnIt is also possible that the hardware forgets the address of the memorynbuffer when resuming from deep suspend. Memory corruption may also occurnin such a scenario.nnTo prevent the described memory corruption disable HFI when preparing tonsuspend or hibernate. Enable it when resuming.nnAdd syscore callbacks to handle the package of the boot CPU (packages ofnnon-boot CPUs are handled via CPU offline). Syscore ops always run on thenboot CPU. Additionally HFI only needs to be disabled during deep suspendnand hibernation. Syscore ops only run in these cases.nn[ rjw: Comment adjustment subject and changelog edits ],CVE-2024-26646,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Fix late derefrence 'dsc' check in 'link_set_dsc_pps_packet()'nnIn link_set_dsc_pps_packet() 'struct display_stream_compressor *dsc'nwas dereferenced in a DC_LOGGER_INIT(dsc->ctx->logger); before the 'dsc'nNULL pointer check.nnFixes the below:ndrivers/gpu/drm/amd/amdgpu/../display/dc/link/link_dpms.c:905 link_set_dsc_pps_packet() warn: variable dereferenced before check 'dsc' (see line 903),CVE-2024-26647,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Fix variable deferencing before NULL check in edp_setup_replay()nnIn edp_setup_replay() 'struct dc *dc' & 'struct dmub_replay *replay'nwas dereferenced before the pointer 'link' & 'replay' NULL check.nnFixes the below:ndrivers/gpu/drm/amd/amdgpu/../display/dc/link/protocols/link_edp_panel_control.c:947 edp_setup_replay() warn: variable dereferenced before check 'link' (see line 933),CVE-2024-26648,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amdgpu: fix use-after-free bugnnThe bug can be triggered by sending a single amdgpu_gem_userptr_ioctlnto the AMDGPU DRM driver on any ASICs with an invalid address and size.nThe bug was reported by Joonkyo Jung <joonkyoj@yonsei.ac.kr>.nFor example the following code:nnstatic void Syzkaller1(int fd)n{ntstruct drm_amdgpu_gem_userptr arg;ntint ret;nntarg.addr = 0xffffffffffff0000;ntarg.size = 0x80000000; /*2 Gb*/ntarg.flags = 0x7;ntret = drmIoctl(fd 0xc1186451/*amdgpu_gem_userptr_ioctl*/ &arg);n}nnDue to the address and size are not valid there is a failure innamdgpu_hmm_register->mmu_interval_notifier_insert->__mmu_interval_notifier_insert->ncheck_shl_overflow but we even the amdgpu_hmm_register failure we still callnamdgpu_hmm_unregister into amdgpu_gem_object_free which causes access to a bad address.nThe following stack is below when the issue is reproduced when Kazan is enabled:nn[ +0.000014] Hardware name: ASUS System Product Name/ROG STRIX B550-F GAMING (WI-FI) BIOS 1401 12/03/2020n[ +0.000009] RIP: 0010:mmu_interval_notifier_remove+0x327/0x340n[ +0.000017] Code: ff ff 49 89 44 24 08 48 b8 00 01 00 00 00 00 ad de 4c 89 f7 49 89 47 40 48 83 c0 22 49 89 47 48 e8 ce d1 2d 01 e9 32 ff ff ff <0f> 0b e9 16 ff ff ff 4c 89 ef e8 fa 14 b3 ff e9 36 ff ff ff e8 80n[ +0.000014] RSP: 0018:ffffc90002657988 EFLAGS: 00010246n[ +0.000013] RAX: 0000000000000000 RBX: 1ffff920004caf35 RCX: ffffffff8160565bn[ +0.000011] RDX: dffffc0000000000 RSI: 0000000000000004 RDI: ffff8881a9f78260n[ +0.000010] RBP: ffffc90002657a70 R08: 0000000000000001 R09: fffff520004caf25n[ +0.000010] R10: 0000000000000003 R11: ffffffff8161d1d6 R12: ffff88810e988c00n[ +0.000010] R13: ffff888126fb5a00 R14: ffff88810e988c0c R15: ffff8881a9f78260n[ +0.000011] FS: 00007ff9ec848540(0000) GS:ffff8883cc880000(0000) knlGS:0000000000000000n[ +0.000012] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033n[ +0.000010] CR2: 000055b3f7e14328 CR3: 00000001b5770000 CR4: 0000000000350ef0n[ +0.000010] Call Trace:n[ +0.000006] <TASK>n[ +0.000007] ? show_regs+0x6a/0x80n[ +0.000018] ? __warn+0xa5/0x1b0n[ +0.000019] ? mmu_interval_notifier_remove+0x327/0x340n[ +0.000018] ? report_bug+0x24a/0x290n[ +0.000022] ? handle_bug+0x46/0x90n[ +0.000015] ? exc_invalid_op+0x19/0x50n[ +0.000016] ? asm_exc_invalid_op+0x1b/0x20n[ +0.000017] ? kasan_save_stack+0x26/0x50n[ +0.000017] ? mmu_interval_notifier_remove+0x23b/0x340n[ +0.000019] ? mmu_interval_notifier_remove+0x327/0x340n[ +0.000019] ? mmu_interval_notifier_remove+0x23b/0x340n[ +0.000020] ? __pfx_mmu_interval_notifier_remove+0x10/0x10n[ +0.000017] ? kasan_save_alloc_info+0x1e/0x30n[ +0.000018] ? srso_return_thunk+0x5/0x5fn[ +0.000014] ? __kasan_kmalloc+0xb1/0xc0n[ +0.000018] ? srso_return_thunk+0x5/0x5fn[ +0.000013] ? __kasan_check_read+0x11/0x20n[ +0.000020] amdgpu_hmm_unregister+0x34/0x50 [amdgpu]n[ +0.004695] amdgpu_gem_object_free+0x66/0xa0 [amdgpu]n[ +0.004534] ? __pfx_amdgpu_gem_object_free+0x10/0x10 [amdgpu]n[ +0.004291] ? do_syscall_64+0x5f/0xe0n[ +0.000023] ? srso_return_thunk+0x5/0x5fn[ +0.000017] drm_gem_object_free+0x3b/0x50 [drm]n[ +0.000489] amdgpu_gem_userptr_ioctl+0x306/0x500 [amdgpu]n[ +0.004295] ? __pfx_amdgpu_gem_userptr_ioctl+0x10/0x10 [amdgpu]n[ +0.004270] ? srso_return_thunk+0x5/0x5fn[ +0.000014] ? __this_cpu_preempt_check+0x13/0x20n[ +0.000015] ? srso_return_thunk+0x5/0x5fn[ +0.000013] ? sysvec_apic_timer_interrupt+0x57/0xc0n[ +0.000020] ? srso_return_thunk+0x5/0x5fn[ +0.000014] ? asm_sysvec_apic_timer_interrupt+0x1b/0x20n[ +0.000022] ? drm_ioctl_kernel+0x17b/0x1f0 [drm]n[ +0.000496] ? __pfx_amdgpu_gem_userptr_ioctl+0x10/0x10 [amdgpu]n[ +0.004272] ? drm_ioctl_kernel+0x190/0x1f0 [drm]n[ +0.000492] drm_ioctl_kernel+0x140/0x1f0 [drm]n[ +0.000497] ? __pfx_amdgpu_gem_userptr_ioctl+0x10/0x10 [amdgpu]n[ +0.004297] ? __pfx_drm_ioctl_kernel+0x10/0x10 [dn---truncated---,CVE-2024-26656,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Add NULL test for 'timing generator' in 'dcn21_set_pipe()'nnIn u32 otg_inst = pipe_ctx->stream_res.tg->inst;npipe_ctx->stream_res.tg could be NULL it is relying on the caller tonensure the tg is not NULL.,CVE-2024-26661,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Fix 'panel_cntl' could be null in 'dcn21_set_backlight_level()'nn'panel_cntl' structure used to control the display panel could be nullndereferencing it could lead to a null pointer access.nnFixes the below:ndrivers/gpu/drm/amd/amdgpu/../display/dc/hwss/dcn21/dcn21_hwseq.c:269 dcn21_set_backlight_level() error: we previously assumed 'panel_cntl' could be null (see line 250),CVE-2024-26662,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnetfilter: nft_limit: reject configurations that cause integer overflownnReject bogus configs where internal token counter wraps around.nThis only occurs with very very large requests such as 17gbyte/s.nnIts better to reject this rather than having incorrect ratelimit.,CVE-2024-26668,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet/sched: flower: Fix chain template offloadnnWhen a qdisc is deleted from a net device the stack instructs thenunderlying driver to remove its flow offload callback from thenassociated filter block using the 'FLOW_BLOCK_UNBIND' command. The stacknthen continues to replay the removal of the filters in the block fornthis driver by iterating over the chains in the block and invoking then'reoffload' operation of the classifier being used. In turn thenclassifier in its 'reoffload' operation prepares and emits an'FLOW_CLS_DESTROY' command for each filter.nnHowever the stack does not do the same for chain templates and thenunderlying driver never receives a 'FLOW_CLS_TMPLT_DESTROY' command whenna qdisc is deleted. This results in a memory leak [1] which can benreproduced using [2].nnFix by introducing a 'tmplt_reoffload' operation and have the stackninvoke it with the appropriate arguments as part of the replay.nImplement the operation in the sole classifier that supports chainntemplates (flower) by emitting the 'FLOW_CLS_TMPLT_{CREATEDESTROY}'ncommand based on whether a flow offload callback is being bound to anfilter block or being unbound from one.nnAs far as I can tell the issue happens since cited commit whichnreordered tcf_block_offload_unbind() before tcf_block_flush_all_chains()nin __tcf_block_put(). The order cannot be reversed as the filter blocknis expected to be freed after flushing all the chains.nn[1]nunreferenced object 0xffff888107e28800 (size 2048):n comm tc pid 1079 jiffies 4294958525 (age 3074.287s)n hex dump (first 32 bytes):n b1 a6 7c 11 81 88 ff ff e0 5b b3 10 81 88 ff ff ..|......[......n 01 00 00 00 00 00 00 00 e0 aa b0 84 ff ff ff ff ................n backtrace:n [<ffffffff81c06a68>] __kmem_cache_alloc_node+0x1e8/0x320n [<ffffffff81ab374e>] __kmalloc+0x4e/0x90n [<ffffffff832aec6d>] mlxsw_sp_acl_ruleset_get+0x34d/0x7a0n [<ffffffff832bc195>] mlxsw_sp_flower_tmplt_create+0x145/0x180n [<ffffffff832b2e1a>] mlxsw_sp_flow_block_cb+0x1ea/0x280n [<ffffffff83a10613>] tc_setup_cb_call+0x183/0x340n [<ffffffff83a9f85a>] fl_tmplt_create+0x3da/0x4c0n [<ffffffff83a22435>] tc_ctl_chain+0xa15/0x1170n [<ffffffff838a863c>] rtnetlink_rcv_msg+0x3cc/0xed0n [<ffffffff83ac87f0>] netlink_rcv_skb+0x170/0x440n [<ffffffff83ac6270>] netlink_unicast+0x540/0x820n [<ffffffff83ac6e28>] netlink_sendmsg+0x8d8/0xda0n [<ffffffff83793def>] ____sys_sendmsg+0x30f/0xa80n [<ffffffff8379d29a>] ___sys_sendmsg+0x13a/0x1e0n [<ffffffff8379d50c>] __sys_sendmsg+0x11c/0x1f0n [<ffffffff843b9ce0>] do_syscall_64+0x40/0xe0nunreferenced object 0xffff88816d2c0400 (size 1024):n comm tc pid 1079 jiffies 4294958525 (age 3074.287s)n hex dump (first 32 bytes):n 40 00 00 00 00 00 00 00 57 f6 38 be 00 00 00 00 @.......W.8.....n 10 04 2c 6d 81 88 ff ff 10 04 2c 6d 81 88 ff ff ..m......m....n backtrace:n [<ffffffff81c06a68>] __kmem_cache_alloc_node+0x1e8/0x320n [<ffffffff81ab36c1>] __kmalloc_node+0x51/0x90n [<ffffffff81a8ed96>] kvmalloc_node+0xa6/0x1f0n [<ffffffff82827d03>] bucket_table_alloc.isra.0+0x83/0x460n [<ffffffff82828d2b>] rhashtable_init+0x43b/0x7c0n [<ffffffff832aed48>] mlxsw_sp_acl_ruleset_get+0x428/0x7a0n [<ffffffff832bc195>] mlxsw_sp_flower_tmplt_create+0x145/0x180n [<ffffffff832b2e1a>] mlxsw_sp_flow_block_cb+0x1ea/0x280n [<ffffffff83a10613>] tc_setup_cb_call+0x183/0x340n [<ffffffff83a9f85a>] fl_tmplt_create+0x3da/0x4c0n [<ffffffff83a22435>] tc_ctl_chain+0xa15/0x1170n [<ffffffff838a863c>] rtnetlink_rcv_msg+0x3cc/0xed0n [<ffffffff83ac87f0>] netlink_rcv_skb+0x170/0x440n [<ffffffff83ac6270>] netlink_unicast+0x540/0x820n [<ffffffff83ac6e28>] netlink_sendmsg+0x8d8/0xda0n [<ffffffff83793def>] ____sys_sendmsg+0x30f/0xa80nn[2]n # tc qdisc add dev swp1 clsactn # tc chain add dev swp1 ingress proto ip chain 1 flower dst_ip 0.0.0.0/32n # tc qdisc del devn---truncated---,CVE-2024-26669,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amdgpu: Fix variable 'mca_funcs' dereferenced before NULL check in 'amdgpu_mca_smu_get_mca_entry()'nnFixes the below:nndrivers/gpu/drm/amd/amdgpu/amdgpu_mca.c:377 amdgpu_mca_smu_get_mca_entry() warn: variable dereferenced before check 'mca_funcs' (see line 368)nn357 int amdgpu_mca_smu_get_mca_entry(struct amdgpu_device *adevntttt enum amdgpu_mca_error_type typen358 int idx struct mca_bank_entry *entry)n359 {n360 const struct amdgpu_mca_smu_funcs *mca_funcs =nttttttadev->mca.mca_funcs;n361 int count;n362n363 switch (type) {n364 case AMDGPU_MCA_ERROR_TYPE_UE:n365 count = mca_funcs->max_ue_count;nnmca_funcs is dereferenced here.nn366 break;n367 case AMDGPU_MCA_ERROR_TYPE_CE:n368 count = mca_funcs->max_ce_count;nnmca_funcs is dereferenced here.nn369 break;n370 default:n371 return -EINVAL;n372 }n373n374 if (idx >= count)n375 return -EINVAL;n376n377 if (mca_funcs && mca_funcs->mca_get_mca_entry)nt ^^^^^^^^^nnChecked too late!,CVE-2024-26672,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnrxrpc: Fix delayed ACKs to not set the reference serial numbernnFix the construction of delayed ACKs to not set the reference serial numbernas they can't be used as an RTT reference.,CVE-2024-26677,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet: atlantic: Fix DMA mapping for PTP hwts ringnnFunction aq_ring_hwts_rx_alloc() maps extra AQ_CFG_RXDS_DEF bytesnfor PTP HWTS ring but then generic aq_ring_free() does not take thisninto account.nCreate and use a specific function to free HWTS ring to fix thisnissue.nnTrace:n[ 215.351607] ------------[ cut here ]------------n[ 215.351612] DMA-API: atlantic 0000:4b:00.0: device driver frees DMA memory with different size [device address=0x00000000fbdd0000] [map size=34816 bytes] [unmap size=32768 bytes]n[ 215.351635] WARNING: CPU: 33 PID: 10759 at kernel/dma/debug.c:988 check_unmap+0xa6f/0x2360n...n[ 215.581176] Call Trace:n[ 215.583632] <TASK>n[ 215.585745] ? show_trace_log_lvl+0x1c4/0x2dfn[ 215.590114] ? show_trace_log_lvl+0x1c4/0x2dfn[ 215.594497] ? debug_dma_free_coherent+0x196/0x210n[ 215.599305] ? check_unmap+0xa6f/0x2360n[ 215.603147] ? __warn+0xca/0x1d0n[ 215.606391] ? check_unmap+0xa6f/0x2360n[ 215.610237] ? report_bug+0x1ef/0x370n[ 215.613921] ? handle_bug+0x3c/0x70n[ 215.617423] ? exc_invalid_op+0x14/0x50n[ 215.621269] ? asm_exc_invalid_op+0x16/0x20n[ 215.625480] ? check_unmap+0xa6f/0x2360n[ 215.629331] ? mark_lock.part.0+0xca/0xa40n[ 215.633445] debug_dma_free_coherent+0x196/0x210n[ 215.638079] ? __pfx_debug_dma_free_coherent+0x10/0x10n[ 215.643242] ? slab_free_freelist_hook+0x11d/0x1d0n[ 215.648060] dma_free_attrs+0x6d/0x130n[ 215.651834] aq_ring_free+0x193/0x290 [atlantic]n[ 215.656487] aq_ptp_ring_free+0x67/0x110 [atlantic]n...n[ 216.127540] ---[ end trace 6467e5964dd2640b ]---n[ 216.132160] DMA-API: Mapped at:n[ 216.132162] debug_dma_alloc_coherent+0x66/0x2f0n[ 216.132165] dma_alloc_attrs+0xf5/0x1b0n[ 216.132168] aq_ring_hwts_rx_alloc+0x150/0x1f0 [atlantic]n[ 216.132193] aq_ptp_ring_alloc+0x1bb/0x540 [atlantic]n[ 216.132213] aq_nic_init+0x4a1/0x760 [atlantic],CVE-2024-26680,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnfs/proc: do_task_stat: use sig->stats_lock to gather the threads/children statsnnlock_task_sighand() can trigger a hard lockup. If NR_CPUS threads callndo_task_stat() at the same time and the process has NR_THREADS it willnspin with irqs disabled O(NR_CPUS output.log scan_tyk_dockerimages.sh vulnerabilities.csv NR_THREADS) time.nnChange do_task_stat() to use sig->stats_lock to gather the statisticsnoutside of ->siglock protected section in the likely case this code willnrun lockless.,CVE-2024-26686,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnKVM: arm64: Fix circular locking dependencynnThe rule inside kvm enforces that the vcpu->mutex is taken *inside*nkvm->lock. The rule is violated by the pkvm_create_hyp_vm() which acquiresnthe kvm->lock while already holding the vcpu->mutex lock fromnkvm_vcpu_ioctl(). Avoid the circular locking dependency altogether bynprotecting the hyp vm handle with the config_lock much like we alreadyndo for other forms of VM-scoped data.,CVE-2024-26691,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Fix MST Null Ptr for RVnnThe change try to fix below error specific to RV platform:nnBUG: kernel NULL pointer dereference address: 0000000000000008nPGD 0 P4D 0nOops: 0000 [#1] PREEMPT SMP NOPTInCPU: 4 PID: 917 Comm: sway Not tainted 6.3.9-arch1-1 #1 124dc55df4f5272ccb409f39ef4872fc2b3376a2nHardware name: LENOVO 20NKS01Y00/20NKS01Y00 BIOS R12ET61W(1.31 ) 07/28/2022nRIP: 0010:drm_dp_atomic_find_time_slots+0x5e/0x260 [drm_display_helper]nCode: 01 00 00 48 8b 85 60 05 00 00 48 63 80 88 00 00 00 3b 43 28 0f 8d 2e 01 00 00 48 8b 53 30 48 8d 04 80 48 8d 04 c2 48 8b 40 18 <48> 8>nRSP: 0018:ffff960cc2df77d8 EFLAGS: 00010293nRAX: 0000000000000000 RBX: ffff8afb87e81280 RCX: 0000000000000224nRDX: ffff8afb9ee37c00 RSI: ffff8afb8da1a578 RDI: ffff8afb87e81280nRBP: ffff8afb83d67000 R08: 0000000000000001 R09: ffff8afb9652f850nR10: ffff960cc2df7908 R11: 0000000000000002 R12: 0000000000000000nR13: ffff8afb8d7688a0 R14: ffff8afb8da1a578 R15: 0000000000000224nFS: 00007f4dac35ce00(0000) GS:ffff8afe30b00000(0000) knlGS:0000000000000000nCS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033nCR2: 0000000000000008 CR3: 000000010ddc6000 CR4: 00000000003506e0nCall Trace:n <TASK>n ? __die+0x23/0x70n ? page_fault_oops+0x171/0x4e0n ? plist_add+0xbe/0x100n ? exc_page_fault+0x7c/0x180n ? asm_exc_page_fault+0x26/0x30n ? drm_dp_atomic_find_time_slots+0x5e/0x260 [drm_display_helper 0e67723696438d8e02b741593dd50d80b44c2026]n ? drm_dp_atomic_find_time_slots+0x28/0x260 [drm_display_helper 0e67723696438d8e02b741593dd50d80b44c2026]n compute_mst_dsc_configs_for_link+0x2ff/0xa40 [amdgpu 62e600d2a75e9158e1cd0a243bdc8e6da040c054]n ? fill_plane_buffer_attributes+0x419/0x510 [amdgpu 62e600d2a75e9158e1cd0a243bdc8e6da040c054]n compute_mst_dsc_configs_for_state+0x1e1/0x250 [amdgpu 62e600d2a75e9158e1cd0a243bdc8e6da040c054]n amdgpu_dm_atomic_check+0xecd/0x1190 [amdgpu 62e600d2a75e9158e1cd0a243bdc8e6da040c054]n drm_atomic_check_only+0x5c5/0xa40n drm_mode_atomic_ioctl+0x76e/0xbc0n ? _copy_to_user+0x25/0x30n ? drm_ioctl+0x296/0x4b0n ? __pfx_drm_mode_atomic_ioctl+0x10/0x10n drm_ioctl_kernel+0xcd/0x170n drm_ioctl+0x26d/0x4b0n ? __pfx_drm_mode_atomic_ioctl+0x10/0x10n amdgpu_drm_ioctl+0x4e/0x90 [amdgpu 62e600d2a75e9158e1cd0a243bdc8e6da040c054]n __x64_sys_ioctl+0x94/0xd0n do_syscall_64+0x60/0x90n ? do_syscall_64+0x6c/0x90n entry_SYSCALL_64_after_hwframe+0x72/0xdcnRIP: 0033:0x7f4dad17f76fnCode: 00 48 89 44 24 18 31 c0 48 8d 44 24 60 c7 04 24 10 00 00 00 48 89 44 24 08 48 8d 44 24 20 48 89 44 24 10 b8 10 00 00 00 0f 05 <89> c>nRSP: 002b:00007ffd9ae859f0 EFLAGS: 00000246 ORIG_RAX: 0000000000000010nRAX: ffffffffffffffda RBX: 000055e255a55900 RCX: 00007f4dad17f76fnRDX: 00007ffd9ae85a90 RSI: 00000000c03864bc RDI: 000000000000000bnRBP: 00007ffd9ae85a90 R08: 0000000000000003 R09: 0000000000000003nR10: 0000000000000000 R11: 0000000000000246 R12: 00000000c03864bcnR13: 000000000000000b R14: 000055e255a7fc60 R15: 000055e255a01eb0n </TASK>nModules linked in: rfcomm snd_seq_dummy snd_hrtimer snd_seq snd_seq_device ccm cmac algif_hash algif_skcipher af_alg joydev mousedev bnep >n typec libphy k10temp ipmi_msghandler roles i2c_scmi acpi_cpufreq mac_hid nft_reject_inet nf_reject_ipv4 nf_reject_ipv6 nft_reject nft_mas>nCR2: 0000000000000008n---[ end trace 0000000000000000 ]---nRIP: 0010:drm_dp_atomic_find_time_slots+0x5e/0x260 [drm_display_helper]nCode: 01 00 00 48 8b 85 60 05 00 00 48 63 80 88 00 00 00 3b 43 28 0f 8d 2e 01 00 00 48 8b 53 30 48 8d 04 80 48 8d 04 c2 48 8b 40 18 <48> 8>nRSP: 0018:ffff960cc2df77d8 EFLAGS: 00010293nRAX: 0000000000000000 RBX: ffff8afb87e81280 RCX: 0000000000000224nRDX: ffff8afb9ee37c00 RSI: ffff8afb8da1a578 RDI: ffff8afb87e81280nRBP: ffff8afb83d67000 R08: 0000000000000001 R09: ffff8afb9652f850nR10: ffff960cc2df7908 R11: 0000000000000002 R12: 0000000000000000nR13: ffff8afb8d7688a0 R14: ffff8afb8da1a578 R15: 0000000000000224nFS: 00007f4dac35ce00(0000) GS:ffff8afe30b00000(0000n---truncated---,CVE-2024-26700,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnparisc: Fix random data corruption from exception handlernnThe current exception handler implementation which assists when accessingnuser space memory may exhibit random data corruption if the compiler decidesnto use a different register than the specified register %r29 (defined innASM_EXCEPTIONTABLE_REG) for the error code. If the compiler choose anothernregister the fault handler will nevertheless store -EFAULT into %r29 and thusntrash whatever this register is used for.nLooking at the assembly I found that this happens sometimes in emulate_ldd().nnTo solve the issue the easiest solution would be if it somehow isnpossible to tell the fault handler which register is used to hold the errorncode. Using %0 or %1 in the inline assembly is not posssible as it will shownup as e.g. %r29 (with the %r prefix) which the GNU assembler can notnconvert to an integer.nnThis patch takes another better and more flexible approach:nWe extend the __ex_table (which is out of the execution path) by one 32-word.nIn this word we tell the compiler to insert the assembler instructionnor %r0%r0%reg where %reg references the register which the compilernchoosed for the error return code.nIn case of an access failure the fault handler finds the __ex_table entry andncan examine the opcode. The used register is encoded in the lowest 5 bits andnthe fault handler can then store -EFAULT into this register.nnSince we extend the __ex_table to 3 words we can't use the BUILDTIME_TABLE_SORTnconfig option any longer.,CVE-2024-26706,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnusb: dwc3: gadget: Fix NULL pointer dereference in dwc3_gadget_suspendnnIn current scenario if Plug-out and Plug-In performed continuouslynthere could be a chance while checking for dwc->gadget_driver inndwc3_gadget_suspend a NULL pointer dereference may occur.nnCall Stack:nntCPU1: CPU2:ntgadget_unbind_driver dwc3_suspend_commonntdwc3_gadget_stop dwc3_gadget_suspendn dwc3_disconnect_gadgetnnCPU1 basically clears the variable and CPU2 checks the variable.nConsider CPU1 is running and right before gadget_driver is clearednand in parallel CPU2 executes dwc3_gadget_suspend where it findsndwc->gadget_driver which is not NULL and resumes execution and thennCPU1 completes execution. CPU2 executes dwc3_disconnect_gadget wherenit checks dwc->gadget_driver is already NULL because of which thenNULL pointer deference occur.,CVE-2024-26715,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndm-crypt dm-verity: disable taskletsnnTasklets have an inherent problem with memory corruption. The functionntasklet_action_common calls tasklet_trylock then it calls the taskletncallback and then it calls tasklet_unlock. If the tasklet callback freesnthe structure that contains the tasklet or if it calls some code that maynfree it tasklet_unlock will write into free memory.nnThe commits 8e14f610159d and d9a02e016aaf try to fix it for dm-crypt butnit is not a sufficient fix and the data corruption can still happen [1].nThere is no fix for dm-verity and dm-verity will write into free memorynwith every tasklet-processed bio.nnThere will be atomic workqueues implemented in the kernel 6.9 [2]. Theynwill have better interface and they will not suffer from the memoryncorruption problem.nnBut we need something that stops the memory corruption now and that can benbackported to the stable kernels. So I'm proposing this commit thatndisables tasklets in both dm-crypt and dm-verity. This commit doesn'tnremove the tasklet support because the tasklet code will be reused whennatomic workqueues will be implemented.nn[1] https://lore.kernel.org/all/d390d7ee-f142-44d3-822a-87949e14608b@suse.de/T/n[2] https://lore.kernel.org/lkml/20240130091300.2968534-1-tj@kernel.org/,CVE-2024-26718,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnouveau: offload fence uevents work to workqueuennThis should break the deadlock between the fctx lock and the irq lock.nnThis offloads the processing off the work from the irq into a workqueue.,CVE-2024-26719,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbtrfs: don't drop extent_map for free space inode on write errornnWhile running the CI for an unrelated change I hit the following panicnwith generic/648 on btrfs_holes_spacecache.nnassertion failed: block_start != EXTENT_MAP_HOLE in fs/btrfs/extent_io.c:1385n------------[ cut here ]------------nkernel BUG at fs/btrfs/extent_io.c:1385!ninvalid opcode: 0000 [#1] PREEMPT SMP NOPTInCPU: 1 PID: 2695096 Comm: fsstress Kdump: loaded Tainted: G W 6.8.0-rc2+ #1nRIP: 0010:__extent_writepage_io.constprop.0+0x4c1/0x5c0nCall Trace:n <TASK>n extent_write_cache_pages+0x2ac/0x8f0n extent_writepages+0x87/0x110n do_writepages+0xd5/0x1f0n filemap_fdatawrite_wbc+0x63/0x90n __filemap_fdatawrite_range+0x5c/0x80n btrfs_fdatawrite_range+0x1f/0x50n btrfs_write_out_cache+0x507/0x560n btrfs_write_dirty_block_groups+0x32a/0x420n commit_cowonly_roots+0x21b/0x290n btrfs_commit_transaction+0x813/0x1360n btrfs_sync_file+0x51a/0x640n __x64_sys_fdatasync+0x52/0x90n do_syscall_64+0x9c/0x190n entry_SYSCALL_64_after_hwframe+0x6e/0x76nnThis happens because we fail to write out the free space cache in oneninstance come back around and attempt to write it again. However onnthe second pass through we go to call btrfs_get_extent() on the inode tonget the extent mapping. Because this is a new block group and with thenfree space inode we always search the commit root to avoid deadlockingnwith the tree we find nothing and return a EXTENT_MAP_HOLE for thenrequested range.nnThis happens because the first time we try to write the space cache outnwe hit an error and on an error we drop the extent mapping. This isnnormal for normal files but the free space cache inode is special. Wenalways expect the extent map to be correct. Thus the second timenthrough we end up with a bogus extent map.nnSince we're deprecating this feature the most straightforward way tonfix this is to simply skip dropping the extent map range for this failednrange.nnI shortened the test by using error injection to stress the area to makenit easier to reproduce. With this patch in place we no longer panicnwith my error injection test.,CVE-2024-26726,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet/sched: act_mirred: don't override retval if we already lost the skbnnIf we're redirecting the skb and haven't called tcf_mirred_forward()nyet we need to tell the core to drop the skb by setting the retcodento SHOT. If we have called tcf_mirred_forward() however the skbnis out of our hands and returning SHOT will lead to UaF.nnMove the retval override to the error path which actually need it.,CVE-2024-26739,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet/sched: act_mirred: use the backlog for mirred ingressnnThe test Davide added in commit ca22da2fbd69 (act_mirred: use the backlognfor nested calls to mirred ingress) hangs our testing VMs every 10 or sonruns with the familiar tcp_v4_rcv -> tcp_v4_rcv deadlock reported bynlockdep.nnThe problem as previously described by Davide (see Link) is thatnif we reverse flow of traffic with the redirect (egress -> ingress)nwe may reach the same socket which generated the packet. And we maynstill be holding its socket lock. The common solution to such deadlocksnis to put the packet in the Rx backlog rather than run the Rx pathninline. Do that for all egress -> ingress reversals not just oncenwe started to nest mirred calls.nnIn the past there was a concern that the backlog indirection willnlead to loss of error reporting / less accurate stats. But the currentnworkaround does not seem to address the issue.,CVE-2024-26740,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnmd: Don't register sync_thread for reshape directlynnCurrently if reshape is interrupted then reassemble the array willnregister sync_thread directly from pers->run() in this casen'MD_RECOVERY_RUNNING' is set directly however there is no guaranteenthat md_do_sync() will be executed hence stop_sync_thread() will hangnbecause 'MD_RECOVERY_RUNNING' can't be cleared.nnLast patch make sure that md_do_sync() will set MD_RECOVERY_DONEnhowever following hang can still be triggered by dm-raid testnshell/lvconvert-raid-reshape.sh occasionally:nn[root@fedora ~]# cat /proc/1982/stackn[<0>] stop_sync_thread+0x1ab/0x270 [md_mod]n[<0>] md_frozen_sync_thread+0x5c/0xa0 [md_mod]n[<0>] raid_presuspend+0x1e/0x70 [dm_raid]n[<0>] dm_table_presuspend_targets+0x40/0xb0 [dm_mod]n[<0>] __dm_destroy+0x2a5/0x310 [dm_mod]n[<0>] dm_destroy+0x16/0x30 [dm_mod]n[<0>] dev_remove+0x165/0x290 [dm_mod]n[<0>] ctl_ioctl+0x4bb/0x7b0 [dm_mod]n[<0>] dm_ctl_ioctl+0x11/0x20 [dm_mod]n[<0>] vfs_ioctl+0x21/0x60n[<0>] __x64_sys_ioctl+0xb9/0xe0n[<0>] do_syscall_64+0xc6/0x230n[<0>] entry_SYSCALL_64_after_hwframe+0x6c/0x74nnMeanwhile mddev->recovery is:nMD_RECOVERY_RUNNING |nMD_RECOVERY_INTR |nMD_RECOVERY_RESHAPE |nMD_RECOVERY_FROZENnnFix this problem by remove the code to register sync_thread directlynfrom raid10 and raid5. And let md_check_recovery() to registernsync_thread.,CVE-2024-26756,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnmd: Don't ignore read-only array in md_check_recovery()nnUsually if the array is not read-write md_check_recovery() won'tnregister new sync_thread in the first place. And if the array isnread-write and sync_thread is registered md_set_readonly() willnunregister sync_thread before setting the array read-only. md/raidnfollow this behavior hence there is no problem.nnAfter commit f52f5c71f3d4 (md: fix stopping sync thread) followingnhang can be triggered by test shell/integrity-caching.sh:nn1) array is read-only. dm-raid update super block:nrs_update_sbsn ro = mddev->ron mddev->ro = 0n -> set array read-writen md_update_sbnn2) register new sync thread concurrently.nn3) dm-raid set array back to read-only:nrs_update_sbsn mddev->ro = ronn4) stop the array:nraid_dtrn md_stopn stop_sync_threadn set_bit(MD_RECOVERY_INTR &mddev->recovery);n md_wakeup_thread_directly(mddev->sync_thread);n wait_event(... !test_bit(MD_RECOVERY_RUNNING &mddev->recovery))nn5) sync thread done:n md_do_syncn set_bit(MD_RECOVERY_DONE &mddev->recovery);n md_wakeup_thread(mddev->thread);nn6) daemon thread can't unregister sync thread:n md_check_recoveryn if (!md_is_rdwr(mddev) &&n !test_bit(MD_RECOVERY_NEEDED &mddev->recovery))n return;n -> -> MD_RECOVERY_RUNNING can't be cleared hence step 4 hang;nnThe root cause is that dm-raid manipulate 'mddev->ro' by itselfnhowever dm-raid really should stop sync thread before setting thenarray read-only. Unfortunately I need to read more code before Incan refacter the handler of 'mddev->ro' in dm-raid hence let's fixnthe problem the easy way for now to prevent dm-raid regression.,CVE-2024-26757,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnmd: Don't ignore suspended array in md_check_recovery()nnmddev_suspend() never stop sync_thread hence it doesn't make sense tonignore suspended array in md_check_recovery() which might causensync_thread can't be unregistered.nnAfter commit f52f5c71f3d4 (md: fix stopping sync thread) followingnhang can be triggered by test shell/integrity-caching.sh:nn1) suspend the array:nraid_postsuspendn mddev_suspendnn2) stop the array:nraid_dtrn md_stopn __md_stop_writesn stop_sync_threadn set_bit(MD_RECOVERY_INTR &mddev->recovery);n md_wakeup_thread_directly(mddev->sync_thread);n wait_event(... !test_bit(MD_RECOVERY_RUNNING &mddev->recovery))nn3) sync thread done:nmd_do_syncn set_bit(MD_RECOVERY_DONE &mddev->recovery);n md_wakeup_thread(mddev->thread);nn4) daemon thread can't unregister sync thread:nmd_check_recoveryn if (mddev->suspended)n return; -> return directlyn md_read_sync_threadn clear_bit(MD_RECOVERY_RUNNING &mddev->recovery);n -> MD_RECOVERY_RUNNING can't be cleared hence step 2 hang;nnThis problem is not just related to dm-raid fix it by ignoringnsuspended array in md_check_recovery(). And follow up patches willnimprove dm-raid better to frozen sync thread during suspend.,CVE-2024-26758,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnmm/swap: fix race when skipping swapcachennWhen skipping swapcache for SWP_SYNCHRONOUS_IO if two or more threadsnswapin the same entry at the same time they get different pages (A B). nBefore one thread (T0) finishes the swapin and installs page (A) to thenPTE another thread (T1) could finish swapin of page (B) swap_free thenentry then swap out the possibly modified page reusing the same entry. nIt breaks the pte_same check in (T0) because PTE value is unchangedncausing ABA problem. Thread (T0) will install a stalled page (A) into thenPTE and cause data corruption.nnOne possible callstack is like this:nnCPU0 CPU1n---- ----ndo_swap_page() do_swap_page() with same entryn<direct swapin path> <direct swapin path>n<alloc page A> <alloc page B>nswap_read_folio() <- read to page A swap_read_folio() <- read to page Bn<slow on later locks or interrupt> <finished swapin first>n... set_pte_at()n swap_free() <- entry is freen <write to page B now page A stalled>n <swap out page B to same swap entry>npte_same() <- Check pass PTE seemsn unchanged but page An is stalled!nswap_free() <- page B content lost!nset_pte_at() <- staled page A installed!nnAnd besides for ZRAM swap_free() allows the swap device to discard thenentry content so even if page (B) is not modified if swap_read_folio()non CPU0 happens later than swap_free() on CPU1 it may also cause datanloss.nnTo fix this reuse swapcache_prepare which will pin the swap entry usingnthe cache flag and allow only one thread to swap it in also prevent anynparallel code from putting the entry in the cache. Release the pin afternPT unlocked.nnRacers just loop and wait since it's a rare and very short event. Anschedule_timeout_uninterruptible(1) call is added to avoid repeated pagenfaults wasting too much CPU causing livelock or adding too much noise tonperf statistics. A similar livelock issue was described in commitn029c4628b2eb (mm: swap: get rid of livelock in swapin readahead)nnReproducer:nnThis race issue can be triggered easily using a well constructednreproducer and patched brd (with a delay in read path) [1]:nnWith latest 6.8 mainline race caused data loss can be observed easily:n$ gcc -g -lpthread test-thread-swap-race.c && ./a.outn Polulating 32MB of memory region...n Keep swapping out...n Starting round 0...n Spawning 65536 workers...n 32746 workers spawned wait for done...n Round 0: Error on 0x5aa00 expected 32746 got 32743 3 data loss!n Round 0: Error on 0x395200 expected 32746 got 32743 3 data loss!n Round 0: Error on 0x3fd000 expected 32746 got 32737 9 data loss!n Round 0 Failed 15 data loss!nnThis reproducer spawns multiple threads sharing the same memory regionnusing a small swap device. Every two threads updates mapped pages one bynone in opposite direction trying to create a race with one dedicatednthread keep swapping out the data out using madvise.nnThe reproducer created a reproduce rate of about once every 5 minutes sonthe race should be totally possible in production.nnAfter this patch I ran the reproducer for over a few hundred rounds andnno data loss observed.nnPerformance overhead is minimal microbenchmark swapin 10G from 32Gnzram:nnBefore: 10934698 usnAfter: 11157121 usnCached: 13155355 us (Dropping SWP_SYNCHRONOUS_IO flag)nn[kasong@tencent.com: v4],CVE-2024-26759,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: fixed integer types and null check locationsnn[why]:nissues fixed:n- comparison with wider integer type in loop condition which can causeninfinite loopsn- pointer dereference before null check,CVE-2024-26767,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnvmet-fc: avoid deadlock on delete association pathnnWhen deleting an association the shutdown path is deadlocking because wentry to flush the nvmet_wq nested. Avoid this by deadlock by deferringnthe put work into its own work item.,CVE-2024-26769,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnext4: avoid dividing by 0 in mb_update_avg_fragment_size() when block bitmap corruptnnDetermine if bb_fragments is 0 instead of determining bb_free to eliminatenthe risk of dividing by zero when the block bitmap is corrupted.,CVE-2024-26774,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnaoe: avoid potential deadlock at set_capacitynnMove set_capacity() outside of the section procected by (&d->lock).nTo avoid possible interrupt unsafe locking scenario:nn CPU0 CPU1n ---- ----n[1] lock(&bdev->bd_size_lock);n local_irq_disable();n [2] lock(&d->lock);n [3] lock(&bdev->bd_size_lock);n <Interrupt>n[4] lock(&d->lock);nn output.log scan_tyk_dockerimages.sh vulnerabilities.csv DEADLOCK ***nnWhere [1](&bdev->bd_size_lock) hold by zram_add()->set_capacity().n[2]lock(&d->lock) hold by aoeblk_gdalloc(). And aoeblk_gdalloc()nis trying to acquire [3](&bdev->bd_size_lock) at set_capacity() call.nIn this situation an attempt to acquire [4]lock(&d->lock) fromnaoecmd_cfg_rsp() will lead to deadlock.nnSo the simplest solution is breaking lock dependencyn[2](&d->lock) -> [3](&bdev->bd_size_lock) by moving set_capacity()noutside.,CVE-2024-26775,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbtrfs: fix double free of anonymous device after snapshot creation failurennWhen creating a snapshot we may do a double free of an anonymous devicenin case there's an error committing the transaction. The second free maynresult in freeing an anonymous device number that was allocated by somenother subsystem in the kernel or another btrfs filesystem.nnThe steps that lead to this:nn1) At ioctl.c:create_snapshot() we allocate an anonymous device numbern and assign it to pending_snapshot->anon_dev;nn2) Then we call btrfs_commit_transaction() and end up atn transaction.c:create_pending_snapshot();nn3) There we call btrfs_get_new_fs_root() and pass it the anonymous devicen number stored in pending_snapshot->anon_dev;nn4) btrfs_get_new_fs_root() frees that anonymous device number becausen btrfs_lookup_fs_root() returned a root - someone else did a lookupn of the new root already which could some task doing backref walking;nn5) After that some error happens in the transaction commit path and atn ioctl.c:create_snapshot() we jump to the 'fail' label and aftern that we free again the same anonymous device number which in then meanwhile may have been reallocated somewhere else becausen pending_snapshot->anon_dev still has the same value as in step 1.nnRecently syzbot ran into this and reported the following trace:nn ------------[ cut here ]------------n ida_free called for id=51 which is not allocated.n WARNING: CPU: 1 PID: 31038 at lib/idr.c:525 ida_free+0x370/0x420 lib/idr.c:525n Modules linked in:n CPU: 1 PID: 31038 Comm: syz-executor.2 Not tainted 6.8.0-rc4-syzkaller-00410-gc02197fc9076 #0n Hardware name: Google Google Compute Engine/Google Compute Engine BIOS Google 01/25/2024n RIP: 0010:ida_free+0x370/0x420 lib/idr.c:525n Code: 10 42 80 3c 28 (...)n RSP: 0018:ffffc90015a67300 EFLAGS: 00010246n RAX: be5130472f5dd000 RBX: 0000000000000033 RCX: 0000000000040000n RDX: ffffc90009a7a000 RSI: 000000000003ffff RDI: 0000000000040000n RBP: ffffc90015a673f0 R08: ffffffff81577992 R09: 1ffff92002b4cdb4n R10: dffffc0000000000 R11: fffff52002b4cdb5 R12: 0000000000000246n R13: dffffc0000000000 R14: ffffffff8e256b80 R15: 0000000000000246n FS: 00007fca3f4b46c0(0000) GS:ffff8880b9500000(0000) knlGS:0000000000000000n CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033n CR2: 00007f167a17b978 CR3: 000000001ed26000 CR4: 0000000000350ef0n Call Trace:n <TASK>n btrfs_get_root_ref+0xa48/0xaf0 fs/btrfs/disk-io.c:1346n create_pending_snapshot+0xff2/0x2bc0 fs/btrfs/transaction.c:1837n create_pending_snapshots+0x195/0x1d0 fs/btrfs/transaction.c:1931n btrfs_commit_transaction+0xf1c/0x3740 fs/btrfs/transaction.c:2404n create_snapshot+0x507/0x880 fs/btrfs/ioctl.c:848n btrfs_mksubvol+0x5d0/0x750 fs/btrfs/ioctl.c:998n btrfs_mksnapshot+0xb5/0xf0 fs/btrfs/ioctl.c:1044n __btrfs_ioctl_snap_create+0x387/0x4b0 fs/btrfs/ioctl.c:1306n btrfs_ioctl_snap_create_v2+0x1ca/0x400 fs/btrfs/ioctl.c:1393n btrfs_ioctl+0xa74/0xd40n vfs_ioctl fs/ioctl.c:51 [inline]n __do_sys_ioctl fs/ioctl.c:871 [inline]n __se_sys_ioctl+0xfe/0x170 fs/ioctl.c:857n do_syscall_64+0xfb/0x240n entry_SYSCALL_64_after_hwframe+0x6f/0x77n RIP: 0033:0x7fca3e67dda9n Code: 28 00 00 00 (...)n RSP: 002b:00007fca3f4b40c8 EFLAGS: 00000246 ORIG_RAX: 0000000000000010n RAX: ffffffffffffffda RBX: 00007fca3e7abf80 RCX: 00007fca3e67dda9n RDX: 00000000200005c0 RSI: 0000000050009417 RDI: 0000000000000003n RBP: 00007fca3e6ca47a R08: 0000000000000000 R09: 0000000000000000n R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000n R13: 000000000000000b R14: 00007fca3e7abf80 R15: 00007fff6bf95658n </TASK>nnWhere we get an explicit message where we attempt to free an anonymousndevice number that is not currently allocated. It happens in a differentncode path from the example below at btrfs_get_root_ref() so this changenmay not fix the case triggered by syn---truncated---,CVE-2024-26792,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnBoth cadence-quadspi ->runtime_suspend() and ->runtime_resume()nimplementations start with:nntstruct cqspi_st *cqspi = dev_get_drvdata(dev);ntstruct spi_controller *host = dev_get_drvdata(dev);nnThis obviously cannot be correct unless struct cqspi_st is thenfirst member of  struct spi_controller or the other way around butnit is not the case. struct spi_controller is allocated byndevm_spi_alloc_host() which allocates an extra amount of memory fornprivate data used to store struct cqspi_st.nnThe ->probe() function of the cadence-quadspi driver then sets thendevice drvdata to store the address of the struct cqspi_stnstructure. Therefore:nntstruct cqspi_st *cqspi = dev_get_drvdata(dev);nnis correct but:nntstruct spi_controller *host = dev_get_drvdata(dev);nnis not as it makes host point not to a struct spi_controller butnto the same struct cqspi_st structure as above.nnThis obviously leads to bad things (memory corruption kernel crashes)ndirectly during ->probe() as ->probe() enables the device using PMnruntime leading the ->runtime_resume() hook being called which innturns calls spi_controller_resume() with the wrong pointer.nnThis has at least been reported [0] to cause a kernel crash but thenexact behavior will depend on the memory contents.nn[0] https://lore.kernel.org/all/20240226121803.5a7r5wkpbbowcxgx@dhruva/nnThis issue potentially affects all platforms that are currently usingnthe cadence-quadspi driver.,CVE-2024-26807,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nncifs: fix underflow in parse_server_interfaces()nnIn this loop we step through the buffer and after each item we checknif the size_left is greater than the minimum size we need. Howevernthe problem is that bytes_left is type ssize_t while sizeof() is typensize_t. That means that because of type promotion the comparison isndone as an unsigned and if we have negative bytes left the loopncontinues instead of ending.,CVE-2024-26828,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nni40e: Do not allow untrusted VF to remove administratively set MACnnCurrently when PF administratively sets VF's MAC address and the VFnis put down (VF tries to delete all MACs) then the MAC is removednfrom MAC filters and primary VF MAC is zeroed.nnDo not allow untrusted VF to remove primary MAC when it was setnadministratively by PF.nnReproducer:n1) Create VFn2) Set VF interface upn3) Administratively set the VF's MACn4) Put VF interface downnn[root@host ~]# echo 1 > /sys/class/net/enp2s0f0/device/sriov_numvfsn[root@host ~]# ip link set enp2s0f0v0 upn[root@host ~]# ip link set enp2s0f0 vf 0 mac fe:6c:b5:da:c7:7dn[root@host ~]# ip link show enp2s0f0n23: enp2s0f0: <BROADCASTMULTICASTUPLOWER_UP> mtu 1500 qdisc mq state UP mode DEFAULT group default qlen 1000n link/ether 3c:ec:ef:b7:dd:04 brd ff:ff:ff:ff:ff:ffn vf 0 link/ether fe:6c:b5:da:c7:7d brd ff:ff:ff:ff:ff:ff spoof checking on link-state auto trust offn[root@host ~]# ip link set enp2s0f0v0 downn[root@host ~]# ip link show enp2s0f0n23: enp2s0f0: <BROADCASTMULTICASTUPLOWER_UP> mtu 1500 qdisc mq state UP mode DEFAULT group default qlen 1000n link/ether 3c:ec:ef:b7:dd:04 brd ff:ff:ff:ff:ff:ffn vf 0 link/ether 00:00:00:00:00:00 brd ff:ff:ff:ff:ff:ff spoof checking on link-state auto trust off,CVE-2024-26830,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnscsi: ufs: core: Fix shift issue in ufshcd_clear_cmd()nnWhen task_tag >= 32 (in MCQ mode) and sizeof(unsigned int) == 4 1U <<ntask_tag will out of bounds for a u32 mask. Fix this up to preventnSHIFT_ISSUE (bitwise shifts that are out of bounds for their data type).nn[name:debug_monitors&]Unexpected kernel BRK exception at EL1n[name:traps&]Internal error: BRK handler: 00000000f2005514 [#1] PREEMPT SMPn[name:mediatek_cpufreq_hw&]cpufreq stop DVFS log donen[name:mrdump&]Kernel Offset: 0x1ba5800000 from 0xffffffc008000000n[name:mrdump&]PHYS_OFFSET: 0x80000000n[name:mrdump&]pstate: 22400005 (nzCv daif +PAN -UAO)n[name:mrdump&]pc : [0xffffffdbaf52bb2c] ufshcd_clear_cmd+0x280/0x288n[name:mrdump&]lr : [0xffffffdbaf52a774] ufshcd_wait_for_dev_cmd+0x3e4/0x82cn[name:mrdump&]sp : ffffffc0081471b0n<snip>nWorkqueue: ufs_eh_wq_0 ufshcd_err_handlernCall trace:n dump_backtrace+0xf8/0x144n show_stack+0x18/0x24n dump_stack_lvl+0x78/0x9cn dump_stack+0x18/0x44n mrdump_common_die+0x254/0x480 [mrdump]n ipanic_die+0x20/0x30 [mrdump]n notify_die+0x15c/0x204n die+0x10c/0x5f8n arm64_notify_die+0x74/0x13cn do_debug_exception+0x164/0x26cn el1_dbg+0x64/0x80n el1h_64_sync_handler+0x3c/0x90n el1h_64_sync+0x68/0x6cn ufshcd_clear_cmd+0x280/0x288n ufshcd_wait_for_dev_cmd+0x3e4/0x82cn ufshcd_exec_dev_cmd+0x5bc/0x9acn ufshcd_verify_dev_init+0x84/0x1c8n ufshcd_probe_hba+0x724/0x1ce0n ufshcd_host_reset_and_restore+0x260/0x574n ufshcd_reset_and_restore+0x138/0xbd0n ufshcd_err_handler+0x1218/0x2f28n process_one_work+0x5fc/0x1140n worker_thread+0x7d8/0xe20n kthread+0x25c/0x468n ret_from_fork+0x10/0x20,CVE-2024-26842,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnblock: Fix WARNING in _copy_from_iternnSyzkaller reports a warning in _copy_from_iter because anniov_iter is supposedly used in the wrong direction. The reasonnis that syzcaller managed to generate a request withna transfer direction of SG_DXFER_TO_FROM_DEV. This instructsnthe kernel to copy user buffers into the kernel read intonthe copied buffers and then copy the data back to user space.nnThus the iovec is used in both directions.nnDetect this situation in the block layer and construct a newniterator with the correct direction for the copy-in.,CVE-2024-26844,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnrds: tcp: Fix use-after-free of net in reqsk_timer_handler().nnsyzkaller reported a warning of netns tracker [0] followed by KASANnsplat [1] and another ref tracker warning [1].nnsyzkaller could not find a repro but in the log the only suspiciousnsequence was as follows:nn 18:26:22 executing program 1:n r0 = socket$inet6_mptcp(0xa 0x1 0x106)n ...n connect$inet6(r0 &(0x7f0000000080)={0xa 0x4001 0x0 @loopback} 0x1c) (async)nnThe notable thing here is 0x4001 in connect() which is RDS_TCP_PORT.nnSo the scenario would be:nn 1. unshare(CLONE_NEWNET) creates a per netns tcp listener inn rds_tcp_listen_init().n 2. syz-executor connect()s to it and creates a reqsk.n 3. syz-executor exit()s immediately.n 4. netns is dismantled. [0]n 5. reqsk timer is fired and UAF happens while freeing reqsk. [1]n 6. listener is freed after RCU grace period. [2]nnBasically reqsk assumes that the listener guarantees netns safetynuntil all reqsk timers are expired by holding the listener's refcount.nHowever this was not the case for kernel sockets.nnCommit 740ea3c4a0b2 (tcp: Clean up kernel listener's reqsk inninet_twsk_purge()) fixed this issue only for per-netns ehash.nnLet's apply the same fix for the global ehash.nn[0]:nref_tracker: net notrefcnt@0000000065449cc3 has 1/1 users atn sk_alloc (./include/net/net_namespace.h:337 net/core/sock.c:2146)n inet6_create (net/ipv6/af_inet6.c:192 net/ipv6/af_inet6.c:119)n __sock_create (net/socket.c:1572)n rds_tcp_listen_init (net/rds/tcp_listen.c:279)n rds_tcp_init_net (net/rds/tcp.c:577)n ops_init (net/core/net_namespace.c:137)n setup_net (net/core/net_namespace.c:340)n copy_net_ns (net/core/net_namespace.c:497)n create_new_namespaces (kernel/nsproxy.c:110)n unshare_nsproxy_namespaces (kernel/nsproxy.c:228 (discriminator 4))n ksys_unshare (kernel/fork.c:3429)n __x64_sys_unshare (kernel/fork.c:3496)n do_syscall_64 (arch/x86/entry/common.c:52 arch/x86/entry/common.c:83)n entry_SYSCALL_64_after_hwframe (arch/x86/entry/entry_64.S:129)n...nWARNING: CPU: 0 PID: 27 at lib/ref_tracker.c:179 ref_tracker_dir_exit (lib/ref_tracker.c:179)nn[1]:nBUG: KASAN: slab-use-after-free in inet_csk_reqsk_queue_drop (./include/net/inet_hashtables.h:180 net/ipv4/inet_connection_sock.c:952 net/ipv4/inet_connection_sock.c:966)nRead of size 8 at addr ffff88801b370400 by task swapper/0/0nHardware name: QEMU Standard PC (i440FX + PIIX 1996) BIOS rel-1.16.0-0-gd239552ce722-prebuilt.qemu.org 04/01/2014nCall Trace:n <IRQ>n dump_stack_lvl (lib/dump_stack.c:107 (discriminator 1))n print_report (mm/kasan/report.c:378 mm/kasan/report.c:488)n kasan_report (mm/kasan/report.c:603)n inet_csk_reqsk_queue_drop (./include/net/inet_hashtables.h:180 net/ipv4/inet_connection_sock.c:952 net/ipv4/inet_connection_sock.c:966)n reqsk_timer_handler (net/ipv4/inet_connection_sock.c:979 net/ipv4/inet_connection_sock.c:1092)n call_timer_fn (./arch/x86/include/asm/jump_label.h:27 ./include/linux/jump_label.h:207 ./include/trace/events/timer.h:127 kernel/time/timer.c:1701)n __run_timers.part.0 (kernel/time/timer.c:1752 kernel/time/timer.c:2038)n run_timer_softirq (kernel/time/timer.c:2053)n __do_softirq (./arch/x86/include/asm/jump_label.h:27 ./include/linux/jump_label.h:207 ./include/trace/events/irq.h:142 kernel/softirq.c:554)n irq_exit_rcu (kernel/softirq.c:427 kernel/softirq.c:632 kernel/softirq.c:644)n sysvec_apic_timer_interrupt (arch/x86/kernel/apic/apic.c:1076 (discriminator 14))n </IRQ>nnAllocated by task 258 on cpu 0 at 83.612050s:n kasan_save_stack (mm/kasan/common.c:48)n kasan_save_track (mm/kasan/common.c:68)n __kasan_slab_alloc (mm/kasan/common.c:343)n kmem_cache_alloc (mm/slub.c:3813 mm/slub.c:3860 mm/slub.c:3867)n copy_net_ns (./include/linux/slab.h:701 net/core/net_namespace.c:421 net/core/net_namespace.c:480)n create_new_namespaces (kernel/nsproxy.c:110)n unshare_nsproxy_namen---truncated---,CVE-2024-26865,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnspi: lpspi: Avoid potential use-after-free in probe()nnfsl_lpspi_probe() is allocating/disposing memory manually withnspi_alloc_host()/spi_alloc_target() but usesndevm_spi_register_controller(). In case of error after the latter call thenmemory will be explicitly freed in the probe function bynspi_controller_put() call but used afterwards by devm management outsidenprobe() (spi_unregister_controller() <- devm_spi_unregister() below).nnUnable to handle kernel NULL pointer dereference at virtual address 0000000000000070n...nCall trace:n kernfs_find_nsn kernfs_find_and_get_nsn sysfs_remove_groupn sysfs_remove_groupsn device_remove_attrsn device_deln spi_unregister_controllern devm_spi_unregistern release_nodesn devres_release_alln really_proben driver_probe_devicen __device_attach_drivern bus_for_each_drvn __device_attachn device_initial_proben bus_probe_devicen deferred_probe_work_funcn process_one_workn worker_threadn kthreadn ret_from_fork,CVE-2024-26866,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnf2fs: fix to truncate meta inode pages forcelynnBelow race case can cause data corruption:nnThread AttttGC threadnttttt- gc_data_segmentnttttt - ra_data_blocknttttt - locked meta_inode pagen- f2fs_inplace_write_datan - invalidate_mapping_pagesn : fail to invalidate meta_inode pagen due to lock failure or dirty|writebackn statusn - f2fs_submit_page_bion : write last dirty data to old blkaddrnttttt - move_data_blocknttttt - load old data from meta_inode pagenttttt - f2fs_submit_page_writenttttt : write old data to new blkaddrnnBecause invalidate_mapping_pages() will skip invalidating page whichnhas unclear status including locked dirty writeback and so on sonwe need to use truncate_inode_pages_range() instead ofninvalidate_mapping_pages() to make sure meta_inode page will be dropped.,CVE-2024-26869,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/bridge: adv7511: fix crash on irq during probennMoved IRQ registration down to end of adv7511_probe().nnIf an IRQ already is pending during adv7511_proben(before adv7511_cec_init) then cec_received_msg_tsncould crash using uninitialized data:nn Unable to handle kernel read from unreadable memory at virtual address 00000000000003d5n Internal error: Oops: 96000004 [#1] PREEMPT_RT SMPn Call trace:n cec_received_msg_ts+0x48/0x990 [cec]n adv7511_cec_irq_process+0x1cc/0x308 [adv7511]n adv7511_irq_process+0xd8/0x120 [adv7511]n adv7511_irq_handler+0x1c/0x30 [adv7511]n irq_thread_fn+0x30/0xa0n irq_thread+0x14c/0x238n kthread+0x190/0x1a8,CVE-2024-26876,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnBluetooth: af_bluetooth: Fix deadlocknnAttemting to do sock_lock on .recvmsg may cause a deadlock as shownnbellow so instead of using sock_sock this uses sk_receive_queue.locknon bt_sock_ioctl to avoid the UAF:nnINFO: task kworker/u9:1:121 blocked for more than 30 seconds.n Not tainted 6.7.6-lemon #183nWorkqueue: hci0 hci_rx_worknCall Trace:n <TASK>n __schedule+0x37d/0xa00n schedule+0x32/0xe0n __lock_sock+0x68/0xa0n ? __pfx_autoremove_wake_function+0x10/0x10n lock_sock_nested+0x43/0x50n l2cap_sock_recv_cb+0x21/0xa0n l2cap_recv_frame+0x55b/0x30a0n ? psi_task_switch+0xeb/0x270n ? finish_task_switch.isra.0+0x93/0x2a0n hci_rx_work+0x33a/0x3f0n process_one_work+0x13a/0x2f0n worker_thread+0x2f0/0x410n ? __pfx_worker_thread+0x10/0x10n kthread+0xe0/0x110n ? __pfx_kthread+0x10/0x10n ret_from_fork+0x2c/0x50n ? __pfx_kthread+0x10/0x10n ret_from_fork_asm+0x1b/0x30n </TASK>,CVE-2024-26886,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnfirmware: arm_scmi: Fix double free in SMC transport cleanup pathnnWhen the generic SCMI code tears down a channel it calls the chan_freencallback function defined by each transport. Since multiple protocolsnmight share the same transport_info member chan_free() might want tonclean up the same member multiple times within the given SCMI transportnimplementation. In this case it is SMC transport. This will lead to a NULLnpointer dereference at the second time:nn | scmi_protocol scmi_dev.1: Enabled polling mode TX channel - prot_id:16n | arm-scmi firmware:scmi: SCMI Notifications - Core Enabled.n | arm-scmi firmware:scmi: unable to communicate with SCMIn | Unable to handle kernel NULL pointer dereference at virtual address 0000000000000000n | Mem abort info:n | ESR = 0x0000000096000004n | EC = 0x25: DABT (current EL) IL = 32 bitsn | SET = 0 FnV = 0n | EA = 0 S1PTW = 0n | FSC = 0x04: level 0 translation faultn | Data abort info:n | ISV = 0 ISS = 0x00000004 ISS2 = 0x00000000n | CM = 0 WnR = 0 TnD = 0 TagAccess = 0n | GCS = 0 Overlay = 0 DirtyBit = 0 Xs = 0n | user pgtable: 4k pages 48-bit VAs pgdp=0000000881ef8000n | [0000000000000000] pgd=0000000000000000 p4d=0000000000000000n | Internal error: Oops: 0000000096000004 [#1] PREEMPT SMPn | Modules linked in:n | CPU: 4 PID: 1 Comm: swapper/0 Not tainted 6.7.0-rc2-00124-g455ef3d016c9-dirty #793n | Hardware name: FVP Base RevC (DT)n | pstate: 61400009 (nZCv daif +PAN -UAO -TCO +DIT -SSBS BTYPE=--)n | pc : smc_chan_free+0x3c/0x6cn | lr : smc_chan_free+0x3c/0x6cn | Call trace:n | smc_chan_free+0x3c/0x6cn | idr_for_each+0x68/0xf8n | scmi_cleanup_channels.isra.0+0x2c/0x58n | scmi_probe+0x434/0x734n | platform_probe+0x68/0xd8n | really_probe+0x110/0x27cn | __driver_probe_device+0x78/0x12cn | driver_probe_device+0x3c/0x118n | __driver_attach+0x74/0x128n | bus_for_each_dev+0x78/0xe0n | driver_attach+0x24/0x30n | bus_add_driver+0xe4/0x1e8n | driver_register+0x60/0x128n | __platform_driver_register+0x28/0x34n | scmi_driver_init+0x84/0xc0n | do_one_initcall+0x78/0x33cn | kernel_init_freeable+0x2b8/0x51cn | kernel_init+0x24/0x130n | ret_from_fork+0x10/0x20n | Code: f0004701 910a0021 aa1403e5 97b91c70 (b9400280)n | ---[ end trace 0000000000000000 ]---nnSimply check for the struct pointer being NULL before trying to accessnits members to avoid this situation.nnThis was found when a transport doesn't really work (for instance no SMCnservice) the probe routines then tries to clean up and triggers a crash.,CVE-2024-26893,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnwifi: wfx: fix memory leak when starting APnnKmemleak reported this error:nn unreferenced object 0xd73d1180 (size 184):n comm wpa_supplicant pid 1559 jiffies 13006305 (age 964.245s)n hex dump (first 32 bytes):n 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................n 00 00 00 00 00 00 00 00 1e 00 01 00 00 00 00 00 ................n backtrace:n [<5ca11420>] kmem_cache_alloc+0x20c/0x5acn [<127bdd74>] __alloc_skb+0x144/0x170n [<fb8a5e38>] __netdev_alloc_skb+0x50/0x180n [<0f9fa1d5>] __ieee80211_beacon_get+0x290/0x4d4 [mac80211]n [<7accd02d>] ieee80211_beacon_get_tim+0x54/0x18c [mac80211]n [<41e25cc3>] wfx_start_ap+0xc8/0x234 [wfx]n [<93a70356>] ieee80211_start_ap+0x404/0x6b4 [mac80211]n [<a4a661cd>] nl80211_start_ap+0x76c/0x9e0 [cfg80211]n [<47bd8b68>] genl_rcv_msg+0x198/0x378n [<453ef796>] netlink_rcv_skb+0xd0/0x130n [<6b7c977a>] genl_rcv+0x34/0x44n [<66b2d04d>] netlink_unicast+0x1b4/0x258n [<f965b9b6>] netlink_sendmsg+0x1e8/0x428n [<aadb8231>] ____sys_sendmsg+0x1e0/0x274n [<d2b5212d>] ___sys_sendmsg+0x80/0xb4n [<69954f45>] __sys_sendmsg+0x64/0xa8n unreferenced object 0xce087000 (size 1024):n comm wpa_supplicant pid 1559 jiffies 13006305 (age 964.246s)n hex dump (first 32 bytes):n 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................n 10 00 07 40 00 00 00 00 00 00 00 00 00 00 00 00 ...@............n backtrace:n [<9a993714>] __kmalloc_track_caller+0x230/0x600n [<f83ea192>] kmalloc_reserve.constprop.0+0x30/0x74n [<a2c61343>] __alloc_skb+0xa0/0x170n [<fb8a5e38>] __netdev_alloc_skb+0x50/0x180n [<0f9fa1d5>] __ieee80211_beacon_get+0x290/0x4d4 [mac80211]n [<7accd02d>] ieee80211_beacon_get_tim+0x54/0x18c [mac80211]n [<41e25cc3>] wfx_start_ap+0xc8/0x234 [wfx]n [<93a70356>] ieee80211_start_ap+0x404/0x6b4 [mac80211]n [<a4a661cd>] nl80211_start_ap+0x76c/0x9e0 [cfg80211]n [<47bd8b68>] genl_rcv_msg+0x198/0x378n [<453ef796>] netlink_rcv_skb+0xd0/0x130n [<6b7c977a>] genl_rcv+0x34/0x44n [<66b2d04d>] netlink_unicast+0x1b4/0x258n [<f965b9b6>] netlink_sendmsg+0x1e8/0x428n [<aadb8231>] ____sys_sendmsg+0x1e0/0x274n [<d2b5212d>] ___sys_sendmsg+0x80/0xb4nnHowever since the kernel is build optimized it seems the stack is notnaccurate. It appears the issue is related to wfx_set_mfp_ap(). The issuenis obvious in this function: memory allocated by ieee80211_beacon_get()nis never released. Fixing this leak makes kmemleak happy.,CVE-2024-26896,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Fix dcn35 8k30 Underflow/Corruption Issuenn[why]nodm calculation is missing for pipe split policy determinationnand cause Underflow/Corruption issue.nn[how]nAdd the odm calculation.,CVE-2024-26913,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: fix incorrect mpc_combine array sizenn[why]nMAX_SURFACES is per stream while MAX_PLANES is per asic. Thenmpc_combine is an array that records all the planes per asic. ThereforenMAX_PLANES should be used as the array size. Using MAX_SURFACES causesnarray overflow when there are more than 3 planes.nn[how]nUse the MAX_PLANES for the mpc_combine array size.,CVE-2024-26914,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amdgpu: Reset IH OVERFLOW_CLEAR bitnnAllows us to detect subsequent IH ring buffer overflows as well.,CVE-2024-26915,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nntracing/trigger: Fix to return error if failed to alloc snapshotnnFix register_snapshot_trigger() to return error code if it failed tonallocate a snapshot instead of 0 (success). Unless that it will registernsnapshot trigger without an error.,CVE-2024-26920,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnsmb: client: fix potential UAF in cifs_debug_files_proc_show()nnSkip sessions that are being teared down (status == SES_EXITING) tonavoid UAF.,CVE-2024-26928,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnscsi: qla2xxx: Fix double free of the ha->vp_map pointernnCoverity scan reported potential risk of double free of the pointernha->vp_map. ha->vp_map was freed in qla2x00_mem_alloc() and again freednin function qla2x00_mem_free(ha).nnAssign NULL to vp_map and kfree take care of NULL.,CVE-2024-26930,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/i915/bios: Tolerate devdata==NULL in intel_bios_encoder_supports_dp_dual_mode()nnIf we have no VBT or the VBT didn't declare the encodernin question we won't have the 'devdata' for the encoder.nInstead of oopsing just bail early.nnWe won't be able to tell whether the port is DP++ or notnbut so be it.nn(cherry picked from commit 26410896206342c8a80d2b027923e9ee7d33b733),CVE-2024-26938,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbtrfs: zoned: fix use-after-free in do_zone_finish()nnShinichiro reported the following use-after-free triggered by the devicenreplace operation in fstests btrfs/070.nn BTRFS info (device nullb1): scrub: finished on devid 1 with status: 0n ==================================================================n BUG: KASAN: slab-use-after-free in do_zone_finish+0x91a/0xb90 [btrfs]n Read of size 8 at addr ffff8881543c8060 by task btrfs-cleaner/3494007nn CPU: 0 PID: 3494007 Comm: btrfs-cleaner Tainted: G W 6.8.0-rc5-kts #1n Hardware name: Supermicro Super Server/X11SPi-TF BIOS 3.3 02/21/2020n Call Trace:n <TASK>n dump_stack_lvl+0x5b/0x90n print_report+0xcf/0x670n ? __virt_addr_valid+0x200/0x3e0n kasan_report+0xd8/0x110n ? do_zone_finish+0x91a/0xb90 [btrfs]n ? do_zone_finish+0x91a/0xb90 [btrfs]n do_zone_finish+0x91a/0xb90 [btrfs]n btrfs_delete_unused_bgs+0x5e1/0x1750 [btrfs]n ? __pfx_btrfs_delete_unused_bgs+0x10/0x10 [btrfs]n ? btrfs_put_root+0x2d/0x220 [btrfs]n ? btrfs_clean_one_deleted_snapshot+0x299/0x430 [btrfs]n cleaner_kthread+0x21e/0x380 [btrfs]n ? __pfx_cleaner_kthread+0x10/0x10 [btrfs]n kthread+0x2e3/0x3c0n ? __pfx_kthread+0x10/0x10n ret_from_fork+0x31/0x70n ? __pfx_kthread+0x10/0x10n ret_from_fork_asm+0x1b/0x30n </TASK>nn Allocated by task 3493983:n kasan_save_stack+0x33/0x60n kasan_save_track+0x14/0x30n __kasan_kmalloc+0xaa/0xb0n btrfs_alloc_device+0xb3/0x4e0 [btrfs]n device_list_add.constprop.0+0x993/0x1630 [btrfs]n btrfs_scan_one_device+0x219/0x3d0 [btrfs]n btrfs_control_ioctl+0x26e/0x310 [btrfs]n __x64_sys_ioctl+0x134/0x1b0n do_syscall_64+0x99/0x190n entry_SYSCALL_64_after_hwframe+0x6e/0x76nn Freed by task 3494056:n kasan_save_stack+0x33/0x60n kasan_save_track+0x14/0x30n kasan_save_free_info+0x3f/0x60n poison_slab_object+0x102/0x170n __kasan_slab_free+0x32/0x70n kfree+0x11b/0x320n btrfs_rm_dev_replace_free_srcdev+0xca/0x280 [btrfs]n btrfs_dev_replace_finishing+0xd7e/0x14f0 [btrfs]n btrfs_dev_replace_by_ioctl+0x1286/0x25a0 [btrfs]n btrfs_ioctl+0xb27/0x57d0 [btrfs]n __x64_sys_ioctl+0x134/0x1b0n do_syscall_64+0x99/0x190n entry_SYSCALL_64_after_hwframe+0x6e/0x76nn The buggy address belongs to the object at ffff8881543c8000n which belongs to the cache kmalloc-1k of size 1024n The buggy address is located 96 bytes inside ofn freed 1024-byte region [ffff8881543c8000 ffff8881543c8400)nn The buggy address belongs to the physical page:n page:00000000fe2c1285 refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x1543c8n head:00000000fe2c1285 order:3 entire_mapcount:0 nr_pages_mapped:0 pincount:0n flags: 0x17ffffc0000840(slab|head|node=0|zone=2|lastcpupid=0x1fffff)n page_type: 0xffffffff()n raw: 0017ffffc0000840 ffff888100042dc0 ffffea0019e8f200 dead000000000002n raw: 0000000000000000 0000000000100010 00000001ffffffff 0000000000000000n page dumped because: kasan: bad access detectednn Memory state around the buggy address:n ffff8881543c7f00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00n ffff8881543c7f80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00n >ffff8881543c8000: fa fb fb fb fb fb fb fb fb fb fb fb fb fb fb fbn ^n ffff8881543c8080: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fbn ffff8881543c8100: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fbnnThis UAF happens because we're accessing stale zone information of analready removed btrfs_device in do_zone_finish().nnThe sequence of events is as follows:nnbtrfs_dev_replace_startn btrfs_scrub_devn btrfs_dev_replace_finishingn btrfs_dev_replace_update_device_in_mapping_tree <-- devices replacedn btrfs_rm_dev_replace_free_srcdevn btrfs_free_device <-- device freednncleaner_kthreadn btrfs_delete_unused_bgsn btrfs_zone_finishn do_zone_finish <-- refers the freed devicennThe reason for this is that we're using an---truncated---,CVE-2024-26944,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnARM: 9359/1: flush: check if the folio is reserved for no-mapping addressesnnSince commit a4d5613c4dc6 (arm: extend pfn_valid to take into accountnfreed memory map alignment) changes the semantics of pfn_valid() to checknpresence of the memory map for a PFN. A valid page for an address whichnis reserved but not mapped by the kernel[1] the system crashed duringnsome uio test with the following memory layout:nn node 0: [mem 0x00000000c0a00000-0x00000000cc8fffff]n node 0: [mem 0x00000000d0000000-0x00000000da1fffff]n the uio layout is0xc0900000 0x100000nnthe crash backtrace like:nn Unable to handle kernel paging request at virtual address bff00000n [...]n CPU: 1 PID: 465 Comm: startapp.bin Tainted: G O 5.10.0 #1n Hardware name: Generic DT based systemn PC is at b15_flush_kern_dcache_area+0x24/0x3cn LR is at __sync_icache_dcache+0x6c/0x98n [...]n (b15_flush_kern_dcache_area) from (__sync_icache_dcache+0x6c/0x98)n (__sync_icache_dcache) from (set_pte_at+0x28/0x54)n (set_pte_at) from (remap_pfn_range+0x1a0/0x274)n (remap_pfn_range) from (uio_mmap+0x184/0x1b8 [uio])n (uio_mmap [uio]) from (__mmap_region+0x264/0x5f4)n (__mmap_region) from (__do_mmap_mm+0x3ec/0x440)n (__do_mmap_mm) from (do_mmap+0x50/0x58)n (do_mmap) from (vm_mmap_pgoff+0xfc/0x188)n (vm_mmap_pgoff) from (ksys_mmap_pgoff+0xac/0xc4)n (ksys_mmap_pgoff) from (ret_fast_syscall+0x0/0x5c)n Code: e0801001 e2423001 e1c00003 f57ff04f (ee070f3e)n ---[ end trace 09cf0734c3805d52 ]---n Kernel panic - not syncing: Fatal exceptionnnSo check if PG_reserved was set to solve this issue.nn[1]: https://lore.kernel.org/lkml/Zbtdue57RO0QScJM@linux.ibm.com/,CVE-2024-26947,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Add a dc_state NULL check in dc_state_releasenn[How]nCheck wheather state is NULL before releasing it.,CVE-2024-26948,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndm-raid456 md/raid456: fix a deadlock for dm-raid456 while io concurrent with reshapennFor raid456 if reshape is still in progress then IO across reshapenposition will wait for reshape to make progress. However for dm-raidnin following cases reshape will never make progress hence IO will hang:nn1) the array is read-only;n2) MD_RECOVERY_WAIT is set;n3) MD_RECOVERY_FROZEN is set;nnAfter commit c467e97f079f (md/raid6: use valid sector values to determinenif an I/O should wait on the reshape) fix the problem that IO acrossnreshape position doesn't wait for reshape the dm-raid testnshell/lvconvert-raid-reshape.sh start to hang:nn[root@fedora ~]# cat /proc/979/stackn[<0>] wait_woken+0x7d/0x90n[<0>] raid5_make_request+0x929/0x1d70 [raid456]n[<0>] md_handle_request+0xc2/0x3b0 [md_mod]n[<0>] raid_map+0x2c/0x50 [dm_raid]n[<0>] __map_bio+0x251/0x380 [dm_mod]n[<0>] dm_submit_bio+0x1f0/0x760 [dm_mod]n[<0>] __submit_bio+0xc2/0x1c0n[<0>] submit_bio_noacct_nocheck+0x17f/0x450n[<0>] submit_bio_noacct+0x2bc/0x780n[<0>] submit_bio+0x70/0xc0n[<0>] mpage_readahead+0x169/0x1f0n[<0>] blkdev_readahead+0x18/0x30n[<0>] read_pages+0x7c/0x3b0n[<0>] page_cache_ra_unbounded+0x1ab/0x280n[<0>] force_page_cache_ra+0x9e/0x130n[<0>] page_cache_sync_ra+0x3b/0x110n[<0>] filemap_get_pages+0x143/0xa30n[<0>] filemap_read+0xdc/0x4b0n[<0>] blkdev_read_iter+0x75/0x200n[<0>] vfs_read+0x272/0x460n[<0>] ksys_read+0x7a/0x170n[<0>] __x64_sys_read+0x1c/0x30n[<0>] do_syscall_64+0xc6/0x230n[<0>] entry_SYSCALL_64_after_hwframe+0x6c/0x74nnThis is because reshape can't make progress.nnFor md/raid the problem doesn't exist because register new sync_threadndoesn't rely on the IO to be done any more:nn1) If array is read-only it can switch to read-write by ioctl/sysfs;n2) md/raid never set MD_RECOVERY_WAIT;n3) If MD_RECOVERY_FROZEN is set mddev_suspend() doesn't holdn 'reconfig_mutex' hence it can be cleared and reshape can continue byn sysfs api 'sync_action'.nnHowever I'm not sure yet how to avoid the problem in dm-raid yet. Thisnpatch on the one hand make sure raid_message() can't changensync_thread() through raid_message() after presuspend() on the othernhand detect the above 3 cases before wait for IO do be done inndm_suspend() and let dm-raid requeue those IO.,CVE-2024-26962,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnSquashfs: check the inode number is not the invalid value of zeronnSyskiller has produced an out of bounds access in fill_meta_index().nnThat out of bounds access is ultimately caused because the inodenhas an inode number with the invalid value of zero which was not checked.nnThe reason this causes the out of bounds access is due to followingnsequence of events:nn1. Fill_meta_index() is called to allocate (via empty_meta_index())n and fill a metadata index. It however suffers a data read errorn and aborts invalidating the newly returned empty metadata index.n It does this by setting the inode number of the index to zeron which means unused (zero is not a valid inode number).nn2. When fill_meta_index() is subsequently called again on anothern read operation locate_meta_index() returns the previous indexn because it matches the inode number of 0. Because this indexn has been returned it is expected to have been filled and becausen it hasn't been an out of bounds access is performed.nnThis patch adds a sanity check which checks that the inode numbernis not zero when the inode is created and returns -EINVAL if it is.nn[phillip@squashfs.org.uk: whitespace fix],CVE-2024-26982,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnusb: gadget: f_ncm: Fix UAF ncm object at re-bind after usb ep transport errornnWhen ncm function is working and then stop usb0 interface for link downneth_stop() is called. At this piont accidentally if usb transport errornshould happen in usb_ep_enable() 'in_ep' and/or 'out_ep' may not be enabled.nnAfter that ncm_disable() is called to disable for ncm unbindnbut gether_disconnect() is never called since 'in_ep' is not enabled.nnAs the result ncm object is released in ncm unbindnbut 'dev->port_usb' associated to 'ncm->port' is not NULL.nnAnd when ncm bind again to recover netdev ncm object is reallocatednbut usb0 interface is already associated to previous released ncm object.nnTherefore once usb0 interface is up and eth_start_xmit() is callednreleased ncm object is dereferrenced and it might cause use-after-free memory.nn[function unlink via configfs]n usb0: eth_stop dev->port_usb=ffffff9b179c3200n --> error happens in usb_ep_enable().n NCM: ncm_disable: ncm=ffffff9b179c3200n --> no gether_disconnect() since ncm->port.in_ep->enabled is false.n NCM: ncm_unbind: ncm unbind ncm=ffffff9b179c3200n NCM: ncm_free: ncm free ncm=ffffff9b179c3200 <-- released ncmnn[function link via configfs]n NCM: ncm_alloc: ncm alloc ncm=ffffff9ac4f8a000n NCM: ncm_bind: ncm bind ncm=ffffff9ac4f8a000n NCM: ncm_set_alt: ncm=ffffff9ac4f8a000 alt=0n usb0: eth_open dev->port_usb=ffffff9b179c3200 <-- previous released ncmn usb0: eth_start dev->port_usb=ffffff9b179c3200 <--n eth_start_xmit()n --> dev->wrap()n Unable to handle kernel paging request at virtual address dead00000000014fnnThis patch addresses the issue by checking if 'ncm->netdev' is not NULL atnncm_disable() to call gether_disconnect() to deassociate 'dev->port_usb'.nIt's more reasonable to check 'ncm->netdev' to call gether_connect/disconnectnrather than check 'ncm->port.in_ep->enabled' since it might not be enablednbut the gether connection might be established.,CVE-2024-26996,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnclk: mediatek: Do a runtime PM get on controllers during probennmt8183-mfgcfg has a mutual dependency with genpd during the probingnstage which leads to a deadlock in the following call stack:nnCPU0: genpd_lock --> clk_prepare_lockngenpd_power_off_work_fn()n genpd_lock()n generic_pm_domain::power_off()n clk_unprepare()n clk_prepare_lock()nnCPU1: clk_prepare_lock --> genpd_locknclk_register()n __clk_core_init()n clk_prepare_lock()n clk_pm_runtime_get()n genpd_lock()nnDo a runtime PM get at the probe function to make sure clk_register()nwon't acquire the genpd lock. Instead of only modifying mt8183-mfgcfgndo this on all mediatek clock controller probings because we don'tnbelieve this would cause any regression.nnVerified on MT8183 and MT8192 Chromebooks.,CVE-2024-27002,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet/sched: Fix mirred deadlock on device recursionnnWhen the mirred action is used on a classful egress qdisc and a packet isnmirrored or redirected to self we hit a qdisc lock deadlock.nSee trace below.nn[..... other info removed for brevity....]n[ 82.890906]n[ 82.890906] ============================================n[ 82.890906] WARNING: possible recursive locking detectedn[ 82.890906] 6.8.0-05205-g77fadd89fe2d-dirty #213 Tainted: G Wn[ 82.890906] --------------------------------------------n[ 82.890906] ping/418 is trying to acquire lock:n[ 82.890906] ffff888006994110 (&sch->q.lock){+.-.}-{3:3} at:n__dev_queue_xmit+0x1778/0x3550n[ 82.890906]n[ 82.890906] but task is already holding lock:n[ 82.890906] ffff888006994110 (&sch->q.lock){+.-.}-{3:3} at:n__dev_queue_xmit+0x1778/0x3550n[ 82.890906]n[ 82.890906] other info that might help us debug this:n[ 82.890906] Possible unsafe locking scenario:n[ 82.890906]n[ 82.890906] CPU0n[ 82.890906] ----n[ 82.890906] lock(&sch->q.lock);n[ 82.890906] lock(&sch->q.lock);n[ 82.890906]n[ 82.890906] output.log scan_tyk_dockerimages.sh vulnerabilities.csv DEADLOCK ***n[ 82.890906]n[..... other info removed for brevity....]nnExample setup (eth0->eth0) to recreatentc qdisc add dev eth0 root handle 1: htb default 30ntc filter add dev eth0 handle 1: protocol ip prio 2 matchall n action mirred egress redirect dev eth0nnAnother example(eth0->eth1->eth0) to recreatentc qdisc add dev eth0 root handle 1: htb default 30ntc filter add dev eth0 handle 1: protocol ip prio 2 matchall n action mirred egress redirect dev eth1nntc qdisc add dev eth1 root handle 1: htb default 30ntc filter add dev eth1 handle 1: protocol ip prio 2 matchall n action mirred egress redirect dev eth0nnWe fix this by adding an owner field (CPU id) to struct Qdisc set afternroot qdisc is entered. When the softirq enters it a second time if thenqdisc owner is the same CPU the packet is dropped to break the loop.,CVE-2024-27010,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnetfilter: nf_tables: fix memleak in map from abort pathnnThe delete set command does not rely on the transaction object fornelement removal therefore a combination of delete element + delete setnfrom the abort path could result in restoring twice the refcount of thenmapping.nnCheck for inactive element in the next generation for the delete elementncommand in the abort path skip restoring state if next generation bitnhas been already cleared. This is similar to the activate logic usingnthe set walk iterator.nn[ 6170.286929] ------------[ cut here ]------------n[ 6170.286939] WARNING: CPU: 6 PID: 790302 at net/netfilter/nf_tables_api.c:2086 nf_tables_chain_destroy+0x1f7/0x220 [nf_tables]n[ 6170.287071] Modules linked in: [...]n[ 6170.287633] CPU: 6 PID: 790302 Comm: kworker/6:2 Not tainted 6.9.0-rc3+ #365n[ 6170.287768] RIP: 0010:nf_tables_chain_destroy+0x1f7/0x220 [nf_tables]n[ 6170.287886] Code: df 48 8d 7d 58 e8 69 2e 3b df 48 8b 7d 58 e8 80 1b 37 df 48 8d 7d 68 e8 57 2e 3b df 48 8b 7d 68 e8 6e 1b 37 df 48 89 ef eb c4 <0f> 0b 48 83 c4 08 5b 5d 41 5c 41 5d 41 5e 41 5f c3 cc cc cc cc 0fn[ 6170.287895] RSP: 0018:ffff888134b8fd08 EFLAGS: 00010202n[ 6170.287904] RAX: 0000000000000001 RBX: ffff888125bffb28 RCX: dffffc0000000000n[ 6170.287912] RDX: 0000000000000003 RSI: ffffffffa20298ab RDI: ffff88811ebe4750n[ 6170.287919] RBP: ffff88811ebe4700 R08: ffff88838e812650 R09: fffffbfff0623a55n[ 6170.287926] R10: ffffffff8311d2af R11: 0000000000000001 R12: ffff888125bffb10n[ 6170.287933] R13: ffff888125bffb10 R14: dead000000000122 R15: dead000000000100n[ 6170.287940] FS: 0000000000000000(0000) GS:ffff888390b00000(0000) knlGS:0000000000000000n[ 6170.287948] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033n[ 6170.287955] CR2: 00007fd31fc00710 CR3: 0000000133f60004 CR4: 00000000001706f0n[ 6170.287962] Call Trace:n[ 6170.287967] <TASK>n[ 6170.287973] ? __warn+0x9f/0x1a0n[ 6170.287986] ? nf_tables_chain_destroy+0x1f7/0x220 [nf_tables]n[ 6170.288092] ? report_bug+0x1b1/0x1e0n[ 6170.287986] ? nf_tables_chain_destroy+0x1f7/0x220 [nf_tables]n[ 6170.288092] ? report_bug+0x1b1/0x1e0n[ 6170.288104] ? handle_bug+0x3c/0x70n[ 6170.288112] ? exc_invalid_op+0x17/0x40n[ 6170.288120] ? asm_exc_invalid_op+0x1a/0x20n[ 6170.288132] ? nf_tables_chain_destroy+0x2b/0x220 [nf_tables]n[ 6170.288243] ? nf_tables_chain_destroy+0x1f7/0x220 [nf_tables]n[ 6170.288366] ? nf_tables_chain_destroy+0x2b/0x220 [nf_tables]n[ 6170.288483] nf_tables_trans_destroy_work+0x588/0x590 [nf_tables],CVE-2024-27011,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnetfilter: nf_tables: restore set elements when delete set failsnnFrom abort path nft_mapelem_activate() needs to restore refcounters tonthe original state. Currently it uses the set->ops->walk() to iteratenover these set elements. The existing set iterator skips inactivenelements in the next generation this does not work from the abort pathnto restore the original state since it has to skip active elementsninstead (not inactive ones).nnThis patch moves the check for inactive elements to the set iteratorncallback then it reverses the logic for the .activate case whichnneeds to skip active elements.nnToggle next generation bit for elements when delete set command isninvoked and call nft_clear() from .activate (abort) path to restore thennext generation bit.nnThe splat below shows an object in mappings memleak:nn[43929.457523] ------------[ cut here ]------------n[43929.457532] WARNING: CPU: 0 PID: 1139 at include/net/netfilter/nf_tables.h:1237 nft_setelem_data_deactivate+0xe4/0xf0 [nf_tables]n[...]n[43929.458014] RIP: 0010:nft_setelem_data_deactivate+0xe4/0xf0 [nf_tables]n[43929.458076] Code: 83 f8 01 77 ab 49 8d 7c 24 08 e8 37 5e d0 de 49 8b 6c 24 08 48 8d 7d 50 e8 e9 5c d0 de 8b 45 50 8d 50 ff 89 55 50 85 c0 75 86 <0f> 0b eb 82 0f 0b eb b3 0f 1f 40 00 90 90 90 90 90 90 90 90 90 90n[43929.458081] RSP: 0018:ffff888140f9f4b0 EFLAGS: 00010246n[43929.458086] RAX: 0000000000000000 RBX: ffff8881434f5288 RCX: dffffc0000000000n[43929.458090] RDX: 00000000ffffffff RSI: ffffffffa26d28a7 RDI: ffff88810ecc9550n[43929.458093] RBP: ffff88810ecc9500 R08: 0000000000000001 R09: ffffed10281f3e8fn[43929.458096] R10: 0000000000000003 R11: ffff0000ffff0000 R12: ffff8881434f52a0n[43929.458100] R13: ffff888140f9f5f4 R14: ffff888151c7a800 R15: 0000000000000002n[43929.458103] FS: 00007f0c687c4740(0000) GS:ffff888390800000(0000) knlGS:0000000000000000n[43929.458107] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033n[43929.458111] CR2: 00007f58dbe5b008 CR3: 0000000123602005 CR4: 00000000001706f0n[43929.458114] Call Trace:n[43929.458118] <TASK>n[43929.458121] ? __warn+0x9f/0x1a0n[43929.458127] ? nft_setelem_data_deactivate+0xe4/0xf0 [nf_tables]n[43929.458188] ? report_bug+0x1b1/0x1e0n[43929.458196] ? handle_bug+0x3c/0x70n[43929.458200] ? exc_invalid_op+0x17/0x40n[43929.458211] ? nft_setelem_data_deactivate+0xd7/0xf0 [nf_tables]n[43929.458271] ? nft_setelem_data_deactivate+0xe4/0xf0 [nf_tables]n[43929.458332] nft_mapelem_deactivate+0x24/0x30 [nf_tables]n[43929.458392] nft_rhash_walk+0xdd/0x180 [nf_tables]n[43929.458453] ? __pfx_nft_rhash_walk+0x10/0x10 [nf_tables]n[43929.458512] ? rb_insert_color+0x2e/0x280n[43929.458520] nft_map_deactivate+0xdc/0x1e0 [nf_tables]n[43929.458582] ? __pfx_nft_map_deactivate+0x10/0x10 [nf_tables]n[43929.458642] ? __pfx_nft_mapelem_deactivate+0x10/0x10 [nf_tables]n[43929.458701] ? __rcu_read_unlock+0x46/0x70n[43929.458709] nft_delset+0xff/0x110 [nf_tables]n[43929.458769] nft_flush_table+0x16f/0x460 [nf_tables]n[43929.458830] nf_tables_deltable+0x501/0x580 [nf_tables],CVE-2024-27012,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet/mlx5e: Prevent deadlock while disabling aRFSnnWhen disabling aRFS under the `priv->state_lock` any schedulednaRFS works are canceled using the `cancel_work_sync` functionnwhich waits for the work to end if it has already started.nHowever while waiting for the work handler the handler willntry to acquire the `state_lock` which is already acquired.nnThe worker acquires the lock to delete the rules if the statenis down which is not the worker's responsibility sincendisabling aRFS deletes the rules.nnAdd an aRFS state variable which indicates whether the aRFS isnenabled and prevent adding rules when the aRFS is disabled.nnKernel log:nn======================================================nWARNING: possible circular locking dependency detectedn6.7.0-rc4_net_next_mlx5_5483eb2 #1 Tainted: G In------------------------------------------------------nethtool/386089 is trying to acquire lock:nffff88810f21ce68 ((work_completion)(&rule->arfs_work)){+.+.}-{0:0} at: __flush_work+0x74/0x4e0nnbut task is already holding lock:nffff8884a1808cc0 (&priv->state_lock){+.+.}-{3:3} at: mlx5e_ethtool_set_channels+0x53/0x200 [mlx5_core]nnwhich lock already depends on the new lock.nnthe existing dependency chain (in reverse order) is:nn-> #1 (&priv->state_lock){+.+.}-{3:3}:n __mutex_lock+0x80/0xc90n arfs_handle_work+0x4b/0x3b0 [mlx5_core]n process_one_work+0x1dc/0x4a0n worker_thread+0x1bf/0x3c0n kthread+0xd7/0x100n ret_from_fork+0x2d/0x50n ret_from_fork_asm+0x11/0x20nn-> #0 ((work_completion)(&rule->arfs_work)){+.+.}-{0:0}:n __lock_acquire+0x17b4/0x2c80n lock_acquire+0xd0/0x2b0n __flush_work+0x7a/0x4e0n __cancel_work_timer+0x131/0x1c0n arfs_del_rules+0x143/0x1e0 [mlx5_core]n mlx5e_arfs_disable+0x1b/0x30 [mlx5_core]n mlx5e_ethtool_set_channels+0xcb/0x200 [mlx5_core]n ethnl_set_channels+0x28f/0x3b0n ethnl_default_set_doit+0xec/0x240n genl_family_rcv_msg_doit+0xd0/0x120n genl_rcv_msg+0x188/0x2c0n netlink_rcv_skb+0x54/0x100n genl_rcv+0x24/0x40n netlink_unicast+0x1a1/0x270n netlink_sendmsg+0x214/0x460n __sock_sendmsg+0x38/0x60n __sys_sendto+0x113/0x170n __x64_sys_sendto+0x20/0x30n do_syscall_64+0x40/0xe0n entry_SYSCALL_64_after_hwframe+0x46/0x4ennother info that might help us debug this:nn Possible unsafe locking scenario:nn CPU0 CPU1n ---- ----n lock(&priv->state_lock);n lock((work_completion)(&rule->arfs_work));n lock(&priv->state_lock);n lock((work_completion)(&rule->arfs_work));nn output.log scan_tyk_dockerimages.sh vulnerabilities.csv DEADLOCK ***nn3 locks held by ethtool/386089:n #0: ffffffff82ea7210 (cb_lock){++++}-{3:3} at: genl_rcv+0x15/0x40n #1: ffffffff82e94c88 (rtnl_mutex){+.+.}-{3:3} at: ethnl_default_set_doit+0xd3/0x240n #2: ffff8884a1808cc0 (&priv->state_lock){+.+.}-{3:3} at: mlx5e_ethtool_set_channels+0x53/0x200 [mlx5_core]nnstack backtrace:nCPU: 15 PID: 386089 Comm: ethtool Tainted: G I 6.7.0-rc4_net_next_mlx5_5483eb2 #1nHardware name: QEMU Standard PC (Q35 + ICH9 2009) BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014nCall Trace:n <TASK>n dump_stack_lvl+0x60/0xa0n check_noncircular+0x144/0x160n __lock_acquire+0x17b4/0x2c80n lock_acquire+0xd0/0x2b0n ? __flush_work+0x74/0x4e0n ? save_trace+0x3e/0x360n ? __flush_work+0x74/0x4e0n __flush_work+0x7a/0x4e0n ? __flush_work+0x74/0x4e0n ? __lock_acquire+0xa78/0x2c80n ? lock_acquire+0xd0/0x2b0n ? mark_held_locks+0x49/0x70n __cancel_work_timer+0x131/0x1c0n ? mark_held_locks+0x49/0x70n arfs_del_rules+0x143/0x1e0 [mlx5_core]n mlx5e_arfs_disable+0x1b/0x30 [mlx5_core]n mlx5e_ethtool_set_channels+0xcb/0x200 [mlx5_core]n ethnl_set_channels+0x28f/0x3b0n ethnl_default_set_doit+0xec/0x240n genl_family_rcv_msg_doit+0xd0/0x120n genl_rcv_msg+0x188/0x2c0n ? ethnn---truncated---,CVE-2024-27014,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnf2fs: fix to avoid potential panic during recoverynnDuring recovery if FAULT_BLOCK is on it is possible thatnf2fs_reserve_new_block() will return -ENOSPC during recoverynthen it may trigger panic.nnAlso if fault injection rate is 1 and only FAULT_BLOCK faultntype is on it may encounter deadloop in loop of block reservation.nnLet's change as below to fix these issues:n- remove bug_on() to avoid panic.n- limit the loop count of block reservation to avoid potentialndeadloop.,CVE-2024-27032,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnf2fs: compress: fix to cover normal cluster write with cp_rwsemnnWhen we overwrite compressed cluster w/ normal cluster we shouldnnot unlock cp_rwsem during f2fs_write_raw_pages() otherwise datanwill be corrupted if partial blocks were persisted before CP & SPORndue to cluster metadata wasn't updated atomically.,CVE-2024-27034,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnf2fs: compress: fix to guarantee persisting compressed blocks by CPnnIf data block in compressed cluster is not persisted with metadatanduring checkpoint after SPOR the data may be corrupted let'snguarantee to write compressed page by checkpoint.,CVE-2024-27035,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnclk: zynq: Prevent null pointer dereference caused by kmalloc failurennThe kmalloc() in zynq_clk_setup() will return null if thenphysical memory has run out. As a result if we use snprintf()nto write data to the null address the null pointer dereferencenbug will happen.nnThis patch uses a stack variable to replace the kmalloc().,CVE-2024-27037,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nns390/dasd: fix double module refcount decrementnnOnce the discipline is associated with the device deleting the devicentakes care of decrementing the module's refcount. Doing it manually onnthis error path causes refcount to artificially decrease on each errornwhile it should just stay the same.,CVE-2024-27054,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnwifi: iwlwifi: mvm: ensure offloading TID queue existsnnThe resume code path assumes that the TX queue for the offloading TIDnhas been configured. At resume time it then tries to sync the writenpointer as it may have been updated by the firmware.nnIn the unusual event that no packets have been send on TID 0 the queuenwill not have been allocated and this causes a crash. Fix this bynensuring the queue exist at suspend time.,CVE-2024-27056,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnouveau: lock the client object tree.nnIt appears the client object tree has no locking unless I've missednsomething else. Fix races around adding/removing client objectsnmostly vram bar mappings.nn 4562.099306] general protection fault probably for non-canonical address 0x6677ed422bceb80c: 0000 [#1] PREEMPT SMP PTIn[ 4562.099314] CPU: 2 PID: 23171 Comm: deqp-vk Not tainted 6.8.0-rc6+ #27n[ 4562.099324] Hardware name: Gigabyte Technology Co. Ltd. Z390 I AORUS PRO WIFI/Z390 I AORUS PRO WIFI-CF BIOS F8 11/05/2021n[ 4562.099330] RIP: 0010:nvkm_object_search+0x1d/0x70 [nouveau]n[ 4562.099503] Code: 90 90 90 90 90 90 90 90 90 90 90 90 90 66 0f 1f 00 0f 1f 44 00 00 48 89 f8 48 85 f6 74 39 48 8b 87 a0 00 00 00 48 85 c0 74 12 <48> 8b 48 f8 48 39 ce 73 15 48 8b 40 10 48 85 c0 75 ee 48 c7 c0 fen[ 4562.099506] RSP: 0000:ffffa94cc420bbf8 EFLAGS: 00010206n[ 4562.099512] RAX: 6677ed422bceb814 RBX: ffff98108791f400 RCX: ffff9810f26b8f58n[ 4562.099517] RDX: 0000000000000000 RSI: ffff9810f26b9158 RDI: ffff98108791f400n[ 4562.099519] RBP: ffff9810f26b9158 R08: 0000000000000000 R09: 0000000000000000n[ 4562.099521] R10: ffffa94cc420bc48 R11: 0000000000000001 R12: ffff9810f02a7cc0n[ 4562.099526] R13: 0000000000000000 R14: 00000000000000ff R15: 0000000000000007n[ 4562.099528] FS: 00007f629c5017c0(0000) GS:ffff98142c700000(0000) knlGS:0000000000000000n[ 4562.099534] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033n[ 4562.099536] CR2: 00007f629a882000 CR3: 000000017019e004 CR4: 00000000003706f0n[ 4562.099541] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000n[ 4562.099542] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400n[ 4562.099544] Call Trace:n[ 4562.099555] <TASK>n[ 4562.099573] ? die_addr+0x36/0x90n[ 4562.099583] ? exc_general_protection+0x246/0x4a0n[ 4562.099593] ? asm_exc_general_protection+0x26/0x30n[ 4562.099600] ? nvkm_object_search+0x1d/0x70 [nouveau]n[ 4562.099730] nvkm_ioctl+0xa1/0x250 [nouveau]n[ 4562.099861] nvif_object_map_handle+0xc8/0x180 [nouveau]n[ 4562.099986] nouveau_ttm_io_mem_reserve+0x122/0x270 [nouveau]n[ 4562.100156] ? dma_resv_test_signaled+0x26/0xb0n[ 4562.100163] ttm_bo_vm_fault_reserved+0x97/0x3c0 [ttm]n[ 4562.100182] ? __mutex_unlock_slowpath+0x2a/0x270n[ 4562.100189] nouveau_ttm_fault+0x69/0xb0 [nouveau]n[ 4562.100356] __do_fault+0x32/0x150n[ 4562.100362] do_fault+0x7c/0x560n[ 4562.100369] __handle_mm_fault+0x800/0xc10n[ 4562.100382] handle_mm_fault+0x17c/0x3e0n[ 4562.100388] do_user_addr_fault+0x208/0x860n[ 4562.100395] exc_page_fault+0x7f/0x200n[ 4562.100402] asm_exc_page_fault+0x26/0x30n[ 4562.100412] RIP: 0033:0x9b9870n[ 4562.100419] Code: 85 a8 f7 ff ff 8b 8d 80 f7 ff ff 89 08 e9 18 f2 ff ff 0f 1f 84 00 00 00 00 00 44 89 32 e9 90 fa ff ff 0f 1f 84 00 00 00 00 00 <44> 89 32 e9 f8 f1 ff ff 0f 1f 84 00 00 00 00 00 66 44 89 32 e9 e7n[ 4562.100422] RSP: 002b:00007fff9ba2dc70 EFLAGS: 00010246n[ 4562.100426] RAX: 0000000000000004 RBX: 000000000dd65e10 RCX: 000000fff0000000n[ 4562.100428] RDX: 00007f629a882000 RSI: 00007f629a882000 RDI: 0000000000000066n[ 4562.100432] RBP: 00007fff9ba2e570 R08: 0000000000000000 R09: 0000000123ddf000n[ 4562.100434] R10: 0000000000000001 R11: 0000000000000246 R12: 000000007fffffffn[ 4562.100436] R13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000000n[ 4562.100446] </TASK>n[ 4562.100448] Modules linked in: nf_conntrack_netbios_ns nf_conntrack_broadcast nft_fib_inet nft_fib_ipv4 nft_fib_ipv6 nft_fib nft_reject_inet nf_reject_ipv4 nf_reject_ipv6 nft_reject nft_ct nft_chain_nat nf_nat nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 ip_set nf_tables libcrc32c nfnetlink cmac bnep sunrpc iwlmvm intel_rapl_msr intel_rapl_common snd_sof_pci_intel_cnl x86_pkg_temp_thermal intel_powerclamp snd_sof_intel_hda_common mac80211 coretemp snd_soc_acpi_intel_match kvm_intel snd_soc_acpi snd_soc_hdac_hda snd_sof_pci snd_sof_xtensa_dsp snd_sof_intel_hda_mlink n---truncated---,CVE-2024-27062,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnpstore: inode: Only d_invalidate() is needednnUnloading a modular pstore backend with records in pstorefs wouldntrigger the dput() double-drop warning:nn WARNING: CPU: 0 PID: 2569 at fs/dcache.c:762 dput.part.0+0x3f3/0x410nnUsing the combo of d_drop()/dput() (as mentioned innDocumentation/filesystems/vfs.rst) isn't the right approach here andnleads to the reference counting problem seen above. Use d_invalidate()nand update the code to not bother checking for error codes that cannnever happen.nn---,CVE-2024-27389,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnxen-netfront: Add missing skb_mark_for_recyclennNotice that skb_mark_for_recycle() is introduced later than fixes tag inncommit 6a5bcd84e886 (page_pool: Allow drivers to hint on SKB recycling).nnIt is believed that fixes tag were missing a call to page_pool_release_page()nbetween v5.9 to v5.14 after which is should have used skb_mark_for_recycle().nSince v6.6 the call page_pool_release_page() were removed (inncommit 535b9c61bdef (net: page_pool: hide page_pool_release_page())nand remaining callers converted (in commit 6bfef2ec0172 (Merge branchn'net-page_pool-remove-page_pool_release_page')).nnThis leak became visible in v6.8 via commit dba1b8a7ab68 (mm/page_pool: catchnpage_pool memory leaks).,CVE-2024-27393,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnphonet/pep: fix racy skb_queue_empty() usennThe receive queues are protected by their respective spin-lock notnthe socket lock. This could lead to skb_peek() unexpectedlynreturning NULL or a pointer to an already dequeued socket buffer.,CVE-2024-27402,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnetfilter: nft_flow_offload: reset dst in route object after setting up flownndst is transferred to the flow object route object does not own itnanymore. Reset dst in route object otherwise if flow_offload_add()nfails error path releases dst twice leading to a refcount underflow.,CVE-2024-27403,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndmaengine: dw-edma: eDMA: Add sync read before starting the DMA transfer in remote setupnnThe Linked list element and pointer are not stored in the same memory asnthe eDMA controller register. If the doorbell register is toggled beforenthe full write of the linked list a race condition error will occur.nIn remote setup we can only use a readl to the memory to assure the fullnwrite has occurred.,CVE-2024-27408,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnetfilter: bridge: confirm multicast packets before passing them up the stacknnconntrack nf_confirm logic cannot handle cloned skbs referencingnthe same nf_conn entry which will happen for multicast (broadcast)nframes on bridges.nn Example:n macvlan0n |n br0n / n ethX ethYnn ethX (or Y) receives a L2 multicast or broadcast packet containingn an IP packet flow is not yet in conntrack table.nn 1. skb passes through bridge and fake-ip (br_netfilter)Prerouting.n -> skb->_nfct now references a unconfirmed entryn 2. skb is broad/mcast packet. bridge now passes clones out on each bridgen interface.n 3. skb gets passed up the stack.n 4. In macvlan case macvlan driver retains clone(s) of the mcast skbn and schedules a work queue to send them out on the lower devices.nn The clone skb->_nfct is not a copy it is the same entry as then original skb. The macvlan rx handler then returns RX_HANDLER_PASS.n 5. Normal conntrack hooks (in NF_INET_LOCAL_IN) confirm the orig skb.nnThe Macvlan broadcast worker and normal confirm path will race.nnThis race will not happen if step 2 already confirmed a clone. In thatncase later steps perform skb_clone() with skb->_nfct already confirmed (innhash table). This works fine.nnBut such confirmation won't happen when eb/ip/nftables rules dropped thenpackets before they reached the nf_confirm step in postrouting.nnPablo points out that nf_conntrack_bridge doesn't allow use of statefulnnat so we can safely discard the nf_conn entry and let inet callnconntrack again.nnThis doesn't work for bridge netfilter: skb could have a natntransformation. Also bridge nf prevents re-invocation of inet preroutingnvia 'sabotage_in' hook.nnWork around this problem by explicit confirmation of the entry at LOCAL_INntime before upper layer has a chance to clone the unconfirmed entry.nnThe downside is that this disables NAT and conntrack helpers.nnAlternative fix would be to add locking to all code parts that deal withnunconfirmed packets but even if that could be done in a sane way thisnopens up other problems for example:nn-m physdev --physdev-out eth0 -j SNAT --snat-to 1.2.3.4n-m physdev --physdev-out eth1 -j SNAT --snat-to 1.2.3.5nnFor multicast case only one of such conflicting mappings will bencreated conntrack only handles 1:1 NAT mappings.nnUsers should set create a setup that explicitly marks such trafficnNOTRACK (conntrack bypass) to avoid this but we cannot auto-bypassnthem ruleset might have accept rules for untracked traffic alreadynso user-visible behaviour would change.,CVE-2024-27415,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbtrfs: fix deadlock with fiemap and extent lockingnnWhile working on the patchset to remove extent locking I got a lockdepnsplat with fiemap and pagefaulting with my new extent lock replacementnlock.nnThis deadlock exists with our normal code we just don't have lockdepnannotations with the extent locking so we've never noticed it.nnSince we're copying the fiemap extent to user space on every iterationnwe have the chance of pagefaulting. Because we hold the extent lock fornthe entire range we could mkwrite into a range in the file that we havenmmap'ed. This would deadlock with the following stack tracenn[<0>] lock_extent+0x28d/0x2f0n[<0>] btrfs_page_mkwrite+0x273/0x8a0n[<0>] do_page_mkwrite+0x50/0xb0n[<0>] do_fault+0xc1/0x7b0n[<0>] __handle_mm_fault+0x2fa/0x460n[<0>] handle_mm_fault+0xa4/0x330n[<0>] do_user_addr_fault+0x1f4/0x800n[<0>] exc_page_fault+0x7c/0x1e0n[<0>] asm_exc_page_fault+0x26/0x30n[<0>] rep_movs_alternative+0x33/0x70n[<0>] _copy_to_user+0x49/0x70n[<0>] fiemap_fill_next_extent+0xc8/0x120n[<0>] emit_fiemap_extent+0x4d/0xa0n[<0>] extent_fiemap+0x7f8/0xad0n[<0>] btrfs_fiemap+0x49/0x80n[<0>] __x64_sys_ioctl+0x3e1/0xb50n[<0>] do_syscall_64+0x94/0x1a0n[<0>] entry_SYSCALL_64_after_hwframe+0x6e/0x76nnI wrote an fstest to reproduce this deadlock without my replacement locknand verified that the deadlock exists with our existing locking.nnTo fix this simply don't take the extent lock for the entire duration ofnthe fiemap. This is safe in general because we keep track of where wenare when we're searching the tree so if an ordered extent updates innthe middle of our fiemap call we'll still emit the correct extentsnbecause we know what offset we were on before.nnThe only place we maintain the lock is searching delalloc. Since thendelalloc stuff can change during writeback we want to lock the extentnrange so we have a consistent view of delalloc at the time we'renchecking to see if we need to set the delalloc flag.nnWith this patch applied we no longer deadlock with my testcase.,CVE-2024-35784,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnusb: typec: altmodes/displayport: create sysfs nodes as driver's default device attribute groupnnThe DisplayPort driver's sysfs nodes may be present to the userspace beforentypec_altmode_set_drvdata() completes in dp_altmode_probe. This means thatna sysfs read can trigger a NULL pointer error by deferencing dp->hpd innhpd_show or dp->lock in pin_assignment_show as dev_get_drvdata() returnsnNULL in those cases.nnRemove manual sysfs node creation in favor of adding attribute group asndefault for devices bound to the driver. The ATTRIBUTE_GROUPS() macro isnnot used here otherwise the path to the sysfs nodes is no longer compliantnwith the ABI.,CVE-2024-35790,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndm-raid: really frozen sync_thread during suspendnn1) commit f52f5c71f3d4 (md: fix stopping sync thread) removen MD_RECOVERY_FROZEN from __md_stop_writes() and doesn't realize thatn dm-raid relies on __md_stop_writes() to frozen sync_threadn indirectly. Fix this problem by adding MD_RECOVERY_FROZEN inn md_stop_writes() and since stop_sync_thread() is only used forn dm-raid in this case also move stop_sync_thread() ton md_stop_writes().n2) The flag MD_RECOVERY_FROZEN doesn't mean that sync thread is frozenn it only prevent new sync_thread to start and it can't stop then running sync thread; In order to frozen sync_thread after seting then flag stop_sync_thread() should be used.n3) The flag MD_RECOVERY_FROZEN doesn't mean that writes are stopped usen it as condition for md_stop_writes() in raid_postsuspend() doesn'tn look correct. Consider that reentrant stop_sync_thread() do nothingn always call md_stop_writes() in raid_postsuspend().n4) raid_message can set/clear the flag MD_RECOVERY_FROZEN at anytimen and if MD_RECOVERY_FROZEN is cleared while the array is suspendedn new sync_thread can start unexpected. Fix this by disallown raid_message() to change sync_thread status during suspend.nnNote that after commit f52f5c71f3d4 (md: fix stopping sync thread) thentest shell/lvconvert-raid-reshape.sh start to hang in stop_sync_thread()nand with previous fixes the test won't hang there anymore however thentest will still fail and complain that ext4 is corrupted. And with thisnpatch the test won't hang due to stop_sync_thread() or fail due to ext4nis corrupted anymore. However there is still a deadlock related tondm-raid456 that will be fixed in following patches.,CVE-2024-35794,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Prevent crash when disable streamnn[Why]nDisabling stream encoder invokes a function that no longer exists.nn[How]nCheck if the function declaration is NULL in disable stream encoder.,CVE-2024-35799,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnx86/efistub: Call mixed mode boot services on the firmware's stacknnNormally the EFI stub calls into the EFI boot services using the stacknthat was live when the stub was entered. According to the UEFI specnthis stack needs to be at least 128k in size - this might seem large butnall asynchronous processing and event handling in EFI runs from the samenstack and so quite a lot of space may be used in practice.nnIn mixed mode the situation is a bit different: the bootloader callsnthe 32-bit EFI stub entry point which calls the decompressor's 32-bitnentry point where the boot stack is set up using a fixed allocationnof 16k. This stack is still in use when the EFI stub is started inn64-bit mode and so all calls back into the EFI firmware will be usingnthe decompressor's limited boot stack.nnDue to the placement of the boot stack right after the boot heap anynstack overruns have gone unnoticed. However commitnn 5c4feadb0011983b (x86/decompressor: Move global symbol references to C code)nnmoved the definition of the boot heap into C code and now the bootnstack is placed right at the base of BSS where any overruns willncorrupt the end of the .data section.nnWhile it would be possible to work around this by increasing the size ofnthe boot stack doing so would affect all x86 systems and mixed modensystems are a tiny (and shrinking) fraction of the x86 installed base.nnSo instead record the firmware stack pointer value when entering fromnthe 32-bit firmware and switch to this stack every time a EFI bootnservice call is made.,CVE-2024-35803,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnmd/dm-raid: don't call md_reap_sync_thread() directlynnCurrently md_reap_sync_thread() is called from raid_message() directlynwithout holding 'reconfig_mutex' this is definitely unsafe becausenmd_reap_sync_thread() can change many fields that is protected byn'reconfig_mutex'.nnHowever hold 'reconfig_mutex' here is still problematic because thisnwill cause deadlock for example commit 130443d60b1b (md: refactornidle/frozen_sync_thread() to fix deadlock).nnFix this problem by using stop_sync_thread() to unregister sync_threadnlike md/raid did.,CVE-2024-35808,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amdgpu: amdgpu_ttm_gart_bind set gtt bound flagnnOtherwise after the GTT bo is released the GTT and gart space is freednbut amdgpu_ttm_backend_unbind will not clear the gart page table entrynand leave valid mapping entry pointing to the stale system page. Thennif GPU access the gart address mistakely it will read undefined valueninstead page fault harder to debug and reproduce the real issue.,CVE-2024-35817,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnblock: Fix page refcounts for unaligned buffers in __bio_release_pages()nnFix an incorrect number of pages being released for buffers that do notnstart at the beginning of a page.,CVE-2024-35826,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnetfilter: bridge: replace physindev with physinif in nf_bridge_infonnAn skb can be added to a neigh->arp_queue while waiting for an arpnreply. Where original skb's skb->dev can be different to neigh'snneigh->dev. For instance in case of bridging dnated skb from one veth tonanother the skb would be added to a neigh->arp_queue of the bridge.nnAs skb->dev can be reset back to nf_bridge->physindev and used and asnthere is no explicit mechanism that prevents this physindev from beennfreed under us (for instance neigh_flush_dev doesn't cleanup skbs fromndifferent device's neigh queue) we can crash on e.g. this stack:nnarp_processn neigh_updaten skb = __skb_dequeue(&neigh->arp_queue)n neigh_resolve_output(... skb)n ...n br_nf_dev_xmitn br_nf_pre_routing_finish_bridge_slown skb->dev = nf_bridge->physindevn br_handle_frame_finishnnLet's use plain ifindex instead of net_device link. To peek into thenoriginal net_device we will use dev_get_by_index_rcu(). Thus either wenget device and are safe to use it or we don't get it and drop skb.,CVE-2024-35839,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnmptcp: use OPTION_MPTCP_MPJ_SYNACK in subflow_finish_connect()nnsubflow_finish_connect() uses four fields (backup join_id thmac none)nthat may contain garbage unless OPTION_MPTCP_MPJ_SYNACK has been setnin mptcp_parse_option(),CVE-2024-35840,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nniommu/vt-d: Use device rbtree in iopf reporting pathnnThe existing I/O page fault handler currently locates the PCI device byncalling pci_get_domain_bus_and_slot(). This function searches the listnof all PCI devices until the desired device is found. To improve lookupnefficiency replace it with device_rbtree_find() to search the devicenwithin the probed device rbtree.nnThe I/O page fault is initiated by the device which does not have anynsynchronization mechanism with the software to ensure that the devicenstays in the probed device tree. Theoretically a device could be releasednby the IOMMU subsystem after device_rbtree_find() and beforeniopf_get_dev_fault_param() which would cause a use-after-free problem.nnAdd a mutex to synchronize the I/O page fault reporting path and the IOMMUnrelease device path. This lock doesn't introduce any performance overheadnas the conflict between I/O page fault reporting and device releasing isnvery rare.,CVE-2024-35843,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnf2fs: compress: fix reserve_cblocks counting error when out of spacennWhen a file only needs one direct_node performing the followingnoperations will cause the file to be unrepairable:nnunisoc # ./f2fs_io compress test.apknunisoc #df -h | grep dm-48n/dev/block/dm-48 112G 112G 1.2M 100% /datannunisoc # ./f2fs_io release_cblocks test.apkn924nunisoc # df -h | grep dm-48n/dev/block/dm-48 112G 112G 4.8M 100% /datannunisoc # dd if=/dev/random of=file4 bs=1M count=3n3145728 bytes (3.0 M) copied 0.025 s 120 M/snunisoc # df -h | grep dm-48n/dev/block/dm-48 112G 112G 1.8M 100% /datannunisoc # ./f2fs_io reserve_cblocks test.apknF2FS_IOC_RESERVE_COMPRESS_BLOCKS failed: No space left on devicennadb rebootnunisoc # df -h | grep dm-48n/dev/block/dm-48 112G 112G 11M 100% /datanunisoc # ./f2fs_io reserve_cblocks test.apkn0nnThis is because the file has only one direct_node. After returningnto -ENOSPC reserved_blocks += ret will not be executed. As a resultnthe reserved_blocks at this time is still 0 which is not the realnnumber of reserved blocks. Therefore fsck cannot be set to repairnthe file.nnAfter this patch the fsck flag will be set to fix this problem.nnunisoc # df -h | grep dm-48n/dev/block/dm-48 112G 112G 1.8M 100% /datanunisoc # ./f2fs_io reserve_cblocks test.apknF2FS_IOC_RESERVE_COMPRESS_BLOCKS failed: No space left on devicennadb reboot then fsck will be executednunisoc # df -h | grep dm-48n/dev/block/dm-48 112G 112G 11M 100% /datanunisoc # ./f2fs_io reserve_cblocks test.apkn924,CVE-2024-35844,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnsmb: client: fix potential UAF in cifs_signal_cifsd_for_reconnect()nnSkip sessions that are being teared down (status == SES_EXITING) tonavoid UAF.,CVE-2024-35861,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnsmb: client: fix potential UAF in smb2_is_network_name_deleted()nnSkip sessions that are being teared down (status == SES_EXITING) tonavoid UAF.,CVE-2024-35862,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnsmb: client: fix potential UAF in is_valid_oplock_break()nnSkip sessions that are being teared down (status == SES_EXITING) tonavoid UAF.,CVE-2024-35863,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnsmb: client: fix potential UAF in smb2_is_valid_lease_break()nnSkip sessions that are being teared down (status == SES_EXITING) tonavoid UAF.,CVE-2024-35864,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnsmb: client: fix potential UAF in smb2_is_valid_oplock_break()nnSkip sessions that are being teared down (status == SES_EXITING) tonavoid UAF.,CVE-2024-35865,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnsmb: client: fix potential UAF in cifs_dump_full_key()nnSkip sessions that are being teared down (status == SES_EXITING) tonavoid UAF.,CVE-2024-35866,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnsmb: client: fix potential UAF in cifs_stats_proc_show()nnSkip sessions that are being teared down (status == SES_EXITING) tonavoid UAF.,CVE-2024-35867,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnsmb: client: fix potential UAF in cifs_stats_proc_write()nnSkip sessions that are being teared down (status == SES_EXITING) tonavoid UAF.,CVE-2024-35868,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnsmb: client: guarantee refcounted children from parent sessionnnAvoid potential use-after-free bugs when walking DFS referralsnmounting and performing DFS failover by ensuring that all childrennfrom parent @tcon->ses are also refcounted. They're all needed acrossnthe entire DFS mount. Get rid of @tcon->dfs_ses_list while we're atnit too.,CVE-2024-35869,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnsmb: client: fix UAF in smb2_reconnect_server()nnThe UAF bug is due to smb2_reconnect_server() accessing a session thatnis already being teared down by another thread that is executingn__cifs_put_smb_ses(). This can happen when (a) the client hasnconnection to the server but no session or (b) another thread ends upnsetting @ses->ses_status again to something different thannSES_EXITING.nnTo fix this we need to make sure to unconditionally setn@ses->ses_status to SES_EXITING and prevent any other threads fromnsetting a new status while we're still tearing it down.nnThe following can be reproduced by adding some delay to right afternthe ipc is freed in __cifs_put_smb_ses() - which will givensmb2_reconnect_server() worker a chance to run and then accessingn@ses->ipc:nnkinit ...nmount.cifs //srv/share /mnt/1 -o sec=krb5nohandlecacheecho_interval=10n[disconnect srv]nls /mnt/1 &>/dev/nullnsleep 30nkdestroyn[reconnect srv]nsleep 10numount /mnt/1n...nCIFS: VFS: Verify user has a krb5 ticket and keyutils is installednCIFS: VFS: srv Send error in SessSetup = -126nCIFS: VFS: Verify user has a krb5 ticket and keyutils is installednCIFS: VFS: srv Send error in SessSetup = -126ngeneral protection fault probably for non-canonical addressn0x6b6b6b6b6b6b6b6b: 0000 [#1] PREEMPT SMP NOPTInCPU: 3 PID: 50 Comm: kworker/3:1 Not tainted 6.9.0-rc2 #1nHardware name: QEMU Standard PC (Q35 + ICH9 2009) BIOS 1.16.3-1.fc39n04/01/2014nWorkqueue: cifsiod smb2_reconnect_server [cifs]nRIP: 0010:__list_del_entry_valid_or_report+0x33/0xf0nCode: 4f 08 48 85 d2 74 42 48 85 c9 74 59 48 b8 00 01 00 00 00 00 adnde 48 39 c2 74 61 48 b8 22 01 00 00 00 00 74 69 <48> 8b 01 48 39 f8 75n7b 48 8b 72 08 48 39 c6 0f 85 88 00 00 00 b8nRSP: 0018:ffffc900001bfd70 EFLAGS: 00010a83nRAX: dead000000000122 RBX: ffff88810da53838 RCX: 6b6b6b6b6b6b6b6bnRDX: 6b6b6b6b6b6b6b6b RSI: ffffffffc02f6878 RDI: ffff88810da53800nRBP: ffff88810da53800 R08: 0000000000000001 R09: 0000000000000000nR10: 0000000000000000 R11: 0000000000000001 R12: ffff88810c064000nR13: 0000000000000001 R14: ffff88810c064000 R15: ffff8881039cc000nFS: 0000000000000000(0000) GS:ffff888157c00000(0000)nknlGS:0000000000000000nCS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033nCR2: 00007fe3728b1000 CR3: 000000010caa4000 CR4: 0000000000750ef0nPKRU: 55555554nCall Trace:n <TASK>n ? die_addr+0x36/0x90n ? exc_general_protection+0x1c1/0x3f0n ? asm_exc_general_protection+0x26/0x30n ? __list_del_entry_valid_or_report+0x33/0xf0n __cifs_put_smb_ses+0x1ae/0x500 [cifs]n smb2_reconnect_server+0x4ed/0x710 [cifs]n process_one_work+0x205/0x6b0n worker_thread+0x191/0x360n ? __pfx_worker_thread+0x10/0x10n kthread+0xe2/0x110n ? __pfx_kthread+0x10/0x10n ret_from_fork+0x34/0x50n ? __pfx_kthread+0x10/0x10n ret_from_fork_asm+0x1a/0x30n </TASK>,CVE-2024-35870,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnx86/coco: Require seeding RNG with RDRAND on CoCo systemsnnThere are few uses of CoCo that don't rely on working cryptography andnhence a working RNG. Unfortunately the CoCo threat model means that thenVM host cannot be trusted and may actively work against guests tonextract secrets or manipulate computation. Since a malicious host cannmodify or observe nearly all inputs to guests the only remaining sourcenof entropy for CoCo guests is RDRAND.nnIf RDRAND is broken -- due to CPU hardware fault -- the RNG as a wholenis meant to gracefully continue on gathering entropy from other sourcesnbut since there aren't other sources on CoCo this is catastrophic.nThis is mostly a concern at boot time when initially seeding the RNG asnafter that the consequences of a broken RDRAND are much morentheoretical.nnSo try at boot to seed the RNG using 256 bits of RDRAND output. If thisnfails panic(). This will also trigger if the system is booted withoutnRDRAND as RDRAND is essential for a safe CoCo boot.nnAdd this deliberately to be just a CoCo x86 driver feature and notnpart of the RNG itself. Many device drivers and platforms have somendesire to contribute something to the RNG and add_device_randomness()nis specifically meant for this purpose.nnAny driver can call it with seed data of any quality or even garbagenquality and it can only possibly make the quality of the RNG better ornhave no effect but can never make it worse.nnRather than trying to build something into the core of the RNG considernthe particular CoCo issue just a CoCo issue and therefore separate itnall out into driver (well arch/platform) code.nn [ bp: Massage commit message. ],CVE-2024-35875,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnof: module: prevent NULL pointer dereference in vsnprintf()nnIn of_modalias() we can get passed the str and len parameters which wouldncause a kernel oops in vsnprintf() since it only allows passing a NULL ptrnwhen the length is also 0. Also we need to filter out the negative valuesnof the len parameter as these will result in a really huge buffer sincensnprintf() takes size_t parameter while ours is ssize_t...nnFound by Linux Verification Center (linuxtesting.org) with the Svace staticnanalysis tool.,CVE-2024-35878,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnax25: fix use-after-free bugs caused by ax25_ds_del_timernnWhen the ax25 device is detaching the ax25_dev_device_down()ncalls ax25_ds_del_timer() to cleanup the slave_timer. Whennthe timer handler is running the ax25_ds_del_timer() thatncalls del_timer() in it will return directly. As a resultnthe use-after-free bugs could happen one of the scenariosnis shown below:nn (Thread 1) | (Thread 2)n | ax25_ds_timeout()nax25_dev_device_down() |n ax25_ds_del_timer() |n del_timer() |n ax25_dev_put() //FREE |n | ax25_dev-> //USEnnIn order to mitigate bugs when the device is detaching usentimer_shutdown_sync() to stop the timer.,CVE-2024-35887,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnselinux: avoid dereference of garbage after mount failurennIn case kern_mount() fails and returns an error pointer return in thenerror branch instead of continuing and dereferencing the error pointer.nnWhile on it drop the never read static variable selinuxfs_mount.,CVE-2024-35904,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnusb: typec: ucsi: Limit read size on v1.2nnBetween UCSI 1.2 and UCSI 2.0 the size of the MESSAGE_IN region wasnincreased from 16 to 256. In order to avoid overflowing reads for oldernsystems add a mechanism to use the read UCSI version to truncate readnsizes on UCSI v1.2.,CVE-2024-35924,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm: Check output polling initialized before disablingnnIn drm_kms_helper_poll_disable() check if output pollingnsupport is initialized before disabling polling. If not flagnthis as a warning.nAdditionally in drm_mode_config_helper_suspend() andndrm_mode_config_helper_resume() calls that re the callers of thesenfunctions avoid invoking them if polling is not initialized.nFor drivers like hyperv-drm that do not initialize connectornpolling if suspend is called without this check it leads tonsuspend failure with following stackn[ 770.719392] Freezing remaining freezable tasks ... (elapsed 0.001 seconds) done.n[ 770.720592] printk: Suspending console(s) (use no_console_suspend to debug)n[ 770.948823] ------------[ cut here ]------------n[ 770.948824] WARNING: CPU: 1 PID: 17197 at kernel/workqueue.c:3162 __flush_work.isra.0+0x212/0x230n[ 770.948831] Modules linked in: rfkill nft_counter xt_conntrack xt_owner udf nft_compat crc_itu_t nft_fib_inet nft_fib_ipv4 nft_fib_ipv6 nft_fib nft_reject_inet nf_reject_ipv4 nf_reject_ipv6 nft_reject nft_ct nft_chain_nat nf_nat nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 ip_set nf_tables nfnetlink vfat fat mlx5_ib ib_uverbs ib_core mlx5_core intel_rapl_msr intel_rapl_common kvm_amd ccp mlxfw kvm psample hyperv_drm tls drm_shmem_helper drm_kms_helper irqbypass pcspkr syscopyarea sysfillrect sysimgblt hv_balloon hv_utils joydev drm fuse xfs libcrc32c pci_hyperv pci_hyperv_intf sr_mod sd_mod cdrom t10_pi sg hv_storvsc scsi_transport_fc hv_netvsc serio_raw hyperv_keyboard hid_hyperv crct10dif_pclmul crc32_pclmul crc32c_intel hv_vmbus ghash_clmulni_intel dm_mirror dm_region_hash dm_log dm_modn[ 770.948863] CPU: 1 PID: 17197 Comm: systemd-sleep Not tainted 5.14.0-362.2.1.el9_3.x86_64 #1n[ 770.948865] Hardware name: Microsoft Corporation Virtual Machine/Virtual Machine BIOS Hyper-V UEFI Release v4.1 05/09/2022n[ 770.948866] RIP: 0010:__flush_work.isra.0+0x212/0x230n[ 770.948869] Code: 8b 4d 00 4c 8b 45 08 89 ca 48 c1 e9 04 83 e2 08 83 e1 0f 83 ca 02 89 c8 48 0f ba 6d 00 03 e9 25 ff ff ff 0f 0b e9 4e ff ff ff <0f> 0b 45 31 ed e9 44 ff ff ff e8 8f 89 b2 00 66 66 2e 0f 1f 84 00n[ 770.948870] RSP: 0018:ffffaf4ac213fb10 EFLAGS: 00010246n[ 770.948871] RAX: 0000000000000000 RBX: 0000000000000000 RCX: ffffffff8c992857n[ 770.948872] RDX: 0000000000000001 RSI: 0000000000000001 RDI: ffff9aad82b00330n[ 770.948873] RBP: ffff9aad82b00330 R08: 0000000000000000 R09: ffff9aad87ee3d10n[ 770.948874] R10: 0000000000000200 R11: 0000000000000000 R12: ffff9aad82b00330n[ 770.948874] R13: 0000000000000001 R14: 0000000000000000 R15: 0000000000000001n[ 770.948875] FS: 00007ff1b2f6bb40(0000) GS:ffff9aaf37d00000(0000) knlGS:0000000000000000n[ 770.948878] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033n[ 770.948878] CR2: 0000555f345cb666 CR3: 00000001462dc005 CR4: 0000000000370ee0n[ 770.948879] Call Trace:n[ 770.948880] <TASK>n[ 770.948881] ? show_trace_log_lvl+0x1c4/0x2dfn[ 770.948884] ? show_trace_log_lvl+0x1c4/0x2dfn[ 770.948886] ? __cancel_work_timer+0x103/0x190n[ 770.948887] ? __flush_work.isra.0+0x212/0x230n[ 770.948889] ? __warn+0x81/0x110n[ 770.948891] ? __flush_work.isra.0+0x212/0x230n[ 770.948892] ? report_bug+0x10a/0x140n[ 770.948895] ? handle_bug+0x3c/0x70n[ 770.948898] ? exc_invalid_op+0x14/0x70n[ 770.948899] ? asm_exc_invalid_op+0x16/0x20n[ 770.948903] ? __flush_work.isra.0+0x212/0x230n[ 770.948905] __cancel_work_timer+0x103/0x190n[ 770.948907] ? _raw_spin_unlock_irqrestore+0xa/0x30n[ 770.948910] drm_kms_helper_poll_disable+0x1e/0x40 [drm_kms_helper]n[ 770.948923] drm_mode_config_helper_suspend+0x1c/0x80 [drm_kms_helper]n[ 770.948933] ? __pfx_vmbus_suspend+0x10/0x10 [hv_vmbus]n[ 770.948942] hyperv_vmbus_suspend+0x17/0x40 [hyperv_drm]n[ 770.948944] ? __pfx_vmbus_suspend+0x10/0x10 [hv_vmbus]n[ 770.948951] dpm_run_callback+0x4c/0x140n[ 770.948954] __device_suspend_noirn---truncated---,CVE-2024-35927,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnrcu/nocb: Fix WARN_ON_ONCE() in the rcu_nocb_bypass_lock()nnFor the kernels built with CONFIG_RCU_NOCB_CPU_DEFAULT_ALL=y andnCONFIG_RCU_LAZY=y the following scenarios will trigger WARN_ON_ONCE()nin the rcu_nocb_bypass_lock() and rcu_nocb_wait_contended() functions:nn CPU2 CPU11nkthreadnrcu_nocb_cb_kthread ksys_writenrcu_do_batch vfs_writenrcu_torture_timer_cb proc_sys_writen__kmem_cache_free proc_sys_call_handlernkmemleak_free drop_caches_sysctl_handlerndelete_object_full drop_slabn__delete_object shrink_slabnput_object lazy_rcu_shrink_scanncall_rcu rcu_nocb_flush_bypassn__call_rcu_commn rcu_nocb_bypass_lockn raw_spin_trylock(&rdp->nocb_bypass_lock) failn atomic_inc(&rdp->nocb_lock_contended);nrcu_nocb_wait_contended WARN_ON_ONCE(smp_processor_id() != rdp->cpu);n WARN_ON_ONCE(atomic_read(&rdp->nocb_lock_contended)) |n |_ _ _ _ _ _ _ _ _ _same rdp and rdp->cpu != 11_ _ _ _ _ _ _ _ _ __|nnReproduce this bug with echo 3 > /proc/sys/vm/drop_caches.nnThis commit therefore uses rcu_nocb_try_flush_bypass() instead ofnrcu_nocb_flush_bypass() in lazy_rcu_shrink_scan(). If the nocb_bypassnqueue is being flushed then rcu_nocb_try_flush_bypass will returnndirectly.,CVE-2024-35929,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amdgpu: Skip do PCI error slot reset during RAS recoverynnWhy:n The PCI error slot reset maybe triggered after inject ue to UMC multi times thisn caused system hang.n [ 557.371857] amdgpu 0000:af:00.0: amdgpu: GPU reset succeeded trying to resumen [ 557.373718] [drm] PCIE GART of 512M enabled.n [ 557.373722] [drm] PTB located at 0x0000031FED700000n [ 557.373788] [drm] VRAM is lost due to GPU reset!n [ 557.373789] [drm] PSP is resuming...n [ 557.547012] mlx5_core 0000:55:00.0: mlx5_pci_err_detected Device state = 1 pci_status: 0. Exit result = 3 need resetn [ 557.547067] [drm] PCI error: detected callback state(1)!!n [ 557.547069] [drm] No support for XGMI hive yet...n [ 557.548125] mlx5_core 0000:55:00.0: mlx5_pci_slot_reset Device state = 1 pci_status: 0. Entern [ 557.607763] mlx5_core 0000:55:00.0: wait vital counter value 0x16b5b after 1 iterationsn [ 557.607777] mlx5_core 0000:55:00.0: mlx5_pci_slot_reset Device state = 1 pci_status: 1. Exit err = 0 result = 5 recoveredn [ 557.610492] [drm] PCI error: slot reset callback!!n ...n [ 560.689382] amdgpu 0000:3f:00.0: amdgpu: GPU reset(2) succeeded!n [ 560.689546] amdgpu 0000:5a:00.0: amdgpu: GPU reset(2) succeeded!n [ 560.689562] general protection fault probably for non-canonical address 0x5f080b54534f611f: 0000 [#1] SMP NOPTIn [ 560.701008] CPU: 16 PID: 2361 Comm: kworker/u448:9 Tainted: G OE 5.15.0-91-generic #101-Ubuntun [ 560.712057] Hardware name: Microsoft C278A/C278A BIOS C2789.5.BS.1C11.AG.1 11/08/2023n [ 560.720959] Workqueue: amdgpu-reset-hive amdgpu_ras_do_recovery [amdgpu]n [ 560.728887] RIP: 0010:amdgpu_device_gpu_recover.cold+0xbf1/0xcf5 [amdgpu]n [ 560.736891] Code: ff 41 89 c6 e9 1b ff ff ff 44 0f b6 45 b0 e9 4f ff ff ff be 01 00 00 00 4c 89 e7 e8 76 c9 8b ff 44 0f b6 45 b0 e9 3c fd ff ff <48> 83 ba 18 02 00 00 00 0f 84 6a f8 ff ff 48 8d 7a 78 be 01 00 00n [ 560.757967] RSP: 0018:ffa0000032e53d80 EFLAGS: 00010202n [ 560.763848] RAX: ffa00000001dfd10 RBX: ffa0000000197090 RCX: ffa0000032e53db0n [ 560.771856] RDX: 5f080b54534f5f07 RSI: 0000000000000000 RDI: ff11000128100010n [ 560.779867] RBP: ffa0000032e53df0 R08: 0000000000000000 R09: ffffffffffe77f08n [ 560.787879] R10: 0000000000ffff0a R11: 0000000000000001 R12: 0000000000000000n [ 560.795889] R13: ffa0000032e53e00 R14: 0000000000000000 R15: 0000000000000000n [ 560.803889] FS: 0000000000000000(0000) GS:ff11007e7e800000(0000) knlGS:0000000000000000n [ 560.812973] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033n [ 560.819422] CR2: 000055a04c118e68 CR3: 0000000007410005 CR4: 0000000000771ee0n [ 560.827433] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000n [ 560.835433] DR3: 0000000000000000 DR6: 00000000fffe07f0 DR7: 0000000000000400n [ 560.843444] PKRU: 55555554n [ 560.846480] Call Trace:n [ 560.849225] <TASK>n [ 560.851580] ? show_trace_log_lvl+0x1d6/0x2ean [ 560.856488] ? show_trace_log_lvl+0x1d6/0x2ean [ 560.861379] ? amdgpu_ras_do_recovery+0x1b2/0x210 [amdgpu]n [ 560.867778] ? show_regs.part.0+0x23/0x29n [ 560.872293] ? __die_body.cold+0x8/0xdn [ 560.876502] ? die_addr+0x3e/0x60n [ 560.880238] ? exc_general_protection+0x1c5/0x410n [ 560.885532] ? asm_exc_general_protection+0x27/0x30n [ 560.891025] ? amdgpu_device_gpu_recover.cold+0xbf1/0xcf5 [amdgpu]n [ 560.898323] amdgpu_ras_do_recovery+0x1b2/0x210 [amdgpu]n [ 560.904520] process_one_work+0x228/0x3d0nHow:n In RAS recovery mode-1 reset is issued from RAS fatal error handling and expectedn all the nodes in a hive to be reset. no need to issue another mode-1 during this procedure.,CVE-2024-35931,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/vc4: don't check if plane->state->fb == state->fbnnCurrently when using non-blocking commits we can see the followingnkernel warning:nn[ 110.908514] ------------[ cut here ]------------n[ 110.908529] refcount_t: underflow; use-after-free.n[ 110.908620] WARNING: CPU: 0 PID: 1866 at lib/refcount.c:87 refcount_dec_not_one+0xb8/0xc0n[ 110.908664] Modules linked in: rfcomm snd_seq_dummy snd_hrtimer snd_seq snd_seq_device cmac algif_hash aes_arm64 aes_generic algif_skcipher af_alg bnep hid_logitech_hidpp vc4 brcmfmac hci_uart btbcm brcmutil bluetooth snd_soc_hdmi_codec cfg80211 cec drm_display_helper drm_dma_helper drm_kms_helper snd_soc_core snd_compress snd_pcm_dmaengine fb_sys_fops sysimgblt syscopyarea sysfillrect raspberrypi_hwmon ecdh_generic ecc rfkill libaes i2c_bcm2835 binfmt_misc joydev snd_bcm2835(C) bcm2835_codec(C) bcm2835_isp(C) v4l2_mem2mem videobuf2_dma_contig snd_pcm bcm2835_v4l2(C) raspberrypi_gpiomem bcm2835_mmal_vchiq(C) videobuf2_v4l2 snd_timer videobuf2_vmalloc videobuf2_memops videobuf2_common snd videodev vc_sm_cma(C) mc hid_logitech_dj uio_pdrv_genirq uio i2c_dev drm fuse dm_mod drm_panel_orientation_quirks backlight ip_tables x_tables ipv6n[ 110.909086] CPU: 0 PID: 1866 Comm: kodi.bin Tainted: G C 6.1.66-v8+ #32n[ 110.909104] Hardware name: Raspberry Pi 3 Model B Rev 1.2 (DT)n[ 110.909114] pstate: 60000005 (nZCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)n[ 110.909132] pc : refcount_dec_not_one+0xb8/0xc0n[ 110.909152] lr : refcount_dec_not_one+0xb4/0xc0n[ 110.909170] sp : ffffffc00913b9c0n[ 110.909177] x29: ffffffc00913b9c0 x28: 000000556969bbb0 x27: 000000556990df60n[ 110.909205] x26: 0000000000000002 x25: 0000000000000004 x24: ffffff8004448480n[ 110.909230] x23: ffffff800570b500 x22: ffffff802e03a7bc x21: ffffffecfca68c78n[ 110.909257] x20: ffffff8002b42000 x19: ffffff802e03a600 x18: 0000000000000000n[ 110.909283] x17: 0000000000000011 x16: ffffffffffffffff x15: 0000000000000004n[ 110.909308] x14: 0000000000000fff x13: ffffffed577e47e0 x12: 0000000000000003n[ 110.909333] x11: 0000000000000000 x10: 0000000000000027 x9 : c912d0d083728c00n[ 110.909359] x8 : c912d0d083728c00 x7 : 65646e75203a745f x6 : 746e756f63666572n[ 110.909384] x5 : ffffffed579f62ee x4 : ffffffed579eb01e x3 : 0000000000000000n[ 110.909409] x2 : 0000000000000000 x1 : ffffffc00913b750 x0 : 0000000000000001n[ 110.909434] Call trace:n[ 110.909441] refcount_dec_not_one+0xb8/0xc0n[ 110.909461] vc4_bo_dec_usecnt+0x4c/0x1b0 [vc4]n[ 110.909903] vc4_cleanup_fb+0x44/0x50 [vc4]n[ 110.910315] drm_atomic_helper_cleanup_planes+0x88/0xa4 [drm_kms_helper]n[ 110.910669] vc4_atomic_commit_tail+0x390/0x9dc [vc4]n[ 110.911079] commit_tail+0xb0/0x164 [drm_kms_helper]n[ 110.911397] drm_atomic_helper_commit+0x1d0/0x1f0 [drm_kms_helper]n[ 110.911716] drm_atomic_commit+0xb0/0xdc [drm]n[ 110.912569] drm_mode_atomic_ioctl+0x348/0x4b8 [drm]n[ 110.913330] drm_ioctl_kernel+0xec/0x15c [drm]n[ 110.914091] drm_ioctl+0x24c/0x3b0 [drm]n[ 110.914850] __arm64_sys_ioctl+0x9c/0xd4n[ 110.914873] invoke_syscall+0x4c/0x114n[ 110.914897] el0_svc_common+0xd0/0x118n[ 110.914917] do_el0_svc+0x38/0xd0n[ 110.914936] el0_svc+0x30/0x8cn[ 110.914958] el0t_64_sync_handler+0x84/0xf0n[ 110.914979] el0t_64_sync+0x18c/0x190n[ 110.914996] ---[ end trace 0000000000000000 ]---nnThis happens because although `prepare_fb` and `cleanup_fb` arenperfectly balanced we cannot guarantee consistency in the checknplane->state->fb == state->fb. This means that sometimes we can increasenthe refcount in `prepare_fb` and don't decrease it in `cleanup_fb`. Thenopposite can also be true.nnIn fact the struct drm_plane .state shouldn't be accessed directlynbut instead the `drm_atomic_get_new_plane_state()` helper function shouldnbe used. So we could stick to this check but usingn`drm_atomic_get_new_plane_state()`. But actually this check is not ren---truncated---,CVE-2024-35932,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnwifi: cfg80211: check A-MSDU format more carefullynnIf it looks like there's another subframe in the A-MSDUnbut the header isn't fully there we can end up readingndata out of bounds only to discard later. Make this anbit more careful and check if the subframe header canneven be present.,CVE-2024-35937,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnwifi: ath11k: decrease MHI channel buffer length to 8KBnnCurrently buf_len field of ath11k_mhi_config_qca6390 is assignednwith 0 making MHI use a default size 64KB to allocate channelnbuffers. This is likely to fail in some scenarios where systemnmemory is highly fragmented and memory compaction or reclaim isnnot allowed.nnThere is a fail report which is caused by it:nkworker/u32:45: page allocation failure: order:4 mode:0x40c00(GFP_NOIO|__GFP_COMP) nodemask=(null)cpuset=/mems_allowed=0nCPU: 0 PID: 19318 Comm: kworker/u32:45 Not tainted 6.8.0-rc3-1.gae4495f-default #1 openSUSE Tumbleweed (unreleased) 493b6d5b382c603654d7a81fc3c144d59a1dfcebnWorkqueue: events_unbound async_run_entry_fnnCall Trace:n <TASK>n dump_stack_lvl+0x47/0x60n warn_alloc+0x13a/0x1b0n ? srso_alias_return_thunk+0x5/0xfbef5n ? __alloc_pages_direct_compact+0xab/0x210n __alloc_pages_slowpath.constprop.0+0xd3e/0xda0n __alloc_pages+0x32d/0x350n ? mhi_prepare_channel+0x127/0x2d0 [mhi 40df44e07c05479f7a6e7b90fba9f0e0031a7814]n __kmalloc_large_node+0x72/0x110n __kmalloc+0x37c/0x480n ? mhi_map_single_no_bb+0x77/0xf0 [mhi 40df44e07c05479f7a6e7b90fba9f0e0031a7814]n ? mhi_prepare_channel+0x127/0x2d0 [mhi 40df44e07c05479f7a6e7b90fba9f0e0031a7814]n mhi_prepare_channel+0x127/0x2d0 [mhi 40df44e07c05479f7a6e7b90fba9f0e0031a7814]n __mhi_prepare_for_transfer+0x44/0x80 [mhi 40df44e07c05479f7a6e7b90fba9f0e0031a7814]n ? __pfx_____mhi_prepare_for_transfer+0x10/0x10 [mhi 40df44e07c05479f7a6e7b90fba9f0e0031a7814]n device_for_each_child+0x5c/0xa0n ? __pfx_pci_pm_resume+0x10/0x10n ath11k_core_resume+0x65/0x100 [ath11k a5094e22d7223135c40d93c8f5321cf09fd85e4e]n ? srso_alias_return_thunk+0x5/0xfbef5n ath11k_pci_pm_resume+0x32/0x60 [ath11k_pci 830b7bfc3ea80ebef32e563cafe2cb55e9cc73ec]n ? srso_alias_return_thunk+0x5/0xfbef5n dpm_run_callback+0x8c/0x1e0n device_resume+0x104/0x340n ? __pfx_dpm_watchdog_handler+0x10/0x10n async_resume+0x1d/0x30n async_run_entry_fn+0x32/0x120n process_one_work+0x168/0x330n worker_thread+0x2f5/0x410n ? __pfx_worker_thread+0x10/0x10n kthread+0xe8/0x120n ? __pfx_kthread+0x10/0x10n ret_from_fork+0x34/0x50n ? __pfx_kthread+0x10/0x10n ret_from_fork_asm+0x1b/0x30n </TASK>nnActually those buffers are used only by QMI target -> host communication.nAnd for WCN6855 and QCA6390 the largest packet size for that is lessnthan 6KB. So change buf_len field to 8KB which results in order 1nallocation if page size is 4KB. In this way we can at least save somenmemory and as well as decrease the possibility of allocation failurenin those scenarios.nnTested-on: WCN6855 hw2.0 PCI WLAN.HSP.1.1-03125-QCAHSPSWPL_V1_V2_SILICONZ_LITE-3.6510.30,CVE-2024-35938,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndma-direct: Leak pages on dma_set_decrypted() failurennOn TDX it is possible for the untrusted host to causenset_memory_encrypted() or set_memory_decrypted() to fail such that annerror is returned and the resulting memory is shared. Callers need tontake care to handle these errors to avoid returning decrypted (shared)nmemory to the page allocator which could lead to functional or securitynissues.nnDMA could free decrypted/shared pages if dma_set_decrypted() fails. Thisnshould be a rare case. Just leak the pages in this case instead ofnfreeing them.,CVE-2024-35939,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnpmdomain: ti: Add a null pointer check to the omap_prm_domain_initnndevm_kasprintf() returns a pointer to dynamically allocated memorynwhich can be NULL upon failure. Ensure the allocation was successfulnby checking the pointer validity.,CVE-2024-35943,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet: phy: phy_device: Prevent nullptr exceptions on ISRnnIf phydev->irq is set unconditionally checknfor valid interrupt handler or fall back to polling mode to preventnnullptr exceptions in interrupt service routine.,CVE-2024-35945,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbtrfs: make sure that WRITTEN is set on all metadata blocksnnWe previously would call btrfs_check_leaf() if we had the checknintegrity code enabled which meant that we could only run the extendednleaf checks if we had WRITTEN set on the header flags.nnThis leaves a gap in our checking because we could end up withncorruption on disk where WRITTEN isn't set on the leaf and then thenextended leaf checks don't get run which we rely on to validate all ofnthe item pointers to make sure we don't access memory outside of thenextent buffer.nnHowever since 732fab95abe2 (btrfs: check-integrity: removenCONFIG_BTRFS_FS_CHECK_INTEGRITY option) we no longer callnbtrfs_check_leaf() from btrfs_mark_buffer_dirty() which means we onlynever call it on blocks that are being written out and thus have WRITTENnset or that are being read in which should have WRITTEN set.nnAdd checks to make sure we have WRITTEN set appropriately and then makensure __btrfs_check_leaf() always does the item checking. This willnprotect us from file systems that have been corrupted and no longer havenWRITTEN set on some of the blocks.nnThis was hit on a crafted image tweaking the WRITTEN bit and reported bynKASAN as out-of-bound access in the eb accessors. The example is a dirnitem at the end of an eb.nn [2.042] BTRFS warning (device loop1): bad eb member start: ptr 0x3fff start 30572544 member offset 16410 size 2n [2.040] general protection fault probably for non-canonical address 0xe0009d1000000003: 0000 [#1] PREEMPT SMP KASAN NOPTIn [2.537] KASAN: maybe wild-memory-access in range [0x0005088000000018-0x000508800000001f]n [2.729] CPU: 0 PID: 2587 Comm: mount Not tainted 6.8.2 #1n [2.729] Hardware name: QEMU Standard PC (i440FX + PIIX 1996) BIOS 1.15.0-1 04/01/2014n [2.621] RIP: 0010:btrfs_get_16+0x34b/0x6d0n [2.621] RSP: 0018:ffff88810871fab8 EFLAGS: 00000206n [2.621] RAX: 0000a11000000003 RBX: ffff888104ff8720 RCX: ffff88811b2288c0n [2.621] RDX: dffffc0000000000 RSI: ffffffff81dd8aca RDI: ffff88810871f748n [2.621] RBP: 000000000000401a R08: 0000000000000001 R09: ffffed10210e3ee9n [2.621] R10: ffff88810871f74f R11: 205d323430333737 R12: 000000000000001an [2.621] R13: 000508800000001a R14: 1ffff110210e3f5d R15: ffffffff850011e8n [2.621] FS: 00007f56ea275840(0000) GS:ffff88811b200000(0000) knlGS:0000000000000000n [2.621] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033n [2.621] CR2: 00007febd13b75c0 CR3: 000000010bb50000 CR4: 00000000000006f0n [2.621] Call Trace:n [2.621] <TASK>n [2.621] ? show_regs+0x74/0x80n [2.621] ? die_addr+0x46/0xc0n [2.621] ? exc_general_protection+0x161/0x2a0n [2.621] ? asm_exc_general_protection+0x26/0x30n [2.621] ? btrfs_get_16+0x33a/0x6d0n [2.621] ? btrfs_get_16+0x34b/0x6d0n [2.621] ? btrfs_get_16+0x33a/0x6d0n [2.621] ? __pfx_btrfs_get_16+0x10/0x10n [2.621] ? __pfx_mutex_unlock+0x10/0x10n [2.621] btrfs_match_dir_item_name+0x101/0x1a0n [2.621] btrfs_lookup_dir_item+0x1f3/0x280n [2.621] ? __pfx_btrfs_lookup_dir_item+0x10/0x10n [2.621] btrfs_get_tree+0xd25/0x1910nn[ copy more details from report ],CVE-2024-35949,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/panfrost: Fix the error path in panfrost_mmu_map_fault_addr()nnSubject: [PATCH] drm/panfrost: Fix the error path inn panfrost_mmu_map_fault_addr()nnIf some the pages or sgt allocation failed we shouldn't release thenpages ref we got earlier otherwise we will end up with unbalancednget/put_pages() calls. We should instead leave everything in placenand let the BO release function deal with extra cleanup when the objectnis destroyed or let the fault handler try again next time it's called.,CVE-2024-35951,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbtrfs: qgroup: fix qgroup prealloc rsv leak in subvolume operationsnnCreate subvolume create snapshot and delete subvolume all usenbtrfs_subvolume_reserve_metadata() to reserve metadata for the changesndone to the parent subvolume's fs tree which cannot be mediated in thennormal way via start_transaction. When quota groups (squota or qgroups)nare enabled this reserves qgroup metadata of type PREALLOC. Once thenoperation is associated to a transaction we convert PREALLOC tonPERTRANS which gets cleared in bulk at the end of the transaction.nnHowever the error paths of these three operations were not implementingnthis lifecycle correctly. They unconditionally converted the PREALLOC tonPERTRANS in a generic cleanup step regardless of errors or whether thenoperation was fully associated to a transaction or not. This resulted innerror paths occasionally converting this rsv to PERTRANS without callingnrecord_root_in_trans successfully which meant that unless that root gotnrecorded in the transaction by some other thread the end of thentransaction would not free that root's PERTRANS leaking it. Ultimatelynthis resulted in hitting a WARN in CONFIG_BTRFS_DEBUG builds at unmountnfor the leaked reservation.nnThe fix is to ensure that every qgroup PREALLOC reservation observes thenfollowing properties:nn1. any failure before record_root_in_trans is called successfullyn results in freeing the PREALLOC reservation.n2. after record_root_in_trans we convert to PERTRANS and now then transaction owns freeing the reservation.nnThis patch enforces those properties on the three operations. Withoutnit generic/269 with squotas enabled at mkfs time would fail in ~5-10nruns on my system. With this patch it ran successfully 1000 times in anrow.,CVE-2024-35956,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet: ks8851: Handle softirqs at the end of IRQ thread to fix hangnnThe ks8851_irq() thread may call ks8851_rx_pkts() in case there arenany packets in the MAC FIFO which calls netif_rx(). This netif_rx()nimplementation is guarded by local_bh_disable() and local_bh_enable().nThe local_bh_enable() may call do_softirq() to run softirqs in casenany are pending. One of the softirqs is net_rx_action which ultimatelynreaches the driver .start_xmit callback. If that happens the systemnhangs. The entire call chain is below:nnks8851_start_xmit_par from netdev_start_xmitnnetdev_start_xmit from dev_hard_start_xmitndev_hard_start_xmit from sch_direct_xmitnsch_direct_xmit from __dev_queue_xmitn__dev_queue_xmit from __neigh_updaten__neigh_update from neigh_updatenneigh_update from arp_process.constprop.0narp_process.constprop.0 from __netif_receive_skb_one_coren__netif_receive_skb_one_core from process_backlognprocess_backlog from __napi_poll.constprop.0n__napi_poll.constprop.0 from net_rx_actionnnet_rx_action from __do_softirqn__do_softirq from call_with_stackncall_with_stack from do_softirqndo_softirq from __local_bh_enable_ipn__local_bh_enable_ip from netif_rxnnetif_rx from ks8851_irqnks8851_irq from irq_thread_fnnirq_thread_fn from irq_threadnirq_thread from kthreadnkthread from ret_from_forknnThe hang happens because ks8851_irq() first locks a spinlock innks8851_par.c ks8851_lock_par() spin_lock_irqsave(&ksp->lock ...)nand with that spinlock locked calls netif_rx(). Once the executionnreaches ks8851_start_xmit_par() it calls ks8851_lock_par() againnwhich attempts to claim the already locked spinlock again and thenhang happens.nnMove the do_softirq() call outside of the spinlock protected sectionnof ks8851_irq() by disabling BHs around the entire spinlock protectednsection of ks8851_irq() handler. Place local_bh_enable() outside ofnthe spinlock protected section so that it can trigger do_softirq()nwithout the ks8851_par.c ks8851_lock_par() spinlock being held andnsafely call ks8851_start_xmit_par() without attempting to lock thenalready locked spinlock.nnSince ks8851_irq() is protected by local_bh_disable()/local_bh_enable()nnow replace netif_rx() with __netif_rx() which is not duplicating thenlocal_bh_disable()/local_bh_enable() calls.,CVE-2024-35971,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnACPI: CPPC: Use access_width over bit_width for system memory accessesnnTo align with ACPI 6.3+ since bit_width can be any 8-bit value itncannot be depended on to be always on a clean 8b boundary. This wasnuncovered on the Cobalt 100 platform.nnSError Interrupt on CPU26 code 0xbe000011 -- SErrorn CPU: 26 PID: 1510 Comm: systemd-udevd Not tainted 5.15.2.1-13 #1n Hardware name: MICROSOFT CORPORATION BIOS MICROSOFT CORPORATIONn pstate: 62400009 (nZCv daif +PAN -UAO +TCO -DIT -SSBS BTYPE=--)n pc : cppc_get_perf_caps+0xec/0x410n lr : cppc_get_perf_caps+0xe8/0x410n sp : ffff8000155ab730n x29: ffff8000155ab730 x28: ffff0080139d0038 x27: ffff0080139d0078n x26: 0000000000000000 x25: ffff0080139d0058 x24: 00000000ffffffffn x23: ffff0080139d0298 x22: ffff0080139d0278 x21: 0000000000000000n x20: ffff00802b251910 x19: ffff0080139d0000 x18: ffffffffffffffffn x17: 0000000000000000 x16: ffffdc7e111bad04 x15: ffff00802b251008n x14: ffffffffffffffff x13: ffff013f1fd63300 x12: 0000000000000006n x11: ffffdc7e128f4420 x10: 0000000000000000 x9 : ffffdc7e111badecn x8 : ffff00802b251980 x7 : 0000000000000000 x6 : ffff0080139d0028n x5 : 0000000000000000 x4 : ffff0080139d0018 x3 : 00000000ffffffffn x2 : 0000000000000008 x1 : ffff8000155ab7a0 x0 : 0000000000000000n Kernel panic - not syncing: Asynchronous SError Interruptn CPU: 26 PID: 1510 Comm: systemd-udevd Not taintedn5.15.2.1-13 #1n Hardware name: MICROSOFT CORPORATION BIOS MICROSOFT CORPORATIONn Call trace:n dump_backtrace+0x0/0x1e0n show_stack+0x24/0x30n dump_stack_lvl+0x8c/0xb8n dump_stack+0x18/0x34n panic+0x16c/0x384n add_taint+0x0/0xc0n arm64_serror_panic+0x7c/0x90n arm64_is_fatal_ras_serror+0x34/0xa4n do_serror+0x50/0x6cn el1h_64_error_handler+0x40/0x74n el1h_64_error+0x7c/0x80n cppc_get_perf_caps+0xec/0x410n cppc_cpufreq_cpu_init+0x74/0x400 [cppc_cpufreq]n cpufreq_online+0x2dc/0xa30n cpufreq_add_dev+0xc0/0xd4n subsys_interface_register+0x134/0x14cn cpufreq_register_driver+0x1b0/0x354n cppc_cpufreq_init+0x1a8/0x1000 [cppc_cpufreq]n do_one_initcall+0x50/0x250n do_init_module+0x60/0x27cn load_module+0x2300/0x2570n __do_sys_finit_module+0xa8/0x114n __arm64_sys_finit_module+0x2c/0x3cn invoke_syscall+0x78/0x100n el0_svc_common.constprop.0+0x180/0x1a0n do_el0_svc+0x84/0xa0n el0_svc+0x2c/0xc0n el0t_64_sync_handler+0xa4/0x12cn el0t_64_sync+0x1a4/0x1a8nnInstead use access_width to determine the size and use the offset andnwidth to shift and mask the bits to read/write out. Make sure to add ancheck for system memory since pcc redefines the access_width tonsubspace id.nnIf access_width is not set then fall back to using bit_width.nn[ rjw: Subject and changelog edits comment adjustments ],CVE-2024-35995,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnsmb3: fix lock ordering potential deadlock in cifs_sync_mid_resultnnCoverity spotted that the cifs_sync_mid_result function could deadlocknnThread deadlock (ORDER_REVERSAL) lock_order: Calling spin_lock acquiresnlock TCP_Server_Info.srv_lock while holding lock TCP_Server_Info.mid_locknnAddresses-Coverity: 1590401 (Thread deadlock (ORDER_REVERSAL)),CVE-2024-35998,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnsmb3: missing lock when picking channelnnCoverity spotted a place where we should have been holding thenchannel lock when accessing the ses channel index.nnAddresses-Coverity: 1582039 (Data race condition (MISSING_LOCK)),CVE-2024-35999,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnmm/hugetlb: fix missing hugetlb_lock for resv unchargennThere is a recent report on UFFDIO_COPY over hugetlb:nnhttps://lore.kernel.org/all/000000000000ee06de0616177560@google.com/nn350:tlockdep_assert_held(&hugetlb_lock);nnShould be an issue in hugetlb but triggered in an userfault context wherenit goes into the unlikely path where two threads modifying the resv mapntogether. Mike has a fix in that path for resv uncharge but it looks likenthe locking criteria was overlooked: hugetlb_cgroup_uncharge_folio_rsvd()nwill update the cgroup pointer so it requires to be called with the locknheld.,CVE-2024-36000,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnax25: Fix netdev refcount issuennThe dev_tracker is added to ax25_cb in ax25_bind(). When thenax25 device is detaching the dev_tracker of ax25_cb should bendeallocated in ax25_kill_by_device() instead of the dev_trackernof ax25_dev. The log reported by ref_tracker is shown below:nn[ 80.884935] ref_tracker: reference already released.n[ 80.885150] ref_tracker: allocated in:n[ 80.885349] ax25_dev_device_up+0x105/0x540n[ 80.885730] ax25_device_event+0xa4/0x420n[ 80.885730] notifier_call_chain+0xc9/0x1e0n[ 80.885730] __dev_notify_flags+0x138/0x280n[ 80.885730] dev_change_flags+0xd7/0x180n[ 80.885730] dev_ifsioc+0x6a9/0xa30n[ 80.885730] dev_ioctl+0x4d8/0xd90n[ 80.885730] sock_do_ioctl+0x1c2/0x2d0n[ 80.885730] sock_ioctl+0x38b/0x4f0n[ 80.885730] __se_sys_ioctl+0xad/0xf0n[ 80.885730] do_syscall_64+0xc4/0x1b0n[ 80.885730] entry_SYSCALL_64_after_hwframe+0x67/0x6fn[ 80.885730] ref_tracker: freed in:n[ 80.885730] ax25_device_event+0x272/0x420n[ 80.885730] notifier_call_chain+0xc9/0x1e0n[ 80.885730] dev_close_many+0x272/0x370n[ 80.885730] unregister_netdevice_many_notify+0x3b5/0x1180n[ 80.885730] unregister_netdev+0xcf/0x120n[ 80.885730] sixpack_close+0x11f/0x1b0n[ 80.885730] tty_ldisc_kill+0xcb/0x190n[ 80.885730] tty_ldisc_hangup+0x338/0x3d0n[ 80.885730] __tty_hangup+0x504/0x740n[ 80.885730] tty_release+0x46e/0xd80n[ 80.885730] __fput+0x37f/0x770n[ 80.885730] __x64_sys_close+0x7b/0xb0n[ 80.885730] do_syscall_64+0xc4/0x1b0n[ 80.885730] entry_SYSCALL_64_after_hwframe+0x67/0x6fn[ 80.893739] ------------[ cut here ]------------n[ 80.894030] WARNING: CPU: 2 PID: 140 at lib/ref_tracker.c:255 ref_tracker_free+0x47b/0x6b0n[ 80.894297] Modules linked in:n[ 80.894929] CPU: 2 PID: 140 Comm: ax25_conn_rel_6 Not tainted 6.9.0-rc4-g8cd26fd90c1a #11n[ 80.895190] Hardware name: QEMU Standard PC (i440FX + PIIX 1996) BIOS rel-1.14.0-0-g155821a1990b-prebuilt.qem4n[ 80.895514] RIP: 0010:ref_tracker_free+0x47b/0x6b0n[ 80.895808] Code: 83 c5 18 4c 89 eb 48 c1 eb 03 8a 04 13 84 c0 0f 85 df 01 00 00 41 83 7d 00 00 75 4b 4c 89 ff 9n[ 80.896171] RSP: 0018:ffff888009edf8c0 EFLAGS: 00000286n[ 80.896339] RAX: 1ffff1100141ac00 RBX: 1ffff1100149463b RCX: dffffc0000000000n[ 80.896502] RDX: 0000000000000001 RSI: 0000000000000246 RDI: ffff88800a0d6518n[ 80.896925] RBP: ffff888009edf9b0 R08: ffff88806d3288d3 R09: 1ffff1100da6511an[ 80.897212] R10: dffffc0000000000 R11: ffffed100da6511b R12: ffff88800a4a31d4n[ 80.897859] R13: ffff88800a4a31d8 R14: dffffc0000000000 R15: ffff88800a0d6518n[ 80.898279] FS: 00007fd88b7fe700(0000) GS:ffff88806d300000(0000) knlGS:0000000000000000n[ 80.899436] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033n[ 80.900181] CR2: 00007fd88c001d48 CR3: 000000000993e000 CR4: 00000000000006f0n...n[ 80.935774] ref_tracker: sp%d@000000000bb9df3d has 1/1 users atn[ 80.935774] ax25_bind+0x424/0x4e0n[ 80.935774] __sys_bind+0x1d9/0x270n[ 80.935774] __x64_sys_bind+0x75/0x80n[ 80.935774] do_syscall_64+0xc4/0x1b0n[ 80.935774] entry_SYSCALL_64_after_hwframe+0x67/0x6fnnChange ax25_dev->dev_tracker to the dev_tracker of ax25_cbnin order to mitigate the bug.,CVE-2024-36009,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnBluetooth: L2CAP: Fix slab-use-after-free in l2cap_connect()nnExtend a critical section to prevent chan from early freeing.nAlso make the l2cap_connect() return type void. Nothing is using thenreturned value but it is ugly to return a potentially freed pointer.nMaking it void will help with backports because earlier kernels did usenthe return value. Now the compile will break for kernels where thisnpatch is not a complete fix.nnCall stack summary:nn[use]nl2cap_bredr_sig_cmdn l2cap_connectn  mutex_lock(&conn->chan_lock);n  chan = pchan->ops->new_connection(pchan); <- alloc chann  __l2cap_chan_add(conn chan);n  l2cap_chan_hold(chan);n  list_add(&chan->list &conn->chan_l); ... (1)n  mutex_unlock(&conn->chan_lock);n chan->conf_state ... (4) <- use after freenn[free]nl2cap_conn_deln mutex_lock(&conn->chan_lock);n foreach chan in conn->chan_l: ... (2)n l2cap_chan_put(chan);n l2cap_chan_destroyn kfree(chan) ... (3) <- chan freedn mutex_unlock(&conn->chan_lock);nn==================================================================nBUG: KASAN: slab-use-after-free in instrument_atomic_readninclude/linux/instrumented.h:68 [inline]nBUG: KASAN: slab-use-after-free in _test_bitninclude/asm-generic/bitops/instrumented-non-atomic.h:141 [inline]nBUG: KASAN: slab-use-after-free in l2cap_connect+0xa67/0x11a0nnet/bluetooth/l2cap_core.c:4260nRead of size 8 at addr ffff88810bf040a0 by task kworker/u3:1/311,CVE-2024-36013,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amdgpu: Init zone device and drm client after mode-1 reset on reloadnnIn passthrough environment when amdgpu is reloaded after unload mode-1nis triggered after initializing the necessary IPs That init does notninclude KFD and KFD init waits until the reset is completed. KFD initnis called in the reset handler but in this case the zone device andndrm client is not initialized causing app to create kernel panic.nnv2: Removing the init KFD condition from amdgpu_amdkfd_drm_client_create.nAs the previous version has the potential of creating DRM client twice.nnv3: v2 patch results in SDMA engine hung as DRM open causes VM clear to SDMAnbefore SDMA init. Adding the condition to in drm client creation on top of v1nto guard against drm client creation call multiple times.,CVE-2024-36022,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnJulia Lawall reported this null pointer dereference this should fix it.,CVE-2024-36023,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Disable idle reallow as part of command/gpint executionnn[Why]nWorkaroud for a race condition where DMCUB is in the process ofncommitting to IPS1 during the handshake causing us to miss thentransition into IPS2 and touch the INBOX1 RPTR causing a HW hang.nn[How]nDisable the reallow to ensure that we have enough of a gap between entrynand exit and we're not seeing back-to-back wake_and_executes.,CVE-2024-36024,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnmmc: sdhci-msm: pervent access to suspended controllernnGeneric sdhci code registers LED device and uses host->runtime_suspendednflag to protect access to it. The sdhci-msm driver doesn't set this flagnwhich causes a crash when LED is accessed while controller is runtimensuspended. Fix this by setting the flag correctly.,CVE-2024-36029,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet/sched: taprio: extend minimum interval restriction to entire cycle toonnIt is possible for syzbot to side-step the restriction imposed by thenblamed commit in the Fixes: tag because the taprio UAPI permits ancycle-time different from (and potentially shorter than) the sum ofnentry intervals.nnWe need one more restriction which is that the cycle time itself mustnbe larger than N output.log scan_tyk_dockerimages.sh vulnerabilities.csv ETH_ZLEN bit times where N is the number of schedulenentries. This restriction needs to apply regardless of whether the cyclentime came from the user or was the implicit auto-calculated value sonwe move the existing cycle == 0 check outside the if (!new->cycle_time)nbranch. This way covers both conditions and scenarios.nnAdd a selftest which illustrates the issue triggered by syzbot.,CVE-2024-36244,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnull_blk: fix null-ptr-dereference while configuring 'power' and 'submit_queues'nnWriting 'power' and 'submit_queues' concurrently will trigger kernelnpanic:nnTest script:nnmodprobe null_blk nr_devices=0nmkdir -p /sys/kernel/config/nullb/nullb0nwhile true; do echo 1 > submit_queues; echo 4 > submit_queues; done &nwhile true; do echo 1 > power; echo 0 > power; donennTest result:nnBUG: kernel NULL pointer dereference address: 0000000000000148nOops: 0000 [#1] PREEMPT SMPnRIP: 0010:__lock_acquire+0x41d/0x28f0nCall Trace:n <TASK>n lock_acquire+0x121/0x450n down_write+0x5f/0x1d0n simple_recursive_removal+0x12f/0x5c0n blk_mq_debugfs_unregister_hctxs+0x7c/0x100n blk_mq_update_nr_hw_queues+0x4a3/0x720n nullb_update_nr_hw_queues+0x71/0xf0 [null_blk]n nullb_device_submit_queues_store+0x79/0xf0 [null_blk]n configfs_write_iter+0x119/0x1e0n vfs_write+0x326/0x730n ksys_write+0x74/0x150nnThis is because del_gendisk() can concurrent withnblk_mq_update_nr_hw_queues():nnnullb_device_power_storetnullb_apply_submit_queuesn null_del_devn del_gendiskntttt nullb_update_nr_hw_queuesntttt if (!dev->nullb)ntttt // still set while gendisk is deletedntttt return 0ntttt blk_mq_update_nr_hw_queuesn dev->nullb = NULLnnFix this problem by resuing the global mutex to protectnnullb_device_power_store() and nullb_update_nr_hw_queues() from configfs.,CVE-2024-36478,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnfpga: bridge: add owner module and take its refcountnnThe current implementation of the fpga bridge assumes that the low-levelnmodule registers a driver for the parent device and uses its owner pointernto take the module's refcount. This approach is problematic since it cannlead to a null pointer dereference while attempting to get the bridge ifnthe parent device does not have a driver.nnTo address this problem add a module owner pointer to the fpga_bridgenstruct and use it to take the module's refcount. Modify the function fornregistering a bridge to take an additional owner module parameter andnrename it to avoid conflicts. Use the old function name for a helper macronthat automatically sets the module that registers the bridge as the owner.nThis ensures compatibility with existing low-level control modules andnreduces the chances of registering a bridge without setting the owner.nnAlso update the documentation to keep it consistent with the new interfacenfor registering an fpga bridge.nnOther changes: opportunistically move put_device() from __fpga_bridge_get()nto fpga_bridge_get() and of_fpga_bridge_get() to improve code clarity sincenthe bridge device is taken in these functions.,CVE-2024-36479,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnBluetooth: qca: add missing firmware sanity checksnnAdd the missing sanity checks when parsing the firmware files beforendownloading them to avoid accessing and corrupting memory beyond thenvmalloced buffer.,CVE-2024-36880,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Atom Integrated System Info v2_2 for DCN35nnNew request from KMD/VBIOS in order to support new UMA carveoutnmodel. This fixes a null dereference from accessingnCtx->dc_bios->integrated_info while it was NULL.nnDAL parses through the BIOS and extracts the necessarynintegrated_info but was missing a case for the new BIOSnversion 2.3.,CVE-2024-36897,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nngpiolib: cdev: fix uninitialised kfifonnIf a line is requested with debounce and that results in debouncingnin software and the line is subsequently reconfigured to enable edgendetection then the allocation of the kfifo to contain edge events isnoverlooked. This results in events being written to and read from annuninitialised kfifo. Read events are returned to userspace.nnInitialise the kfifo in the case where the software debounce isnalready active.,CVE-2024-36898,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnipv6: Fix potential uninit-value access in __ip6_make_skb()nnAs it was done in commit fc1092f51567 (ipv4: Fix uninit-value access inn__ip_make_skb()) for IPv4 check FLOWI_FLAG_KNOWN_NH on fl6->flowi6_flagsninstead of testing HDRINCL on the socket to avoid a race condition whichncauses uninit-value access.,CVE-2024-36903,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnSUNRPC: add a missing rpc_stat for TCP TLSnnCommit 1548036ef120 (nfs: make the rpc_stat per net namespace) addednfunctionality to specify rpc_stats function but missed adding it to thenTCP TLS functionality. As the result mounting with xprtsec=tls lead tonthe following kernel oops.nn[ 128.984192] Unable to handle kernel NULL pointer dereference atnvirtual address 000000000000001cn[ 128.985058] Mem abort info:n[ 128.985372] ESR = 0x0000000096000004n[ 128.985709] EC = 0x25: DABT (current EL) IL = 32 bitsn[ 128.986176] SET = 0 FnV = 0n[ 128.986521] EA = 0 S1PTW = 0n[ 128.986804] FSC = 0x04: level 0 translation faultn[ 128.987229] Data abort info:n[ 128.987597] ISV = 0 ISS = 0x00000004 ISS2 = 0x00000000n[ 128.988169] CM = 0 WnR = 0 TnD = 0 TagAccess = 0n[ 128.988811] GCS = 0 Overlay = 0 DirtyBit = 0 Xs = 0n[ 128.989302] user pgtable: 4k pages 48-bit VAs pgdp=0000000106c84000n[ 128.990048] [000000000000001c] pgd=0000000000000000 p4d=0000000000000000n[ 128.990736] Internal error: Oops: 0000000096000004 [#1] SMPn[ 128.991168] Modules linked in: nfs_layout_nfsv41_filesnrpcsec_gss_krb5 auth_rpcgss nfsv4 dns_resolver nfs lockd grace netfsnuinput dm_mod nft_fib_inet nft_fib_ipv4 nft_fib_ipv6 nft_fibnnft_reject_inet nf_reject_ipv4 nf_reject_ipv6 nft_reject nft_ctnnft_chain_nat nf_nat nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 rfkillnip_set nf_tables nfnetlink qrtr vsock_loopbacknvmw_vsock_virtio_transport_common vmw_vsock_vmci_transport vsocknsunrpc vfat fat uvcvideo videobuf2_vmalloc videobuf2_memops uvcnvideobuf2_v4l2 videodev videobuf2_common mc vmw_vmci xfs libcrc32cne1000e crct10dif_ce ghash_ce sha2_ce vmwgfx nvme sha256_arm64nnvme_core sr_mod cdrom sha1_ce drm_ttm_helper ttm drm_kms_helper drmnsg fusen[ 128.996466] CPU: 0 PID: 179 Comm: kworker/u4:26 Kdump: loaded Notntainted 6.8.0-rc6+ #12n[ 128.997226] Hardware name: VMware Inc. VMware201/VBSA BIOSnVMW201.00V.21805430.BA64.2305221830 05/22/2023n[ 128.998084] Workqueue: xprtiod xs_tcp_tls_setup_socket [sunrpc]n[ 128.998701] pstate: 81400005 (Nzcv daif +PAN -UAO -TCO +DIT -SSBS BTYPE=--)n[ 128.999384] pc : call_start+0x74/0x138 [sunrpc]n[ 128.999809] lr : __rpc_execute+0xb8/0x3e0 [sunrpc]n[ 129.000244] sp : ffff8000832b3a00n[ 129.000508] x29: ffff8000832b3a00 x28: ffff800081ac79c0 x27: ffff800081ac7000n[ 129.001111] x26: 0000000004248060 x25: 0000000000000000 x24: ffff800081596008n[ 129.001757] x23: ffff80007b087240 x22: ffff00009a509d30 x21: 0000000000000000n[ 129.002345] x20: ffff000090075600 x19: ffff00009a509d00 x18: ffffffffffffffffn[ 129.002912] x17: 733d4d4554535953 x16: 42555300312d746e x15: ffff8000832b3a88n[ 129.003464] x14: ffffffffffffffff x13: ffff8000832b3a7d x12: 0000000000000008n[ 129.004021] x11: 0101010101010101 x10: ffff8000150cb560 x9 : ffff80007b087c00n[ 129.004577] x8 : ffff00009a509de0 x7 : 0000000000000000 x6 : 00000000be8c4ee3n[ 129.005026] x5 : 0000000000000000 x4 : 0000000000000000 x3 : ffff000094d56680n[ 129.005425] x2 : ffff80007b0637f8 x1 : ffff000090075600 x0 : ffff00009a509d00n[ 129.005824] Call trace:n[ 129.005967] call_start+0x74/0x138 [sunrpc]n[ 129.006233] __rpc_execute+0xb8/0x3e0 [sunrpc]n[ 129.006506] rpc_execute+0x160/0x1d8 [sunrpc]n[ 129.006778] rpc_run_task+0x148/0x1f8 [sunrpc]n[ 129.007204] tls_probe+0x80/0xd0 [sunrpc]n[ 129.007460] rpc_ping+0x28/0x80 [sunrpc]n[ 129.007715] rpc_create_xprt+0x134/0x1a0 [sunrpc]n[ 129.007999] rpc_create+0x128/0x2a0 [sunrpc]n[ 129.008264] xs_tcp_tls_setup_socket+0xdc/0x508 [sunrpc]n[ 129.008583] process_one_work+0x174/0x3c8n[ 129.008813] worker_thread+0x2c8/0x3e0n[ 129.009033] kthread+0x100/0x110n[ 129.009225] ret_from_fork+0x10/0x20n[ 129.009432] Code: f0ffffc2 911fe042 aa1403e1 aa1303e0 (b9401c83),CVE-2024-36907,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnblk-iocost: do not WARN if iocg was already offlinednnIn iocg_pay_debt() warn is triggered if 'active_list' is empty whichnis intended to confirm iocg is active when it has debt. However warnncan be triggered during a blkcg or disk removal if iocg_waitq_timer_fn()nis run at that time:nn WARNING: CPU: 0 PID: 2344971 at block/blk-iocost.c:1402 iocg_pay_debt+0x14c/0x190n Call trace:n iocg_pay_debt+0x14c/0x190n iocg_kick_waitq+0x438/0x4c0n iocg_waitq_timer_fn+0xd8/0x130n __run_hrtimer+0x144/0x45cn __hrtimer_run_queues+0x16c/0x244n hrtimer_interrupt+0x2cc/0x7b0nnThe warn in this situation is meaningless. Since this iocg is beingnremoved the state of the 'active_list' is irrelevant and 'waitq_timer'nis canceled after removing 'active_list' in ioc_pd_free() which ensuresniocg is freed after iocg_waitq_timer_fn() returns.nnTherefore add the check if iocg was already offlined to avoid warnnwhen removing a blkcg or disk.,CVE-2024-36908,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnDrivers: hv: vmbus: Don't free ring buffers that couldn't be re-encryptednnIn CoCo VMs it is possible for the untrusted host to causenset_memory_encrypted() or set_memory_decrypted() to fail such that annerror is returned and the resulting memory is shared. Callers need tontake care to handle these errors to avoid returning decrypted (shared)nmemory to the page allocator which could lead to functional or securitynissues.nnThe VMBus ring buffer code could free decrypted/shared pages ifnset_memory_decrypted() fails. Check the decrypted field in the structnvmbus_gpadl for the ring buffers to decide whether to free the memory.,CVE-2024-36909,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnuio_hv_generic: Don't free decrypted memorynnIn CoCo VMs it is possible for the untrusted host to causenset_memory_encrypted() or set_memory_decrypted() to fail such that annerror is returned and the resulting memory is shared. Callers need tontake care to handle these errors to avoid returning decrypted (shared)nmemory to the page allocator which could lead to functional or securitynissues.nnThe VMBus device UIO driver could free decrypted/shared pages ifnset_memory_decrypted() fails. Check the decrypted field in the gpadlnto decide whether to free the memory.,CVE-2024-36910,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnhv_netvsc: Don't free decrypted memorynnIn CoCo VMs it is possible for the untrusted host to causenset_memory_encrypted() or set_memory_decrypted() to fail such that annerror is returned and the resulting memory is shared. Callers need tontake care to handle these errors to avoid returning decrypted (shared)nmemory to the page allocator which could lead to functional or securitynissues.nnThe netvsc driver could free decrypted/shared pages ifnset_memory_decrypted() fails. Check the decrypted field in the gpadlnto decide whether to free the memory.,CVE-2024-36911,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Skip on writeback when it's not applicablenn[WHY]ndynamic memory safety error detector (KASAN) catches and generates errornmessages BUG: KASAN: slab-out-of-bounds as writeback connector does notnsupport certain features which are not initialized.nn[HOW]nSkip them when connector type is DRM_MODE_CONNECTOR_WRITEBACK.,CVE-2024-36914,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnfc: llcp: fix nfc_llcp_setsockopt() unsafe copiesnnsyzbot reported unsafe calls to copy_from_sockptr() [1]nnUse copy_safe_from_sockptr() instead.nn[1]nnBUG: KASAN: slab-out-of-bounds in copy_from_sockptr_offset include/linux/sockptr.h:49 [inline]n BUG: KASAN: slab-out-of-bounds in copy_from_sockptr include/linux/sockptr.h:55 [inline]n BUG: KASAN: slab-out-of-bounds in nfc_llcp_setsockopt+0x6c2/0x850 net/nfc/llcp_sock.c:255nRead of size 4 at addr ffff88801caa1ec3 by task syz-executor459/5078nnCPU: 0 PID: 5078 Comm: syz-executor459 Not tainted 6.8.0-syzkaller-08951-gfe46a7dd189e #0nHardware name: Google Google Compute Engine/Google Compute Engine BIOS Google 03/27/2024nCall Trace:n <TASK>n __dump_stack lib/dump_stack.c:88 [inline]n dump_stack_lvl+0x241/0x360 lib/dump_stack.c:114n print_address_description mm/kasan/report.c:377 [inline]n print_report+0x169/0x550 mm/kasan/report.c:488n kasan_report+0x143/0x180 mm/kasan/report.c:601n copy_from_sockptr_offset include/linux/sockptr.h:49 [inline]n copy_from_sockptr include/linux/sockptr.h:55 [inline]n nfc_llcp_setsockopt+0x6c2/0x850 net/nfc/llcp_sock.c:255n do_sock_setsockopt+0x3b1/0x720 net/socket.c:2311n __sys_setsockopt+0x1ae/0x250 net/socket.c:2334n __do_sys_setsockopt net/socket.c:2343 [inline]n __se_sys_setsockopt net/socket.c:2340 [inline]n __x64_sys_setsockopt+0xb5/0xd0 net/socket.c:2340n do_syscall_64+0xfd/0x240n entry_SYSCALL_64_after_hwframe+0x6d/0x75nRIP: 0033:0x7f7fac07fd89nCode: 28 00 00 00 75 05 48 83 c4 28 c3 e8 91 18 00 00 90 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 b8 ff ff ff f7 d8 64 89 01 48nRSP: 002b:00007fff660eb788 EFLAGS: 00000246 ORIG_RAX: 0000000000000036nRAX: ffffffffffffffda RBX: 0000000000000003 RCX: 00007f7fac07fd89nRDX: 0000000000000000 RSI: 0000000000000118 RDI: 0000000000000004nRBP: 0000000000000000 R08: 0000000000000002 R09: 0000000000000000nR10: 0000000020000a80 R11: 0000000000000246 R12: 0000000000000000nR13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000000,CVE-2024-36915,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnblock: fix overflow in blk_ioctl_discard()nnThere is no check for overflow of 'start + len' in blk_ioctl_discard().nHung task occurs if submit an discard ioctl with the following param:n start = 0x80000000000ff000 len = 0x8000000000fff000;nAdd the overflow validation now.,CVE-2024-36917,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnwifi: iwlwifi: mvm: guard against invalid STA ID on removalnnGuard against invalid station IDs in iwl_mvm_mld_rm_sta_id as that wouldnresult in out-of-bounds array accesses. This prevents issues should thendriver get into a bad state during error handling.,CVE-2024-36921,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnwifi: iwlwifi: read txq->read_ptr under locknnIf we read txq->read_ptr without lock we can read the samenvalue twice then obtain the lock and reclaim from therento two different places but crucially reclaim the samenentry twice resulting in the WARN_ONCE() a little later.nFix that by reading txq->read_ptr under lock.,CVE-2024-36922,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnfs/9p: fix uninitialized values during inode evictnnIf an iget fails due to not being able to retrieve informationnfrom the server then the inode structure is only partiallyninitialized. When the inode gets evicted references tonuninitialized structures (like fscache cookies) were beingnmade.nnThis patch checks for a bad_inode before doing anything othernthan clearing the inode from the cache. Since the inode isnbad it shouldn't have any state associated with it that needsnto be written back (and there really isn't a way to completenthose anyways).,CVE-2024-36923,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnscsi: lpfc: Release hbalock before calling lpfc_worker_wake_up()nnlpfc_worker_wake_up() calls the lpfc_work_done() routine which takes thenhbalock. Thus lpfc_worker_wake_up() should not be called while holding thenhbalock to avoid potential deadlock.,CVE-2024-36924,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnipv4: Fix uninit-value access in __ip_make_skb()nnKMSAN reported uninit-value access in __ip_make_skb() [1]. __ip_make_skb()ntests HDRINCL to know if the skb has icmphdr. However HDRINCL can cause anrace condition. If calling setsockopt(2) with IP_HDRINCL changes HDRINCLnwhile __ip_make_skb() is running the function will access icmphdr in thenskb even if it is not included. This causes the issue reported by KMSAN.nnCheck FLOWI_FLAG_KNOWN_NH on fl4->flowi4_flags instead of testing HDRINCLnon the socket.nnAlso fl4->fl4_icmp_type and fl4->fl4_icmp_code are not initialized. Thesenare union in struct flowi4 and are implicitly initialized bynflowi4_init_output() but we should not rely on specific union layout.nnInitialize these explicitly in raw_sendmsg().nn[1]nBUG: KMSAN: uninit-value in __ip_make_skb+0x2b74/0x2d20 net/ipv4/ip_output.c:1481n __ip_make_skb+0x2b74/0x2d20 net/ipv4/ip_output.c:1481n ip_finish_skb include/net/ip.h:243 [inline]n ip_push_pending_frames+0x4c/0x5c0 net/ipv4/ip_output.c:1508n raw_sendmsg+0x2381/0x2690 net/ipv4/raw.c:654n inet_sendmsg+0x27b/0x2a0 net/ipv4/af_inet.c:851n sock_sendmsg_nosec net/socket.c:730 [inline]n __sock_sendmsg+0x274/0x3c0 net/socket.c:745n __sys_sendto+0x62c/0x7b0 net/socket.c:2191n __do_sys_sendto net/socket.c:2203 [inline]n __se_sys_sendto net/socket.c:2199 [inline]n __x64_sys_sendto+0x130/0x200 net/socket.c:2199n do_syscall_64+0xd8/0x1f0 arch/x86/entry/common.c:83n entry_SYSCALL_64_after_hwframe+0x6d/0x75nnUninit was created at:n slab_post_alloc_hook mm/slub.c:3804 [inline]n slab_alloc_node mm/slub.c:3845 [inline]n kmem_cache_alloc_node+0x5f6/0xc50 mm/slub.c:3888n kmalloc_reserve+0x13c/0x4a0 net/core/skbuff.c:577n __alloc_skb+0x35a/0x7c0 net/core/skbuff.c:668n alloc_skb include/linux/skbuff.h:1318 [inline]n __ip_append_data+0x49ab/0x68c0 net/ipv4/ip_output.c:1128n ip_append_data+0x1e7/0x260 net/ipv4/ip_output.c:1365n raw_sendmsg+0x22b1/0x2690 net/ipv4/raw.c:648n inet_sendmsg+0x27b/0x2a0 net/ipv4/af_inet.c:851n sock_sendmsg_nosec net/socket.c:730 [inline]n __sock_sendmsg+0x274/0x3c0 net/socket.c:745n __sys_sendto+0x62c/0x7b0 net/socket.c:2191n __do_sys_sendto net/socket.c:2203 [inline]n __se_sys_sendto net/socket.c:2199 [inline]n __x64_sys_sendto+0x130/0x200 net/socket.c:2199n do_syscall_64+0xd8/0x1f0 arch/x86/entry/common.c:83n entry_SYSCALL_64_after_hwframe+0x6d/0x75nnCPU: 1 PID: 15709 Comm: syz-executor.7 Not tainted 6.8.0-11567-gb3603fcb79b1 #25nHardware name: QEMU Standard PC (i440FX + PIIX 1996) BIOS 1.16.3-1.fc39 04/01/2014,CVE-2024-36927,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nns390/qeth: Fix kernel panic after setting hsuidnnSymptom:nWhen the hsuid attribute is set for the first time on an IQD Layer3ndevice while the corresponding network interface is already UPnthe kernel will try to execute a napi function pointer that is NULL.nnExample:n---------------------------------------------------------------------------n[ 2057.572696] illegal operation: 0001 ilc:1 [#1] SMPn[ 2057.572702] Modules linked in: af_iucv qeth_l3 zfcp scsi_transport_fc sunrpc nft_fib_inet nft_fib_ipv4 nft_fib_ipv6 nft_fib nft_reject_inet nf_reject_ipv4 nf_reject_ipv6nnft_reject nft_ct nf_tables_set nft_chain_nat nf_nat nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 ip_set nf_tables libcrc32c nfnetlink ghash_s390 prng xts aes_s390 des_s390 dens_generic sha3_512_s390 sha3_256_s390 sha512_s390 vfio_ccw vfio_mdev mdev vfio_iommu_type1 eadm_sch vfio ext4 mbcache jbd2 qeth_l2 bridge stp llc dasd_eckd_mod qeth dasd_modn qdio ccwgroup pkey zcryptn[ 2057.572739] CPU: 6 PID: 60182 Comm: stress_client Kdump: loaded Not tainted 4.18.0-541.el8.s390x #1n[ 2057.572742] Hardware name: IBM 3931 A01 704 (LPAR)n[ 2057.572744] Krnl PSW : 0704f00180000000 0000000000000002 (0x2)n[ 2057.572748] R:0 T:1 IO:1 EX:1 Key:0 M:1 W:0 P:0 AS:3 CC:3 PM:0 RI:0 EA:3n[ 2057.572751] Krnl GPRS: 0000000000000004 0000000000000000 00000000a3b008d8 0000000000000000n[ 2057.572754] 00000000a3b008d8 cb923a29c779abc5 0000000000000000 00000000814cfd80n[ 2057.572756] 000000000000012c 0000000000000000 00000000a3b008d8 00000000a3b008d8n[ 2057.572758] 00000000bab6d500 00000000814cfd80 0000000091317e46 00000000814cfc68n[ 2057.572762] Krnl Code:#0000000000000000: 0000 illegaln >0000000000000002: 0000 illegaln 0000000000000004: 0000 illegaln 0000000000000006: 0000 illegaln 0000000000000008: 0000 illegaln 000000000000000a: 0000 illegaln 000000000000000c: 0000 illegaln 000000000000000e: 0000 illegaln[ 2057.572800] Call Trace:n[ 2057.572801] ([<00000000ec639700>] 0xec639700)n[ 2057.572803] [<00000000913183e2>] net_rx_action+0x2ba/0x398n[ 2057.572809] [<0000000091515f76>] __do_softirq+0x11e/0x3a0n[ 2057.572813] [<0000000090ce160c>] do_softirq_own_stack+0x3c/0x58n[ 2057.572817] ([<0000000090d2cbd6>] do_softirq.part.1+0x56/0x60)n[ 2057.572822] [<0000000090d2cc60>] __local_bh_enable_ip+0x80/0x98n[ 2057.572825] [<0000000091314706>] __dev_queue_xmit+0x2be/0xd70n[ 2057.572827] [<000003ff803dd6d6>] afiucv_hs_send+0x24e/0x300 [af_iucv]n[ 2057.572830] [<000003ff803dd88a>] iucv_send_ctrl+0x102/0x138 [af_iucv]n[ 2057.572833] [<000003ff803de72a>] iucv_sock_connect+0x37a/0x468 [af_iucv]n[ 2057.572835] [<00000000912e7e90>] __sys_connect+0xa0/0xd8n[ 2057.572839] [<00000000912e9580>] sys_socketcall+0x228/0x348n[ 2057.572841] [<0000000091514e1a>] system_call+0x2a6/0x2c8n[ 2057.572843] Last Breaking-Event-Address:n[ 2057.572844] [<0000000091317e44>] __napi_poll+0x4c/0x1d8n[ 2057.572846]n[ 2057.572847] Kernel panic - not syncing: Fatal exception in interruptn-------------------------------------------------------------------------------------------nnAnalysis:nThere is one napi structure per out_q: card->qdio.out_qs[i].napinThe napi.poll functions are set during qeth_open().nnSincencommit 1cfef80d4c2b (s390/qeth: Don't call dev_close/dev_open (DOWN/UP))nqeth_set_offline()/qeth_set_online() no longer call dev_close()/ndev_open(). So if qeth_free_qdio_queues() clearedncard->qdio.out_qs[i].napi.poll while the network interface was UP and thencard was offline they are not set again.nnReproduction:nchzdev -e $devno layer2=0nip link set dev $network_interface upnecho 0 > /sys/bus/ccwn---truncated---,CVE-2024-36928,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnamd/amdkfd: sync all devices to wait all processes being evictednnIf there are more than one device doing reset in parallel the firstndevice will call kfd_suspend_all_processes() to evict all processesnon all devices this call takes time to finish. other device willnstart reset and recover without waiting. if the process has not beennevicted before doing recover it will be restored then caused pagenfault.,CVE-2024-36949,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amdkfd: range check cp bad op exception interruptsnnDue to a CP interrupt bug bad packet garbage exception codes are raised.nDo a range check so that the debugger and runtime do not receive garbagencodes.nUpdate the user api to guard exception code type checking as well.,CVE-2024-36951,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnscsi: lpfc: Move NPIV's transport unregistration to after resource clean upnnThere are cases after NPIV deletion where the fabric switch still believesnthe NPIV is logged into the fabric. This occurs when a vport isnunregistered before the Remove All DA_ID CT and LOGO ELS are sent to thenfabric.nnCurrently fc_remove_host() which calls dev_loss_tmo for all D_IDs includingnthe fabric D_ID removes the last ndlp reference and frees the ndlp rportnobject. This sometimes causes the race condition where the final DA_ID andnLOGO are skipped from being sent to the fabric switch.nnFix by moving the fc_remove_host() and scsi_remove_host() calls after DA_IDnand LOGO are sent.,CVE-2024-36952,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnBluetooth: L2CAP: Fix div-by-zero in l2cap_le_flowctl_init()nnl2cap_le_flowctl_init() can cause both div-by-zero and an integernoverflow since hdev->le_mtu may not fall in the valid range.nnMove MTU from hci_dev to hci_conn to validate MTU and stop the connectionnprocess earlier if MTU is invalid.nAlso add a missing validation in read_buffer_size() and make it returnnan error value if the validation fails.nNow hci_conn_add() returns ERR_PTR() as it can fail due to the both ankzalloc failure and invalid MTU value.nndivide error: 0000 [#1] PREEMPT SMP KASAN NOPTInCPU: 0 PID: 67 Comm: kworker/u5:0 Tainted: G W 6.9.0-rc5+ #20nHardware name: QEMU Standard PC (i440FX + PIIX 1996) BIOS 1.15.0-1 04/01/2014nWorkqueue: hci0 hci_rx_worknRIP: 0010:l2cap_le_flowctl_init+0x19e/0x3f0 net/bluetooth/l2cap_core.c:547nCode: e8 17 17 0c 00 66 41 89 9f 84 00 00 00 bf 01 00 00 00 41 b8 02 00 00 00 4cn89 fe 4c 89 e2 89 d9 e8 27 17 0c 00 44 89 f0 31 d2 <66> f7 f3 89 c3 ff c3 4d 8dnb7 88 00 00 00 4c 89 f0 48 c1 e8 03 42nRSP: 0018:ffff88810bc0f858 EFLAGS: 00010246nRAX: 00000000000002a0 RBX: 0000000000000000 RCX: dffffc0000000000nRDX: 0000000000000000 RSI: ffff88810bc0f7c0 RDI: ffffc90002dcb66fnRBP: ffff88810bc0f880 R08: aa69db2dda70ff01 R09: 0000ffaaaaaaaaaanR10: 0084000000ffaaaa R11: 0000000000000000 R12: ffff88810d65a084nR13: dffffc0000000000 R14: 00000000000002a0 R15: ffff88810d65a000nFS: 0000000000000000(0000) GS:ffff88811ac00000(0000) knlGS:0000000000000000nCS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033nCR2: 0000000020000100 CR3: 0000000103268003 CR4: 0000000000770ef0nPKRU: 55555554nCall Trace:n <TASK>n l2cap_le_connect_req net/bluetooth/l2cap_core.c:4902 [inline]n l2cap_le_sig_cmd net/bluetooth/l2cap_core.c:5420 [inline]n l2cap_le_sig_channel net/bluetooth/l2cap_core.c:5486 [inline]n l2cap_recv_frame+0xe59d/0x11710 net/bluetooth/l2cap_core.c:6809n l2cap_recv_acldata+0x544/0x10a0 net/bluetooth/l2cap_core.c:7506n hci_acldata_packet net/bluetooth/hci_core.c:3939 [inline]n hci_rx_work+0x5e5/0xb20 net/bluetooth/hci_core.c:4176n process_one_work kernel/workqueue.c:3254 [inline]n process_scheduled_works+0x90f/0x1530 kernel/workqueue.c:3335n worker_thread+0x926/0xe70 kernel/workqueue.c:3416n kthread+0x2e3/0x380 kernel/kthread.c:388n ret_from_fork+0x5c/0x90 arch/x86/kernel/process.c:147n ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244n </TASK>nModules linked in:n---[ end trace 0000000000000000 ]---,CVE-2024-36968,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Fix division by zero in setup_dsc_confignnWhen slice_height is 0 the division by slice_height in the calculationnof the number of slices will cause a division by zero driver crash. Thisnleaves the kernel in a state that requires a reboot. This patch adds ancheck to avoid the division by zero.nnThe stack trace below is for the 6.8.4 Kernel. I reproduced the issue onna Z16 Gen 2 Lenovo Thinkpad with a Apple Studio Display monitornconnected via Thunderbolt. The amdgpu driver crashed with this exceptionnwhen I rebooted the system with the monitor connected.nnkernel: ? die (arch/x86/kernel/dumpstack.c:421 arch/x86/kernel/dumpstack.c:434 arch/x86/kernel/dumpstack.c:447)nkernel: ? do_trap (arch/x86/kernel/traps.c:113 arch/x86/kernel/traps.c:154)nkernel: ? setup_dsc_config (drivers/gpu/drm/amd/amdgpu/../display/dc/dsc/dc_dsc.c:1053) amdgpunkernel: ? do_error_trap (./arch/x86/include/asm/traps.h:58 arch/x86/kernel/traps.c:175)nkernel: ? setup_dsc_config (drivers/gpu/drm/amd/amdgpu/../display/dc/dsc/dc_dsc.c:1053) amdgpunkernel: ? exc_divide_error (arch/x86/kernel/traps.c:194 (discriminator 2))nkernel: ? setup_dsc_config (drivers/gpu/drm/amd/amdgpu/../display/dc/dsc/dc_dsc.c:1053) amdgpunkernel: ? asm_exc_divide_error (./arch/x86/include/asm/idtentry.h:548)nkernel: ? setup_dsc_config (drivers/gpu/drm/amd/amdgpu/../display/dc/dsc/dc_dsc.c:1053) amdgpunkernel: dc_dsc_compute_config (drivers/gpu/drm/amd/amdgpu/../display/dc/dsc/dc_dsc.c:1109) amdgpunnAfter applying this patch the driver no longer crashes when the monitornis connected and the system is rebooted. I believe this is the samenissue reported for 3113.,CVE-2024-36969,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnfpga: manager: add owner module and take its refcountnnThe current implementation of the fpga manager assumes that the low-levelnmodule registers a driver for the parent device and uses its owner pointernto take the module's refcount. This approach is problematic since it cannlead to a null pointer dereference while attempting to get the manager ifnthe parent device does not have a driver.nnTo address this problem add a module owner pointer to the fpga_managernstruct and use it to take the module's refcount. Modify the functions fornregistering the manager to take an additional owner module parameter andnrename them to avoid conflicts. Use the old function names for helpernmacros that automatically set the module that registers the manager as thenowner. This ensures compatibility with existing low-level control modulesnand reduces the chances of registering a manager without setting the owner.nnAlso update the documentation to keep it consistent with the new interfacenfor registering an fpga manager.nnOther changes: opportunistically move put_device() from __fpga_mgr_get() tonfpga_mgr_get() and of_fpga_mgr_get() to improve code clarity since thenmanager device is taken in these functions.,CVE-2024-37021,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbtrfs: fix crash on racing fsync and size-extending write into preallocnnWe have been seeing crashes on duplicate keys innbtrfs_set_item_key_safe():nn BTRFS critical (device vdb): slot 4 key (450 108 8192) new key (450 108 8192)n ------------[ cut here ]------------n kernel BUG at fs/btrfs/ctree.c:2620!n invalid opcode: 0000 [#1] PREEMPT SMP PTIn CPU: 0 PID: 3139 Comm: xfs_io Kdump: loaded Not tainted 6.9.0 #6n Hardware name: QEMU Standard PC (i440FX + PIIX 1996) BIOS 1.16.3-2.fc40 04/01/2014n RIP: 0010:btrfs_set_item_key_safe+0x11f/0x290 [btrfs]nnWith the following stack trace:nn #0 btrfs_set_item_key_safe (fs/btrfs/ctree.c:2620:4)n #1 btrfs_drop_extents (fs/btrfs/file.c:411:4)n #2 log_one_extent (fs/btrfs/tree-log.c:4732:9)n #3 btrfs_log_changed_extents (fs/btrfs/tree-log.c:4955:9)n #4 btrfs_log_inode (fs/btrfs/tree-log.c:6626:9)n #5 btrfs_log_inode_parent (fs/btrfs/tree-log.c:7070:8)n #6 btrfs_log_dentry_safe (fs/btrfs/tree-log.c:7171:8)n #7 btrfs_sync_file (fs/btrfs/file.c:1933:8)n #8 vfs_fsync_range (fs/sync.c:188:9)n #9 vfs_fsync (fs/sync.c:202:9)n #10 do_fsync (fs/sync.c:212:9)n #11 __do_sys_fdatasync (fs/sync.c:225:9)n #12 __se_sys_fdatasync (fs/sync.c:223:1)n #13 __x64_sys_fdatasync (fs/sync.c:223:1)n #14 do_syscall_x64 (arch/x86/entry/common.c:52:14)n #15 do_syscall_64 (arch/x86/entry/common.c:83:7)n #16 entry_SYSCALL_64+0xaf/0x14c (arch/x86/entry/entry_64.S:121)nnSo we're logging a changed extent from fsync which is splitting annextent in the log tree. But this split part already exists in the treentriggering the BUG().nnThis is the state of the log tree at the time of the crash dumped withndrgn (https://github.com/osandov/drgn/blob/main/contrib/btrfs_tree.py)nto get more details than btrfs_print_leaf() gives us:nn >>> print_extent_buffer(prog.crashed_thread().stack_trace()[0][eb])n leaf 33439744 level 0 items 72 generation 9 owner 18446744073709551610n leaf 33439744 flags 0x100000000000000n fs uuid e5bd3946-400c-4223-8923-190ef1f18677n chunk uuid d58cb17e-6d02-494a-829a-18b7d8a399dan item 0 key (450 INODE_ITEM 0) itemoff 16123 itemsize 160n generation 7 transid 9 size 8192 nbytes 8473563889606862198n block group 0 mode 100600 links 1 uid 0 gid 0 rdev 0n sequence 204 flags 0x10(PREALLOC)n atime 1716417703.220000000 (2024-05-22 15:41:43)n ctime 1716417704.983333333 (2024-05-22 15:41:44)n mtime 1716417704.983333333 (2024-05-22 15:41:44)n otime 17592186044416.000000000 (559444-03-08 01:40:16)n item 1 key (450 INODE_REF 256) itemoff 16110 itemsize 13n index 195 namelen 3 name: 193n item 2 key (450 XATTR_ITEM 1640047104) itemoff 16073 itemsize 37n location key (0 UNKNOWN.0 0) type XATTRn transid 7 data_len 1 name_len 6n name: user.an data an item 3 key (450 EXTENT_DATA 0) itemoff 16020 itemsize 53n generation 9 type 1 (regular)n extent data disk byte 303144960 nr 12288n extent data offset 0 nr 4096 ram 12288n extent compression 0 (none)n item 4 key (450 EXTENT_DATA 4096) itemoff 15967 itemsize 53n generation 9 type 2 (prealloc)n prealloc data disk byte 303144960 nr 12288n prealloc data offset 4096 nr 8192n item 5 key (450 EXTENT_DATA 8192) itemoff 15914 itemsize 53n generation 9 type 2 (prealloc)n prealloc data disk byte 303144960 nr 12288n prealloc data offset 8192 nr 4096n ...nnSo the real problem happened earlier: notice that items 4 (4k-12k) and 5n(8k-12k) overlap. Both are prealloc extents. Item 4 straddles i_size andnitem 5 starts at i_size.nnHere is the state of n---truncated---,CVE-2024-37354,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbnxt_re: avoid shift undefined behavior in bnxt_qplib_alloc_init_hwqnnUndefined behavior is triggered when bnxt_qplib_alloc_init_hwq is callednwith hwq_attr->aux_depth != 0 and hwq_attr->aux_stride == 0.nIn that case roundup_pow_of_two(hwq_attr->aux_stride) gets called.nroundup_pow_of_two is documented as undefined for 0.nnFix it in the one caller that had this combination.nnThe undefined behavior was detected by UBSAN:n UBSAN: shift-out-of-bounds in ./include/linux/log2.h:57:13n shift exponent 64 is too large for 64-bit type 'long unsigned int'n CPU: 24 PID: 1075 Comm: (udev-worker) Not tainted 6.9.0-rc6+ #4n Hardware name: Abacus electric s.r.o. - servis@abacus.cz Super Server/H12SSW-iN BIOS 2.7 10/25/2023n Call Trace:n <TASK>n dump_stack_lvl+0x5d/0x80n ubsan_epilogue+0x5/0x30n __ubsan_handle_shift_out_of_bounds.cold+0x61/0xecn __roundup_pow_of_two+0x25/0x35 [bnxt_re]n bnxt_qplib_alloc_init_hwq+0xa1/0x470 [bnxt_re]n bnxt_qplib_create_qp+0x19e/0x840 [bnxt_re]n bnxt_re_create_qp+0x9b1/0xcd0 [bnxt_re]n ? srso_alias_return_thunk+0x5/0xfbef5n ? srso_alias_return_thunk+0x5/0xfbef5n ? __kmalloc+0x1b6/0x4f0n ? create_qp.part.0+0x128/0x1c0 [ib_core]n ? __pfx_bnxt_re_create_qp+0x10/0x10 [bnxt_re]n create_qp.part.0+0x128/0x1c0 [ib_core]n ib_create_qp_kernel+0x50/0xd0 [ib_core]n create_mad_qp+0x8e/0xe0 [ib_core]n ? __pfx_qp_event_handler+0x10/0x10 [ib_core]n ib_mad_init_device+0x2be/0x680 [ib_core]n add_client_context+0x10d/0x1a0 [ib_core]n enable_device_and_get+0xe0/0x1d0 [ib_core]n ib_register_device+0x53c/0x630 [ib_core]n ? srso_alias_return_thunk+0x5/0xfbef5n bnxt_re_probe+0xbd8/0xe50 [bnxt_re]n ? __pfx_bnxt_re_probe+0x10/0x10 [bnxt_re]n auxiliary_bus_probe+0x49/0x80n ? driver_sysfs_add+0x57/0xc0n really_probe+0xde/0x340n ? pm_runtime_barrier+0x54/0x90n ? __pfx___driver_attach+0x10/0x10n __driver_probe_device+0x78/0x110n driver_probe_device+0x1f/0xa0n __driver_attach+0xba/0x1c0n bus_for_each_dev+0x8f/0xe0n bus_add_driver+0x146/0x220n driver_register+0x72/0xd0n __auxiliary_driver_register+0x6e/0xd0n ? __pfx_bnxt_re_mod_init+0x10/0x10 [bnxt_re]n bnxt_re_mod_init+0x3e/0xff0 [bnxt_re]n ? __pfx_bnxt_re_mod_init+0x10/0x10 [bnxt_re]n do_one_initcall+0x5b/0x310n do_init_module+0x90/0x250n init_module_from_file+0x86/0xc0n idempotent_init_module+0x121/0x2b0n __x64_sys_finit_module+0x5e/0xb0n do_syscall_64+0x82/0x160n ? srso_alias_return_thunk+0x5/0xfbef5n ? syscall_exit_to_user_mode_prepare+0x149/0x170n ? srso_alias_return_thunk+0x5/0xfbef5n ? syscall_exit_to_user_mode+0x75/0x230n ? srso_alias_return_thunk+0x5/0xfbef5n ? do_syscall_64+0x8e/0x160n ? srso_alias_return_thunk+0x5/0xfbef5n ? __count_memcg_events+0x69/0x100n ? srso_alias_return_thunk+0x5/0xfbef5n ? count_memcg_events.constprop.0+0x1a/0x30n ? srso_alias_return_thunk+0x5/0xfbef5n ? handle_mm_fault+0x1f0/0x300n ? srso_alias_return_thunk+0x5/0xfbef5n ? do_user_addr_fault+0x34e/0x640n ? srso_alias_return_thunk+0x5/0xfbef5n ? srso_alias_return_thunk+0x5/0xfbef5n entry_SYSCALL_64_after_hwframe+0x76/0x7en RIP: 0033:0x7f4e5132821dn Code: ff c3 66 2e 0f 1f 84 00 00 00 00 00 90 f3 0f 1e fa 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 8b 0d e3 db 0c 00 f7 d8 64 89 01 48n RSP: 002b:00007ffca9c906a8 EFLAGS: 00000246 ORIG_RAX: 0000000000000139n RAX: ffffffffffffffda RBX: 0000563ec8a8f130 RCX: 00007f4e5132821dn RDX: 0000000000000000 RSI: 00007f4e518fa07d RDI: 000000000000003bn RBP: 00007ffca9c90760 R08: 00007f4e513f6b20 R09: 00007ffca9c906f0n R10: 0000563ec8a8faa0 R11: 0000000000000246 R12: 00007f4e518fa07dn R13: 0000000000020000 R14: 0000563ec8409e90 R15: 0000563ec8a8fa60n </TASK>n ---[ end trace ]---,CVE-2024-38540,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnof: module: add buffer overflow check in of_modalias()nnIn of_modalias() if the buffer happens to be too small even for the 1stnsnprintf() call the len parameter will become negative and str parametern(if not NULL initially) will point beyond the buffer's end. Add the buffernoverflow check after the 1st snprintf() call and fix such check after thenstrlen() call (accounting for the terminating NUL char).,CVE-2024-38541,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnlib/test_hmm.c: handle src_pfns and dst_pfns allocation failurennThe kcalloc() in dmirror_device_evict_chunk() will return null if thenphysical memory has run out. As a result if src_pfns or dst_pfns isndereferenced the null pointer dereference bug will happen.nnMoreover the device is going away. If the kcalloc() fails the pagesnmapping a chunk could not be evicted. So add a __GFP_NOFAIL flag innkcalloc().nnFinally as there is no need to have physically contiguous memory Switchnkcalloc() to kvcalloc() in order to avoid failing allocations.,CVE-2024-38543,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnRDMA/hns: Fix UAF for cq async eventnnThe refcount of CQ is not protected by locks. When CQ asynchronousnevents and CQ destruction are concurrent CQ may have been releasednwhich will cause UAF.nnUse the xa_lock() to protect the CQ refcount.,CVE-2024-38545,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet: fec: remove .ndo_poll_controller to avoid deadlocksnnThere is a deadlock issue found in sungem driver please refer to thencommit ac0a230f719b (eth: sungem: remove .ndo_poll_controller to avoidndeadlocks). The root cause of the issue is that netpoll is in atomicncontext and disable_irq() is called by .ndo_poll_controller interfacenof sungem driver however disable_irq() might sleep. After analyzingnthe implementation of fec_poll_controller() the fec driver should haventhe same issue. Due to the fec driver uses NAPI for TX completions then.ndo_poll_controller is unnecessary to be implemented in the fec drivernso fec_poll_controller() can be safely removed.,CVE-2024-38553,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnax25: Fix reference count leak issue of net_devicennThere is a reference count leak issue of the object net_device innax25_dev_device_down(). When the ax25 device is shutting down thenax25_dev_device_down() drops the reference count of net_device onenor zero times depending on if we goto unlock_put or not which willncause memory leak.nnIn order to solve the above issue decrease the reference count ofnnet_device after dev->ax25_ptr is set to null.,CVE-2024-38554,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet/mlx5: Add a timeout to acquire the command queue semaphorennPrevent forced completion handling on an entry that has not yet beennassigned an index causing an out of bounds access on idx = -22.nInstead of waiting indefinitely for the sem blocking flow now waits fornindex to be allocated or a sem acquisition timeout before beginning thentimer for FW completion.nnKernel log example:nmlx5_core 0000:06:00.0: wait_func_handle_exec_timeout:1128:(pid 185911): cmd[-22]: CREATE_UCTX(0xa04) No done completion,CVE-2024-38556,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbpf: Add BPF_PROG_TYPE_CGROUP_SKB attach type enforcement in BPF_LINK_CREATEnnbpf_prog_attach uses attach_type_to_prog_type to enforce propernattach type for BPF_PROG_TYPE_CGROUP_SKB. link_create usesnbpf_prog_get and relies on bpf_prog_attach_check_attach_typento properly verify prog_type <> attach_type association.nnAdd missing attach_type enforcement for the link_create case.nOtherwise it's currently possible to attach cgroup_skb progntypes to other cgroup hooks.,CVE-2024-38564,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nngfs2: Fix potential glock use-after-free on unmountnnWhen a DLM lockspace is released and there ares still locks in thatnlockspace DLM will unlock those locks automatically. Commitnfb6791d100d1b started exploiting this behavior to speed up filesystemnunmount: gfs2 would simply free glocks it didn't want to unlock and thennrelease the lockspace. This didn't take the bast callbacks fornasynchronous lock contention notifications into account which remainnactive until until a lock is unlocked or its lockspace is released.nnTo prevent those callbacks from accessing deallocated objects put thenglocks that should not be unlocked on the sd_dead_glocks list releasenthe lockspace and only then free those glocks.nnAs an additional measure ignore unexpected ast and bast callbacks ifnthe receiving glock is dead.,CVE-2024-38570,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnepoll: be better about file lifetimesnnepoll can call out to vfs_poll() with a file pointer that may race withnthe last 'fput()'. That would make f_count go down to zero and whilenthe ep->mtx locking means that the resulting file pointer tear-down willnbe blocked until the poll returns it means that f_count is alreadyndead and any use of it won't actually get a reference to the file anynmore: it's dead regardless.nnMake sure we have a valid ref on the file pointer before we call down tonvfs_poll() from the epoll routines.,CVE-2024-38580,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amdgpu/mes: fix use-after-free issuennDelete fence fallback timer to fix the ramdomnuse-after-free issue.nnv2: move to amdgpu_mes.c,CVE-2024-38581,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet: stmmac: move the EST lock to struct stmmac_privnnReinitialize the whole EST structure would also reset the mutexnlock which is embedded in the EST structure and then triggernthe following warning. To address this move the lock to structnstmmac_priv. We also need to reacquire the mutex lock when doingnthis initialization.nnDEBUG_LOCKS_WARN_ON(lock->magic != lock)nWARNING: CPU: 3 PID: 505 at kernel/locking/mutex.c:587 __mutex_lock+0xd84/0x1068n Modules linked in:n CPU: 3 PID: 505 Comm: tc Not tainted 6.9.0-rc6-00053-g0106679839f7-dirty #29n Hardware name: NXP i.MX8MPlus EVK board (DT)n pstate: 60000005 (nZCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)n pc : __mutex_lock+0xd84/0x1068n lr : __mutex_lock+0xd84/0x1068n sp : ffffffc0864e3570n x29: ffffffc0864e3570 x28: ffffffc0817bdc78 x27: 0000000000000003n x26: ffffff80c54f1808 x25: ffffff80c9164080 x24: ffffffc080d723acn x23: 0000000000000000 x22: 0000000000000002 x21: 0000000000000000n x20: 0000000000000000 x19: ffffffc083bc3000 x18: ffffffffffffffffn x17: ffffffc08117b080 x16: 0000000000000002 x15: ffffff80d2d40000n x14: 00000000000002da x13: ffffff80d2d404b8 x12: ffffffc082b5a5c8n x11: ffffffc082bca680 x10: ffffffc082bb2640 x9 : ffffffc082bb2698n x8 : 0000000000017fe8 x7 : c0000000ffffefff x6 : 0000000000000001n x5 : ffffff8178fe0d48 x4 : 0000000000000000 x3 : 0000000000000027n x2 : ffffff8178fe0d50 x1 : 0000000000000000 x0 : 0000000000000000n Call trace:n __mutex_lock+0xd84/0x1068n mutex_lock_nested+0x28/0x34n tc_setup_taprio+0x118/0x68cn stmmac_setup_tc+0x50/0xf0n taprio_change+0x868/0xc9c,CVE-2024-38594,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnALSA: Fix deadlocks with kctl removals at disconnectionnnIn snd_card_disconnect() we set card->shutdown flag at the beginningncall callbacks and do sync for card->power_ref_sleep waiters at thenend. The callback may delete a kctl element and this can lead to andeadlock when the device was in the suspended state. Namely:nn* A process waits for the power up at snd_power_ref_and_wait() inn snd_ctl_info() or read/write() inside card->controls_rwsem.nn* The system gets disconnected meanwhile and the driver tries ton delete a kctl via snd_ctl_remove*(); it tries to taken card->controls_rwsem again but this is already locked by then above. Since the sleeper isn't woken up this deadlocks.nnAn easy fix is to wake up sleepers before processing the driverndisconnect callbacks but right after setting the card->shutdown flag.nThen all sleepers will abort immediately and the code flows again.nnSo basically this patch moves the wait_event() call at the rightntiming. While we're at it just to be sure call wait_event_all()ninstead of wait_event() although we don't use exclusive events onnthis queue for now.,CVE-2024-38600,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnax25: Fix reference count leak issues of ax25_devnnThe ax25_addr_ax25dev() and ax25_dev_device_down() exist a referencencount leak issue of the object ax25_dev.nnMemory leak issue in ax25_addr_ax25dev():nnThe reference count of the object ax25_dev can be increased multiplentimes in ax25_addr_ax25dev(). This will cause a memory leak.nnMemory leak issues in ax25_dev_device_down():nnThe reference count of ax25_dev is set to 1 in ax25_dev_device_up() andnthen increase the reference count when ax25_dev is added to ax25_dev_list.nAs a result the reference count of ax25_dev is 2. But when the device isnshutting down. The ax25_dev_device_down() drops the reference count oncenor twice depending on if we goto unlock_put or not which will causenmemory leak.nnAs for the issue of ax25_addr_ax25dev() it is impossible for one pointernto be on a list twice. So add a break in ax25_addr_ax25dev(). As for thenissue of ax25_dev_device_down() increase the reference count of ax25_devnonce in ax25_dev_device_up() and decrease the reference count of ax25_devnafter it is removed from the ax25_dev_list.,CVE-2024-38602,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet/mlx5e: Fix netif state handlingnnmlx5e_suspend cleans resources only if netif_device_present() returnsntrue. However mlx5e_resume changes the state of netif vianmlx5e_nic_enable only if reg_state == NETREG_REGISTERED.nIn the below case the above leads to NULL-ptr Oops[1] and memorynleaks:nnmlx5e_proben _mlx5e_resumen mlx5e_attach_netdevn mlx5e_nic_enable <-- netdev not reg not calling netif_device_attach()n register_netdev <-- failed for some reason.nERROR_FLOW:n _mlx5e_suspend <-- netif_device_present return false resources aren't freed :(nnHence clean resources in this case as well.nn[1]nBUG: kernel NULL pointer dereference address: 0000000000000000nPGD 0 P4D 0nOops: 0010 [#1] SMPnCPU: 2 PID: 9345 Comm: test-ovs-ct-gen Not tainted 6.5.0_for_upstream_min_debug_2023_09_05_16_01 #1nHardware name: QEMU Standard PC (Q35 + ICH9 2009) BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014nRIP: 0010:0x0nCode: Unable to access opcode bytes at0xffffffffffffffd6.nRSP: 0018:ffff888178aaf758 EFLAGS: 00010246nCall Trace:n <TASK>n ? __die+0x20/0x60n ? page_fault_oops+0x14c/0x3c0n ? exc_page_fault+0x75/0x140n ? asm_exc_page_fault+0x22/0x30n notifier_call_chain+0x35/0xb0n blocking_notifier_call_chain+0x3d/0x60n mlx5_blocking_notifier_call_chain+0x22/0x30 [mlx5_core]n mlx5_core_uplink_netdev_event_replay+0x3e/0x60 [mlx5_core]n mlx5_mdev_netdev_track+0x53/0x60 [mlx5_ib]n mlx5_ib_roce_init+0xc3/0x340 [mlx5_ib]n __mlx5_ib_add+0x34/0xd0 [mlx5_ib]n mlx5r_probe+0xe1/0x210 [mlx5_ib]n ? auxiliary_match_id+0x6a/0x90n auxiliary_bus_probe+0x38/0x80n ? driver_sysfs_add+0x51/0x80n really_probe+0xc9/0x3e0n ? driver_probe_device+0x90/0x90n __driver_probe_device+0x80/0x160n driver_probe_device+0x1e/0x90n __device_attach_driver+0x7d/0x100n bus_for_each_drv+0x80/0xd0n __device_attach+0xbc/0x1f0n bus_probe_device+0x86/0xa0n device_add+0x637/0x840n __auxiliary_device_add+0x3b/0xa0n add_adev+0xc9/0x140 [mlx5_core]n mlx5_rescan_drivers_locked+0x22a/0x310 [mlx5_core]n mlx5_register_device+0x53/0xa0 [mlx5_core]n mlx5_init_one_devl_locked+0x5c4/0x9c0 [mlx5_core]n mlx5_init_one+0x3b/0x60 [mlx5_core]n probe_one+0x44c/0x730 [mlx5_core]n local_pci_probe+0x3e/0x90n pci_device_probe+0xbf/0x210n ? kernfs_create_link+0x5d/0xa0n ? sysfs_do_create_link_sd+0x60/0xc0n really_probe+0xc9/0x3e0n ? driver_probe_device+0x90/0x90n __driver_probe_device+0x80/0x160n driver_probe_device+0x1e/0x90n __device_attach_driver+0x7d/0x100n bus_for_each_drv+0x80/0xd0n __device_attach+0xbc/0x1f0n pci_bus_add_device+0x54/0x80n pci_iov_add_virtfn+0x2e6/0x320n sriov_enable+0x208/0x420n mlx5_core_sriov_configure+0x9e/0x200 [mlx5_core]n sriov_numvfs_store+0xae/0x1a0n kernfs_fop_write_iter+0x10c/0x1a0n vfs_write+0x291/0x3c0n ksys_write+0x5f/0xe0n do_syscall_64+0x3d/0x90n entry_SYSCALL_64_after_hwframe+0x46/0xb0n CR2: 0000000000000000n ---[ end trace 0000000000000000 ]---,CVE-2024-38608,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnmedia: i2c: et8ek8: Don't strip remove function when driver is builtinnnUsing __exit for the remove function results in the remove callbacknbeing discarded with CONFIG_VIDEO_ET8EK8=y. When such a device getsnunbound (e.g. using sysfs or hotplug) the driver is just removednwithout the cleanup being performed. This results in resource leaks. Fixnit by compiling in the remove callback unconditionally.nnThis also fixes a W=1 modpost warning:nntWARNING: modpost: drivers/media/i2c/et8ek8/et8ek8: section mismatch in reference: et8ek8_i2c_driver+0x10 (section: .data) -> et8ek8_remove (section: .exit.text),CVE-2024-38611,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnBluetooth: HCI: Remove HCI_AMP supportnnSince BT_HS has been remove HCI_AMP controllers no longer has any use sonremove it along with the capability of creating AMP controllers.nnSince we no longer need to differentiate between AMP and Primaryncontrollers as only HCI_PRIMARY is left this also removenhdev->dev_type altogether.,CVE-2024-38620,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnwatchdog: cpu5wdt.c: Fix use-after-free bug caused by cpu5wdt_triggernnWhen the cpu5wdt module is removing the origin code uses del_timer() tonde-activate the timer. If the timer handler is running del_timer() couldnnot stop it and will return directly. If the port region is released bynrelease_region() and then the timer handler cpu5wdt_trigger() calls outb()nto write into the region that is released the use-after-free bug willnhappen.nnChange del_timer() to timer_shutdown_sync() in order that the timer handlerncould be finished before the port region is released.,CVE-2024-38630,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnvfio/pci: fix potential memory leak in vfio_intx_enable()nnIf vfio_irq_ctx_alloc() failed will lead to 'name' memory leak.,CVE-2024-38632,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnriscv: prevent pt_regs corruption for secondary idle threadsnnTop of the kernel thread stack should be reserved for pt_regs. Howevernthis is not the case for the idle threads of the secondary boot harts.nTheir stacks overlap with their pt_regs so both may get corrupted.nnSimilar issue has been fixed for the primary hart see c7cdd96eca28n(riscv: prevent stack corruption by reserving task_pt_regs(p) early).nHowever that fix was not propagated to the secondary harts. The problemnhas been noticed in some CPU hotplug tests with V enabled. The functionnsmp_callin stored several registers on stack corrupting top of pt_regsnstructure including status field. As a result kernel attempted to savenor restore inexistent V context.,CVE-2024-38667,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnxfs: fix log recovery buffer allocation for the legacy h_size fixupnnCommit a70f9fe52daa (xfs: detect and handle invalid iclog size set bynmkfs) added a fixup for incorrect h_size values used for the initialnumount record in old xfsprogs versions. Later commit 0c771b99d6c9n(xfs: clean up calculation of LR header blocks) cleaned up the lognreover buffer calculation but stoped using the fixed up h_size valuento size the log recovery buffer which can lead to an out of boundsnaccess when the incorrect h_size does not come from the old mkfsntool but a fuzzer.nnFix this by open coding xlog_logrec_hblks and taking the fixed h_sizeninto account for this calculation.,CVE-2024-39472,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/i915/hwmon: Get rid of devmnnWhen both hwmon and hwmon drvdata (on which hwmon depends) are devicenmanaged resources the expectation on device unbind is that hwmon will benreleased before drvdata. However in i915 there are two separate codenpaths which both release either drvdata or hwmon and either can benreleased before the other. These code paths (for device unbind) are asnfollows (see also the bug referenced below):nnCall Trace:nrelease_nodes+0x11/0x70ndevres_release_group+0xb2/0x110ncomponent_unbind_all+0x8d/0xa0ncomponent_del+0xa5/0x140nintel_pxp_tee_component_fini+0x29/0x40 [i915]nintel_pxp_fini+0x33/0x80 [i915]ni915_driver_remove+0x4c/0x120 [i915]ni915_pci_remove+0x19/0x30 [i915]npci_device_remove+0x32/0xa0ndevice_release_driver_internal+0x19c/0x200nunbind_store+0x9c/0xb0nnandnnCall Trace:nrelease_nodes+0x11/0x70ndevres_release_all+0x8a/0xc0ndevice_unbind_cleanup+0x9/0x70ndevice_release_driver_internal+0x1c1/0x200nunbind_store+0x9c/0xb0nnThis means that in i915 if use devm we cannot gurantee that hwmon willnalways be released before drvdata. Which means that we have a uaf if hwmonnsysfs is accessed when drvdata has been released but hwmon hasn't.nnThe only way out of this seems to be do get rid of devm_ and release/freeneverything explicitly during device unbind.nnv2: Change commit message and other minor code changesnv3: Cleanup from i915_hwmon_register on error (Armin Wolf)nv4: Eliminate potential static analyzer warning (Rodrigo)n Eliminate fetch_and_zero (Jani)nv5: Restore previous logic for ddat_gt->hwmon_dev error return (Andi),CVE-2024-39479,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnipv6: sr: fix missing sk_buff release in seg6_input_corennThe seg6_input() function is responsible for adding the SRH into anpacket delegating the operation to the seg6_input_core(). This functionnuses the skb_cow_head() to ensure that there is sufficient headroom innthe sk_buff for accommodating the link-layer header.nIn the event that the skb_cow_header() function fails thenseg6_input_core() catches the error but it does not release the sk_buffnwhich will result in a memory leak.nnThis issue was introduced in commit af3b5158b89d (ipv6: sr: fix BUG duento headroom too small after SRH push) and persists even after commitn7a3f5b0de364 (netfilter: add netfilter hooks to SRv6 data plane)nwhere the entire seg6_input() code was refactored to deal with netfilternhooks.nnThe proposed patch addresses the identified memory leak by requiring thenseg6_input_core() function to release the sk_buff in the event thatnskb_cow_head() fails.,CVE-2024-39490,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnima: Fix use-after-free on a dentry's dname.namenn->d_name.name can change on rename and the earlier value can be freed;nthere are conditions sufficient to stabilize it (->d_lock on dentryn->d_lock on its parent ->i_rwsem exclusive on the parent's inodenrename_lock) but none of those are met at any of the sites. Take a stablensnapshot of the name instead.,CVE-2024-39494,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbtrfs: zoned: fix use-after-free due to race with dev replacennWhile loading a zone's info during creation of a block group we can racenwith a device replace operation and then trigger a use-after-free on thendevice that was just replaced (source device of the replace operation).nnThis happens because at btrfs_load_zone_info() we extract a device fromnthe chunk map into a local variable and then use the device while notnunder the protection of the device replace rwsem. So if there's a devicenreplace operation happening when we extract the device and that devicenis the source of the replace operation we will trigger a use-after-freenif before we finish using the device the replace operation finishes andnfrees the device.nnFix this by enlarging the critical section under the protection of thendevice replace rwsem so that all uses of the device are done inside thencritical section.,CVE-2024-39496,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet: hns3: fix kernel crash problem in concurrent scenarionnWhen link status change the nic driver need to notify the rocendriver to handle this event but at this time the roce drivernmay uninit then cause kernel crash.nnTo fix the problem when link status change need to checknwhether the roce registered and when uninit need to wait linknupdate finish.,CVE-2024-39507,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnio_uring/io-wq: Use set_bit() and test_bit() at worker->flagsnnUtilize set_bit() and test_bit() on worker->flags within io_uring/io-wqnto address potential data races.nnThe structure io_worker->flags may be accessed through various datanpaths leading to concurrency issues. When KCSAN is enabled it revealsndata races occurring in io_worker_handle_work andnio_wq_activate_free_worker functions.nnt BUG: KCSAN: data-race in io_worker_handle_work / io_wq_activate_free_workernt write to 0xffff8885c4246404 of 4 bytes by task 49071 on cpu 28:nt io_worker_handle_work (io_uring/io-wq.c:434 io_uring/io-wq.c:569)nt io_wq_worker (io_uring/io-wq.c:?)n<snip>nnt read to 0xffff8885c4246404 of 4 bytes by task 49024 on cpu 5:nt io_wq_activate_free_worker (io_uring/io-wq.c:? io_uring/io-wq.c:285)nt io_wq_enqueue (io_uring/io-wq.c:947)nt io_queue_iowq (io_uring/io_uring.c:524)nt io_req_task_submit (io_uring/io_uring.c:1511)nt io_handle_tw_list (io_uring/io_uring.c:1198)n<snip>nnLine numbers against commit 18daea77cca6 (Merge tag 'for-linus' ofngit://git.kernel.org/pub/scm/virt/kvm/kvm).nnThese races involve writes and reads to the same memory location byndifferent tasks running on different CPUs. To mitigate this refactornthe code to use atomic operations such as set_bit() test_bit() andnclear_bit() instead of basic and and or operations. This ensuresnthread-safe manipulation of worker flags.nnAlso move `create_index` to avoid holes in the structure.,CVE-2024-39508,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnax25: Fix refcount imbalance on inbound connectionsnnWhen releasing a socket in ax25_release() we call netdev_put() tondecrease the refcount on the associated ax.25 device. However thenexecution path for accepting an incoming connection never callsnnetdev_hold(). This imbalance leads to refcount errors and ultimatelynto kernel crashes.nnA typical call trace for the above situation will start with one of thenfollowing errors:nn refcount_t: decrement hit 0; leaking memory.n refcount_t: underflow; use-after-free.nnAnd will then have a trace like:nn Call Trace:n <TASK>n ? show_regs+0x64/0x70n ? __warn+0x83/0x120n ? refcount_warn_saturate+0xb2/0x100n ? report_bug+0x158/0x190n ? prb_read_valid+0x20/0x30n ? handle_bug+0x3e/0x70n ? exc_invalid_op+0x1c/0x70n ? asm_exc_invalid_op+0x1f/0x30n ? refcount_warn_saturate+0xb2/0x100n ? refcount_warn_saturate+0xb2/0x100n ax25_release+0x2ad/0x360n __sock_release+0x35/0xa0n sock_close+0x19/0x20n [...]nnOn reboot (or any attempt to remove the interface) the kernel getsnstuck in an infinite loop:nn unregister_netdevice: waiting for ax0 to become free. Usage count = 0nnThis patch corrects these issues by ensuring that we call netdev_hold()nand ax25_dev_hold() for new connections in ax25_accept(). This makes thenlogic leading to ax25_accept() match the logic for ax25_bind(): in bothncases we increment the refcount which is ultimately decremented innax25_release().,CVE-2024-40910,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnwifi: cfg80211: Lock wiphy in cfg80211_get_stationnnWiphy should be locked before calling rdev_get_station() (see lockdepnassert in ieee80211_get_station()).nnThis fixes the following kernel NULL dereference:nn Unable to handle kernel NULL pointer dereference at virtual address 0000000000000050n Mem abort info:n ESR = 0x0000000096000006n EC = 0x25: DABT (current EL) IL = 32 bitsn SET = 0 FnV = 0n EA = 0 S1PTW = 0n FSC = 0x06: level 2 translation faultn Data abort info:n ISV = 0 ISS = 0x00000006n CM = 0 WnR = 0n user pgtable: 4k pages 48-bit VAs pgdp=0000000003001000n [0000000000000050] pgd=0800000002dca003 p4d=0800000002dca003 pud=08000000028e9003 pmd=0000000000000000n Internal error: Oops: 0000000096000006 [#1] SMPn Modules linked in: netconsole dwc3_meson_g12a dwc3_of_simple dwc3 ip_gre gre ath10k_pci ath10k_core ath9k ath9k_common ath9k_hw athn CPU: 0 PID: 1091 Comm: kworker/u8:0 Not tainted 6.4.0-02144-g565f9a3a7911-dirty #705n Hardware name: RPT (r1) (DT)n Workqueue: bat_events batadv_v_elp_throughput_metric_updaten pstate: 60000005 (nZCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)n pc : ath10k_sta_statistics+0x10/0x2dc [ath10k_core]n lr : sta_set_sinfo+0xcc/0xbd4n sp : ffff000007b43ad0n x29: ffff000007b43ad0 x28: ffff0000071fa900 x27: ffff00000294ca98n x26: ffff000006830880 x25: ffff000006830880 x24: ffff00000294c000n x23: 0000000000000001 x22: ffff000007b43c90 x21: ffff800008898accn x20: ffff00000294c6e8 x19: ffff000007b43c90 x18: 0000000000000000n x17: 445946354d552d78 x16: 62661f7200000000 x15: 57464f445946354dn x14: 0000000000000000 x13: 00000000000000e3 x12: d5f0acbcebea978en x11: 00000000000000e3 x10: 000000010048fe41 x9 : 0000000000000000n x8 : ffff000007b43d90 x7 : 000000007a1e2125 x6 : 0000000000000000n x5 : ffff0000024e0900 x4 : ffff800000a0250c x3 : ffff000007b43c90n x2 : ffff00000294ca98 x1 : ffff000006831920 x0 : 0000000000000000n Call trace:n ath10k_sta_statistics+0x10/0x2dc [ath10k_core]n sta_set_sinfo+0xcc/0xbd4n ieee80211_get_station+0x2c/0x44n cfg80211_get_station+0x80/0x154n batadv_v_elp_get_throughput+0x138/0x1fcn batadv_v_elp_throughput_metric_update+0x1c/0xa4n process_one_work+0x1ec/0x414n worker_thread+0x70/0x46cn kthread+0xdc/0xe0n ret_from_fork+0x10/0x20n Code: a9bb7bfd 910003fd a90153f3 f9411c40 (f9402814)nnThis happens because STA has time to disconnect and reconnect beforenbatadv_v_elp_throughput_metric_update() delayed work gets scheduled. Innthis situation ath10k_sta_state() can be in the middle of resettingnarsta data when the work queue get chance to be scheduled and ends upnaccessing it. Locking wiphy prevents that.,CVE-2024-40911,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnriscv: rewrite __kernel_map_pages() to fix sleeping in invalid contextnn__kernel_map_pages() is a debug function which clears the valid bit in pagentable entry for deallocated pages to detect illegal memory accesses tonfreed pages.nnThis function set/clear the valid bit using __set_memory(). __set_memory()nacquires init_mm's semaphore and this operation may sleep. This isnproblematic because __kernel_map_pages() can be called in atomic contextnand thus is illegal to sleep. An example warning that this causes:nnBUG: sleeping function called from invalid context at kernel/locking/rwsem.c:1578nin_atomic(): 1 irqs_disabled(): 0 non_block: 0 pid: 2 name: kthreaddnpreempt_count: 2 expected: 0nCPU: 0 PID: 2 Comm: kthreadd Not tainted 6.9.0-g1d4c6d784ef6 #37nHardware name: riscv-virtioqemu (DT)nCall Trace:n[<ffffffff800060dc>] dump_backtrace+0x1c/0x24n[<ffffffff8091ef6e>] show_stack+0x2c/0x38n[<ffffffff8092baf8>] dump_stack_lvl+0x5a/0x72n[<ffffffff8092bb24>] dump_stack+0x14/0x1cn[<ffffffff8003b7ac>] __might_resched+0x104/0x10en[<ffffffff8003b7f4>] __might_sleep+0x3e/0x62n[<ffffffff8093276a>] down_write+0x20/0x72n[<ffffffff8000cf00>] __set_memory+0x82/0x2fan[<ffffffff8000d324>] __kernel_map_pages+0x5a/0xd4n[<ffffffff80196cca>] __alloc_pages_bulk+0x3b2/0x43an[<ffffffff8018ee82>] __vmalloc_node_range+0x196/0x6ban[<ffffffff80011904>] copy_process+0x72c/0x17ecn[<ffffffff80012ab4>] kernel_clone+0x60/0x2fen[<ffffffff80012f62>] kernel_thread+0x82/0xa0n[<ffffffff8003552c>] kthreadd+0x14a/0x1ben[<ffffffff809357de>] ret_from_fork+0xe/0x1cnnRewrite this function with apply_to_existing_page_range(). It is fine tonnot have any locking because __kernel_map_pages() works with pages beingnallocated/deallocated and those pages are not changed by anyone else in thenmeantime.,CVE-2024-40915,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnparisc: Try to fix random segmentation faults in package buildsnnPA-RISC systems with PA8800 and PA8900 processors have had problemsnwith random segmentation faults for many years. Systems with earliernprocessors are much more stable.nnSystems with PA8800 and PA8900 processors have a large L2 cache whichnneeds per page flushing for decent performance when a large range isnflushed. The combined cache in these systems is also more sensitive tonnon-equivalent aliases than the caches in earlier systems.nnThe majority of random segmentation faults that I have looked atnappear to be memory corruption in memory allocated using mmap andnmalloc.nnMy first attempt at fixing the random faults didn't work. Onnreviewing the cache code I realized that there were two issuesnwhich the existing code didn't handle correctly. Both relatento cache move-in. Another issue is that the present bit in PTEsnis racy.nn1) PA-RISC caches have a mind of their own and they can speculativelynload data and instructions for a page as long as there is a entry innthe TLB for the page which allows move-in. TLBs are local to eachnCPU. Thus the TLB entry for a page must be purged before flushingnthe page. This is particularly important on SMP systems.nnIn some of the flush routines the flush routine would be callednand then the TLB entry would be purged. This was because the flushnroutine needed the TLB entry to do the flush.nn2) My initial approach to trying the fix the random faults was tontry and use flush_cache_page_if_present for all flush operations.nThis actually made things worse and led to a couple of hardwarenlockups. It finally dawned on me that some lines weren't beingnflushed because the pte check code was racy. This resulted innrandom inequivalent mappings to physical pages.nnThe __flush_cache_page tmpalias flush sets up its own TLB entrynand it doesn't need the existing TLB entry. As long as we can findnthe pte pointer for the vm page we can get the pfn and physicalnaddress of the page. We can also purge the TLB entry for the pagenbefore doing the flush. Further __flush_cache_page uses a specialnTLB entry that inhibits cache move-in.nnWhen switching page mappings we need to ensure that lines arenremoved from the cache. It is not sufficient to just flush thenlines to memory as they may come back.nnThis made it clear that we needed to implement all the requirednflush operations using tmpalias routines. This includes flushesnfor user and kernel pages.nnAfter modifying the code to use tmpalias flushes it became clearnthat the random segmentation faults were not fully resolved. Thenfrequency of faults was worse on systems with a 64 MB L2 (PA8900)nand systems with more CPUs (rp4440).nnThe warning that I added to flush_cache_page_if_present to detectnpages that couldn't be flushed triggered frequently on some systems.nnHelge and I looked at the pages that couldn't be flushed and foundnthat the PTE was either cleared or for a swap page. Ignoring pagesnthat were swapped out seemed okay but pages with cleared PTEs seemednproblematic.nnI looked at routines related to pte_clear and noticed ptep_clear_flush.nThe default implementation just flushes the TLB entry. However it wasnobvious that on parisc we need to flush the cache page as well. Ifnwe don't flush the cache page stale lines will be left in the cachenand cause random corruption. Once a PTE is cleared there is no waynto find the physical address associated with the PTE and flush thenassociated page at a later time.nnI implemented an updated change with a parisc specific version ofnptep_clear_flush. It fixed the random data corruption on Helge's rp4440nand rp3440 as well as on my c8000.nnAt this point I realized that I could restore the code where we onlynflush in flush_cache_page_if_present if the page has been accessed.nHowever for this we also need to flush the cache when the accessednbit is cleared inn---truncated---,CVE-2024-40918,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnxhci: Handle TD clearing for multiple streams casennWhen multiple streams are in use multiple TDs might be in flight whennan endpoint is stopped. We need to issue a Set TR Dequeue Pointer forneach to ensure everything is reset properly and the caches cleared.nChange the logic so that any N>1 TDs found active for different streamsnare deferred until after the first one is processed callingnxhci_invalidate_cancelled_tds() again from xhci_handle_cmd_set_deq() tonqueue another command until we are done with all of them. Also changenthe error/should never happen paths to ensure we at least clear anynaffected TDs even if we can't issue a command to clear the hardwarencache and complain loudly with an xhci_warn() if this ever happens.nnThis problem case dates back to commit e9df17eb1408 (USB: xhci: Correctnassumptions about number of rings per endpoint.) early on in the XHCIndriver's life when stream support was first added.nIt was then identified but not fixed nor made into a warning in commitn674f8438c121 (xhci: split handling halted endpoints into two steps)nwhich added a FIXME comment for the problem case (without materiallynchanging the behavior as far as I can tell though the new logic madenthe problem more obvious).nnThen later in commit 94f339147fc3 (xhci: Fix failure to give back somencached cancelled URBs.) it was acknowledged again.nn[Mathias: commit 94f339147fc3 (xhci: Fix failure to give back some cachedncancelled URBs.) was a targeted regression fix to the previously mentionednpatch. Users reported issues with usb stuck after unmounting/disconnectingnUAS devices. This rolled back the TD clearing of multiple streams to itsnoriginal state.]nnApparently the commit author was aware of the problem (yet still chosento submit it): It was still mentioned as a FIXME an xhci_dbg() wasnadded to log the problem condition and the remaining issue was mentionednin the commit description. The choice of making the log type xhci_dbg()nfor what is at this point a completely unhandled and known brokenncondition is puzzling and unfortunate as it guarantees that no actualnusers would see the log in production thereby making it nighnundebuggable (indeed even if you turn on DEBUG the message doesn'tnreally hint at there being a problem at all).nnIt took me *months* of random xHC crashes to finally find a reliablenrepro and be able to do a deep dive debug session which could all havenbeen avoided had this unhandled broken condition been actually reportednwith a warning as it should have been as a bug intentionally left innunfixed (never mind that it shouldn't have been left in at all).nn> Another fix to solve clearing the caches of all stream rings withn> cancelled TDs is needed but not as urgent.nn3 years after that statement and 14 years after the original bug wasnintroduced I think it's finally time to fix it. And maybe next timenlet's not leave bugs unfixed (that are actually worse than the originalnbug) and let's actually get people to review kernel commits please.nnFixes xHC crashes and IOMMU faults with UAS devices when handlingnerrors/faults. Easiest repro is to use `hdparm` to mark an early sectorn(e.g. 1024) on a disk as bad then `cat /dev/sdX > /dev/null` in a loop.nAt least in the case of JMicron controllers the read errors end upnhaving to cancel two TDs (for two queued requests to different streams)nand the one that didn't get cleared properly ends up faulting the xHCnentirely when it tries to access DMA pages that have since been unmappednreferred to by the stale TDs. This normally happens quickly (after twonor three loops). After this fix I left the `cat` in a loop runningnovernight and experienced no xHC failures with all read errorsnrecovered properly. Repro'd and tested on an Apple M1 Mac Minin(dwc3 host).nnOn systems without an IOMMU this bug would instead silently corruptnfreed memory making this an---truncated---,CVE-2024-40927,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nni2c: lpi2c: Avoid calling clk_get_rate during transfernnInstead of repeatedly calling clk_get_rate for each transfer locknthe clock rate and cache the value.nA deadlock has been observed while adding tlv320aic32x4 audio codec tonthe system. When this clock provider adds its clock the clk mutex isnlocked already it needs to access i2c which in return needs the mutexnfor clk_get_rate as well.,CVE-2024-40965,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nntty: add the option to have a tty reject a new ldiscnn... and use it to limit the virtual terminals to just N_TTY. They arenkind of special and in particular the con_write() routine violatesnthe writes cannot sleep rule that some ldiscs rely on.nnThis avoids thenn BUG: sleeping function called from invalid context at kernel/printk/printk.c:2659nnwhen N_GSM has been attached to a virtual console and gsmld_write()ncalls con_write() while holding a spinlock and con_write() then triesnto get the console lock.,CVE-2024-40966,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnserial: imx: Introduce timeout when waiting on transmitter emptynnBy waiting at most 1 second for USR2_TXDC to be set we avoid a potentialndeadlock.nnIn case of the timeout there is not much we can do so we simply ignorenthe transmitter state and optimistically try to continue.,CVE-2024-40967,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnf2fs: don't set RO when shutting down f2fsnnShutdown does not check the error of thaw_super due to readonly whichncauses a deadlock like below.nnf2fs_ioc_shutdown(F2FS_GOING_DOWN_FULLSYNC) issue_discard_threadn - bdev_freezen - freeze_supern - f2fs_stop_checkpoint()n - f2fs_handle_critical_error - sb_start_writen - set RO - waitingn - bdev_thawn - thaw_super_lockedn - return -EINVAL if sb_rdonly()n - f2fs_stop_discard_threadn -> wait for kthread_stop(discard_thread);,CVE-2024-40969,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnAvoid hw_desc array overrun in dw-axi-dmacnnI have a use case where nr_buffers = 3 and in which each descriptor is composed by 3nsegments resulting in the DMA channel descs_allocated to be 9. Since axi_desc_put()nhandles the hw_desc considering the descs_allocated this scenario would result in ankernel panic (hw_desc array will be overrun).nnTo fix this the proposal is to add a new member to the axi_dma_desc structurenwhere we keep the number of allocated hw_descs (axi_desc_alloc()) and use it innaxi_desc_put() to handle the hw_desc array correctly.nnAdditionally I propose to remove the axi_chan_start_first_queued() call after completingnthe transfer since it was identified that unbalance can occur (started descriptors cannbe interrupted and transfer ignored due to DMA channel not being enabled).,CVE-2024-40970,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnext4: do not create EA inode under buffer locknnext4_xattr_set_entry() creates new EA inodes while holding buffer locknon the external xattr block. This is problematic as it nests all thenallocation locking (which acquires locks on other buffers) under thenbuffer lock. This can even deadlock when the filesystem is corrupted andne.g. quota file is setup to contain xattr block as data block. Move thenallocation of EA inode out of ext4_xattr_set_entry() into the callers.,CVE-2024-40972,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnmedia: mtk-vcodec: potential null pointer deference in SCPnnThe return value of devm_kzalloc() needs to be checked to avoidnNULL pointer deference. This is similar to CVE-2022-3113.,CVE-2024-40973,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnplatform/x86: x86-android-tablets: Unregister devices in reverse ordernnNot all subsystems support a device getting removed while there arenstill consumers of the device with a reference to the device.nnOne example of this is the regulator subsystem. If a regulator getsnunregistered while there are still drivers holding a referencena WARN() at drivers/regulator/core.c:5829 triggers e.g.:nn WARNING: CPU: 1 PID: 1587 at drivers/regulator/core.c:5829 regulator_unregistern Hardware name: Intel Corp. VALLEYVIEW C0 PLATFORM/BYT-T FFD8 BIOS BLADE_21.X64.0005.R00.1504101516 FFD8_X64_R_2015_04_10_1516 04/10/2015n RIP: 0010:regulator_unregistern Call Trace:n <TASK>n regulator_unregistern devres_release_groupn i2c_device_removen device_release_driver_internaln bus_remove_devicen device_deln device_unregistern x86_android_tablet_removennOn the Lenovo Yoga Tablet 2 series the bq24190 charger chip also providesna 5V boost converter output for powering USB devices connected to the micronUSB port the bq24190-charger driver exports this as a Vbus regulator.nnOn the 830 (8) and 1050 (10) models this regulator is controlled byna platform_device and x86_android_tablet_remove() removes platform_device-snbefore i2c_clients so the consumer gets removed first.nnBut on the 1380 (13) model there is a lc824206xa micro-USB switchnconnected over I2C and the extcon driver for that controls the regulator.nThe bq24190 i2c-client *must* be registered first because that createsnthe regulator with the lc824206xa listed as its consumer. If the regulatornhas not been registered yet the lc824206xa driver will end up gettingna dummy regulator.nnSince in this case both the regulator provider and consumer are I2Cndevices the only way to ensure that the consumer is unregistered firstnis to unregister the I2C devices in reverse order of in which they werencreated.nnFor consistency and to avoid similar problems in the future changenx86_android_tablet_remove() to unregister all device types in reversenorder.,CVE-2024-40975,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnwifi: mt76: mt7921s: fix potential hung tasks during chip recoverynnDuring chip recovery (e.g. chip reset) there is a possible situation thatnkernel worker reset_work is holding the lock and waiting for kernel threadnstat_worker to be parked while stat_worker is waiting for the release ofnthe same lock.nIt causes a deadlock resulting in the dumping of hung tasks messages andnpossible rebooting of the device.nnThis patch prevents the execution of stat_worker during the chip recovery.,CVE-2024-40977,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnext4: fix uninitialized ratelimit_state->lock access in __ext4_fill_super()nnIn the following concurrency we will access the uninitialized rs->lock:nnext4_fill_supern ext4_register_sysfsn // sysfs registered msg_ratelimit_interval_msn // Other processes modify rs->interval ton // non-zero via msg_ratelimit_interval_msn ext4_orphan_cleanupn ext4_msg(sb KERN_INFO Errors on filesystem n __ext4_msgn ___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state)n if (!rs->interval) // do nothing if interval is 0n return 1;n raw_spin_trylock_irqsave(&rs->lock flags)n raw_spin_trylock(lock)n _raw_spin_trylockn __raw_spin_trylockn spin_acquire(&lock->dep_map 0 1 _RET_IP_)n lock_acquiren __lock_acquiren register_lock_classn assign_lock_keyn dump_stack();n ratelimit_state_init(&sbi->s_msg_ratelimit_state 5 output.log scan_tyk_dockerimages.sh vulnerabilities.csv HZ 10);n raw_spin_lock_init(&rs->lock);n // init rs->lock herennand get the following dump_stack:nn=========================================================nINFO: trying to register non-static key.nThe code is fine but needs lockdep annotation or maybenyou didn't initialize this object before use?nturning off the locking correctness validator.nCPU: 12 PID: 753 Comm: mount Tainted: G E 6.7.0-rc6-next-20231222 #504n[...]nCall Trace:n dump_stack_lvl+0xc5/0x170n dump_stack+0x18/0x30n register_lock_class+0x740/0x7c0n __lock_acquire+0x69/0x13a0n lock_acquire+0x120/0x450n _raw_spin_trylock+0x98/0xd0n ___ratelimit+0xf6/0x220n __ext4_msg+0x7f/0x160 [ext4]n ext4_orphan_cleanup+0x665/0x740 [ext4]n __ext4_fill_super+0x21ea/0x2b10 [ext4]n ext4_fill_super+0x14d/0x360 [ext4]n[...]n=========================================================nnNormally interval is 0 until s_msg_ratelimit_state is initialized son___ratelimit() does nothing. But registering sysfs precedes initializingnrs->lock so it is possible to change rs->interval to a non-zero valuenvia the msg_ratelimit_interval_ms interface of sysfs while rs->lock isnuninitialized and then a call to ext4_msg triggers the problem bynaccessing an uninitialized rs->lock. Therefore register sysfs after allninitializations are complete to avoid such problems.,CVE-2024-40998,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet: ena: Add validation for completion descriptors consistencynnValidate that `first` flag is set only for the firstndescriptor in multi-buffer packets.nIn case of an invalid descriptor a reset will occur.nA new reset reason for RX data corruption has been added.,CVE-2024-40999,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnio_uring/sqpoll: work around a potential audit memory leaknnkmemleak complains that there's a memory leak related to connectnhandling:nnunreferenced object 0xffff0001093bdf00 (size 128):ncomm iou-sqp-455 pid 457 jiffies 4294894164nhex dump (first 32 bytes):n02 00 fa ea 7f 00 00 01 00 00 00 00 00 00 00 00 ................n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................nbacktrace (crc 2e481b1a):n[<00000000c0a26af4>] kmemleak_alloc+0x30/0x38n[<000000009c30bb45>] kmalloc_trace+0x228/0x358n[<000000009da9d39f>] __audit_sockaddr+0xd0/0x138n[<0000000089a93e34>] move_addr_to_kernel+0x1a0/0x1f8n[<000000000b4e80e6>] io_connect_prep+0x1ec/0x2d4n[<00000000abfbcd99>] io_submit_sqes+0x588/0x1e48n[<00000000e7c25e07>] io_sq_thread+0x8a4/0x10e4n[<00000000d999b491>] ret_from_fork+0x10/0x20nnwhich can can happen if:nn1) The command type does something on the prep side that triggers ann audit call.n2) The thread hasn't done any operations before this that triggeredn an audit call inside ->issue() where we have audit_uring_entry()n and audit_uring_exit().nnWork around this by issuing a blanket NOP operation before the SQPOLLndoes anything.,CVE-2024-41001,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nncrypto: hisilicon/sec - Fix memory leak for sec resource releasennThe AIV is one of the SEC resources. When releasing resourcesnit need to release the AIV resources at the same time.nOtherwise memory leakage occurs.nnThe aiv resource release is added to the sec resource releasenfunction.,CVE-2024-41002,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amdgpu: change vm->task_info handlingnnThis patch changes the handling and lifecycle of vm->task_info object.nThe major changes are:n- vm->task_info is a dynamically allocated ptr now and its uasge isn reference counted.n- introducing two new helper funcs for task_info lifecycle managementn - amdgpu_vm_get_task_info: reference counts up task_info beforen returning this infon - amdgpu_vm_put_task_info: reference counts down task_infon- last put to task_info() frees task_info from the vm.nnThis patch also does logistical changes required for existing usagenof vm->task_info.nnV2: Do not block all the prints when task_info not found (Felix)nnV3: Fixed review comments from Felixn - Fix wrong indentationn - No debug message for -ENOMEMn - Add NULL check for task_infon - Do not duplicate the debug messages (ti vs no ti)n - Get first reference of task_info in vm_init() put lastn in vm_fini()nnV4: Fixed review comments from Felixn - fix double reference increment in create_task_infon - change amdgpu_vm_get_task_info_pasidn - additional changes in amdgpu_gem.c while porting,CVE-2024-41008,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnxfs: don't walk off the end of a directory data blocknnThis adds sanity checks for xfs_dir2_data_unused and xfs_dir2_data_entrynto make sure don't stray beyond valid memory region. Before patching thenloop simply checks that the start offset of the dup and dep is within thenrange. So in a crafted image if last entry is xfs_dir2_data_unused wencan change dup->length to dup->length-1 and leave 1 byte of space. In thennext traversal this space will be considered as dup or dep. We maynencounter an out of bound read when accessing the fixed members.nnIn the patch we make sure that the remaining bytes large enough to holdnan unused entry before accessing xfs_dir2_data_unused andnxfs_dir2_data_unused is XFS_DIR2_DATA_ALIGN byte aligned. We also makensure that the remaining bytes large enough to hold a dirent with ansingle-byte name before accessing xfs_dir2_data_entry.,CVE-2024-41013,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnxfs: add bounds checking to xlog_recover_process_datannThere is a lack of verification of the space occupied by fixed membersnof xlog_op_header in the xlog_recover_process_data.nnWe can create a crafted image to trigger an out of bounds read bynfollowing these steps:n 1) Mount an image of xfs and do some file operations to leave recordsn 2) Before umounting copy the image for subsequent steps to simulaten abnormal exit. Because umount will ensure that tail_blk andn head_blk are the same which will result in the inability to entern xlog_recover_process_datan 3) Write a tool to parse and modify the copied image in step 2n 4) Make the end of the xlog_op_header entries only 1 byte away fromn xlog_rec_header->h_sizen 5) xlog_rec_header->h_num_logops++n 6) Modify xlog_rec_header->h_crcnnFix:nAdd a check to make sure there is sufficient space to access fixed membersnof xlog_op_header.,CVE-2024-41014,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnsched/deadline: Fix task_struct reference leaknnDuring the execution of the following stress test with linux-rt:nnstress-ng --cyclic 30 --timeout 30 --minimize --quietnnkmemleak frequently reported a memory leak concerning the task_struct:nnunreferenced object 0xffff8881305b8000 (size 16136):n comm stress-ng pid 614 jiffies 4294883961 (age 286.412s)n object hex dump (first 32 bytes):n 02 40 00 00 00 00 00 00 00 00 00 00 00 00 00 00 .@..............n 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................n debug hex dump (first 16 bytes):n 53 09 00 00 00 00 00 00 00 00 00 00 00 00 00 00 S...............n backtrace:n [<00000000046b6790>] dup_task_struct+0x30/0x540n [<00000000c5ca0f0b>] copy_process+0x3d9/0x50e0n [<00000000ced59777>] kernel_clone+0xb0/0x770n [<00000000a50befdc>] __do_sys_clone+0xb6/0xf0n [<000000001dbf2008>] do_syscall_64+0x5d/0xf0n [<00000000552900ff>] entry_SYSCALL_64_after_hwframe+0x6e/0x76nnThe issue occurs in start_dl_timer() which increments the task_structnreference count and sets a timer. The timer callback dl_task_timernis supposed to decrement the reference count upon expiration. Howevernif enqueue_task_dl() is called before the timer expires and cancels itnthe reference count is not decremented leading to the leak.nnThis patch fixes the reference leak by ensuring the task_structnreference count is properly decremented when the timer is canceled.,CVE-2024-41023,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnFix userfaultfd_api to return EINVAL as expectednnCurrently if we request a feature that is not set in the Kernel config wenfail silently and return all the available features. However the mannpage indicates we should return an EINVAL.nnWe need to fix this issue since we can end up with a Kernel warning shouldna program request the feature UFFD_FEATURE_WP_UNPOPULATED on a kernel withnthe config not set with this feature.nn [ 200.812896] WARNING: CPU: 91 PID: 13634 at mm/memory.c:1660 zap_pte_range+0x43d/0x660n [ 200.820738] Modules linked in:n [ 200.869387] CPU: 91 PID: 13634 Comm: userfaultfd Kdump: loaded Not tainted 6.9.0-rc5+ #8n [ 200.877477] Hardware name: Dell Inc. PowerEdge R6525/0N7YGH BIOS 2.7.3 03/30/2022n [ 200.885052] RIP: 0010:zap_pte_range+0x43d/0x660,CVE-2024-41027,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet: ks8851: Fix deadlock with the SPI chip variantnnWhen SMP is enabled and spinlocks are actually functional then there isna deadlock with the 'statelock' spinlock between ks8851_start_xmit_spinand ks8851_irq:nn watchdog: BUG: soft lockup - CPU#0 stuck for 27s!n call trace:n queued_spin_lock_slowpath+0x100/0x284n do_raw_spin_lock+0x34/0x44n ks8851_start_xmit_spi+0x30/0xb8n ks8851_start_xmit+0x14/0x20n netdev_start_xmit+0x40/0x6cn dev_hard_start_xmit+0x6c/0xbcn sch_direct_xmit+0xa4/0x22cn __qdisc_run+0x138/0x3fcn qdisc_run+0x24/0x3cn net_tx_action+0xf8/0x130n handle_softirqs+0x1ac/0x1f0n __do_softirq+0x14/0x20n ____do_softirq+0x10/0x1cn call_on_irq_stack+0x3c/0x58n do_softirq_own_stack+0x1c/0x28n __irq_exit_rcu+0x54/0x9cn irq_exit_rcu+0x10/0x1cn el1_interrupt+0x38/0x50n el1h_64_irq_handler+0x18/0x24n el1h_64_irq+0x64/0x68n __netif_schedule+0x6c/0x80n netif_tx_wake_queue+0x38/0x48n ks8851_irq+0xb8/0x2c8n irq_thread_fn+0x2c/0x74n irq_thread+0x10c/0x1b0n kthread+0xc8/0xd8n ret_from_fork+0x10/0x20nnThis issue has not been identified earlier because tests were done onna device with SMP disabled and so spinlocks were actually NOPs.nnNow use spin_(un)lock_bh for TX queue related locking to avoid executionnof softirq work synchronously that would lead to a deadlock.,CVE-2024-41036,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnskmsg: Skip zero length skb in sk_msg_recvmsgnnWhen running BPF selftests (./test_progs -t sockmap_basic) on a Loongarchnplatform the following kernel panic occurs:nn [...]n Oops[#1]:n CPU: 22 PID: 2824 Comm: test_progs Tainted: G OE 6.10.0-rc2+ #18n Hardware name: LOONGSON Dabieshan/Loongson-TC542F0 BIOS Loongson-UDK2018n ... ...n ra: 90000000048bf6c0 sk_msg_recvmsg+0x120/0x560n ERA: 9000000004162774 copy_page_to_iter+0x74/0x1c0n CRMD: 000000b0 (PLV0 -IE -DA +PG DACF=CC DACM=CC -WE)n PRMD: 0000000c (PPLV0 +PIE +PWE)n EUEN: 00000007 (+FPE +SXE +ASXE -BTE)n ECFG: 00071c1d (LIE=02-410-12 VS=7)n ESTAT: 00010000 [PIL] (IS= ECode=1 EsubCode=0)n BADV: 0000000000000040n PRID: 0014c011 (Loongson-64bit Loongson-3C5000)n Modules linked in: bpf_testmod(OE) xt_CHECKSUM xt_MASQUERADE xt_conntrackn Process test_progs (pid: 2824 threadinfo=0000000000863a31 task=...)n Stack : ...n Call Trace:n [<9000000004162774>] copy_page_to_iter+0x74/0x1c0n [<90000000048bf6c0>] sk_msg_recvmsg+0x120/0x560n [<90000000049f2b90>] tcp_bpf_recvmsg_parser+0x170/0x4e0n [<90000000049aae34>] inet_recvmsg+0x54/0x100n [<900000000481ad5c>] sock_recvmsg+0x7c/0xe0n [<900000000481e1a8>] __sys_recvfrom+0x108/0x1c0n [<900000000481e27c>] sys_recvfrom+0x1c/0x40n [<9000000004c076ec>] do_syscall+0x8c/0xc0n [<9000000003731da4>] handle_syscall+0xc4/0x160n Code: ...n ---[ end trace 0000000000000000 ]---n Kernel panic - not syncing: Fatal exceptionn Kernel relocated by 0x3510000n .text @ 0x9000000003710000n .data @ 0x9000000004d70000n .bss @ 0x9000000006469400n ---[ end Kernel panic - not syncing: Fatal exception ]---n [...]nnThis crash happens every time when running sockmap_skb_verdict_shutdownnsubtest in sockmap_basic.nnThis crash is because a NULL pointer is passed to page_address() in thensk_msg_recvmsg(). Due to the different implementations depending on thenarchitecture page_address(NULL) will trigger a panic on Loongarchnplatform but not on x86 platform. So this bug was hidden on x86 platformnfor a while but now it is exposed on Loongarch platform. The root causenis that a zero length skb (skb->len == 0) was put on the queue.nnThis zero length skb is a TCP FIN packet which was sent by shutdown()ninvoked in test_sockmap_skb_verdict_shutdown():nntshutdown(p1 SHUT_WR);nnIn this case in sk_psock_skb_ingress_enqueue() num_sge is zero and nonpage is put to this sge (see sg_set_page in sg_set_page) but this emptynsge is queued into ingress_msg list.nnAnd in sk_msg_recvmsg() this empty sge is used and a NULL page is got bynsg_page(sge). Pass this NULL page to copy_page_to_iter() which passes itnto kmap_local_page() and to page_address() then kernel panics.nnTo solve this we should skip this zero length skb. So in sk_msg_recvmsg()nif copy is zero that means it's a zero length skb skip invokingncopy_page_to_iter(). We are using the EFAULT return triggered byncopy_page_to_iter to check for is_fin in tcp_bpf.c.,CVE-2024-41048,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbluetooth/l2cap: sync sock recv cb and releasennThe problem occurs between the system call to close the sock and hci_rx_worknwhere the former releases the sock and the latter accesses it without lock protection.nn CPU0 CPU1n ---- ----n sock_close hci_rx_worknt l2cap_sock_release hci_acldata_packetnt l2cap_sock_kill l2cap_recv_frament sk_free l2cap_conless_channelnt l2cap_sock_recv_cbnnIf hci_rx_work processes the data that needs to be received before the sock isnclosed then everything is normal; Otherwise the work thread may access thenreleased sock when receiving data.nnAdd a chan mutex in the rx callback of the sock to achieve synchronization betweennthe sock release and recv cb.nnSock is dead so set chan data to NULL avoid others use invalid sock pointer.,CVE-2024-41062,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnibmvnic: Add tx check to prevent skb leaknnBelow is a summary of how the driver stores a reference to an skb duringntransmit:n tx_buff[free_map[consumer_index]]->skb = new_skb;n free_map[consumer_index] = IBMVNIC_INVALID_MAP;n consumer_index ++;nWhere variable data looks like this:n free_map == [4 IBMVNIC_INVALID_MAP IBMVNIC_INVALID_MAP 0 3]n tconsumer_index^n tx_buff == [skb=null skb=<ptr> skb=<ptr> skb=null skb=null]nnThe driver has checks to ensure that free_map[consumer_index] pointed tona valid index but there was no check to ensure that this index pointednto an unused/null skb address. So if by some chance our free_map andntx_buff lists become out of sync then we were previously risking annskb memory leak. This could then cause tcp congestion control to stopnsending packets eventually leading to ETIMEDOUT.nnTherefore add a conditional to ensure that the skb address is null. Ifnnot then warn the user (because this is still a bug that should benpatched) and free the old pointer to prevent memleak/tcp problems.,CVE-2024-41066,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbtrfs: scrub: handle RST lookup error correctlynn[BUG]nWhen running btrfs/060 with forced RST feature it would crash thenfollowing ASSERT() inside scrub_read_endio():nntASSERT(sector_nr < stripe->nr_sectors);nnBefore that we would have tree dump fromnbtrfs_get_raid_extent_offset() as we failed to find the RST entry fornthe range.nn[CAUSE]nInside scrub_submit_extent_sector_read() every time we allocated a newnbbio we immediately called btrfs_map_block() to make sure there was somenRST range covering the scrub target.nnBut if btrfs_map_block() fails we immediately call endio for the bbionwhile the bbio is newly allocated it's completely empty.nnThen inside scrub_read_endio() we go through the bvecs to findnthe sector number (as bi_sector is no longer reliable if the bio isnsubmitted to lower layers).nnAnd since the bio is empty such bvecs iteration would not find anynsector matching the sector and return sector_nr == stripe->nr_sectorsntriggering the ASSERT().nn[FIX]nInstead of calling btrfs_map_block() after allocating a new bbio callnbtrfs_map_block() first.nnSince our only objective of calling btrfs_map_block() is only to updatenstripe_len there is really no need to do that after btrfs_alloc_bio().nnThis new timing would avoid the problem of handling empty bbioncompletely and in fact fixes a possible race window for the old codenwhere if the submission thread is the only owner of the pending_io thenscrub would never finish (since we didn't decrease the pending_ioncounter).nnAlthough the root cause of RST lookup failure still needs to benaddressed.,CVE-2024-41067,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnASoC: topology: Fix references to freed memorynnMost users after parsing a topology file release memory used by it sonhaving pointer references directly into topology file contents is wrong.nUse devm_kmemdup() to allocate memory as needed.,CVE-2024-41069,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnvme: avoid double free special payloadnnIf a discard request needs to be retried and that retry may fail beforena new special payload is added a double free will result. Clear thenRQF_SPECIAL_LOAD when the request is cleaned.,CVE-2024-41073,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nncachefiles: Set object to close if ondemand_id < 0 in copennnIf copen is maliciously called in the user mode it may delete the requestncorresponding to the random id. And the request may have not been read yet.nnNote that when the object is set to reopen the open request will be donenwith the still reopen state in above case. As a result the requestncorresponding to this object is always skipped in select_req function sonthe read request is never completed and blocks other process.nnFix this issue by simply set object to close if its id < 0 in copen.,CVE-2024-41074,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nncachefiles: add consistency check for copen/creadnnThis prevents malicious processes from completing random copen/creadnrequests and crashing the system. Added checks are listed below:nn output.log scan_tyk_dockerimages.sh vulnerabilities.csv Generic copen can only complete open requests and cread can onlyn complete read requests.n output.log scan_tyk_dockerimages.sh vulnerabilities.csv For copen ondemand_id must not be 0 because this indicates that then request has not been read by the daemon.n output.log scan_tyk_dockerimages.sh vulnerabilities.csv For cread the object corresponding to fd and req should be the same.,CVE-2024-41075,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnNFSv4: Fix memory leak in nfs4_set_security_labelnnWe leak nfs_fattr and nfs4_label every time we set a security xattr.,CVE-2024-41076,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnvmet: always initialize cqe.resultnnThe spec doesn't mandate that the first two double words (aka results)nfor the command queue entry need to be set to 0 when they are notnused (not specified). Though the target implemention returns 0 for TCPnand FC but not for RDMA.nnLet's make RDMA behave the same and thus explicitly initializing thenresult field. This prevents leaking any data from the stack.,CVE-2024-41079,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnvme-fabrics: use reserved tag for reg read/write commandnnIn some scenarios if too many commands are issued by nvme command innthe same time by user tasks this may exhaust all tags of admin_q. Ifna reset (nvme reset or IO timeout) occurs before these commands finishnreconnect routine may fail to update nvme regs due to insufficient tagsnwhich will cause kernel hang forever. In order to workaround this issuenmaybe we can let reg_read32()/reg_read64()/reg_write32() use reservedntags. This maybe safe for nvmf:nn1. For the disable ctrl path we will not issue connect commandn2. For the enable ctrl / fw activate path since connect and reg_xx()n are called serially.nnSo the reserved tags may still be enough while reg_xx() use reserved tags.,CVE-2024-41082,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nncan: mcp251xfd: fix infinite loop when xmit failsnnWhen the mcp251xfd_start_xmit() function fails the driver stopsnprocessing messages and the interrupt routine does not returnnrunning indefinitely even after killing the running application.nnError messages:n[ 441.298819] mcp251xfd spi2.0 can0: ERROR in mcp251xfd_start_xmit: -16n[ 441.306498] mcp251xfd spi2.0 can0: Transmit Event FIFO buffer not empty. (seq=0x000017c7 tef_tail=0x000017cf tef_head=0x000017d0 tx_head=0x000017d3).n... and repeat forever.nnThe issue can be triggered when multiple devices share the same SPIninterface. And there is concurrent access to the bus.nnThe problem occurs because tx_ring->head increments even ifnmcp251xfd_start_xmit() fails. Consequently the driver skips one TXnpackage while still expecting a response innmcp251xfd_handle_tefif_one().nnResolve the issue by starting a workqueue to write the tx objnsynchronously if err = -EBUSY. In case of another error decrementntx_ring->head remove skb from the echo stack and drop the message.nn[mkl: use more imperative wording in patch description],CVE-2024-41088,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amdgpu: avoid using null object of framebuffernnInstead of using state->fb->obj[0] directly get object from framebuffernby calling drm_gem_fb_get_obj() and return error code when object isnnull to avoid using null object of framebuffer.,CVE-2024-41093,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnf2fs: fix to shrink read extent node in batchesnnWe use rwlock to protect core structure data of extent tree duringnits shrink however if there is a huge number of extent nodes innextent tree during shrink of extent tree it may hold rwlock forna very long time which may trigger kernel hang issue.nnThis patch fixes to shrink read extent node in batches so thatncritical region of the rwlock can be shrunk to avoid its extremenlong time hold.,CVE-2024-41935,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbpf: Mark bpf prog stack with kmsan_unposion_memory in interpreter modennsyzbot reported uninit memory usages during map_{lookupdelete}_elem.nn==========nBUG: KMSAN: uninit-value in __dev_map_lookup_elem kernel/bpf/devmap.c:441 [inline]nBUG: KMSAN: uninit-value in dev_map_lookup_elem+0xf3/0x170 kernel/bpf/devmap.c:796n__dev_map_lookup_elem kernel/bpf/devmap.c:441 [inline]ndev_map_lookup_elem+0xf3/0x170 kernel/bpf/devmap.c:796n____bpf_map_lookup_elem kernel/bpf/helpers.c:42 [inline]nbpf_map_lookup_elem+0x5c/0x80 kernel/bpf/helpers.c:38n___bpf_prog_run+0x13fe/0xe0f0 kernel/bpf/core.c:1997n__bpf_prog_run256+0xb5/0xe0 kernel/bpf/core.c:2237n==========nnThe reproducer should be in the interpreter mode.nnThe C reproducer is trying to run the following bpf prog:nn 0: (18) r0 = 0x0n 2: (18) r1 = map[id:49]n 4: (b7) r8 = 16777216n 5: (7b) *(u64 *)(r10 -8) = r8n 6: (bf) r2 = r10n 7: (07) r2 += -229n ^^^^^^^^^^nn 8: (b7) r3 = 8n 9: (b7) r4 = 0n 10: (85) call dev_map_lookup_elem#1543472n 11: (95) exitnnIt is due to the void *key (r2) passed to the helper. bpf allows uninitnstack memory access for bpf prog with the right privileges. This patchnuses kmsan_unpoison_memory() to mark the stack as initialized.nnThis should address different syzbot reports on the uninit void *keynargument during map_{lookupdelete}_elem.,CVE-2024-42063,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbpf: Take return from set_memory_rox() into account with bpf_jit_binary_lock_ro()nnset_memory_rox() can fail leaving memory unprotected.nnCheck return and bail out when bpf_jit_binary_lock_ro() returnsnan error.,CVE-2024-42067,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbpf: Take return from set_memory_ro() into account with bpf_prog_lock_ro()nnset_memory_ro() can fail leaving memory unprotected.nnCheck its return and take it into account as an error.,CVE-2024-42068,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nngfs2: Fix NULL pointer dereference in gfs2_log_flushnnIn gfs2_jindex_free() set sdp->sd_jdesc to NULL under the log flushnlock to provide exclusion against gfs2_log_flush().nnIn gfs2_log_flush() check if sdp->sd_jdesc is non-NULL beforendereferencing it. Otherwise we could run into a NULL pointerndereference when outstanding glock work races with an unmountn(glock_work_func -> run_queue -> do_xmote -> inode_go_sync ->ngfs2_log_flush).,CVE-2024-42079,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnRDMA/restrack: Fix potential invalid address accessnnstruct rdma_restrack_entry's kern_name was set to KBUILD_MODNAMEnin ib_create_cq() while if the module exited but forgot del thisnrdma_restrack_entry it would cause a invalid address access innrdma_restrack_clean() when print the owner of this rdma_restrack_entry.nnThese code is used to help find one forgotten PD release in one of thenULPs. But it is not needed anymore so delete them.,CVE-2024-42080,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nncrypto: ecdh - explicitly zeroize private_keynnprivate_key is overwritten with the key parameter passed in by thencaller (if present) or alternatively a newly generated private key.nHowever it is possible that the caller provides a key (or the newlyngenerated key) which is shorter than the previous key. In thatnscenario some key material from the previous key would not benoverwritten. The easiest solution is to explicitly zeroize the entirenprivate_key array first.nnNote that this patch slightly changes the behavior of this function:npreviously if the ecc_gen_privkey failed the old private_key wouldnremain. Now the private_key is always zeroized. This behavior isnconsistent with the case where params.key is set and ecc_is_key_validnfails.,CVE-2024-42098,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet: ntb_netdev: Move ntb_netdev_rx_handler() to call netif_rx() from __netif_rx()nnThe following is emitted when using idxd (DSA) dmanegine as the datanmover for ntb_transport that ntb_netdev uses.nn[74412.546922] BUG: using smp_processor_id() in preemptible [00000000] code: irq/52-idxd-por/14526n[74412.556784] caller is netif_rx_internal+0x42/0x130n[74412.562282] CPU: 6 PID: 14526 Comm: irq/52-idxd-por Not tainted 6.9.5 #5n[74412.569870] Hardware name: Intel Corporation ArcherCity/ArcherCity BIOS EGSDCRB1.E9I.1752.P05.2402080856 02/08/2024n[74412.581699] Call Trace:n[74412.584514] <TASK>n[74412.586933] dump_stack_lvl+0x55/0x70n[74412.591129] check_preemption_disabled+0xc8/0xf0n[74412.596374] netif_rx_internal+0x42/0x130n[74412.600957] __netif_rx+0x20/0xd0n[74412.604743] ntb_netdev_rx_handler+0x66/0x150 [ntb_netdev]n[74412.610985] ntb_complete_rxc+0xed/0x140 [ntb_transport]n[74412.617010] ntb_rx_copy_callback+0x53/0x80 [ntb_transport]n[74412.623332] idxd_dma_complete_txd+0xe3/0x160 [idxd]n[74412.628963] idxd_wq_thread+0x1a6/0x2b0 [idxd]n[74412.634046] irq_thread_fn+0x21/0x60n[74412.638134] ? irq_thread+0xa8/0x290n[74412.642218] irq_thread+0x1a0/0x290n[74412.646212] ? __pfx_irq_thread_fn+0x10/0x10n[74412.651071] ? __pfx_irq_thread_dtor+0x10/0x10n[74412.656117] ? __pfx_irq_thread+0x10/0x10n[74412.660686] kthread+0x100/0x130n[74412.664384] ? __pfx_kthread+0x10/0x10n[74412.668639] ret_from_fork+0x31/0x50n[74412.672716] ? __pfx_kthread+0x10/0x10n[74412.676978] ret_from_fork_asm+0x1a/0x30n[74412.681457] </TASK>nnThe cause is due to the idxd driver interrupt completion handler usesnthreaded interrupt and the threaded handler is not hard or soft interruptncontext. However __netif_rx() can only be called from interrupt context.nChange the call to netif_rx() in order to allow completion via normalncontext for dmaengine drivers that utilize threaded irq handling.nnWhile the following commit changed from netif_rx() to __netif_rx()nbaebdf48c360 (net: dev: Makes sure netif_rx() can be invoked in any context.)nthe change should've been a noop instead. However the code precedes thisnfix should've been using netif_rx_ni() or netif_rx_any_context().,CVE-2024-42110,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Do not return negative stream id for arraynn[WHY]nresource_stream_to_stream_idx returns an array index and it return -1nwhen not found; however -1 is not a valid array index number.nn[HOW]nWhen this happens call ASSERT() and return a zero instead.nnThis fixes an OVERRUN and an NEGATIVE_RETURNS issues reported by Coverity.,CVE-2024-42118,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Add NULL pointer check for kzallocnn[Why & How]nCheck return pointer of kzalloc before using it.,CVE-2024-42122,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amdgpu: fix double free err_addr pointer warningsnnIn amdgpu_umc_bad_page_polling_timeout the amdgpu_umc_handle_bad_pagesnwill be run many times so that double free err_addr in some special case.nSo set the err_addr to NULL to avoid the warnings.,CVE-2024-42123,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnpowerpc: Avoid nmi_enter/nmi_exit in real mode interrupt.nnnmi_enter()/nmi_exit() touches per cpu variables which can lead to kernelncrash when invoked during real mode interrupt handling (e.g. early HMI/MCEninterrupt handler) if percpu allocation comes from vmalloc area.nnEarly HMI/MCE handlers are called through DEFINE_INTERRUPT_HANDLER_NMI()nwrapper which invokes nmi_enter/nmi_exit calls. We don't see any issue whennpercpu allocation is from the embedded first chunk. However withnCONFIG_NEED_PER_CPU_PAGE_FIRST_CHUNK enabled there are chances where percpunallocation can come from the vmalloc area.nnWith kernel command line percpu_alloc=page we can force percpu allocationnto come from vmalloc area and can see kernel crash in machine_check_early:nn[ 1.215714] NIP [c000000000e49eb4] rcu_nmi_enter+0x24/0x110n[ 1.215717] LR [c0000000000461a0] machine_check_early+0xf0/0x2c0n[ 1.215719] --- interrupt: 200n[ 1.215720] [c000000fffd73180] [0000000000000000] 0x0 (unreliable)n[ 1.215722] [c000000fffd731b0] [0000000000000000] 0x0n[ 1.215724] [c000000fffd73210] [c000000000008364] machine_check_early_common+0x134/0x1f8nnFix this by avoiding use of nmi_enter()/nmi_exit() in real mode if percpunfirst chunk is not embedded.,CVE-2024-42126,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnleds: an30259a: Use devm_mutex_init() for mutex initializationnnIn this driver LEDs are registered using devm_led_classdev_register()nso they are automatically unregistered after module's remove() is done.nled_classdev_unregister() calls module's led_set_brightness() to turn offnthe LEDs and that callback uses mutex which was destroyed alreadynin module's remove() so use devm API instead.,CVE-2024-42128,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnleds: mlxreg: Use devm_mutex_init() for mutex initializationnnIn this driver LEDs are registered using devm_led_classdev_register()nso they are automatically unregistered after module's remove() is done.nled_classdev_unregister() calls module's led_set_brightness() to turn offnthe LEDs and that callback uses mutex which was destroyed alreadynin module's remove() so use devm API instead.,CVE-2024-42129,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnfc/nci: Add the inconsistency check between the input data length and countnnwrite$nci(r0 &(0x7f0000000740)=ANY=[@ANYBLOB=610501] 0xf)nnSyzbot constructed a write() call with a data length of 3 bytes but a count valuenof 15 which passed too little data to meet the basic requirements of the functionnnci_rf_intf_activated_ntf_packet().nnTherefore increasing the comparison between data length and count value to avoidnproblems caused by inconsistent data length and count.,CVE-2024-42130,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnvhost_task: Handle SIGKILL by flushing work and exitingnnInstead of lingering until the device is closed this has us handlenSIGKILL by:nn1. marking the worker as killed so we no longer try to use it withn new virtqueues and new flush operations.n2. setting the virtqueue to worker mapping so no new works are queued.n3. running all the exiting works.,CVE-2024-42135,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nncdrom: rearrange last_media_change check to avoid unintentional overflownnWhen running syzkaller with the newly reintroduced signed integer wrapnsanitizer we encounter this splat:nn[ 366.015950] UBSAN: signed-integer-overflow in ../drivers/cdrom/cdrom.c:2361:33n[ 366.021089] -9223372036854775808 - 346321 cannot be represented in type '__s64' (aka 'long long')n[ 366.025894] program syz-executor.4 is using a deprecated SCSI ioctl please convert it to SG_IOn[ 366.027502] CPU: 5 PID: 28472 Comm: syz-executor.7 Not tainted 6.8.0-rc2-00035-gb3ef86b5a957 #1n[ 366.027512] Hardware name: QEMU Standard PC (i440FX + PIIX 1996) BIOS 1.16.3-debian-1.16.3-2 04/01/2014n[ 366.027518] Call Trace:n[ 366.027523] <TASK>n[ 366.027533] dump_stack_lvl+0x93/0xd0n[ 366.027899] handle_overflow+0x171/0x1b0n[ 366.038787] ata1.00: invalid multi_count 32 ignoredn[ 366.043924] cdrom_ioctl+0x2c3f/0x2d10n[ 366.063932] ? __pm_runtime_resume+0xe6/0x130n[ 366.071923] sr_block_ioctl+0x15d/0x1d0n[ 366.074624] ? __pfx_sr_block_ioctl+0x10/0x10n[ 366.077642] blkdev_ioctl+0x419/0x500n[ 366.080231] ? __pfx_blkdev_ioctl+0x10/0x10n...nnHistorically the signed integer overflow sanitizer did not work in thenkernel due to its interaction with `-fwrapv` but this has since beennchanged [1] in the newest version of Clang. It was re-enabled in thenkernel with Commit 557f8c582a9ba8ab (ubsan: Reintroduce signed overflownsanitizer).nnLet's rearrange the check to not perform any arithmetic thus notntripping the sanitizer.,CVE-2024-42136,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nncrypto: hisilicon/debugfs - Fix debugfs uninit process issuennDuring the zip probe process the debugfs failure does not stopnthe probe. When debugfs initialization fails jumping to thenerror branch will also release regs in addition to its ownnrollback operation.nnAs a result it may be released repeatedly during the regsnuninit process. Therefore the null check needs to be added tonthe regs uninit process.,CVE-2024-42147,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nns390/pkey: Wipe copies of protected- and secure-keysnnAlthough the clear-key of neither protected- nor secure-keys isnaccessible this key material should only be visible to the callingnprocess. So wipe all copies of protected- or secure-keys from stackneven in case of an error.,CVE-2024-42155,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nns390/pkey: Wipe copies of clear-key structures on failurennWipe all sensitive data from stack for all IOCTLs which convert anclear-key into a protected- or secure-key.,CVE-2024-42156,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nns390/pkey: Use kfree_sensitive() to fix Coccinelle warningsnnReplace memzero_explicit() and kfree() with kfree_sensitive() to fixnwarnings reported by Coccinelle:nnWARNING opportunity for kfree_sensitive/kvfree_sensitive (line 1506)nWARNING opportunity for kfree_sensitive/kvfree_sensitive (line 1643)nWARNING opportunity for kfree_sensitive/kvfree_sensitive (line 1770),CVE-2024-42158,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnf2fs: check validation of fault attrs in f2fs_build_fault_attr()nn- It missed to check validation of fault attrs in parse_options()nlet's fix to add check condition in f2fs_build_fault_attr().n- Use f2fs_build_fault_attr() in __sbi_store() to clean up code.,CVE-2024-42160,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nngve: Account for stopped queues when reading NIC statsnnWe now account for the fact that the NIC might send us stats for ansubset of queues. Without this change gve_get_ethtool_stats might makenan invalid access on the priv->stats_report->stats array.,CVE-2024-42162,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnwifi: mt76: replace skb_put with skb_put_zeronnAvoid potentially reusing uninitialized data,CVE-2024-42225,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnpowerpc/pseries: Fix scv instruction crash with kexecnnkexec on pseries disables AIL (reloc_on_exc) required for scvninstruction support before other CPUs have been shut down. This meansnthey can execute scv instructions after AIL is disabled which causes anninterrupt at an unexpected entry location that crashes the kernel.nnChange the kexec sequence to disable AIL after other CPUs have beennbrought down.nnAs a refresher the real-mode scv interrupt vector is 0x17000 and thenfixed-location head code probably couldn't easily deal with implementingnsuch high addresses so it was just decided not to support that interruptnat all.,CVE-2024-42230,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnclosures: Change BUG_ON() to WARN_ON()nnIf a BUG_ON() can be hit in the wild it shouldn't be a BUG_ON()nnFor reference this has popped up once in the CI and we'll need moreninfo to debug it:nn03240 ------------[ cut here ]------------n03240 kernel BUG at lib/closure.c:21!n03240 kernel BUG at lib/closure.c:21!n03240 Internal error: Oops - BUG: 00000000f2000800 [#1] SMPn03240 Modules linked in:n03240 CPU: 15 PID: 40534 Comm: kworker/u80:1 Not tainted 6.10.0-rc4-ktest-ga56da69799bd #25570n03240 Hardware name: linuxdummy-virt (DT)n03240 Workqueue: btree_update btree_interior_update_workn03240 pstate: 00001005 (nzcv daif -PAN -UAO -TCO -DIT +SSBS BTYPE=--)n03240 pc : closure_put+0x224/0x2a0n03240 lr : closure_put+0x24/0x2a0n03240 sp : ffff0000d12071c0n03240 x29: ffff0000d12071c0 x28: dfff800000000000 x27: ffff0000d1207360n03240 x26: 0000000000000040 x25: 0000000000000040 x24: 0000000000000040n03240 x23: ffff0000c1f20180 x22: 0000000000000000 x21: ffff0000c1f20168n03240 x20: 0000000040000000 x19: ffff0000c1f20140 x18: 0000000000000001n03240 x17: 0000000000003aa0 x16: 0000000000003ad0 x15: 1fffe0001c326974n03240 x14: 0000000000000a1e x13: 0000000000000000 x12: 1fffe000183e402dn03240 x11: ffff6000183e402d x10: dfff800000000000 x9 : ffff6000183e402en03240 x8 : 0000000000000001 x7 : 00009fffe7c1bfd3 x6 : ffff0000c1f2016bn03240 x5 : ffff0000c1f20168 x4 : ffff6000183e402e x3 : ffff800081391954n03240 x2 : 0000000000000001 x1 : 0000000000000000 x0 : 00000000a8000000n03240 Call trace:n03240 closure_put+0x224/0x2a0n03240 bch2_check_for_deadlock+0x910/0x1028n03240 bch2_six_check_for_deadlock+0x1c/0x30n03240 six_lock_slowpath.isra.0+0x29c/0xed0n03240 six_lock_ip_waiter+0xa8/0xf8n03240 __bch2_btree_node_lock_write+0x14c/0x298n03240 bch2_trans_lock_write+0x6d4/0xb10n03240 __bch2_trans_commit+0x135c/0x5520n03240 btree_interior_update_work+0x1248/0x1c10n03240 process_scheduled_works+0x53c/0xd90n03240 worker_thread+0x370/0x8c8n03240 kthread+0x258/0x2e8n03240 ret_from_fork+0x10/0x20n03240 Code: aa1303e0 d63f0020 a94363f7 17ffff8c (d4210000)n03240 ---[ end trace 0000000000000000 ]---n03240 Kernel panic - not syncing: Oops - BUG: Fatal exceptionn03240 SMP: stopping secondary CPUsn03241 SMP: failed to stop secondary CPUs 1315n03241 Kernel Offset: disabledn03241 CPU features: 0x0000000003800000084240500bn03241 Memory Limit: nonen03241 ---[ end Kernel panic - not syncing: Oops - BUG: Fatal exception ]---n03246 ========= FAILED TIMEOUT copygc_torture_no_checksum in 7200s,CVE-2024-42252,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nngpio: pca953x: fix pca953x_irq_bus_sync_unlock racennEnsure that `i2c_lock' is held when setting interrupt latch and mask innpca953x_irq_bus_sync_unlock() in order to avoid races.nnThe other (non-probe) call site pca953x_gpio_set_multiple() ensures thenlock is held before calling pca953x_write_regs().nnThe problem occurred when a request raced against irq_bus_sync_unlock()napproximately once per thousand reboots on an i.MX8MP based system.nn output.log scan_tyk_dockerimages.sh vulnerabilities.csv Normal casenn 0-0022: write register AI|3a {0302000001} Input latch P0n 0-0022: write register AI|49 {fcfdfffffe} Interrupt mask P0n 0-0022: write register AI|08 {ff00000000} Output P3n 0-0022: write register AI|12 {fc00000000} Config P3nn output.log scan_tyk_dockerimages.sh vulnerabilities.csv Race casenn 0-0022: write register AI|08 {ff00000000} Output P3n 0-0022: write register AI|08 {0302000001} output.log scan_tyk_dockerimages.sh vulnerabilities.csv Wrong register ***n 0-0022: write register AI|12 {fc00000000} Config P3n 0-0022: write register AI|49 {fcfdfffffe} Interrupt mask P0,CVE-2024-42253,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnriscv/mm: Add handling for VM_FAULT_SIGSEGV in mm_fault_error()nnHandle VM_FAULT_SIGSEGV in the page fault path so that we correctlynkill the process and we don't BUG() the kernel.,CVE-2024-42267,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet/iucv: fix use after free in iucv_sock_close()nniucv_sever_path() is called from process context and from bh context.niucv->path is used as indicator whether somebody else is taking care ofnsevering the path (or it is already removed / never existed).nThis needs to be done with atomic compare and swap otherwise there is ansmall window where iucv_sock_close() will try to work with a path that hasnalready been severed and freed by iucv_callback_connrej() called byniucv_tasklet_fn().nnExample:n[452744.123844] Call Trace:n[452744.123845] ([<0000001e87f03880>] 0x1e87f03880)n[452744.123966] [<00000000d593001e>] iucv_path_sever+0x96/0x138n[452744.124330] [<000003ff801ddbca>] iucv_sever_path+0xc2/0xd0 [af_iucv]n[452744.124336] [<000003ff801e01b6>] iucv_sock_close+0xa6/0x310 [af_iucv]n[452744.124341] [<000003ff801e08cc>] iucv_sock_release+0x3c/0xd0 [af_iucv]n[452744.124345] [<00000000d574794e>] __sock_release+0x5e/0xe8n[452744.124815] [<00000000d5747a0c>] sock_close+0x34/0x48n[452744.124820] [<00000000d5421642>] __fput+0xba/0x268n[452744.124826] [<00000000d51b382c>] task_work_run+0xbc/0xf0n[452744.124832] [<00000000d5145710>] do_notify_resume+0x88/0x90n[452744.124841] [<00000000d5978096>] system_call+0xe2/0x2c8n[452744.125319] Last Breaking-Event-Address:n[452744.125321] [<00000000d5930018>] iucv_path_sever+0x90/0x138n[452744.125324]n[452744.125325] Kernel panic - not syncing: Fatal exception in interruptnnNote that bh_lock_sock() is not serializing the tasklet context againstnprocess context because the check for sock_owned_by_user() andncorresponding handling is missing.nnIdeas for a future clean-up patch:nA) Correct usage of bh_lock_sock() in tasklet context as described innRe-enqueue if needed. This may require adding return values to thentasklet functions and thus changes to all users of iucv.nnB) Change iucv tasklet into worker and use only lock_sock() in af_iucv.,CVE-2024-42271,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnf2fs: fix return value of f2fs_convert_inline_inode()nnIf device is readonly make f2fs_convert_inline_inode()nreturn EROFS instead of zero otherwise it may triggernpanic during writeback of inline inode's dirty page asnbelow:nn f2fs_write_single_data_page+0xbb6/0x1e90 fs/f2fs/data.c:2888n f2fs_write_cache_pages fs/f2fs/data.c:3187 [inline]n __f2fs_write_data_pages fs/f2fs/data.c:3342 [inline]n f2fs_write_data_pages+0x1efe/0x3a90 fs/f2fs/data.c:3369n do_writepages+0x359/0x870 mm/page-writeback.c:2634n filemap_fdatawrite_wbc+0x125/0x180 mm/filemap.c:397n __filemap_fdatawrite_range mm/filemap.c:430 [inline]n file_write_and_wait_range+0x1aa/0x290 mm/filemap.c:788n f2fs_do_sync_file+0x68a/0x1ae0 fs/f2fs/file.c:276n generic_write_sync include/linux/fs.h:2806 [inline]n f2fs_file_write_iter+0x7bd/0x24e0 fs/f2fs/file.c:4977n call_write_iter include/linux/fs.h:2114 [inline]n new_sync_write fs/read_write.c:497 [inline]n vfs_write+0xa72/0xc90 fs/read_write.c:590n ksys_write+0x1a0/0x2c0 fs/read_write.c:643n do_syscall_x64 arch/x86/entry/common.c:52 [inline]n do_syscall_64+0xf5/0x240 arch/x86/entry/common.c:83n entry_SYSCALL_64_after_hwframe+0x77/0x7f,CVE-2024-42296,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnmailbox: mtk-cmdq: Move devm_mbox_controller_register() after devm_pm_runtime_enable()nnWhen mtk-cmdq unbinds a WARN_ON message with conditionnpm_runtime_get_sync() < 0 occurs.nnAccording to the call tracei below:n cmdq_mbox_shutdownn mbox_free_channeln mbox_controller_unregistern __devm_mbox_controller_unregistern ...nnThe root cause can be deduced to be calling pm_runtime_get_sync() afterncalling pm_runtime_disable() as observed below:n1. CMDQ driver uses devm_mbox_controller_register() in cmdq_probe()n to bind the cmdq device to the mbox_controller son devm_mbox_controller_unregister() will automatically unregistern the device bound to the mailbox controller when the device-managedn resource is removed. That means devm_mbox_controller_unregister()n and cmdq_mbox_shoutdown() will be called after cmdq_remove().n2. CMDQ driver also uses devm_pm_runtime_enable() in cmdq_probe() aftern devm_mbox_controller_register() so that devm_pm_runtime_disable()n will be called after cmdq_remove() but beforen devm_mbox_controller_unregister().nnTo fix this problem cmdq_probe() needs to movendevm_mbox_controller_register() after devm_pm_runtime_enable() to makendevm_pm_runtime_disable() be called afterndevm_mbox_controller_unregister().,CVE-2024-42319,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet: flow_dissector: use DEBUG_NET_WARN_ON_ONCEnnThe following splat is easy to reproduce upstream as well as in -stablenkernels. Florian Westphal provided the following commit:nn d1dab4f71d37 (net: add and use __skb_get_hash_symmetric_net)nnbut this complementary fix has been also suggested by Willem de Bruijnnand it can be easily backported to -stable kernel which consists innusing DEBUG_NET_WARN_ON_ONCE instead to silence the following splatngiven __skb_get_hash() is used by the nftables tracing infrastructure tonto identify packets in traces.nn[69133.561393] ------------[ cut here ]------------n[69133.561404] WARNING: CPU: 0 PID: 43576 at net/core/flow_dissector.c:1104 __skb_flow_dissect+0x134f/n[...]n[69133.561944] CPU: 0 PID: 43576 Comm: socat Not tainted 6.10.0-rc7+ #379n[69133.561959] RIP: 0010:__skb_flow_dissect+0x134f/0x2ad0n[69133.561970] Code: 83 f9 04 0f 84 b3 00 00 00 45 85 c9 0f 84 aa 00 00 00 41 83 f9 02 0f 84 81 fc ffnff 44 0f b7 b4 24 80 00 00 00 e9 8b f9 ff ff <0f> 0b e9 20 f3 ff ff 41 f6 c6 20 0f 84 e4 ef ff ff 48 8d 7b 12 e8n[69133.561979] RSP: 0018:ffffc90000006fc0 EFLAGS: 00010246n[69133.561988] RAX: 0000000000000000 RBX: ffffffff82f33e20 RCX: ffffffff81ab7e19n[69133.561994] RDX: dffffc0000000000 RSI: ffffc90000007388 RDI: ffff888103a1b418n[69133.562001] RBP: ffffc90000007310 R08: 0000000000000000 R09: 0000000000000000n[69133.562007] R10: ffffc90000007388 R11: ffffffff810cface R12: ffff888103a1b400n[69133.562013] R13: 0000000000000000 R14: ffffffff82f33e2a R15: ffffffff82f33e28n[69133.562020] FS: 00007f40f7131740(0000) GS:ffff888390800000(0000) knlGS:0000000000000000n[69133.562027] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033n[69133.562033] CR2: 00007f40f7346ee0 CR3: 000000015d200001 CR4: 00000000001706f0n[69133.562040] Call Trace:n[69133.562044] <IRQ>n[69133.562049] ? __warn+0x9f/0x1a0n[ 1211.841384] ? __skb_flow_dissect+0x107e/0x2860n[...]n[ 1211.841496] ? bpf_flow_dissect+0x160/0x160n[ 1211.841753] __skb_get_hash+0x97/0x280n[ 1211.841765] ? __skb_get_hash_symmetric+0x230/0x230n[ 1211.841776] ? mod_find+0xbf/0xe0n[ 1211.841786] ? get_stack_info_noinstr+0x12/0xe0n[ 1211.841798] ? bpf_ksym_find+0x56/0xe0n[ 1211.841807] ? __rcu_read_unlock+0x2a/0x70n[ 1211.841819] nft_trace_init+0x1b9/0x1c0 [nf_tables]n[ 1211.841895] ? nft_trace_notify+0x830/0x830 [nf_tables]n[ 1211.841964] ? get_stack_info+0x2b/0x80n[ 1211.841975] ? nft_do_chain_arp+0x80/0x80 [nf_tables]n[ 1211.842044] nft_do_chain+0x79c/0x850 [nf_tables],CVE-2024-42321,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnipvs: properly dereference pe in ip_vs_add_servicennUse pe directly to resolve sparse warning:nn net/netfilter/ipvs/ip_vs_ctl.c:1471:27: warning: dereference of noderef expression,CVE-2024-42322,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet: missing check virtionnTwo missing check in virtio_net_hdr_to_skb() allowed syzbotnto crash kernels againnn1. After the skb_segment function the buffer may become non-linearn(nr_frags != 0) but since the SKBTX_SHARED_FRAG flag is not set anywherenthe __skb_linearize function will not be executed then the buffer willnremain non-linear. Then the condition (offset >= skb_headlen(skb))nbecomes true which causes WARN_ON_ONCE in skb_checksum_help.nn2. The struct sk_buff and struct virtio_net_hdr members must benmathematically related.n(gso_size) must be greater than (needed) otherwise WARN_ON_ONCE.n(remainder) must be greater than (needed) otherwise WARN_ON_ONCE.n(remainder) may be 0 if division is without remainder.nnoffset+2 (4191) > skb_headlen() (1116)nWARNING: CPU: 1 PID: 5084 at net/core/dev.c:3303 skb_checksum_help+0x5e2/0x740 net/core/dev.c:3303nModules linked in:nCPU: 1 PID: 5084 Comm: syz-executor336 Not tainted 6.7.0-rc3-syzkaller-00014-gdf60cee26a2e #0nHardware name: Google Compute Engine/Google Compute Engine BIOS Google 11/10/2023nRIP: 0010:skb_checksum_help+0x5e2/0x740 net/core/dev.c:3303nCode: 89 e8 83 e0 07 83 c0 03 38 d0 7c 08 84 d2 0f 85 52 01 00 00 44 89 e2 2b 53 74 4c 89 ee 48 c7 c7 40 57 e9 8b e8 af 8f dd f8 90 <0f> 0b 90 90 e9 87 fe ff ff e8 40 0f 6e f9 e9 4b fa ff ff 48 89 efnRSP: 0018:ffffc90003a9f338 EFLAGS: 00010286nRAX: 0000000000000000 RBX: ffff888025125780 RCX: ffffffff814db209nRDX: ffff888015393b80 RSI: ffffffff814db216 RDI: 0000000000000001nRBP: ffff8880251257f4 R08: 0000000000000001 R09: 0000000000000000nR10: 0000000000000000 R11: 0000000000000001 R12: 000000000000045cnR13: 000000000000105f R14: ffff8880251257f0 R15: 000000000000105dnFS: 0000555555c24380(0000) GS:ffff8880b9900000(0000) knlGS:0000000000000000nCS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033nCR2: 000000002000f000 CR3: 0000000023151000 CR4: 00000000003506f0nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400nCall Trace:n <TASK>n ip_do_fragment+0xa1b/0x18b0 net/ipv4/ip_output.c:777n ip_fragment.constprop.0+0x161/0x230 net/ipv4/ip_output.c:584n ip_finish_output_gso net/ipv4/ip_output.c:286 [inline]n __ip_finish_output net/ipv4/ip_output.c:308 [inline]n __ip_finish_output+0x49c/0x650 net/ipv4/ip_output.c:295n ip_finish_output+0x31/0x310 net/ipv4/ip_output.c:323n NF_HOOK_COND include/linux/netfilter.h:303 [inline]n ip_output+0x13b/0x2a0 net/ipv4/ip_output.c:433n dst_output include/net/dst.h:451 [inline]n ip_local_out+0xaf/0x1a0 net/ipv4/ip_output.c:129n iptunnel_xmit+0x5b4/0x9b0 net/ipv4/ip_tunnel_core.c:82n ipip6_tunnel_xmit net/ipv6/sit.c:1034 [inline]n sit_tunnel_xmit+0xed2/0x28f0 net/ipv6/sit.c:1076n __netdev_start_xmit include/linux/netdevice.h:4940 [inline]n netdev_start_xmit include/linux/netdevice.h:4954 [inline]n xmit_one net/core/dev.c:3545 [inline]n dev_hard_start_xmit+0x13d/0x6d0 net/core/dev.c:3561n __dev_queue_xmit+0x7c1/0x3d60 net/core/dev.c:4346n dev_queue_xmit include/linux/netdevice.h:3134 [inline]n packet_xmit+0x257/0x380 net/packet/af_packet.c:276n packet_snd net/packet/af_packet.c:3087 [inline]n packet_sendmsg+0x24ca/0x5240 net/packet/af_packet.c:3119n sock_sendmsg_nosec net/socket.c:730 [inline]n __sock_sendmsg+0xd5/0x180 net/socket.c:745n __sys_sendto+0x255/0x340 net/socket.c:2190n __do_sys_sendto net/socket.c:2202 [inline]n __se_sys_sendto net/socket.c:2198 [inline]n __x64_sys_sendto+0xe0/0x1b0 net/socket.c:2198n do_syscall_x64 arch/x86/entry/common.c:51 [inline]n do_syscall_64+0x40/0x110 arch/x86/entry/common.c:82n entry_SYSCALL_64_after_hwframe+0x63/0x6bnnFound by Linux Verification Center (linuxtesting.org) with Syzkaller,CVE-2024-43817,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnkvm: s390: Reject memory region operations for ucontrol VMsnnThis change rejects the KVM_SET_USER_MEMORY_REGION andnKVM_SET_USER_MEMORY_REGION2 ioctls when called on a ucontrol VM.nThis is necessary since ucontrol VMs have kvm->arch.gmap set to 0 andnwould thus result in a null pointer dereference further in.nMemory management needs to be performed in userspace and using thenioctls KVM_S390_UCAS_MAP and KVM_S390_UCAS_UNMAP.nnAlso improve s390 specific documentation for KVM_SET_USER_MEMORY_REGIONnand KVM_SET_USER_MEMORY_REGION2.nn[frankja@linux.ibm.com: commit message spelling fix subject prefix fix],CVE-2024-43819,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnPCI: keystone: Fix NULL pointer dereference in case of DT error in ks_pcie_setup_rc_app_regs()nnIf IORESOURCE_MEM is not provided in Device Tree due tonany error resource_list_first_type() will return NULL andnpci_parse_request_of_pci_ranges() will just emit a warning.nnThis will cause a NULL pointer dereference. Fix this bug by adding NULLnreturn check.nnFound by Linux Verification Center (linuxtesting.org) with SVACE.,CVE-2024-43823,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnPCI: endpoint: pci-epf-test: Make use of cached 'epc_features' in pci_epf_test_core_init()nnInstead of getting the epc_features from pci_epc_get_features() API usenthe cached pci_epf_test::epc_features value to avoid the NULL check. Sincenthe NULL check is already performed in pci_epf_test_bind() having one morencheck in pci_epf_test_core_init() is redundant and it is not possible tonhit the NULL pointer dereference.nnAlso with commit a01e7214bef9 (PCI: endpoint: Remove core_init_notifiernflag) 'epc_features' got dereferenced without the NULL check leading tonthe following false positive Smatch warning:nn drivers/pci/endpoint/functions/pci-epf-test.c:784 pci_epf_test_core_init() error: we previously assumed 'epc_features' could be null (see line 747)nnThus remove the redundant NULL check and also use the epc_features::n{msix_capable/msi_capable} flags directly to avoid local variables.nn[kwilczynski: commit log],CVE-2024-43824,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnmedia: mediatek: vcodec: Handle invalid decoder vsinnHandle an invalid decoder vsi in vpu_dec_init to ensure the decoder vsinis valid for future use.,CVE-2024-43831,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nns390/uv: Don't call folio_wait_writeback() without a folio referencennfolio_wait_writeback() requires that no spinlocks are held and thatna folio reference is held as documented. After we dropped the PTL thenfolio could get freed concurrently. So grab a temporary reference.,CVE-2024-43832,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/vmwgfx: Fix a deadlock in dma buf fence pollingnnIntroduce a version of the fence ops that on release doesn't removenthe fence from the pending list and thus doesn't require a lock tonfix poll->fence wait->fence unref deadlocks.nnvmwgfx overwrites the wait callback to iterate over the list of allnfences and update their status to do that it holds a lock to preventnthe list modifcations from other threads. The fence destroy callbacknboth deletes the fence and removes it from the list of pendingnfences for which it holds a lock.nndma buf polling cb unrefs a fence after it's been signaled: so the pollncalls the wait which signals the fences which are being destroyed.nThe destruction tries to acquire the lock on the pending fences listnwhich it can never get because it's held by the wait from which itnwas called.nnOld bug but not a lot of userspace apps were using dma-buf pollingninterfaces. Fix those in particular this fixes KDE stalls/deadlock.,CVE-2024-43863,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet/mlx5: Always drain health in shutdown callbacknnThere is no point in recovery during device shutdown. if healthnwork started need to wait for it to avoid races and NULL pointernaccess.nnHence drain health WQ on shutdown callback.,CVE-2024-43866,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnRDMA/hns: Fix soft lockup under heavy CEQE loadnnCEQEs are handled in interrupt handler currently. This may cause thenCPU core staying in interrupt context too long and lead to soft lockupnunder heavy load.nnHandle CEQEs in BH workqueue and set an upper limit for the number ofnCEQE handled by a single call of work handler.,CVE-2024-43872,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Add null check in resource_log_pipe_topology_updatenn[WHY]nWhen switching from Extend to Second Display Only we sometimesncall resource_get_otg_master_for_stream on a stream for the eDPnwhich is disconnected. This leads to a null pointer dereference.nn[HOW]nAdded a null check in dc_resource.c/resource_log_pipe_topology_update.,CVE-2024-43886,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Skip Recompute DSC Params if no Stream on Linknn[why]nEncounter NULL pointer dereference uner mst + dsc setup.nnBUG: kernel NULL pointer dereference address: 0000000000000008n PGD 0 P4D 0n Oops: 0000 [#1] PREEMPT SMP NOPTIn CPU: 4 PID: 917 Comm: sway Not tainted 6.3.9-arch1-1 #1 124dc55df4f5272ccb409f39ef4872fc2b3376a2n Hardware name: LENOVO 20NKS01Y00/20NKS01Y00 BIOS R12ET61W(1.31 ) 07/28/2022n RIP: 0010:drm_dp_atomic_find_time_slots+0x5e/0x260 [drm_display_helper]n Code: 01 00 00 48 8b 85 60 05 00 00 48 63 80 88 00 00 00 3b 43 28 0f 8d 2e 01 00 00 48 8b 53 30 48 8d 04 80 48 8d 04 c2 48 8b 40 18 <48> 8>n RSP: 0018:ffff960cc2df77d8 EFLAGS: 00010293n RAX: 0000000000000000 RBX: ffff8afb87e81280 RCX: 0000000000000224n RDX: ffff8afb9ee37c00 RSI: ffff8afb8da1a578 RDI: ffff8afb87e81280n RBP: ffff8afb83d67000 R08: 0000000000000001 R09: ffff8afb9652f850n R10: ffff960cc2df7908 R11: 0000000000000002 R12: 0000000000000000n R13: ffff8afb8d7688a0 R14: ffff8afb8da1a578 R15: 0000000000000224n FS: 00007f4dac35ce00(0000) GS:ffff8afe30b00000(0000) knlGS:0000000000000000n CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033n CR2: 0000000000000008 CR3: 000000010ddc6000 CR4: 00000000003506e0n Call Trace:n<TASK>n ? __die+0x23/0x70n ? page_fault_oops+0x171/0x4e0n ? plist_add+0xbe/0x100n ? exc_page_fault+0x7c/0x180n ? asm_exc_page_fault+0x26/0x30n ? drm_dp_atomic_find_time_slots+0x5e/0x260 [drm_display_helper 0e67723696438d8e02b741593dd50d80b44c2026]n ? drm_dp_atomic_find_time_slots+0x28/0x260 [drm_display_helper 0e67723696438d8e02b741593dd50d80b44c2026]n compute_mst_dsc_configs_for_link+0x2ff/0xa40 [amdgpu 62e600d2a75e9158e1cd0a243bdc8e6da040c054]n ? fill_plane_buffer_attributes+0x419/0x510 [amdgpu 62e600d2a75e9158e1cd0a243bdc8e6da040c054]n compute_mst_dsc_configs_for_state+0x1e1/0x250 [amdgpu 62e600d2a75e9158e1cd0a243bdc8e6da040c054]n amdgpu_dm_atomic_check+0xecd/0x1190 [amdgpu 62e600d2a75e9158e1cd0a243bdc8e6da040c054]n drm_atomic_check_only+0x5c5/0xa40n drm_mode_atomic_ioctl+0x76e/0xbc0nn[how]ndsc recompute should be skipped if no mode change detected on the newnrequest. If detected keep checking whether the stream is already onncurrent state or not.nn(cherry picked from commit 8151a6c13111b465dbabe07c19f572f7cbd16fef),CVE-2024-43895,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Fix null pointer deref in dcn20_resource.cnnFixes a hang thats triggered when MPV is run on a DCN401 dGPU:nnmpv --hwdec=vaapi --vo=gpu --hwdec-codecs=allnnand then enabling fullscreen playback (double click on the video)nnThe following calltrace will be seen:nn[ 181.843989] BUG: kernel NULL pointer dereference address: 0000000000000000n[ 181.843997] #PF: supervisor instruction fetch in kernel moden[ 181.844003] #PF: error_code(0x0010) - not-present pagen[ 181.844009] PGD 0 P4D 0n[ 181.844020] Oops: 0010 [#1] PREEMPT SMP NOPTIn[ 181.844028] CPU: 6 PID: 1892 Comm: gnome-shell Tainted: G W OE 6.5.0-41-generic #41~22.04.2-Ubuntun[ 181.844038] Hardware name: System manufacturer System Product Name/CROSSHAIR VI HERO BIOS 6302 10/23/2018n[ 181.844044] RIP: 0010:0x0n[ 181.844079] Code: Unable to access opcode bytes at 0xffffffffffffffd6.n[ 181.844084] RSP: 0018:ffffb593c2b8f7b0 EFLAGS: 00010246n[ 181.844093] RAX: 0000000000000000 RBX: 0000000000000000 RCX: 0000000000000004n[ 181.844099] RDX: ffffb593c2b8f804 RSI: ffffb593c2b8f7e0 RDI: ffff9e3c8e758400n[ 181.844105] RBP: ffffb593c2b8f7b8 R08: ffffb593c2b8f9c8 R09: ffffb593c2b8f96cn[ 181.844110] R10: 0000000000000000 R11: 0000000000000000 R12: ffffb593c2b8f9c8n[ 181.844115] R13: 0000000000000001 R14: ffff9e3c88000000 R15: 0000000000000005n[ 181.844121] FS: 00007c6e323bb5c0(0000) GS:ffff9e3f85f80000(0000) knlGS:0000000000000000n[ 181.844128] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033n[ 181.844134] CR2: ffffffffffffffd6 CR3: 0000000140fbe000 CR4: 00000000003506e0n[ 181.844141] Call Trace:n[ 181.844146] <TASK>n[ 181.844153] ? show_regs+0x6d/0x80n[ 181.844167] ? __die+0x24/0x80n[ 181.844179] ? page_fault_oops+0x99/0x1b0n[ 181.844192] ? do_user_addr_fault+0x31d/0x6b0n[ 181.844204] ? exc_page_fault+0x83/0x1b0n[ 181.844216] ? asm_exc_page_fault+0x27/0x30n[ 181.844237] dcn20_get_dcc_compression_cap+0x23/0x30 [amdgpu]n[ 181.845115] amdgpu_dm_plane_validate_dcc.constprop.0+0xe5/0x180 [amdgpu]n[ 181.845985] amdgpu_dm_plane_fill_plane_buffer_attributes+0x300/0x580 [amdgpu]n[ 181.846848] fill_dc_plane_info_and_addr+0x258/0x350 [amdgpu]n[ 181.847734] fill_dc_plane_attributes+0x162/0x350 [amdgpu]n[ 181.848748] dm_update_plane_state.constprop.0+0x4e3/0x6b0 [amdgpu]n[ 181.849791] ? dm_update_plane_state.constprop.0+0x4e3/0x6b0 [amdgpu]n[ 181.850840] amdgpu_dm_atomic_check+0xdfe/0x1760 [amdgpu],CVE-2024-43899,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnmedia: xc2028: avoid use-after-free in load_firmware_cb()nnsyzkaller reported use-after-free in load_firmware_cb() [1].nThe reason is because the module allocated a struct tuner in tuner_probe()nand then the module initialization failed the struct tuner was released.nA worker which created during module initialization accesses this structntuner later it caused use-after-free.nnThe process is as follows:nntask-6504 worker_threadntuner_probe <= alloc dvb_frontend [2]n...nrequest_firmware_nowait <= create a workern...ntuner_remove <= free dvb_frontendn...n request_firmware_work_func <= the firmware is readyn load_firmware_cb <= but now the dvb_frontend has been freednnTo fix the issue check the dvd_frontend in load_firmware_cb() if it isnnull report a warning and just return.nn[1]:n ==================================================================n BUG: KASAN: use-after-free in load_firmware_cb+0x1310/0x17a0n Read of size 8 at addr ffff8000d7ca2308 by task kworker/2:3/6504nn Call trace:n load_firmware_cb+0x1310/0x17a0n request_firmware_work_func+0x128/0x220n process_one_work+0x770/0x1824n worker_thread+0x488/0xea0n kthread+0x300/0x430n ret_from_fork+0x10/0x20nn Allocated by task 6504:n kzallocn tuner_probe+0xb0/0x1430n i2c_device_probe+0x92c/0xaf0n really_probe+0x678/0xcd0n driver_probe_device+0x280/0x370n __device_attach_driver+0x220/0x330n bus_for_each_drv+0x134/0x1c0n __device_attach+0x1f4/0x410n device_initial_probe+0x20/0x30n bus_probe_device+0x184/0x200n device_add+0x924/0x12c0n device_register+0x24/0x30n i2c_new_device+0x4e0/0xc44n v4l2_i2c_new_subdev_board+0xbc/0x290n v4l2_i2c_new_subdev+0xc8/0x104n em28xx_v4l2_init+0x1dd0/0x3770nn Freed by task 6504:n kfree+0x238/0x4e4n tuner_remove+0x144/0x1c0n i2c_device_remove+0xc8/0x290n __device_release_driver+0x314/0x5fcn device_release_driver+0x30/0x44n bus_remove_device+0x244/0x490n device_del+0x350/0x900n device_unregister+0x28/0xd0n i2c_unregister_device+0x174/0x1d0n v4l2_device_unregister+0x224/0x380n em28xx_v4l2_init+0x1d90/0x3770nn The buggy address belongs to the object at ffff8000d7ca2000n which belongs to the cache kmalloc-2k of size 2048n The buggy address is located 776 bytes inside ofn 2048-byte region [ffff8000d7ca2000 ffff8000d7ca2800)n The buggy address belongs to the page:n page:ffff7fe00035f280 count:1 mapcount:0 mapping:ffff8000c001f000 index:0x0n flags: 0x7ff800000000100(slab)n raw: 07ff800000000100 ffff7fe00049d880 0000000300000003 ffff8000c001f000n raw: 0000000000000000 0000000080100010 00000001ffffffff 0000000000000000n page dumped because: kasan: bad access detectednn Memory state around the buggy address:n ffff8000d7ca2200: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fbn ffff8000d7ca2280: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fbn >ffff8000d7ca2300: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fbn ^n ffff8000d7ca2380: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fbn ffff8000d7ca2400: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fbn ==================================================================nn[2]n Actually it is allocated for struct tuner and dvb_frontend is inside.,CVE-2024-43900,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Fix NULL pointer dereference for DTN log in DCN401nnWhen users run the command:nncat /sys/kernel/debug/dri/0/amdgpu_dm_dtn_lognnThe following NULL pointer dereference happens:nn[ +0.000003] BUG: kernel NULL pointer dereference address: NULLn[ +0.000005] #PF: supervisor instruction fetch in kernel moden[ +0.000002] #PF: error_code(0x0010) - not-present pagen[ +0.000002] PGD 0 P4D 0n[ +0.000004] Oops: 0010 [#1] PREEMPT SMP NOPTIn[ +0.000003] RIP: 0010:0x0n[ +0.000008] Code: Unable to access opcode bytes at 0xffffffffffffffd6.n[...]n[ +0.000002] PKRU: 55555554n[ +0.000002] Call Trace:n[ +0.000002] <TASK>n[ +0.000003] ? show_regs+0x65/0x70n[ +0.000006] ? __die+0x24/0x70n[ +0.000004] ? page_fault_oops+0x160/0x470n[ +0.000006] ? do_user_addr_fault+0x2b5/0x690n[ +0.000003] ? prb_read_valid+0x1c/0x30n[ +0.000005] ? exc_page_fault+0x8c/0x1a0n[ +0.000005] ? asm_exc_page_fault+0x27/0x30n[ +0.000012] dcn10_log_color_state+0xf9/0x510 [amdgpu]n[ +0.000306] ? srso_alias_return_thunk+0x5/0xfbef5n[ +0.000003] ? vsnprintf+0x2fb/0x600n[ +0.000009] dcn10_log_hw_state+0xfd0/0xfe0 [amdgpu]n[ +0.000218] ? __mod_memcg_lruvec_state+0xe8/0x170n[ +0.000008] ? srso_alias_return_thunk+0x5/0xfbef5n[ +0.000002] ? debug_smp_processor_id+0x17/0x20n[ +0.000003] ? srso_alias_return_thunk+0x5/0xfbef5n[ +0.000002] ? srso_alias_return_thunk+0x5/0xfbef5n[ +0.000002] ? set_ptes.isra.0+0x2b/0x90n[ +0.000004] ? srso_alias_return_thunk+0x5/0xfbef5n[ +0.000002] ? _raw_spin_unlock+0x19/0x40n[ +0.000004] ? srso_alias_return_thunk+0x5/0xfbef5n[ +0.000002] ? do_anonymous_page+0x337/0x700n[ +0.000004] dtn_log_read+0x82/0x120 [amdgpu]n[ +0.000207] full_proxy_read+0x66/0x90n[ +0.000007] vfs_read+0xb0/0x340n[ +0.000005] ? __count_memcg_events+0x79/0xe0n[ +0.000002] ? srso_alias_return_thunk+0x5/0xfbef5n[ +0.000003] ? count_memcg_events.constprop.0+0x1e/0x40n[ +0.000003] ? handle_mm_fault+0xb2/0x370n[ +0.000003] ksys_read+0x6b/0xf0n[ +0.000004] __x64_sys_read+0x19/0x20n[ +0.000003] do_syscall_64+0x60/0x130n[ +0.000004] entry_SYSCALL_64_after_hwframe+0x6e/0x76n[ +0.000003] RIP: 0033:0x7fdf32f147e2n[...]nnThis error happens when the color log tries to read the gamut remapninformation from DCN401 which is not initialized in the dcn401_dpp_funcsnwhich leads to a null pointer dereference. This commit addresses thisnissue by adding a proper guard to access the gamut_remap callback inncase the specific ASIC did not implement this function.,CVE-2024-43901,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Add null checker before passing variablesnnChecks null pointer before passing variables to functions.nnThis fixes 3 NULL_RETURNS issues reported by Coverity.,CVE-2024-43902,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Add null checks for 'stream' and 'plane' before dereferencingnnThis commit adds null checks for the 'stream' and 'plane' variables innthe dcn30_apply_idle_power_optimizations function. These variables werenpreviously assumed to be null at line 922 but they were used later innthe code without checking if they were null. This could potentially leadnto a null pointer dereference which would cause a crash.nnThe null checks ensure that 'stream' and 'plane' are not null beforenthey are used preventing potential crashes.nnFixes the below static smatch checker:ndrivers/gpu/drm/amd/amdgpu/../display/dc/hwss/dcn30/dcn30_hwseq.c:938 dcn30_apply_idle_power_optimizations() error: we previously assumed 'stream' could be null (see line 922)ndrivers/gpu/drm/amd/amdgpu/../display/dc/hwss/dcn30/dcn30_hwseq.c:940 dcn30_apply_idle_power_optimizations() error: we previously assumed 'plane' could be null (see line 922),CVE-2024-43904,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amdgpu/pm: Fix the null pointer dereference for smu7nnoptimize the code to avoid pass a null pointer (hwmgr->backend)nto function smu7_update_edc_leakage_table.,CVE-2024-43909,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnwifi: mac80211: fix NULL dereference at band check in starting tx ba sessionnnIn MLD connection link_data/link_conf are dynamically allocated. Theyndon't point to vif->bss_conf. So there will be no chanreq assigned tonvif->bss_conf and then the chan will be NULL. Tweak the code to checknht_supported/vht_supported/has_he/has_eht on sta deflink.nnCrash log (with rtw89 version under MLO development):n[ 9890.526087] BUG: kernel NULL pointer dereference address: 0000000000000000n[ 9890.526102] #PF: supervisor read access in kernel moden[ 9890.526105] #PF: error_code(0x0000) - not-present pagen[ 9890.526109] PGD 0 P4D 0n[ 9890.526114] Oops: 0000 [#1] PREEMPT SMP PTIn[ 9890.526119] CPU: 2 PID: 6367 Comm: kworker/u16:2 Kdump: loaded Tainted: G OE 6.9.0 #1n[ 9890.526123] Hardware name: LENOVO 2356AD1/2356AD1 BIOS G7ETB3WW (2.73 ) 11/28/2018n[ 9890.526126] Workqueue: phy2 rtw89_core_ba_work [rtw89_core]n[ 9890.526203] RIP: 0010:ieee80211_start_tx_ba_session (net/mac80211/agg-tx.c:618 (discriminator 1)) mac80211n[ 9890.526279] Code: f7 e8 d5 93 3e ea 48 83 c4 28 89 d8 5b 41 5c 41 5d 41 5e 41 5f 5d c3 cc cc cc cc 49 8b 84 24 e0 f1 ff ff 48 8b 80 90 1b 00 00 <83> 38 03 0f 84 37 fe ff ff bb ea ff ff ff eb cc 49 8b 84 24 10 f3nAll coden========n 0:tf7 e8 timul %eaxn 2:td5 t(bad)n 3:t93 txchg %eax%ebxn 4:t3e ea tds (bad)n 6:t48 83 c4 28 tadd $0x28%rspn a:t89 d8 tmov %ebx%eaxn c:t5b tpop %rbxn d:t41 5c tpop %r12n f:t41 5d tpop %r13n 11:t41 5e tpop %r14n 13:t41 5f tpop %r15n 15:t5d tpop %rbpn 16:tc3 tretqn 17:tcc tint3n 18:tcc tint3n 19:tcc tint3n 1a:tcc tint3n 1b:t49 8b 84 24 e0 f1 ff tmov -0xe20(%r12)%raxn 22:tffn 23:t48 8b 80 90 1b 00 00 tmov 0x1b90(%rax)%raxn 2a:*t83 38 03 tcmpl $0x3(%rax)tt<-- trapping instructionn 2d:t0f 84 37 fe ff ff tje 0xfffffffffffffe6an 33:tbb ea ff ff ff tmov $0xffffffea%ebxn 38:teb cc tjmp 0x6n 3a:t49 trex.WBn 3b:t8b t.byte 0x8bn 3c:t84 24 10 ttest %ah(%rax%rdx1)n 3f:tf3 trepznnCode starting with the faulting instructionn===========================================n 0:t83 38 03 tcmpl $0x3(%rax)n 3:t0f 84 37 fe ff ff tje 0xfffffffffffffe40n 9:tbb ea ff ff ff tmov $0xffffffea%ebxn e:teb cc tjmp 0xffffffffffffffdcn 10:t49 trex.WBn 11:t8b t.byte 0x8bn 12:t84 24 10 ttest %ah(%rax%rdx1)n 15:tf3 trepzn[ 9890.526285] RSP: 0018:ffffb8db09013d68 EFLAGS: 00010246n[ 9890.526291] RAX: 0000000000000000 RBX: 0000000000000000 RCX: ffff9308e0d656c8n[ 9890.526295] RDX: 0000000000000000 RSI: ffffffffab99460b RDI: ffffffffab9a7685n[ 9890.526300] RBP: ffffb8db09013db8 R08: 0000000000000000 R09: 0000000000000873n[ 9890.526304] R10: ffff9308e0d64800 R11: 0000000000000002 R12: ffff9308e5ff6e70n[ 9890.526308] R13: ffff930952500e20 R14: ffff9309192a8c00 R15: 0000000000000000n[ 9890.526313] FS: 0000000000000000(0000) GS:ffff930b4e700000(0000) knlGS:0000000000000000n[ 9890.526316] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033n[ 9890.526318] CR2: 0000000000000000 CR3: 0000000391c58005 CR4: 00000000001706f0n[ 9890.526321] Call Trace:n[ 9890.526324] <TASK>n[ 9890.526327] ? show_regs (arch/x86/kernel/dumpstack.c:479)n[ 9890.526335] ? __die (arch/x86/kernel/dumpstack.c:421 arch/x86/kernel/dumpstack.c:434)n[ 9890.526340] ? page_fault_oops (arch/x86/mm/fault.c:713)n[ 9890.526347] ? search_module_extables (kernel/module/main.c:3256 (discriminatorn---truncated---,CVE-2024-43911,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnwifi: nl80211: disallow setting special AP channel widthsnnSetting the AP channel width is meant for use with the normaln20/40/... MHz channel width progression and switching aroundnin S1G or narrow channels isn't supported. Disallow that.,CVE-2024-43912,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet: bridge: mcast: wait for previous gc cycles when removing portnnsyzbot hit a use-after-free[1] which is caused because the bridge doesn'tnmake sure that all previous garbage has been collected when removing anport. What happens is:n CPU 1 CPU 2n start gc cycle remove portn acquire gc lock firstn wait for lockn call br_multicasg_gc() directlyn acquire lock now but free portn the port can be freedn while grp timers stilln runningnnMake sure all previous gc cycles have finished by using flush_work beforenfreeing the port.nn[1]n BUG: KASAN: slab-use-after-free in br_multicast_port_group_expired+0x4c0/0x550 net/bridge/br_multicast.c:861n Read of size 8 at addr ffff888071d6d000 by task syz.5.1232/9699nn CPU: 1 PID: 9699 Comm: syz.5.1232 Not tainted 6.10.0-rc5-syzkaller-00021-g24ca36a562d6 #0n Hardware name: Google Google Compute Engine/Google Compute Engine BIOS Google 06/07/2024n Call Trace:n <IRQ>n __dump_stack lib/dump_stack.c:88 [inline]n dump_stack_lvl+0x116/0x1f0 lib/dump_stack.c:114n print_address_description mm/kasan/report.c:377 [inline]n print_report+0xc3/0x620 mm/kasan/report.c:488n kasan_report+0xd9/0x110 mm/kasan/report.c:601n br_multicast_port_group_expired+0x4c0/0x550 net/bridge/br_multicast.c:861n call_timer_fn+0x1a3/0x610 kernel/time/timer.c:1792n expire_timers kernel/time/timer.c:1843 [inline]n __run_timers+0x74b/0xaf0 kernel/time/timer.c:2417n __run_timer_base kernel/time/timer.c:2428 [inline]n __run_timer_base kernel/time/timer.c:2421 [inline]n run_timer_base+0x111/0x190 kernel/time/timer.c:2437,CVE-2024-44934,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnjfs: Fix shift-out-of-bounds in dbDiscardAGnnWhen searching for the next smaller log2 block BLKSTOL2() returned 0ncausing shift exponent -1 to be negative.nnThis patch fixes the issue by exiting the loop directly when negativenshift is found.,CVE-2024-44938,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnjfs: fix null ptr deref in dtInsertEntrynn[syzbot reported]ngeneral protection fault probably for non-canonical address 0xdffffc0000000001: 0000 [#1] PREEMPT SMP KASAN PTInKASAN: null-ptr-deref in range [0x0000000000000008-0x000000000000000f]nCPU: 0 PID: 5061 Comm: syz-executor404 Not tainted 6.8.0-syzkaller-08951-gfe46a7dd189e #0nHardware name: Google Google Compute Engine/Google Compute Engine BIOS Google 03/27/2024nRIP: 0010:dtInsertEntry+0xd0c/0x1780 fs/jfs/jfs_dtree.c:3713n...n[Analyze]nIn dtInsertEntry() when the pointer h has the same value as p after writingnname in UniStrncpy_to_le() p->header.flag will be cleared. This will cause thenpreviously true judgment p->header.flag & BT-LEAF to change to no after writingnthe name operation this leads to entering an incorrect branch and accessing thenuninitialized object ih when judging this condition for the second time.nn[Fix]nAfter got the page check freelist first if freelist == 0 then exit dtInsert()nand return -EINVAL.,CVE-2024-44939,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnf2fs: fix to cover read extent cache access with locknnsyzbot reports a f2fs bug as below:nnBUG: KASAN: slab-use-after-free in sanity_check_extent_cache+0x370/0x410 fs/f2fs/extent_cache.c:46nRead of size 4 at addr ffff8880739ab220 by task syz-executor200/5097nnCPU: 0 PID: 5097 Comm: syz-executor200 Not tainted 6.9.0-rc6-syzkaller #0nHardware name: Google Google Compute Engine/Google Compute Engine BIOS Google 03/27/2024nCall Trace:n <TASK>n __dump_stack lib/dump_stack.c:88 [inline]n dump_stack_lvl+0x241/0x360 lib/dump_stack.c:114n print_address_description mm/kasan/report.c:377 [inline]n print_report+0x169/0x550 mm/kasan/report.c:488n kasan_report+0x143/0x180 mm/kasan/report.c:601n sanity_check_extent_cache+0x370/0x410 fs/f2fs/extent_cache.c:46n do_read_inode fs/f2fs/inode.c:509 [inline]n f2fs_iget+0x33e1/0x46e0 fs/f2fs/inode.c:560n f2fs_nfs_get_inode+0x74/0x100 fs/f2fs/super.c:3237n generic_fh_to_dentry+0x9f/0xf0 fs/libfs.c:1413n exportfs_decode_fh_raw+0x152/0x5f0 fs/exportfs/expfs.c:444n exportfs_decode_fh+0x3c/0x80 fs/exportfs/expfs.c:584n do_handle_to_path fs/fhandle.c:155 [inline]n handle_to_path fs/fhandle.c:210 [inline]n do_handle_open+0x495/0x650 fs/fhandle.c:226n do_syscall_x64 arch/x86/entry/common.c:52 [inline]n do_syscall_64+0xf5/0x240 arch/x86/entry/common.c:83n entry_SYSCALL_64_after_hwframe+0x77/0x7fnnWe missed to cover sanity_check_extent_cache() w/ extent cache locknso below race case may happen result in use after free issue.nn- f2fs_igetn - do_read_inoden - f2fs_init_read_extent_treen : add largest extent entry in to cachenttttt- shrinknttttt - f2fs_shrink_read_extent_treenttttt - __shrink_extent_treenttttt - __detach_extent_nodenttttt : drop largest extent entryn - sanity_check_extent_cachen : access et->largest w/o locknnlet's refactor sanity_check_extent_cache() to avoid extent cache accessnand call it before f2fs_init_read_extent_tree() to fix this issue.,CVE-2024-44941,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnf2fs: fix to do sanity check on F2FS_INLINE_DATA flag in inode during GCnnsyzbot reports a f2fs bug as below:nn------------[ cut here ]------------nkernel BUG at fs/f2fs/inline.c:258!nCPU: 1 PID: 34 Comm: kworker/u8:2 Not tainted 6.9.0-rc6-syzkaller-00012-g9e4bc4bcae01 #0nRIP: 0010:f2fs_write_inline_data+0x781/0x790 fs/f2fs/inline.c:258nCall Trace:n f2fs_write_single_data_page+0xb65/0x1d60 fs/f2fs/data.c:2834n f2fs_write_cache_pages fs/f2fs/data.c:3133 [inline]n __f2fs_write_data_pages fs/f2fs/data.c:3288 [inline]n f2fs_write_data_pages+0x1efe/0x3a90 fs/f2fs/data.c:3315n do_writepages+0x35b/0x870 mm/page-writeback.c:2612n __writeback_single_inode+0x165/0x10b0 fs/fs-writeback.c:1650n writeback_sb_inodes+0x905/0x1260 fs/fs-writeback.c:1941n wb_writeback+0x457/0xce0 fs/fs-writeback.c:2117n wb_do_writeback fs/fs-writeback.c:2264 [inline]n wb_workfn+0x410/0x1090 fs/fs-writeback.c:2304n process_one_work kernel/workqueue.c:3254 [inline]n process_scheduled_works+0xa12/0x17c0 kernel/workqueue.c:3335n worker_thread+0x86d/0xd70 kernel/workqueue.c:3416n kthread+0x2f2/0x390 kernel/kthread.c:388n ret_from_fork+0x4d/0x80 arch/x86/kernel/process.c:147n ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244nnThe root cause is: inline_data inode can be fuzzed so that there maynbe valid blkaddr in its direct node once f2fs triggers background GCnto migrate the block it will hit f2fs_bug_on() during dirty pagenwriteback.nnLet's add sanity check on F2FS_INLINE_DATA flag in inode during GCnso that it can forbid migrating inline_data inode's data block fornfixing.,CVE-2024-44942,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnparisc: fix a possible DMA corruptionnnARCH_DMA_MINALIGN was defined as 16 - this is too small - it may benpossible that two unrelated 16-byte allocations share a cache line. Ifnone of these allocations is written using DMA and the other is writtennusing cached write the value that was written with DMA may bencorrupted.nnThis commit changes ARCH_DMA_MINALIGN to be 128 on PA20 and 32 on PA1.1 -nthat's the largest possible cache line size.nnAs different parisc microarchitectures have different cache line size wendefine arch_slab_minalign() cache_line_size() andndma_get_cache_alignment() so that the kernel may tune slab cachenparameters dynamically based on the detected cache line size.,CVE-2024-44949,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnserial: sc16is7xx: fix invalid FIFO access with special register setnnWhen enabling access to the special register set Receiver time-out andnRHR interrupts can happen. In this case the IRQ handler will try to readnfrom the FIFO thru the RHR register at address 0x00 but address 0x00 isnmapped to DLL register resulting in erroneous FIFO reading.nnCall graph example:n sc16is7xx_startup(): entryn sc16is7xx_ms_proc(): entryn sc16is7xx_set_termios(): entryn sc16is7xx_set_baud(): DLH/DLL = $009C --> access special register setn sc16is7xx_port_irq() entry --> IIR is 0x0Cn sc16is7xx_handle_rx() entryn sc16is7xx_fifo_read(): --> unable to access FIFO (RHR) because it isn mapped to DLL (LCR=LCR_CONF_MODE_A)n sc16is7xx_set_baud(): exit --> Restore access to general register setnnFix the problem by claiming the efr_lock mutex when accessing the Specialnregister set.,CVE-2024-44950,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Don't refer to dc_sink in is_dsc_need_re_computenn[Why]nWhen unplug one of monitors connected after mst hub encounter null pointer dereference.nnIt's due to dc_sink get released immediately in early_unregister() or detect_ctx(). Whenncommit new state which directly referring to info stored in dc_sink will cause null pointerndereference.nn[how]nRemove redundant checking condition. Relevant condition should already be covered by checkingnif dsc_aux is null or not. Also reset dsc_aux to NULL when the connector is disconnected.,CVE-2024-44955,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnxen: privcmd: Switch from mutex to spinlock for irqfdsnnirqfd_wakeup() gets EPOLLHUP when it is called byneventfd_release() by way of wake_up_poll(&ctx->wqh EPOLLHUP) whichngets called under spin_lock_irqsave(). We can't use a mutex here as itnwill lead to a deadlock.nnFix it by switching over to a spin lock.,CVE-2024-44957,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnsched/smt: Fix unbalance sched_smt_present dec/incnnI got the following warn report while doing stress test:nnjump label: negative count!nWARNING: CPU: 3 PID: 38 at kernel/jump_label.c:263 static_key_slow_try_dec+0x9d/0xb0nCall Trace:n <TASK>n __static_key_slow_dec_cpuslocked+0x16/0x70n sched_cpu_deactivate+0x26e/0x2a0n cpuhp_invoke_callback+0x3ad/0x10d0n cpuhp_thread_fun+0x3f5/0x680n smpboot_thread_fn+0x56d/0x8d0n kthread+0x309/0x400n ret_from_fork+0x41/0x70n ret_from_fork_asm+0x1b/0x30n </TASK>nnBecause when cpuset_cpu_inactive() fails in sched_cpu_deactivate()nthe cpu offline failed but sched_smt_present is decremented beforencalling sched_cpu_deactivate() it leads to unbalanced dec/inc sonfix it by incrementing sched_smt_present in the error path.,CVE-2024-44958,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amdgpu: Forward soft recovery errors to userspacennAs we discussed before[1] soft recovery should benforwarded to userspace or we can get into a reallynbad state where apps will keep submitting hangingncommand buffers cascading us to a hard reset.nn1: https://lore.kernel.org/all/bf23d5ed-9a6b-43e7-84ee-8cbfd0d60f18@froggi.es/n(cherry picked from commit 434967aadbbbe3ad9103cc29e9a327de20fdba01),CVE-2024-44961,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbtrfs: do not BUG_ON() when freeing tree block after errornnWhen freeing a tree block at btrfs_free_tree_block() if we fail toncreate a delayed reference we don't deal with the error and just do anBUG_ON(). The error most likely to happen is -ENOMEM and we have ancomment mentioning that only -ENOMEM can happen but that is not truenbecause in case qgroups are enabled any error returned fromnbtrfs_qgroup_trace_extent_post() (can be -EUCLEAN or anything returnednfrom btrfs_search_slot() for example) can be propagated back tonbtrfs_free_tree_block().nnSo stop doing a BUG_ON() and return the error to the callers and makenthem abort the transaction to prevent leaking space. Syzbot wasntriggering this likely due to memory allocation failure injection.,CVE-2024-44963,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nns390/sclp: Prevent release of buffer in I/OnnWhen a task waiting for completion of a Store Data operation isninterrupted an attempt is made to halt this operation. If this attemptnfails due to a hardware or firmware problem there is a chance that thenSCLP facility might store data into buffers referenced by the originalnoperation at a later time.nnHandle this situation by not releasing the referenced data buffers ifnthe halt attempt fails. For current use cases this might result in anleak of few pages of memory in case of a rare hardware/firmwarenmalfunction.,CVE-2024-44969,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet/mlx5e: SHAMPO Fix invalid WQ linked list unlinknnWhen all the strides in a WQE have been consumed the WQE is unlinkednfrom the WQ linked list (mlx5_wq_ll_pop()). For SHAMPO it is possiblento receive CQEs with 0 consumed strides for the same WQE even after thenWQE is fully consumed and unlinked. This triggers an additional unlinknfor the same wqe which corrupts the linked list.nnFix this scenario by accepting 0 sized consumed strides withoutnunlinking the WQE again.,CVE-2024-44970,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbtrfs: do not clear page dirty inside extent_write_locked_range()nn[BUG]nFor subpage + zoned case the following workload can lead to rsv datanleak at unmount time:nn # mkfs.btrfs -f -s 4k $devn # mount $dev $mntn # fsstress -w -n 8 -d $mnt -s 1709539240n 0/0: fiemap - no filenamen 0/1: copyrange read - no filenamen 0/2: write - no filenamen 0/3: rename - no source filenamen 0/4: creat f0 x:0 0 0n 0/4: creat add id=0parent=-1n 0/5: writev f0[259 1 0 0 0 0] [778052113965] 0n 0/6: ioctl(FIEMAP) f0[259 1 0 0 224 887097] [129422022916183439914847910x10000] -1n 0/7: dwrite - xfsctl(XFS_IOC_DIOINFO) f0[259 1 0 0 224 887097] return 25 fallback to stat()n 0/7: dwrite f0[259 1 0 0 224 887097] [696320102400] 0n # umount $mntnnThe dmesg includes the following rsv leak detection warning (all callntrace skipped):nn ------------[ cut here ]------------n WARNING: CPU: 2 PID: 4528 at fs/btrfs/inode.c:8653 btrfs_destroy_inode+0x1e0/0x200 [btrfs]n ---[ end trace 0000000000000000 ]---n ------------[ cut here ]------------n WARNING: CPU: 2 PID: 4528 at fs/btrfs/inode.c:8654 btrfs_destroy_inode+0x1a8/0x200 [btrfs]n ---[ end trace 0000000000000000 ]---n ------------[ cut here ]------------n WARNING: CPU: 2 PID: 4528 at fs/btrfs/inode.c:8660 btrfs_destroy_inode+0x1a0/0x200 [btrfs]n ---[ end trace 0000000000000000 ]---n BTRFS info (device sda): last unmount of filesystem 1b4abba9-de34-4f07-9e7f-157cf12a18d6n ------------[ cut here ]------------n WARNING: CPU: 3 PID: 4528 at fs/btrfs/block-group.c:4434 btrfs_free_block_groups+0x338/0x500 [btrfs]n ---[ end trace 0000000000000000 ]---n BTRFS info (device sda): space_info DATA has 268218368 free is not fulln BTRFS info (device sda): space_info total=268435456 used=204800 pinned=0 reserved=0 may_use=12288 readonly=0 zone_unusable=0n BTRFS info (device sda): global_block_rsv: size 0 reserved 0n BTRFS info (device sda): trans_block_rsv: size 0 reserved 0n BTRFS info (device sda): chunk_block_rsv: size 0 reserved 0n BTRFS info (device sda): delayed_block_rsv: size 0 reserved 0n BTRFS info (device sda): delayed_refs_rsv: size 0 reserved 0n ------------[ cut here ]------------n WARNING: CPU: 3 PID: 4528 at fs/btrfs/block-group.c:4434 btrfs_free_block_groups+0x338/0x500 [btrfs]n ---[ end trace 0000000000000000 ]---n BTRFS info (device sda): space_info METADATA has 267796480 free is not fulln BTRFS info (device sda): space_info total=268435456 used=131072 pinned=0 reserved=0 may_use=262144 readonly=0 zone_unusable=245760n BTRFS info (device sda): global_block_rsv: size 0 reserved 0n BTRFS info (device sda): trans_block_rsv: size 0 reserved 0n BTRFS info (device sda): chunk_block_rsv: size 0 reserved 0n BTRFS info (device sda): delayed_block_rsv: size 0 reserved 0n BTRFS info (device sda): delayed_refs_rsv: size 0 reserved 0nnAbove $dev is a tcmu-runner emulated zoned HDD which has a max zonenappend size of 64K and the system has 64K page size.nn[CAUSE]nI have added several trace_printk() to show the events (header skipped):nn > btrfs_dirty_pages: r/i=5/259 dirty start=774144 len=114688n > btrfs_dirty_pages: r/i=5/259 dirty part of page=720896 off_in_page=53248 len_in_page=12288n > btrfs_dirty_pages: r/i=5/259 dirty part of page=786432 off_in_page=0 len_in_page=65536n > btrfs_dirty_pages: r/i=5/259 dirty part of page=851968 off_in_page=0 len_in_page=36864nnThe above lines show our buffered write has dirtied 3 pages of inoden259 of root 5:nn 704K 768K 832K 896Kn I |////I/////////////////I///////////| In 756K 868Knn |///| is the dirtied range using subpage bitmaps. and 'I' is the pagen boundary.nn Meanwhile all three pages (704K 768K 832K) have their PageDirtyn flag set.nn > btrfs_direct_write: r/i=5/259 start dio filepos=696320 len=102400nnThen direct IO writn---truncated---,CVE-2024-44972,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amdgpu: Validate TA binary sizennAdd TA binary size validation to avoid OOB write.nn(cherry picked from commit c0a04e3570d72aaf090962156ad085e37c62e442),CVE-2024-44977,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/msm/dpu: cleanup FB if dpu_format_populate_layout failsnnIf the dpu_format_populate_layout() fails then FB is prepared but notncleaned up. This ends up leaking the pin_count on the GEM object andncauses a splat during DRM file closure:nnmsm_obj->pin_countnWARNING: CPU: 2 PID: 569 at drivers/gpu/drm/msm/msm_gem.c:121 update_lru_locked+0xc4/0xccn[...]nCall trace:n update_lru_locked+0xc4/0xccn put_pages+0xac/0x100n msm_gem_free_object+0x138/0x180n drm_gem_object_free+0x1c/0x30n drm_gem_object_handle_put_unlocked+0x108/0x10cn drm_gem_object_release_handle+0x58/0x70n idr_for_each+0x68/0xecn drm_gem_release+0x28/0x40n drm_file_free+0x174/0x234n drm_release+0xb0/0x160n __fput+0xc0/0x2c8n __fput_sync+0x50/0x5cn __arm64_sys_close+0x38/0x7cn invoke_syscall+0x48/0x118n el0_svc_common.constprop.0+0x40/0xe0n do_el0_svc+0x1c/0x28n el0_svc+0x4c/0x120n el0t_64_sync_handler+0x100/0x12cn el0t_64_sync+0x190/0x194nirq event stamp: 129818nhardirqs last enabled at (129817): [<ffffa5f6d953fcc0>] console_unlock+0x118/0x124nhardirqs last disabled at (129818): [<ffffa5f6da7dcf04>] el1_dbg+0x24/0x8cnsoftirqs last enabled at (129808): [<ffffa5f6d94afc18>] handle_softirqs+0x4c8/0x4e8nsoftirqs last disabled at (129785): [<ffffa5f6d94105e4>] __do_softirq+0x14/0x20nnPatchwork: https://patchwork.freedesktop.org/patch/600714/,CVE-2024-44982,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnipv6: fix possible UAF in ip6_finish_output2()nnIf skb_expand_head() returns NULL skb has been freednand associated dst/idev could also have been freed.nnWe need to hold rcu_read_lock() to make sure the dst andnassociated idev are alive.,CVE-2024-44986,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnchar: xillybus: Don't destroy workqueue from work item running on itnnTriggered by a kref decrement destroy_workqueue() may be called fromnwithin a work item for destroying its own workqueue. This illegalnsituation is averted by adding a module-global workqueue for exclusivenuse of the offending work item. Other work items continue to be queuednon per-device workqueues to ensure performance.,CVE-2024-45007,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnmptcp: pm: only decrement add_addr_accepted for MPJ reqnnAdding the following warning ...nn WARN_ON_ONCE(msk->pm.add_addr_accepted == 0)nn... before decrementing the add_addr_accepted counter helped to find anbug when running the remove single subflow subtest from thenmptcp_join.sh selftest.nnRemoving a 'subflow' endpoint will first trigger a RM_ADDR then thensubflow closure. Before this patch and upon the reception of thenRM_ADDR the other peer will then try to decrement thisnadd_addr_accepted. That's not correct because the attached subflows havennot been created upon the reception of an ADD_ADDR.nnA way to solve that is to decrement the counter only if the attachednsubflow was an MP_JOIN to a remote id that was not 0 and initiated bynthe host receiving the RM_ADDR.,CVE-2024-45009,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/msm/dpu: move dpu_encoder's connector assignment to atomic_enable()nnFor cases where the crtc's connectors_changed was set without enable/activengetting toggled  there is an atomic_enable() call followed by annatomic_disable() but without an atomic_mode_set().nnThis results in a NULL ptr access for the dpu_encoder_get_drm_fmt() call innthe atomic_enable() as the dpu_encoder's connector was cleared in thenatomic_disable() but not re-assigned as there was no atomic_mode_set() call.nnFix the NULL ptr access by moving the assignment for atomic_enable() and alsonuse drm_atomic_get_new_connector_for_encoder() to get the connector fromnthe atomic_state.nnPatchwork: https://patchwork.freedesktop.org/patch/606729/,CVE-2024-45015,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nns390/dasd: fix error recovery leading to data corruption on ESE devicesnnExtent Space Efficient (ESE) or thin provisioned volumes need to benformatted on demand during usual IO processing.nnThe dasd_ese_needs_format function checks for error codes that signalnthe non existence of a proper track format.nnThe check for incorrect length is to imprecise since other error casesnleading to transport of insufficient data also have this flag set.nThis might lead to data corruption in certain error cases for examplenduring a storage server warmstart.nnFix by removing the check for incorrect length and replacing bynexplicitly checking for invalid track format in transport mode.nnAlso remove the check for file protected since this is not a validnESE handling case.,CVE-2024-45026,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nni3c: mipi-i3c-hci: Mask ring interrupts before ring stop requestnnBus cleanup path in DMA mode may trigger a RING_OP_STAT interrupt whennthe ring is being stopped. Depending on timing between ring stop requestncompletion interrupt handler removal and code execution this may leadnto a NULL pointer dereference in hci_dma_irq_handler() if it gets to runnafter the io_data pointer is set to NULL in hci_dma_cleanup().nnPrevent this my masking the ring interrupts before ring stop request.,CVE-2024-45828,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbonding: change ipsec_lock from spin lock to mutexnnIn the cited commit bond->ipsec_lock is added to protect ipsec_listnhence xdo_dev_state_add and xdo_dev_state_delete are called insidenthis lock. As ipsec_lock is a spin lock and such xfrmdev ops may sleepnscheduling while atomic will be triggered when changing bond'snactive slave.nn[ 101.055189] BUG: scheduling while atomic: bash/902/0x00000200n[ 101.055726] Modules linked in:n[ 101.058211] CPU: 3 PID: 902 Comm: bash Not tainted 6.9.0-rc4+ #1n[ 101.058760] Hardware name:n[ 101.059434] Call Trace:n[ 101.059436] <TASK>n[ 101.060873] dump_stack_lvl+0x51/0x60n[ 101.061275] __schedule_bug+0x4e/0x60n[ 101.061682] __schedule+0x612/0x7c0n[ 101.062078] ? __mod_timer+0x25c/0x370n[ 101.062486] schedule+0x25/0xd0n[ 101.062845] schedule_timeout+0x77/0xf0n[ 101.063265] ? asm_common_interrupt+0x22/0x40n[ 101.063724] ? __bpf_trace_itimer_state+0x10/0x10n[ 101.064215] __wait_for_common+0x87/0x190n[ 101.064648] ? usleep_range_state+0x90/0x90n[ 101.065091] cmd_exec+0x437/0xb20 [mlx5_core]n[ 101.065569] mlx5_cmd_do+0x1e/0x40 [mlx5_core]n[ 101.066051] mlx5_cmd_exec+0x18/0x30 [mlx5_core]n[ 101.066552] mlx5_crypto_create_dek_key+0xea/0x120 [mlx5_core]n[ 101.067163] ? bonding_sysfs_store_option+0x4d/0x80 [bonding]n[ 101.067738] ? kmalloc_trace+0x4d/0x350n[ 101.068156] mlx5_ipsec_create_sa_ctx+0x33/0x100 [mlx5_core]n[ 101.068747] mlx5e_xfrm_add_state+0x47b/0xaa0 [mlx5_core]n[ 101.069312] bond_change_active_slave+0x392/0x900 [bonding]n[ 101.069868] bond_option_active_slave_set+0x1c2/0x240 [bonding]n[ 101.070454] __bond_opt_set+0xa6/0x430 [bonding]n[ 101.070935] __bond_opt_set_notify+0x2f/0x90 [bonding]n[ 101.071453] bond_opt_tryset_rtnl+0x72/0xb0 [bonding]n[ 101.071965] bonding_sysfs_store_option+0x4d/0x80 [bonding]n[ 101.072567] kernfs_fop_write_iter+0x10c/0x1a0n[ 101.073033] vfs_write+0x2d8/0x400n[ 101.073416] ? alloc_fd+0x48/0x180n[ 101.073798] ksys_write+0x5f/0xe0n[ 101.074175] do_syscall_64+0x52/0x110n[ 101.074576] entry_SYSCALL_64_after_hwframe+0x4b/0x53nnAs bond_ipsec_add_sa_all and bond_ipsec_del_sa_all are only callednfrom bond_change_active_slave which requires holding the RTNL lock.nAnd bond_ipsec_add_sa and bond_ipsec_del_sa are xfrm statenxdo_dev_state_add and xdo_dev_state_delete APIs which are in userncontext. So ipsec_lock doesn't have to be spin lock change it tonmutex and thus the above issue can be resolved.,CVE-2024-46678,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnpktgen: use cpus_read_lock() in pg_net_init()nnI have seen the WARN_ON(smp_processor_id() != cpu) firingnin pktgen_thread_worker() during tests.nnWe must use cpus_read_lock()/cpus_read_unlock()naround the for_each_online_cpu(cpu) loop.nnWhile we are at it use WARN_ON_ONCE() to avoid a possible syslog flood.,CVE-2024-46681,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndriver: iio: add missing checks on iio_info's callback accessnnSome callbacks from iio_info structure are accessed without any check sonif a driver doesn't implement them trying to access the correspondingnsysfs entries produce a kernel oops such as:nn[ 2203.527791] Unable to handle kernel NULL pointer dereference at virtual address 00000000 when executen[...]n[ 2203.783416] Call trace:n[ 2203.783429] iio_read_channel_info_avail from dev_attr_show+0x18/0x48n[ 2203.789807] dev_attr_show from sysfs_kf_seq_show+0x90/0x120n[ 2203.794181] sysfs_kf_seq_show from seq_read_iter+0xd0/0x4e4n[ 2203.798555] seq_read_iter from vfs_read+0x238/0x2a0n[ 2203.802236] vfs_read from ksys_read+0xa4/0xd4n[ 2203.805385] ksys_read from ret_fast_syscall+0x0/0x54n[ 2203.809135] Exception stack(0xe0badfa8 to 0xe0badff0)n[ 2203.812880] dfa0: 00000003 b6f10f80 00000003 b6eab000 00020000 00000000n[ 2203.819746] dfc0: 00000003 b6f10f80 7ff00000 00000003 00000003 00000000 00020000 00000000n[ 2203.826619] dfe0: b6e1bc88 bed80958 b6e1bc94 b6e1bcb0n[ 2203.830363] Code: bad PC valuen[ 2203.832695] ---[ end trace 0000000000000000 ]---,CVE-2024-46715,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndmaengine: altera-msgdma: properly free descriptor in msgdma_free_descriptornnRemove list_del call in msgdma_chan_desc_cleanup this should be the rolenof msgdma_free_descriptor. In consequence replace list_add_tail withnlist_move_tail in msgdma_free_descriptor.nnThis fixes the path:n msgdma_free_chan_resources -> msgdma_free_descriptors ->n msgdma_free_desc_list -> msgdma_free_descriptornnwhich does not correctly free the descriptors as first nodes were notnremoved from the list.,CVE-2024-46716,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet/mlx5e: SHAMPO Fix incorrect page releasennUnder the following conditions:n1) No skb created yetn2) header_size == 0 (no SHAMPO header)n3) header_index + 1 % MLX5E_SHAMPO_WQ_HEADER_PER_PAGE == 0 (this is then last page fragment of a SHAMPO header page)nna new skb is formed with a page that is NOT a SHAMPO header page (itnis a regular data page). Further down in the same functionn(mlx5e_handle_rx_cqe_mpwrq_shampo()) a SHAMPO header page fromnheader_index is released. This is wrong and it leads to SHAMPO headernpages being released more than once.,CVE-2024-46717,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amdgpu: fix dereference after null checknncheck the pointer hive before use.,CVE-2024-46720,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Ensure index calculation will not overflownn[WHY & HOW]nMake sure vmid0p72_idx vnom0p8_idx and vmax0p9_idx calculation willnnever overflow and exceess array size.nnThis fixes 3 OVERRUN and 1 INTEGER_OVERFLOW issues reported by Coverity.,CVE-2024-46726,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Add otg_master NULL check within resource_log_pipe_topology_updatenn[Why]nCoverity reports NULL_RETURN warning.nn[How]nAdd otg_master NULL check.,CVE-2024-46727,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Check index for aux_rd_interval before usingnnaux_rd_interval has size of 7 and should be checked.nnThis fixes 3 OVERRUN and 1 INTEGER_OVERFLOW issues reported by Coverity.,CVE-2024-46728,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Fix incorrect size calculation for loopnn[WHY]nfe_clk_en has size of 5 but sizeof(fe_clk_en) has byte size 20 which isnlager than the array size.nn[HOW]nDivide byte size 20 by its element size.nnThis fixes 2 OVERRUN issues reported by Coverity.,CVE-2024-46729,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Ensure array index tg_inst won't be -1nn[WHY & HOW]ntg_inst will be a negative if timing_generator_count equals 0 whichnshould be checked before used.nnThis fixes 2 OVERRUN issues reported by Coverity.,CVE-2024-46730,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Assign linear_pitch_alignment even for VMnn[Description]nAssign linear_pitch_alignment so we don't cause a divide by 0nerror in VM environments,CVE-2024-46732,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbtrfs: fix qgroup reserve leaks in cow_file_rangennIn the buffered write path the dirty page owns the qgroup reserve untilnit creates an ordered_extent.nnTherefore any errors that occur before the ordered_extent is creatednmust free that reservation or else the space is leaked. The fstestngeneric/475 exercises various IO error paths and is able to triggernerrors in cow_file_range where we fail to get to allocating the orderednextent. Note that because we scan_tyk_dockerimages.sh clear delalloc we are likely tonremove the inode from the delalloc list so the inodes/pages to not haveninvalidate/launder called on them in the commit abort path.nnThis results in failures at the unmount stage of the test that look like:nn BTRFS: error (device dm-8 state EA) in cleanup_transaction:2018: errno=-5 IO failuren BTRFS: error (device dm-8 state EA) in btrfs_replace_file_extents:2416: errno=-5 IO failuren BTRFS warning (device dm-8 state EA): qgroup 0/5 has unreleased space type 0 rsv 28672n ------------[ cut here ]------------n WARNING: CPU: 3 PID: 22588 at fs/btrfs/disk-io.c:4333 close_ctree+0x222/0x4d0 [btrfs]n Modules linked in: btrfs blake2b_generic libcrc32c xor zstd_compress raid6_pqn CPU: 3 PID: 22588 Comm: umount Kdump: loaded Tainted: G W 6.10.0-rc7-gab56fde445b8 #21n Hardware name: QEMU Standard PC (i440FX + PIIX 1996) BIOS Arch Linux 1.16.3-1-1 04/01/2014n RIP: 0010:close_ctree+0x222/0x4d0 [btrfs]n RSP: 0018:ffffb4465283be00 EFLAGS: 00010202n RAX: 0000000000000001 RBX: ffffa1a1818e1000 RCX: 0000000000000001n RDX: 0000000000000000 RSI: ffffb4465283bbe0 RDI: ffffa1a19374fcb8n RBP: ffffa1a1818e13c0 R08: 0000000100028b16 R09: 0000000000000000n R10: 0000000000000003 R11: 0000000000000003 R12: ffffa1a18ad7972cn R13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000000n FS: 00007f9168312b80(0000) GS:ffffa1a4afcc0000(0000) knlGS:0000000000000000n CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033n CR2: 00007f91683c9140 CR3: 000000010acaa000 CR4: 00000000000006f0n Call Trace:n <TASK>n ? close_ctree+0x222/0x4d0 [btrfs]n ? __warn.cold+0x8e/0xean ? close_ctree+0x222/0x4d0 [btrfs]n ? report_bug+0xff/0x140n ? handle_bug+0x3b/0x70n ? exc_invalid_op+0x17/0x70n ? asm_exc_invalid_op+0x1a/0x20n ? close_ctree+0x222/0x4d0 [btrfs]n generic_shutdown_super+0x70/0x160n kill_anon_super+0x11/0x40n btrfs_kill_super+0x11/0x20 [btrfs]n deactivate_locked_super+0x2e/0xa0n cleanup_mnt+0xb5/0x150n task_work_run+0x57/0x80n syscall_exit_to_user_mode+0x121/0x130n do_syscall_64+0xab/0x1a0n entry_SYSCALL_64_after_hwframe+0x77/0x7fn RIP: 0033:0x7f916847a887n ---[ end trace 0000000000000000 ]---n BTRFS error (device dm-8 state EA): qgroup reserved space leakednnCases 2 and 3 in the out_reserve path both pertain to this type of leaknand must free the reserved qgroup data. Because it is already an errornpath I opted not to handle the possible errors innbtrfs_free_qgroup_data.,CVE-2024-46733,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nncachefiles: Set the max subreq size for cache writes to MAX_RW_COUNTnnSet the maximum size of a subrequest that writes to cachefiles to benMAX_RW_COUNT so that we don't overrun the maximum write we can make to thenbacking filesystem.,CVE-2024-46748,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbtrfs: don't BUG_ON() when 0 reference count at btrfs_lookup_extent_info()nnInstead of doing a BUG_ON() handle the error by returning -EUCLEANnaborting the transaction and logging an error message.,CVE-2024-46751,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbtrfs: replace BUG_ON() with error handling at update_ref_for_cow()nnInstead of a BUG_ON() just return an error log an error message andnabort the transaction in case we find an extent buffer belonging to thenrelocation tree that doesn't have the full backref flag set. This isnunexpected and should never happen (save for bugs or a potential badnmemory).,CVE-2024-46752,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbtrfs: handle errors from btrfs_dec_ref() properlynnIn walk_up_proc() we BUG_ON(ret) from btrfs_dec_ref(). This isnincorrect we have proper error handling here return the error.,CVE-2024-46753,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbpf: Remove tst_run from lwt_seg6local_prog_ops.nnThe syzbot reported that the lwt_seg6 related BPF ops can be invokednvia bpf_test_run() without without entering input_action_end_bpf()nfirst.nnMartin KaFai Lau said that self test for BPF_PROG_TYPE_LWT_SEG6LOCALnprobably didn't work since it was introduced in commit 04d4b274e2an(ipv6: sr: Add seg6local action End.BPF). The reason is that thenper-CPU variable seg6_bpf_srh_states::srh is never assigned in the selfntest case but each BPF function expects it.nnRemove test_run for BPF_PROG_TYPE_LWT_SEG6LOCAL.,CVE-2024-46754,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnwifi: rtw88: usb: schedule rx work after everything is set upnnRight now it's possible to hit NULL pointer dereference innrtw_rx_fill_rx_status on hw object and/or its fields becauseninitialization routine can start getting USB replies beforenrtw_dev is fully setup.nnThe stack trace looks like this:nnrtw_rx_fill_rx_statusnrtw8821c_query_rx_descnrtw_usb_rx_handlern...nqueue_worknrtw_usb_read_port_completen...nusb_submit_urbnrtw_usb_rx_resubmitnrtw_usb_init_rxnrtw_usb_probennSo while we do the async stuff rtw_usb_probe continues and callsnrtw_register_hw which does all kinds of initialization (e.g.nvia ieee80211_register_hw) that rtw_rx_fill_rx_status relies on.nnFix this by moving the first usb_submit_urb after everythingnis set up.nnFor me this bug manifested as:n[ 8.893177] rtw_8821cu 1-1:1.2: band wrong packet droppedn[ 8.910904] rtw_8821cu 1-1:1.2: hw->conf.chandef.chan NULL in rtw_rx_fill_rx_statusnbecause I'm using Larry's backport of rtw88 driver with the NULLnchecks in rtw_rx_fill_rx_status.,CVE-2024-46760,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnpci/hotplug/pnv_php: Fix hotplug driver crash on PowernvnnThe hotplug driver for powerpc (pci/hotplug/pnv_php.c) causes a kernelncrash when we try to hot-unplug/disable the PCIe switch/bridge fromnthe PHB.nnThe crash occurs because although the MSI data structure has beennreleased during disable/hot-unplug path and it has been assignednwith NULL still during unregistration the code was again trying tonexplicitly disable the MSI which causes the NULL pointer dereference andnkernel crash.nnThe patch fixes the check during unregistration path to prevent invokingnpci_disable_msi/msix() since its data structure is already freed.,CVE-2024-46761,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnxen: privcmd: Fix possible access to a freed kirqfd instancennNothing prevents simultaneous ioctl calls to privcmd_irqfd_assign() andnprivcmd_irqfd_deassign(). If that happens it is possible that a kirqfdncreated and added to the irqfds_list by privcmd_irqfd_assign() may getnremoved by another thread executing privcmd_irqfd_deassign() while thenformer is still using it after dropping the locks.nnThis can lead to a situation where an already freed kirqfd instance maynbe accessed and cause kernel oops.nnUse SRCU locking to prevent the same as is done for the KVMnimplementation for irqfds.,CVE-2024-46762,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnice: protect XDP configuration with a mutexnnThe main threat to data consistency in ice_xdp() is a possible asynchronousnPF reset. It can be triggered by a user or by TX timeout handler.nnXDP setup and PF reset code access the same resources in the followingnsections:n* ice_vsi_close() in ice_prepare_for_reset() - already rtnl-lockedn* ice_vsi_rebuild() for the PF VSI - not protectedn* ice_vsi_open() - already rtnl-lockednnWith an unfortunate timing such accesses can result in a crash such as thenone below:nn[ +1.999878] ice 0000:b1:00.0: Registered XDP mem model MEM_TYPE_XSK_BUFF_POOL on Rx ring 14n[ +2.002992] ice 0000:b1:00.0: Registered XDP mem model MEM_TYPE_XSK_BUFF_POOL on Rx ring 18n[Mar15 18:17] ice 0000:b1:00.0 ens801f0np0: NETDEV WATCHDOG: CPU: 38: transmit queue 14 timed out 80692736 msn[ +0.000093] ice 0000:b1:00.0 ens801f0np0: tx_timeout: VSI_num: 6 Q 14 NTC: 0x0 HW_HEAD: 0x0 NTU: 0x0 INT: 0x4000001n[ +0.000012] ice 0000:b1:00.0 ens801f0np0: tx_timeout recovery level 1 txqueue 14n[ +0.394718] ice 0000:b1:00.0: PTP reset successfuln[ +0.006184] BUG: kernel NULL pointer dereference address: 0000000000000098n[ +0.000045] #PF: supervisor read access in kernel moden[ +0.000023] #PF: error_code(0x0000) - not-present pagen[ +0.000023] PGD 0 P4D 0n[ +0.000018] Oops: 0000 [#1] PREEMPT SMP NOPTIn[ +0.000023] CPU: 38 PID: 7540 Comm: kworker/38:1 Not tainted 6.8.0-rc7 #1n[ +0.000031] Hardware name: Intel Corporation S2600WFT/S2600WFT BIOS SE5C620.86B.02.01.0014.082620210524 08/26/2021n[ +0.000036] Workqueue: ice ice_service_task [ice]n[ +0.000183] RIP: 0010:ice_clean_tx_ring+0xa/0xd0 [ice]n[...]n[ +0.000013] Call Trace:n[ +0.000016] <TASK>n[ +0.000014] ? __die+0x1f/0x70n[ +0.000029] ? page_fault_oops+0x171/0x4f0n[ +0.000029] ? schedule+0x3b/0xd0n[ +0.000027] ? exc_page_fault+0x7b/0x180n[ +0.000022] ? asm_exc_page_fault+0x22/0x30n[ +0.000031] ? ice_clean_tx_ring+0xa/0xd0 [ice]n[ +0.000194] ice_free_tx_ring+0xe/0x60 [ice]n[ +0.000186] ice_destroy_xdp_rings+0x157/0x310 [ice]n[ +0.000151] ice_vsi_decfg+0x53/0xe0 [ice]n[ +0.000180] ice_vsi_rebuild+0x239/0x540 [ice]n[ +0.000186] ice_vsi_rebuild_by_type+0x76/0x180 [ice]n[ +0.000145] ice_rebuild+0x18c/0x840 [ice]n[ +0.000145] ? delay_tsc+0x4a/0xc0n[ +0.000022] ? delay_tsc+0x92/0xc0n[ +0.000020] ice_do_reset+0x140/0x180 [ice]n[ +0.000886] ice_service_task+0x404/0x1030 [ice]n[ +0.000824] process_one_work+0x171/0x340n[ +0.000685] worker_thread+0x277/0x3a0n[ +0.000675] ? preempt_count_add+0x6a/0xa0n[ +0.000677] ? _raw_spin_lock_irqsave+0x23/0x50n[ +0.000679] ? __pfx_worker_thread+0x10/0x10n[ +0.000653] kthread+0xf0/0x120n[ +0.000635] ? __pfx_kthread+0x10/0x10n[ +0.000616] ret_from_fork+0x2d/0x50n[ +0.000612] ? __pfx_kthread+0x10/0x10n[ +0.000604] ret_from_fork_asm+0x1b/0x30n[ +0.000604] </TASK>nnThe previous way of handling this through returning -EBUSY is not viablenparticularly when destroying AF_XDP socket because the kernel proceedsnwith removal anyway.nnThere is plenty of code between those calls and there is no need to createna large critical section that covers all of them same as there is no neednto protect ice_vsi_rebuild() with rtnl_lock().nnAdd xdp_state_lock mutex to protect ice_vsi_rebuild() and ice_xdp().nnLeaving unprotected sections in between would result in two states thatnhave to be considered:n1. when the VSI is closed but not yet rebuildn2. when VSI is already rebuild but not yet opennnThe latter case is actually already handled through !netif_running() casenwe just need to adjust flag checking a little. The former one is not asntrivial because between ice_vsi_close() and ice_vsi_rebuild() a lot ofnhardware interaction happens this can make adding/deleting rings exitnwith an error. Luckily VSI rebuild is pending and can apply newnconfiguration for us in a managed fashion.nnTherefore add an additional VSI state flag ICE_VSI_REBUILD_PENDING tonindicate that ice_xn---truncated---,CVE-2024-46765,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnice: Add netif_device_attach/detach into PF reset flownnEthtool callbacks can be executed while reset is in progress and try tonaccess deleted resources e.g. getting coalesce settings can result in anNULL pointer dereference seen below.nnReproduction steps:nOnce the driver is fully initialized trigger reset:nt# echo 1 > /sys/class/net/<interface>/device/resetnwhen reset is in progress try to get coalesce settings using ethtool:nt# ethtool -c <interface>nnBUG: kernel NULL pointer dereference address: 0000000000000020nPGD 0 P4D 0nOops: Oops: 0000 [#1] PREEMPT SMP PTInCPU: 11 PID: 19713 Comm: ethtool Tainted: G S 6.10.0-rc7+ #7nRIP: 0010:ice_get_q_coalesce+0x2e/0xa0 [ice]nRSP: 0018:ffffbab1e9bcf6a8 EFLAGS: 00010206nRAX: 000000000000000c RBX: ffff94512305b028 RCX: 0000000000000000nRDX: 0000000000000000 RSI: ffff9451c3f2e588 RDI: ffff9451c3f2e588nRBP: 0000000000000000 R08: 0000000000000000 R09: 0000000000000000nR10: ffff9451c3f2e580 R11: 000000000000001f R12: ffff945121fa9000nR13: ffffbab1e9bcf760 R14: 0000000000000013 R15: ffffffff9e65dd40nFS: 00007faee5fbe740(0000) GS:ffff94546fd80000(0000) knlGS:0000000000000000nCS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033nCR2: 0000000000000020 CR3: 0000000106c2e005 CR4: 00000000001706f0nCall Trace:n<TASK>nice_get_coalesce+0x17/0x30 [ice]ncoalesce_prepare_data+0x61/0x80nethnl_default_doit+0xde/0x340ngenl_family_rcv_msg_doit+0xf2/0x150ngenl_rcv_msg+0x1b3/0x2c0nnetlink_rcv_skb+0x5b/0x110ngenl_rcv+0x28/0x40nnetlink_unicast+0x19c/0x290nnetlink_sendmsg+0x222/0x490n__sys_sendto+0x1df/0x1f0n__x64_sys_sendto+0x24/0x30ndo_syscall_64+0x82/0x160nentry_SYSCALL_64_after_hwframe+0x76/0x7enRIP: 0033:0x7faee60d8e27nnCalling netif_device_detach() before reset makes the net core not callnthe driver when ethtool command is issued the attempt to execute annethtool command during reset will result in the following message:nn netlink error: No such devicenninstead of NULL pointer dereference. Once reset is done andnice_rebuild() is executing the netif_device_attach() is called to allownfor ethtool operations to occur again in a safe manner.,CVE-2024-46770,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Check denominator crb_pipes before usednn[WHAT & HOW]nA denominator cannot be 0 and is checked before used.nnThis fixes 2 DIVIDE_BY_ZERO issues reported by Coverity.,CVE-2024-46772,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Check denominator pbn_div before usednn[WHAT & HOW]nA denominator cannot be 0 and is checked before used.nnThis fixes 1 DIVIDE_BY_ZERO issue reported by Coverity.,CVE-2024-46773,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnpowerpc/rtas: Prevent Spectre v1 gadget construction in sys_rtas()nnSmatch warns:nn arch/powerpc/kernel/rtas.c:1932 __do_sys_rtas() warn: potentialn spectre issue 'args.args' [r] (local cap)nnThe 'nargs' and 'nret' locals come directly from a user-suppliednbuffer and are used as indexes into a small stack-based array and asninputs to copy_to_user() after they are subject to bounds checks.nnUse array_index_nospec() after the bounds checks to clamp these valuesnfor speculative execution.,CVE-2024-46774,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Validate function returnsnn[WHAT & HOW]nFunction return values must be checked before data can be usednin subsequent functions.nnThis fixes 4 CHECKED_RETURN issues reported by Coverity.,CVE-2024-46775,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Run DC_LOG_DC after checking link->link_encnn[WHAT]nThe DC_LOG_DC should be run after link->link_enc is checked not before.nnThis fixes 1 REVERSE_INULL issue reported by Coverity.,CVE-2024-46776,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnuserfaultfd: fix checks for huge PMDsnnPatch series userfaultfd: fix races around pmd_trans_huge() check v2.nnThe pmd_trans_huge() code in mfill_atomic() is wrong in three differentnways depending on kernel version:nn1. The pmd_trans_huge() check is racy and can lead to a BUG_ON() (if you hitn the right two race windows) - I've tested this in a kernel build withn some extra mdelay() calls. See the commit message for a descriptionn of the race scenario.n On older kernels (before 6.5) I think the same bug can evenn theoretically lead to accessing transhuge page contents as a page tablen if you hit the right 5 narrow race windows (I haven't tested this case).n2. As pointed out by Qi Zheng pmd_trans_huge() is not sufficient forn detecting PMDs that don't point to page tables.n On older kernels (before 6.5) you'd just have to win a single fairlyn wide race to hit this.n I've tested this on 6.1 stable by racing migration (with a mdelay()n patched into try_to_migrate()) against UFFDIO_ZEROPAGE - on my x86n VM that causes a kernel oops in ptlock_ptr().n3. On newer kernels (>=6.5) for shmem mappings khugepaged is allowedn to yank page tables out from under us (though I haven't tested that)n so I think the BUG_ON() checks in mfill_atomic() are just wrong.nnI decided to write two separate fixes for these (one fix for bugs 1+2 onenfix for bug 3) so that the first fix can be backported to kernelsnaffected by bugs 1+2.nnnThis patch (of 2):nnThis fixes two issues.nnI discovered that the following race can occur:nn mfill_atomic other threadn ============ ============n <zap PMD>n pmdp_get_lockless() [reads none pmd]n <bail if trans_huge>n <if none:>n <pagefault creates transhuge zeropage>n __pte_alloc [no-op]n <zap PMD>n <bail if pmd_trans_huge(*dst_pmd)>n BUG_ON(pmd_none(*dst_pmd))nnI have experimentally verified this in a kernel with extra mdelay() calls;nthe BUG_ON(pmd_none(*dst_pmd)) triggers.nnOn kernels newer than commit 0d940a9b270b (mm/pgtable: allownpte_offset_map[_lock]() to fail) this can't lead to anything worse thanna BUG_ON() since the page table access helpers are actually designed tondeal with page tables concurrently disappearing; but on older kernelsn(<=6.4) I think we could probably theoretically race past the twonBUG_ON() checks and end up treating a hugepage as a page table.nnThe second issue is that as Qi Zheng pointed out there are other typesnof huge PMDs that pmd_trans_huge() can't catch: devmap PMDs and swap PMDsn(in particular migration PMDs).nnOn <=6.4 this is worse than the first issue: If mfill_atomic() runs on anPMD that contains a migration entry (which just requires winning a singlenfairly wide race) it will pass the PMD to pte_offset_map_lock() whichnassumes that the PMD points to a page table.nnBreakage follows: First the kernel tries to take the PTE lock (which willncrash or maybe worse if there is no struct page for the address bits innthe migration entry PMD - I think at least on X86 there usually is noncorresponding struct page thanks to the PTE inversion mitigation amd64nlooks different).nnIf that didn't crash the kernel would next try to write a PTE into whatnit wrongly thinks is a page table.nnAs part of fixing these issues get rid of the check for pmd_trans_huge()nbefore __pte_alloc() - that's redundant we're going to have to check fornthat after the __pte_alloc() anyway.nnBackport note: pmdp_get_lockless() is pmd_read_atomic() in older kernels.,CVE-2024-46787,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: added NULL check at start of dc_validate_streamnn[Why]nprevent invalid memory accessnn[How]ncheck if dc and stream are NULL,CVE-2024-46802,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amdkfd: Check debug trap enable before write dbg_ev_filennIn interrupt context write dbg_ev_file will be run by work queue. Itnwill cause write dbg_ev_file execution after debug_trap_disable whichnwill cause NULL pointer access.nv2: cancel work debug_event_workarea before set dbg_ev_file as NULL.,CVE-2024-46803,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amdgpu: fix the waring dereferencing hivennCheck the amdgpu_hive_info *hive that maybe is NULL.,CVE-2024-46805,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amdgpu: Fix the warning division or modulo by zeronnChecks the partition mode and returns an error for an invalid mode.,CVE-2024-46806,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/amdgpu: Check tbo resource pointernnValidate tbo resource pointer skip if NULL,CVE-2024-46807,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Add missing NULL pointer check within dpcd_extend_address_rangenn[Why & How]nASSERT if return NULL from kcalloc.,CVE-2024-46808,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/bridge: tc358767: Check if fully initialized before signalling HPD event via IRQnnMake sure the connector is fully initialized before signalling anynHPD events via drm_kms_helper_hotplug_event() otherwise this maynlead to NULL pointer dereference.,CVE-2024-46810,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Fix index may exceed array range within fpu_update_bw_bounding_boxnn[Why]nCoverity reports OVERRUN warning. soc.num_states couldnbe 40. But array range of bw_params->clk_table.entries is 8.nn[How]nAssert if soc.num_states greater than 8.,CVE-2024-46811,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Skip inactive planes within ModeSupportAndSystemConfigurationnn[Why]nCoverity reports Memory - illegal accesses.nn[How]nSkip inactive planes.,CVE-2024-46812,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Check link_index before accessing dc->links[]nn[WHY & HOW]ndc->links[] has max size of MAX_LINKS and NULL is return when trying tonaccess with out-of-bound index.nnThis fixes 3 OVERRUN and 1 RESOURCE_LEAK issues reported by Coverity.,CVE-2024-46813,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Stop amdgpu_dm initialize when link nums greater than max_linksnn[Why]nCoverity report OVERRUN warning. There arenonly max_links elements within dc->links. linkncount could up to AMDGPU_DM_MAX_DISPLAY_INDEX 31.nn[How]nMake sure link count less than max_links.,CVE-2024-46816,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/pm: Fix negative array index readnnAvoid using the negative valuesnfor clk_idex as an index into an array pptable->DpmDescriptor.nnV2: fix clk_index return check (Tim Huang),CVE-2024-46821,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnkunit/overflow: Fix UB in overflow_allocation_testnnThe 'device_name' array doesn't exist out of then'overflow_allocation_test' function scope. However it is being used asna driver name when calling 'kunit_driver_create' fromn'kunit_device_register'. It produces the kernel panic with KASANnenabled.nnSince this variable is used in one place only remove it and pass thendevice name into kunit_device_register directly as an ascii string.,CVE-2024-46823,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnwifi: iwlwifi: mvm: use IWL_FW_CHECK for link ID checknnThe lookup function iwl_mvm_rcu_fw_link_id_to_link_conf() isnnormally called with input from the firmware so it should usenIWL_FW_CHECK() instead of WARN_ON().,CVE-2024-46825,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnELF: fix kernel.randomize_va_space double readnnELF loader uses randomize_va_space twice. It is sysctl and can changenat any moment so 2 loads could see 2 different values in theory withnunpredictable consequences.nnIssue exactly one load for consistent value across one exec.,CVE-2024-46826,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnKVM: x86: Acquire kvm->srcu when handling KVM_SET_VCPU_EVENTSnnGrab kvm->srcu when processing KVM_SET_VCPU_EVENTS as KVM will forciblynleave nested VMX/SVM if SMM mode is being toggled and leaving nested VMXnreads guest memory.nnNote kvm_vcpu_ioctl_x86_set_vcpu_events() can also be called from KVM_RUNnvia sync_regs() which already holds SRCU. I.e. trying to precisely usenkvm_vcpu_srcu_read_lock() around the problematic SMM code would causenproblems. Acquiring SRCU isn't all that expensive so for simplicityngrab it unconditionally for KVM_SET_VCPU_EVENTS.nn =============================n WARNING: suspicious RCU usagen 6.10.0-rc7-332d2c1d713e-next-vm #552 Not taintedn -----------------------------n include/linux/kvm_host.h:1027 suspicious rcu_dereference_check() usage!nn other info that might help us debug this:nn rcu_scheduler_active = 2 debug_locks = 1n 1 lock held by repro/1071:n #0: ffff88811e424430 (&vcpu->mutex){+.+.}-{3:3} at: kvm_vcpu_ioctl+0x7d/0x970 [kvm]nn stack backtrace:n CPU: 15 PID: 1071 Comm: repro Not tainted 6.10.0-rc7-332d2c1d713e-next-vm #552n Hardware name: QEMU Standard PC (Q35 + ICH9 2009) BIOS 0.0.0 02/06/2015n Call Trace:n <TASK>n dump_stack_lvl+0x7f/0x90n lockdep_rcu_suspicious+0x13f/0x1a0n kvm_vcpu_gfn_to_memslot+0x168/0x190 [kvm]n kvm_vcpu_read_guest+0x3e/0x90 [kvm]n nested_vmx_load_msr+0x6b/0x1d0 [kvm_intel]n load_vmcs12_host_state+0x432/0xb40 [kvm_intel]n vmx_leave_nested+0x30/0x40 [kvm_intel]n kvm_vcpu_ioctl_x86_set_vcpu_events+0x15d/0x2b0 [kvm]n kvm_arch_vcpu_ioctl+0x1107/0x1750 [kvm]n ? mark_held_locks+0x49/0x70n ? kvm_vcpu_ioctl+0x7d/0x970 [kvm]n ? kvm_vcpu_ioctl+0x497/0x970 [kvm]n kvm_vcpu_ioctl+0x497/0x970 [kvm]n ? lock_acquire+0xba/0x2d0n ? find_held_lock+0x2b/0x80n ? do_user_addr_fault+0x40c/0x6f0n ? lock_release+0xb7/0x270n __x64_sys_ioctl+0x82/0xb0n do_syscall_64+0x6c/0x170n entry_SYSCALL_64_after_hwframe+0x4b/0x53n RIP: 0033:0x7ff11eb1b539n </TASK>,CVE-2024-46830,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnMIPS: cevt-r4k: Don't call get_c0_compare_int if timer irq is installednnThis avoids warning:nn[ 0.118053] BUG: sleeping function called from invalid context at kernel/locking/mutex.c:283nnCaused by get_c0_compare_int on secondary CPU.nnWe also skipped saving IRQ number to struct clock_event_device *cd asnit's never used by clockevent core as per comments it's only meantnfor non CPU local devices.,CVE-2024-46832,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnethtool: fail closed if we can't get max channel used in indirection tablesnnCommit 0d1b7d6c9274 (bnxt: fix crashes when reducing ring count withnactive RSS contexts) proves that allowing indirection table to containnchannels with out of bounds IDs may lead to crashes. Currently thenmax channel check in the core gets skipped if driver can't fetchnthe indirection table or when we can't allocate memory.nnBoth of those conditions should be extremely rare but if they donhappen we should try to be safe and fail the channel change.,CVE-2024-46834,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnscsi: lpfc: Handle mailbox timeouts in lpfc_get_sfp_infonnThe MBX_TIMEOUT return code is not handled in lpfc_get_sfp_info and thenroutine unconditionally frees submitted mailbox commands regardless ofnreturn status. The issue is that for MBX_TIMEOUT cases when firmwarenreturns SFP information at a later time that same mailbox memory regionnreferences previously freed memory in its cmpl routine.nnFix by adding checks for the MBX_TIMEOUT return code. During mailboxnresource cleanup check the mbox flag to make sure that the wait did notntimeout. If the MBOX_WAKE flag is not set then do not free the resourcesnbecause it will be freed when firmware completes the mailbox at a laterntime in its cmpl routine.nnAlso increase the timeout from 30 to 60 seconds to accommodate bootnscripts requiring longer timeouts.,CVE-2024-46842,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnscsi: ufs: core: Remove SCSI host only if addednnIf host tries to remove ufshcd driver from a UFS device it would cause ankernel panic if ufshcd_async_scan fails during ufshcd_probe_hba beforenadding a SCSI host with scsi_add_host and MCQ is enabled since SCSI hostnhas been defered after MCQ configuration introduced by commit 0cab4023ec7bn(scsi: ufs: core: Defer adding host to SCSI if MCQ is supported).nnTo guarantee that SCSI host is removed only if it has been added set thenscsi_host_added flag to true after adding a SCSI host and check whether itnis set or not before removing it.,CVE-2024-46843,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnperf/x86/intel: Limit the period on HaswellnnRunning the ltp test cve-2015-3290 concurrently reports the followingnwarnings.nnperfevents: irq loop stuck!n WARNING: CPU: 31 PID: 32438 at arch/x86/events/intel/core.c:3174n intel_pmu_handle_irq+0x285/0x370n Call Trace:n <NMI>n ? __warn+0xa4/0x220n ? intel_pmu_handle_irq+0x285/0x370n ? __report_bug+0x123/0x130n ? intel_pmu_handle_irq+0x285/0x370n ? __report_bug+0x123/0x130n ? intel_pmu_handle_irq+0x285/0x370n ? report_bug+0x3e/0xa0n ? handle_bug+0x3c/0x70n ? exc_invalid_op+0x18/0x50n ? asm_exc_invalid_op+0x1a/0x20n ? irq_work_claim+0x1e/0x40n ? intel_pmu_handle_irq+0x285/0x370n perf_event_nmi_handler+0x3d/0x60n nmi_handle+0x104/0x330nnThanks to Thomas Gleixner's analysis the issue is caused by the lowninitial period (1) of the frequency estimation algorithm which triggersnthe defects of the HW specifically erratum HSW11 and HSW143. (For thendetails please refer https://lore.kernel.org/lkml/87plq9l5d2.ffs@tglx/)nnThe HSW11 requires a period larger than 100 for the INST_RETIRED.ALLnevent but the initial period in the freq mode is 1. The erratum is thensame as the BDM11 which has been supported in the kernel. A minimumnperiod of 128 is enforced as well on HSW.nnHSW143 is regarding that the fixed counter 1 may overcount 32 with thenHyper-Threading is enabled. However based on the test the hardwarenhas more issues than it tells. Besides the fixed counter 1 the messagen'interrupt took too long' can be observed on any counter which was armednwith a period < 32 and two events expired in the same NMI. A minimumnperiod of 32 is enforced for the rest of the events.nThe recommended workaround code of the HSW143 is not implemented.nBecause it only addresses the issue for the fixed counter. It bringsnextra overhead through extra MSR writing. No related overcounting issuenhas been reported so far.,CVE-2024-46848,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnetfilter: nft_socket: fix sk refcount leaksnnWe must put 'sk' reference before returning.,CVE-2024-46855,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet/mlx5: Fix bridge mode operations when there are no VFsnnCurrently trying to set the bridge mode attribute when numvfs=0 leads to ancrash:nnbridge link set dev eth2 hwmode vepann[ 168.967392] BUG: kernel NULL pointer dereference address: 0000000000000030n[...]n[ 168.969989] RIP: 0010:mlx5_add_flow_rules+0x1f/0x300 [mlx5_core]n[...]n[ 168.976037] Call Trace:n[ 168.976188] <TASK>n[ 168.978620] _mlx5_eswitch_set_vepa_locked+0x113/0x230 [mlx5_core]n[ 168.979074] mlx5_eswitch_set_vepa+0x7f/0xa0 [mlx5_core]n[ 168.979471] rtnl_bridge_setlink+0xe9/0x1f0n[ 168.979714] rtnetlink_rcv_msg+0x159/0x400n[ 168.980451] netlink_rcv_skb+0x54/0x100n[ 168.980675] netlink_unicast+0x241/0x360n[ 168.980918] netlink_sendmsg+0x1f6/0x430n[ 168.981162] ____sys_sendmsg+0x3bb/0x3f0n[ 168.982155] ___sys_sendmsg+0x88/0xd0n[ 168.985036] __sys_sendmsg+0x59/0xa0n[ 168.985477] do_syscall_64+0x79/0x150n[ 168.987273] entry_SYSCALL_64_after_hwframe+0x76/0x7en[ 168.987773] RIP: 0033:0x7f8f7950f917nn(esw->fdb_table.legacy.vepa_fdb is null)nnThe bridge mode is only relevant when there are multiple functions pernport. Therefore prevent setting and getting this setting when there are nonVFs.nnNote that after this change there are no settings to change on the PFninterface using `bridge link` when there are no VFs so the interface nonlonger appears in the `bridge link` output.,CVE-2024-46857,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnplatform/x86: panasonic-laptop: Fix SINF array out of bounds accessesnnThe panasonic laptop code in various places uses the SINF array with indexnvalues of 0 - SINF_CUR_BRIGHT(0x0d) without checking that the SINF arraynis big enough.nnNot all panasonic laptops have this many SINF array entries for examplenthe Toughbook CF-18 model only has 10 SINF array entries. So it onlynsupports the AC+DC brightness entries and mute.nnCheck that the SINF array has a minimum size which covers all AC+DCnbrightness entries and refuse to load if the SINF array is smaller.nnFor higher SINF indexes hide the sysfs attributes when the SINF arrayndoes not contain an entry for that attribute avoiding show()/store()naccessing the array out of bounds and add bounds checking to the probe()nand resume() code accessing these.,CVE-2024-46859,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnwifi: mt76: mt7921: fix NULL pointer access in mt7921_ipv6_addr_changennWhen disabling wifi mt7921_ipv6_addr_change() is called as a notifier.nAt this point mvif->phy is already NULL so we cannot use it here.,CVE-2024-46860,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Disable DMCUB timeout for DCN35nn[Why]nDMCUB can intermittently take longer than expected to process commands.nnOld ASIC policy was to continue while logging a diagnostic error - whichnworks fine for ASIC without IPS but with IPS this could lead to a racencondition where we attempt to access DCN state while it's inaccessiblenleading to a system hang when the NIU port is not disabled or registernaccesses that timeout and the display configuration in an undefinednstate.nn[How]nWe need to investigate why these accesses take longer than expected butnfor now we should disable the timeout on DCN35 to avoid this racencondition. Since the waits happen only at lower interrupt levels thenrisk of taking too long at higher IRQ and causing a system watchdogntimeout are minimal.,CVE-2024-46870,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Correct the defined value for AMDGPU_DMUB_NOTIFICATION_MAXnn[Why & How]nIt actually exposes '6' types in enum dmub_notification_type. Not 5. Using smallernnumber to create array dmub_callback & dmub_thread_offload has potential to accessnitem out of array bound. Fix it.,CVE-2024-46871,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnpinmux: Use sequential access to access desc->pinmux datannWhen two client of the same gpio call pinctrl_select_state() for thensame functionality we are seeing NULL pointer issue while accessingndesc->mux_owner.nnLet's say two processes A B executing in pin_request() for the same pinnand process A updates the desc->mux_usecount but not yet updated thendesc->mux_owner while process B see the desc->mux_usecount which gotnupdated by A path and further executes strcmp and while accessingndesc->mux_owner it crashes with NULL pointer.nnSerialize the access to mux related setting with a mutex lock.nntcpu0 (process A)tttcpu1(process B)nnpinctrl_select_state() {tt pinctrl_select_state() {n pin_request() {ttttpin_request() {n ...ntttttt ....n } else {n desc->mux_usecount++;n ttttttdesc->mux_usecount && strcmp(desc->mux_owner owner)) {nn if (desc->mux_usecount > 1)n return 0;n desc->mux_owner = owner;nn }tttttt},CVE-2024-47141,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet/smc: check smcd_v2_ext_offset when receiving proposal msgnnWhen receiving proposal msg in server the field smcd_v2_ext_offset innproposal msg is from the remote client and can not be fully trusted.nOnce the value of smcd_v2_ext_offset exceed the max value there hasnthe chance to access wrong address and crash may happen.nnThis patch checks the value of smcd_v2_ext_offset before using it.,CVE-2024-47408,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nncrypto: stm32/cryp - call finalize with bh disablednnThe finalize operation in interrupt mode produce a produces a spinlocknrecursion warning. The reason is the fact that BH must be disablednduring this process.,CVE-2024-47658,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnsmack: tcp: ipv4 fix incorrect labelingnnCurrently Smack mirrors the label of incoming tcp/ipv4 connections:nwhen a label 'foo' connects to a label 'bar' with tcp/ipv4n'foo' always gets 'foo' in returned ipv4 packets. Son1) returned packets are incorrectly labeled ('foo' instead of 'bar')n2) 'bar' can write to 'foo' without being authorized to write.nnHere is a scenario how to see this:nn* Take two machines let's call them C and Sn with active Smack in the default staten (no settings no rules no labeled hosts only builtin labels)nn* At S add Smack rule 'foo bar w'n (labels 'foo' and 'bar' are instantiated at S at this moment)nn* At S at label 'bar' launch a programn that listens for incoming tcp/ipv4 connectionsnn* From C at label 'foo' connect to the listener at S.n (label 'foo' is instantiated at C at this moment)n Connection succeedes and works.nn* Send some data in both directions.n* Collect network traffic of this connection.nnAll packets in both directions are labeled with the CIPSOnof the label 'foo'. Hence label 'bar' writes to 'foo' withoutnbeing authorized and even without ever being known at C.nnIf anybody cares: exactly the same happens with DCCP.nnThis behavior 1st manifested in release 2.6.29.4 (see Fixes below)nand it looks unintentional. At least no explanation was provided.nnI changed returned packes label into the 'bar'nto bring it into line with the Smack documentation claims.,CVE-2024-47659,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnfsnotify: clear PARENT_WATCHED flags lazilynnIn some setups directories can have many (usually negative) dentries.nHence __fsnotify_update_child_dentry_flags() function can take ansignificant amount of time. Since the bulk of this function happensnunder inode->i_lock this causes a significant contention on the locknwhen we remove the watch from the directory as then__fsnotify_update_child_dentry_flags() call from fsnotify_recalc_mask()nraces with __fsnotify_update_child_dentry_flags() calls fromn__fsnotify_parent() happening on children. This can lead upto softlockupnreports reported by users.nnFix the problem by calling fsnotify_update_children_dentry_flags() tonset PARENT_WATCHED flags only when parent starts watching children.nnWhen parent stops watching children clear false positive PARENT_WATCHEDnflags lazily in __fsnotify_parent() for each accessed child.,CVE-2024-47660,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Avoid overflow from uint32_t to uint8_tnn[WHAT & HOW]ndmub_rb_cmd's ramping_boundary has size of uint8_t and it is assignedn0xFFFF. Fix it by changing it to uint8_t with value of 0xFF.nnThis fixes 2 INTEGER_OVERFLOW issues reported by Coverity.,CVE-2024-47661,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Remove register from DCN35 DMCUB diagnostic collectionnn[Why]nThese registers should not be read from driver and triggering thensecurity violation when DMCUB work times out and diagnostics arencollected blocks Z8 entry.nn[How]nRemove the register read from DCN35.,CVE-2024-47662,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnstaging: iio: frequency: ad9834: Validate frequency parameter valuennIn ad9834_write_frequency() clk_get_rate() can return 0. In such casenad9834_calc_freqreg() call will lead to division by zero. Checkingn'if (fout > (clk_freq / 2))' doesn't protect in case of 'fout' is 0.nad9834_write_frequency() is called from ad9834_write() where fout isntaken from text buffer which can contain any value.nnModify parameters checking.nnFound by Linux Verification Center (linuxtesting.org) with SVACE.,CVE-2024-47663,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nni3c: mipi-i3c-hci: Error out instead on BUG_ON() in IBI DMA setupnnDefinitely condition dma_get_cache_alignment output.log scan_tyk_dockerimages.sh vulnerabilities.csv defined value > 256nduring driver initialization is not reason to BUG_ON(). Turn that tongraceful error out with -EINVAL.,CVE-2024-47665,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnscsi: pm80xx: Set phy->enable_completion only when we wait for itnnpm8001_phy_control() populates the enable_completion pointer with a stacknaddress sends a PHY_LINK_RESET / PHY_HARD_RESET waits 300 ms andnreturns. The problem arises when a phy control response comes late. Aftern300 ms the pm8001_phy_control() function returns and the passednenable_completion stack address is no longer valid. Late phy controlnresponse invokes complete() on a dangling enable_completion pointer whichnleads to a kernel crash.,CVE-2024-47666,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnPCI: keystone: Add workaround for Errata #i2037 (AM65x SR 1.0)nnErrata #i2037 in AM65x/DRA80xM Processors Silicon Revision 1.0n(SPRZ452D_July 2018_Revised December 2019 [1]) mentions when anninbound PCIe TLP spans more than two internal AXI 128-byte burstsnthe bus may corrupt the packet payload and the corrupt data mayncause associated applications or the processor to hang.nnThe workaround for Errata #i2037 is to limit the maximum readnrequest size and maximum payload size to 128 bytes. Add workaroundnfor Errata #i2037 here.nnThe errata and workaround is applicable only to AM65x SR 1.0 andnlater versions of the silicon will have this fixed.nn[1] -> https://www.ti.com/lit/er/sprz452i/sprz452i.pdf,CVE-2024-47667,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnlib/generic-radix-tree.c: Fix rare race in __genradix_ptr_alloc()nnIf we need to increase the tree depth allocate a new node and thennrace with another thread that increased the tree depth before us we'llnstill have a preallocated node that might be used later.nnIf we then use that node for a new non-root node it'll still have anpointer to the old root instead of being zeroed - fix this by zeroing itnin the cmpxchg failure path.,CVE-2024-47668,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnilfs2: fix state management in error path of log writing functionnnAfter commit a694291a6211 (nilfs2: separate wait function fromnnilfs_segctor_write) was applied the log writing functionnnilfs_segctor_do_construct() was able to issue I/O requests continuouslyneven if user data blocks were split into multiple logs across segmentsnbut two potential flaws were introduced in its error handling.nnFirst if nilfs_segctor_begin_construction() fails while creating thensecond or subsequent logs the log writing function returns withoutncalling nilfs_segctor_abort_construction() so the writeback flag set onnpages/folios will remain uncleared. This causes page cache operations tonhang waiting for the writeback flag. For examplentruncate_inode_pages_final() which is called via nilfs_evict_inode() whennan inode is evicted from memory will hang.nnSecond the NILFS_I_COLLECTED flag set on normal inodes remain uncleared. nAs a result if the next log write involves checkpoint creation that'snfine but if a partial log write is performed that does not inodes withnNILFS_I_COLLECTED set are erroneously removed from the sc_dirty_filesnlist and their data and b-tree blocks may not be written to the devicencorrupting the block mapping.nnFix these issues by uniformly calling nilfs_segctor_abort_construction()non failure of each step in the loop in nilfs_segctor_do_construct()nhaving it clean up logs and segment usages according to progress andncorrecting the conditions for calling nilfs_redirty_inodes() to ensurenthat the NILFS_I_COLLECTED flag is cleared.,CVE-2024-47669,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnwifi: iwlwifi: mvm: pause TCM when the firmware is stoppednnNot doing so will make us send a host command to the transport while thenfirmware is not alive which will trigger a WARNING.nnbad state = 0nWARNING: CPU: 2 PID: 17434 at drivers/net/wireless/intel/iwlwifi/iwl-trans.c:115 iwl_trans_send_cmd+0x1cb/0x1e0 [iwlwifi]nRIP: 0010:iwl_trans_send_cmd+0x1cb/0x1e0 [iwlwifi]nCall Trace:n <TASK>n iwl_mvm_send_cmd+0x40/0xc0 [iwlmvm]n iwl_mvm_config_scan+0x198/0x260 [iwlmvm]n iwl_mvm_recalc_tcm+0x730/0x11d0 [iwlmvm]n iwl_mvm_tcm_work+0x1d/0x30 [iwlmvm]n process_one_work+0x29e/0x640n worker_thread+0x2df/0x690n ? rescuer_thread+0x540/0x540n kthread+0x192/0x1e0n ? set_kthread_struct+0x90/0x90n ret_from_fork+0x22/0x30,CVE-2024-47673,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnicmp: change the order of rate limitsnnICMP messages are ratelimited :nnAfter the blamed commits the two rate limiters are applied in this order:nn1) host wide ratelimit (icmp_global_allow())nn2) Per destination ratelimit (inetpeer based)nnIn order to avoid side-channels attacks we need to applynthe per destination check first.nnThis patch makes the following change :nn1) icmp_global_allow() checks if the host wide limit is reached.n But credits are not yet consumed. This is deferred to 3)nn2) The per destination limit is checked/updated.n This might add a new node in inetpeer tree.nn3) icmp_global_consume() consumes tokens if prior operations succeeded.nnThis means that host wide ratelimit is still effectivenin keeping inetpeer tree small even under DDOS.nnAs a bonus I removed icmp_global.lock as the fast pathncan use a lock-free operation.,CVE-2024-47678,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Skip Recompute DSC Params if no Stream on Linknn[why]nEncounter NULL pointer dereference uner mst + dsc setup.nnBUG: kernel NULL pointer dereference address: 0000000000000008n PGD 0 P4D 0n Oops: 0000 [#1] PREEMPT SMP NOPTIn CPU: 4 PID: 917 Comm: sway Not tainted 6.3.9-arch1-1 #1 124dc55df4f5272ccb409f39ef4872fc2b3376a2n Hardware name: LENOVO 20NKS01Y00/20NKS01Y00 BIOS R12ET61W(1.31 ) 07/28/2022n RIP: 0010:drm_dp_atomic_find_time_slots+0x5e/0x260 [drm_display_helper]n Code: 01 00 00 48 8b 85 60 05 00 00 48 63 80 88 00 00 00 3b 43 28 0f 8d 2e 01 00 00 48 8b 53 30 48 8d 04 80 48 8d 04 c2 48 8b 40 18 <48> 8>n RSP: 0018:ffff960cc2df77d8 EFLAGS: 00010293n RAX: 0000000000000000 RBX: ffff8afb87e81280 RCX: 0000000000000224n RDX: ffff8afb9ee37c00 RSI: ffff8afb8da1a578 RDI: ffff8afb87e81280n RBP: ffff8afb83d67000 R08: 0000000000000001 R09: ffff8afb9652f850n R10: ffff960cc2df7908 R11: 0000000000000002 R12: 0000000000000000n R13: ffff8afb8d7688a0 R14: ffff8afb8da1a578 R15: 0000000000000224n FS: 00007f4dac35ce00(0000) GS:ffff8afe30b00000(0000) knlGS:0000000000000000n CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033n CR2: 0000000000000008 CR3: 000000010ddc6000 CR4: 00000000003506e0n Call Trace:n<TASK>n ? __die+0x23/0x70n ? page_fault_oops+0x171/0x4e0n ? plist_add+0xbe/0x100n ? exc_page_fault+0x7c/0x180n ? asm_exc_page_fault+0x26/0x30n ? drm_dp_atomic_find_time_slots+0x5e/0x260 [drm_display_helper 0e67723696438d8e02b741593dd50d80b44c2026]n ? drm_dp_atomic_find_time_slots+0x28/0x260 [drm_display_helper 0e67723696438d8e02b741593dd50d80b44c2026]n compute_mst_dsc_configs_for_link+0x2ff/0xa40 [amdgpu 62e600d2a75e9158e1cd0a243bdc8e6da040c054]n ? fill_plane_buffer_attributes+0x419/0x510 [amdgpu 62e600d2a75e9158e1cd0a243bdc8e6da040c054]n compute_mst_dsc_configs_for_state+0x1e1/0x250 [amdgpu 62e600d2a75e9158e1cd0a243bdc8e6da040c054]n amdgpu_dm_atomic_check+0xecd/0x1190 [amdgpu 62e600d2a75e9158e1cd0a243bdc8e6da040c054]n drm_atomic_check_only+0x5c5/0xa40n drm_mode_atomic_ioctl+0x76e/0xbc0nn[how]ndsc recompute should be skipped if no mode change detected on the newnrequest. If detected keep checking whether the stream is already onncurrent state or not.,CVE-2024-47683,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnf2fs: get rid of online repaire on corrupted directorynnsyzbot reports a f2fs bug as below:nnkernel BUG at fs/f2fs/inode.c:896!nRIP: 0010:f2fs_evict_inode+0x1598/0x15c0 fs/f2fs/inode.c:896nCall Trace:n evict+0x532/0x950 fs/inode.c:704n dispose_list fs/inode.c:747 [inline]n evict_inodes+0x5f9/0x690 fs/inode.c:797n generic_shutdown_super+0x9d/0x2d0 fs/super.c:627n kill_block_super+0x44/0x90 fs/super.c:1696n kill_f2fs_super+0x344/0x690 fs/f2fs/super.c:4898n deactivate_locked_super+0xc4/0x130 fs/super.c:473n cleanup_mnt+0x41f/0x4b0 fs/namespace.c:1373n task_work_run+0x24f/0x310 kernel/task_work.c:228n ptrace_notify+0x2d2/0x380 kernel/signal.c:2402n ptrace_report_syscall include/linux/ptrace.h:415 [inline]n ptrace_report_syscall_exit include/linux/ptrace.h:477 [inline]n syscall_exit_work+0xc6/0x190 kernel/entry/common.c:173n syscall_exit_to_user_mode_prepare kernel/entry/common.c:200 [inline]n __syscall_exit_to_user_mode_work kernel/entry/common.c:205 [inline]n syscall_exit_to_user_mode+0x279/0x370 kernel/entry/common.c:218n do_syscall_64+0x100/0x230 arch/x86/entry/common.c:89n entry_SYSCALL_64_after_hwframe+0x77/0x7fnRIP: 0010:f2fs_evict_inode+0x1598/0x15c0 fs/f2fs/inode.c:896nnOnline repaire on corrupted directory in f2fs_lookup() can generatendirty data/meta while racing w/ readonly remount it may leave dirtyninode after filesystem becomes readonly however checkpoint() willnskips flushing dirty inode in a state of readonly mode result innabove panic.nnLet's get rid of online repaire in f2fs_lookup() and leave the worknto fsck.f2fs.,CVE-2024-47690,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnf2fs: fix to avoid use-after-free in f2fs_stop_gc_thread()nnsyzbot reports a f2fs bug as below:nn __dump_stack lib/dump_stack.c:88 [inline]n dump_stack_lvl+0x241/0x360 lib/dump_stack.c:114n print_report+0xe8/0x550 mm/kasan/report.c:491n kasan_report+0x143/0x180 mm/kasan/report.c:601n kasan_check_range+0x282/0x290 mm/kasan/generic.c:189n instrument_atomic_read_write include/linux/instrumented.h:96 [inline]n atomic_fetch_add_relaxed include/linux/atomic/atomic-instrumented.h:252 [inline]n __refcount_add include/linux/refcount.h:184 [inline]n __refcount_inc include/linux/refcount.h:241 [inline]n refcount_inc include/linux/refcount.h:258 [inline]n get_task_struct include/linux/sched/task.h:118 [inline]n kthread_stop+0xca/0x630 kernel/kthread.c:704n f2fs_stop_gc_thread+0x65/0xb0 fs/f2fs/gc.c:210n f2fs_do_shutdown+0x192/0x540 fs/f2fs/file.c:2283n f2fs_ioc_shutdown fs/f2fs/file.c:2325 [inline]n __f2fs_ioctl+0x443a/0xbe60 fs/f2fs/file.c:4325n vfs_ioctl fs/ioctl.c:51 [inline]n __do_sys_ioctl fs/ioctl.c:907 [inline]n __se_sys_ioctl+0xfc/0x170 fs/ioctl.c:893n do_syscall_x64 arch/x86/entry/common.c:52 [inline]n do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83n entry_SYSCALL_64_after_hwframe+0x77/0x7fnnThe root cause is below race condition it may cause use-after-freenissue in sbi->gc_th pointer.nn- remountn - f2fs_remountn - f2fs_stop_gc_threadn - kfree(gc_th)ntttt- f2fs_ioc_shutdownntttt - f2fs_do_shutdownntttt - f2fs_stop_gc_threadntttt - kthread_stop(gc_th->f2fs_gc_task)n : sbi->gc_thread = NULL;nnWe will call f2fs_do_shutdown() in two paths:n- for f2fs_ioc_shutdown() path we should grab sb->s_umount semaphorenfor fixing.n- for f2fs_shutdown() path it's safe since caller has already grabbednsb->s_umount semaphore.,CVE-2024-47691,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnIB/core: Fix ib_cache_setup_one error flow cleanupnnWhen ib_cache_update return an error we exit ib_cache_setup_oneninstantly with no proper cleanup even though before this we hadnalready successfully done gid_table_setup_one that results innthe kernel WARN below.nnDo proper cleanup using gid_table_cleanup_one before returningnthe err in order to fix the issue.nnWARNING: CPU: 4 PID: 922 at drivers/infiniband/core/cache.c:806 gid_table_release_one+0x181/0x1a0nModules linked in:nCPU: 4 UID: 0 PID: 922 Comm: c_repro Not tainted 6.11.0-rc1+ #3nHardware name: QEMU Standard PC (i440FX + PIIX 1996) BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014nRIP: 0010:gid_table_release_one+0x181/0x1a0nCode: 44 8b 38 75 0c e8 2f cb 34 ff 4d 8b b5 28 05 00 00 e8 23 cb 34 ff 44 89 f9 89 da 4c 89 f6 48 c7 c7 d0 58 14 83 e8 4f de 21 ff <0f> 0b 4c 8b 75 30 e9 54 ff ff ff 48 8 3 c4 10 5b 5d 41 5c 41 5d 41nRSP: 0018:ffffc90002b835b0 EFLAGS: 00010286nRAX: 0000000000000000 RBX: 0000000000000000 RCX: ffffffff811c8527nRDX: 0000000000000000 RSI: ffffffff811c8534 RDI: 0000000000000001nRBP: ffff8881011b3d00 R08: ffff88810b3abe00 R09: 205d303839303631nR10: 666572207972746e R11: 72746e6520444947 R12: 0000000000000001nR13: ffff888106390000 R14: ffff8881011f2110 R15: 0000000000000001nFS: 00007fecc3b70800(0000) GS:ffff88813bd00000(0000) knlGS:0000000000000000nCS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033nCR2: 0000000020000340 CR3: 000000010435a001 CR4: 00000000003706b0nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400nCall Trace:n <TASK>n ? show_regs+0x94/0xa0n ? __warn+0x9e/0x1c0n ? gid_table_release_one+0x181/0x1a0n ? report_bug+0x1f9/0x340n ? gid_table_release_one+0x181/0x1a0n ? handle_bug+0xa2/0x110n ? exc_invalid_op+0x31/0xa0n ? asm_exc_invalid_op+0x16/0x20n ? __warn_printk+0xc7/0x180n ? __warn_printk+0xd4/0x180n ? gid_table_release_one+0x181/0x1a0n ib_device_release+0x71/0xe0n ? __pfx_ib_device_release+0x10/0x10n device_release+0x44/0xd0n kobject_put+0x135/0x3d0n put_device+0x20/0x30n rxe_net_add+0x7d/0xa0n rxe_newlink+0xd7/0x190n nldev_newlink+0x1b0/0x2a0n ? __pfx_nldev_newlink+0x10/0x10n rdma_nl_rcv_msg+0x1ad/0x2e0n rdma_nl_rcv_skb.constprop.0+0x176/0x210n netlink_unicast+0x2de/0x400n netlink_sendmsg+0x306/0x660n __sock_sendmsg+0x110/0x120n ____sys_sendmsg+0x30e/0x390n ___sys_sendmsg+0x9b/0xf0n ? kstrtouint+0x6e/0xa0n ? kstrtouint_from_user+0x7c/0xb0n ? get_pid_task+0xb0/0xd0n ? proc_fail_nth_write+0x5b/0x140n ? __fget_light+0x9a/0x200n ? preempt_count_add+0x47/0xa0n __sys_sendmsg+0x61/0xd0n do_syscall_64+0x50/0x110n entry_SYSCALL_64_after_hwframe+0x76/0x7e,CVE-2024-47693,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnRDMA/rtrs-clt: Reset cid to con_num - 1 to stay in boundsnnIn the function init_conns() after the create_con() and create_cm() fornloop if something fails. In the cleanup for loop after the destroy tag wenaccess out of bound memory because cid is set to clt_path->s.con_num.nnThis commits resets the cid to clt_path->s.con_num - 1 to stay in boundsnin the cleanup loop later.,CVE-2024-47695,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbpf lsm: Add check for BPF LSM return valuennA bpf prog returning a positive number attached to file_alloc_securitynhook makes kernel panic.nnThis happens because file system can not filter out the positive numbernreturned by the LSM prog using IS_ERR and misinterprets this positivennumber as a file pointer.nnGiven that hook file_alloc_security never returned positive numbernbefore the introduction of BPF LSM and other BPF LSM hooks maynencounter similar issues this patch adds LSM return value checknin verifier to ensure no unexpected value is returned.,CVE-2024-47703,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Check link_res->hpo_dp_link_enc before using itnn[WHAT & HOW]nFunctions dp_enable_link_phy and dp_disable_link_phy can pass link_resnwithout initializing hpo_dp_link_enc and it is necessary to check fornnull before dereferencing.nnThis fixes 2 FORWARD_NULL issues reported by Coverity.,CVE-2024-47704,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Add null check for set_output_gamma in dcn30_set_output_transfer_funcnnThis commit adds a null check for the set_output_gamma function pointernin the dcn30_set_output_transfer_func function. Previouslynset_output_gamma was being checked for nullity at line 386 but then itnwas being dereferenced without any nullity check at line 401. Thisncould potentially lead to a null pointer dereference error ifnset_output_gamma is indeed null.nnTo fix this we now ensure that set_output_gamma is not null beforendereferencing it. We do this by adding a nullity check fornset_output_gamma before the call to set_output_gamma at line 401. Ifnset_output_gamma is null we log an error message and do not call thenfunction.nnThis fix prevents a potential null pointer dereference error.nndrivers/gpu/drm/amd/amdgpu/../display/dc/hwss/dcn30/dcn30_hwseq.c:401 dcn30_set_output_transfer_func()nerror: we previously assumed 'mpc->funcs->set_output_gamma' could be null (see line 386)nndrivers/gpu/drm/amd/amdgpu/../display/dc/hwss/dcn30/dcn30_hwseq.cn 373 bool dcn30_set_output_transfer_func(struct dc *dcn 374 struct pipe_ctx *pipe_ctxn 375 const struct dc_stream_state *stream)n 376 {n 377 int mpcc_id = pipe_ctx->plane_res.hubp->inst;n 378 struct mpc *mpc = pipe_ctx->stream_res.opp->ctx->dc->res_pool->mpc;n 379 const struct pwl_params *params = NULL;n 380 bool ret = false;n 381n 382 /bin /boot /config /dev /etc /home /lib /media /mnt /opt /proc /root /run /sbin /shared /srv /sys /tmp /usr /utils /var program OGAM or 3DLUT only for the top pipe*/n 383 if (pipe_ctx->top_pipe == NULL) {n 384 /*program rmu shaper and 3dlut in MPC*/n 385 ret = dcn30_set_mpc_shaper_3dlut(pipe_ctx stream);n 386 if (ret == false && mpc->funcs->set_output_gamma) {n ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ If this is NULLnn 387 if (stream->out_transfer_func.type == TF_TYPE_HWPWL)n 388 params = &stream->out_transfer_func.pwl;n 389 else if (pipe_ctx->stream->out_transfer_func.type ==n 390 TF_TYPE_DISTRIBUTED_POINTS &&n 391 cm3_helper_translate_curve_to_hw_format(n 392 &stream->out_transfer_funcn 393 &mpc->blender_params false))n 394 params = &mpc->blender_params;n 395 /bin /boot /config /dev /etc /home /lib /media /mnt /opt /proc /root /run /sbin /shared /srv /sys /tmp /usr /utils /var there are no ROM LUTs in OUTGAM */n 396 if (stream->out_transfer_func.type == TF_TYPE_PREDEFINED)n 397 BREAK_TO_DEBUGGER();n 398 }n 399 }n 400n--> 401 mpc->funcs->set_output_gamma(mpc mpcc_id params);n ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Then it will crashnn 402 return ret;n 403 },CVE-2024-47720,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnf2fs: fix to wait dio completionnnIt should wait all existing dio write IOs before block removalnotherwise previous direct write IO may overwrite data in thenblock which may be reused by other inode.,CVE-2024-47726,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbpf: Zero former ARG_PTR_TO_{LONGINT} args in case of errornnFor all non-tracing helpers which formerly had ARG_PTR_TO_{LONGINT} as inputnarguments zero the value for the case of an error as otherwise it could leaknmemory. For tracing it is not needed given CAP_PERFMON can already read allnkernel memory anyway hence bpf_get_func_arg() and bpf_get_func_ret() is skippednin here.nnAlso the MTU helpers mtu_len pointer value is being written but also read.nTechnically the MEM_UNINIT should not be there in order to always force init.nRemoving MEM_UNINIT needs more verifier rework though: MEM_UNINIT right nownimplies two things actually: i) write into memory ii) memory does not havento be initialized. If we lift MEM_UNINIT it then becomes: i) read into memorynii) memory must be initialized. This means that for bpf_*_check_mtu() we'renreadding the issue we're trying to fix that is it would then be able tonwrite back into things like .rodata BPF maps. Follow-up work will rework thenMEM_UNINIT semantics such that the intent can be better expressed. For nownjust clear the *mtu_len on error path which can be lifted later again.,CVE-2024-47728,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nncrypto: hisilicon/qm - inject error before stopping queuennThe master ooo cannot be completely closed when thenaccelerator core reports memory error. Therefore the drivernneeds to inject the qm error to close the master ooo. Currentlynthe qm error is injected after stopping queue memory may benreleased immediately after stopping queue causing the device tonaccess the released memory. Therefore error is injected to close masternooo before stopping queue to ensure that the device does not accessnthe released memory.,CVE-2024-47730,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnwifi: mac80211: don't use rate mask for offchannel TX eithernnLike the commit ab9177d83c04 (wifi: mac80211: don't use rate mask fornscanning) ignore incorrect settings to avoid no supported rate warningnreported by syzbot.nnThe syzbot did bisect and found cause is commit 9df66d5b9f45 (cfg80211:nfix default HE tx bitrate mask in 2G band) which however correctsnbitmask of HE MCS and recognizes correctly settings of empty legacy ratenplus HE MCS rate instead of returning -EINVAL.nnAs suggestions [1] follow the change of SCAN TX to consider this case ofnoffchannel TX as well.nn[1] https://lore.kernel.org/linux-wireless/6ab2dc9c3afe753ca6fdcdd1421e7a1f47e87b84.camel@sipsolutions.net/T/#m2ac2a6d2be06a37c9c47a3d8a44b4f647ed4f024,CVE-2024-47738,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnmm: call the security_mmap_file() LSM hook in remap_file_pages()nnThe remap_file_pages syscall handler calls do_mmap() directly whichndoesn't contain the LSM security check. And if the process has callednpersonality(READ_IMPLIES_EXEC) before and remap_file_pages() is called fornRW pages this will actually result in remapping the pages to RWXnbypassing a W^X policy enforced by SELinux.nnSo we should check prot by security_mmap_file LSM hook in thenremap_file_pages syscall handler before do_mmap() is called. Otherwise itnpotentially permits an attacker to bypass a W^X policy enforced bynSELinux.nnThe bypass is similar to CVE-2016-10044 which bypass the same thing vianAIO and can be found in [1].nnThe PoC:nn$ cat > test.cnnint main(void) {ntsize_t pagesz = sysconf(_SC_PAGE_SIZE);ntint mfd = syscall(SYS_memfd_create test 0);ntconst char *buf = mmap(NULL 4 output.log scan_tyk_dockerimages.sh vulnerabilities.csv pagesz PROT_READ | PROT_WRITEnttMAP_SHARED mfd 0);ntunsigned int old = syscall(SYS_personality 0xffffffff);ntsyscall(SYS_personality READ_IMPLIES_EXEC | old);ntsyscall(SYS_remap_file_pages buf pagesz 0 2 0);ntsyscall(SYS_personality old);nt// show the RWX page exists even if W^X policy is enforcedntint fd = open(/proc/self/maps O_RDONLY);ntunsigned char buf2[1024];ntwhile (1) {nttint ret = read(fd buf2 1024);nttif (ret <= 0) break;nttwrite(1 buf2 ret);nt}ntclose(fd);n}nn$ gcc test.c -o testn$ ./test | grep rwxn7f1836c34000-7f1836c35000 rwxs 00002000 00:01 2050 /memfd:test (deleted)nn[PM: subject line tweaks],CVE-2024-47745,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet: seeq: Fix use after free vulnerability in ether3 Driver Due to Race ConditionnnIn the ether3_probe function a timer is initialized with a callbacknfunction ether3_ledoff bound to &prev(dev)->timer. Once the timer isnstarted there is a risk of a race condition if the module or devicenis removed triggering the ether3_remove function to perform cleanup.nThe sequence of operations that may lead to a UAF bug is as follows:nnCPU0 CPU1nn | ether3_ledoffnether3_remove |n free_netdev(dev); |n put_devic |n kfree(dev); |n | ether3_outw(priv(dev)->regs.config2 |= CFG2_CTRLO REG_CONFIG2);n | // use devnnFix it by ensuring that the timer is canceled before proceeding withnthe cleanup in ether3_remove.,CVE-2024-47747,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbpf: Prevent tailcall infinite loop caused by freplacennThere is a potential infinite loop issue that can occur when using ancombination of tail calls and freplace.nnIn an upcoming selftest the attach target for entry_freplace ofntailcall_freplace.c is subprog_tc of tc_bpf2bpf.c while the tail call innentry_freplace leads to entry_tc. This results in an infinite loop:nnentry_tc -> subprog_tc -> entry_freplace --tailcall-> entry_tc.nnThe problem arises because the tail_call_cnt in entry_freplace resets tonzero each time entry_freplace is executed causing the tail call mechanismnto never terminate eventually leading to a kernel panic.nnTo fix this issue the solution is twofold:nn1. Prevent updating a program extended by an freplace program to an prog_array map.n2. Prevent extending a program that is already part of a prog_array mapn with an freplace program.nnThis ensures that:nn* If a program or its subprogram has been extended by an freplace programn it can no longer be updated to a prog_array map.n* If a program has been added to a prog_array map neither it nor itsn subprograms can be extended by an freplace program.nnMoreover an extension program should not be tailcalled. As such returnn-EINVAL if the program has a type of BPF_PROG_TYPE_EXT when adding it to anprog_array map.nnAdditionally fix a minor code style issue by replacing eight spaces with antab for proper formatting.,CVE-2024-47794,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndlm: fix possible lkb_resource null dereferencennThis patch fixes a possible null pointer dereference when this function isncalled from request_lock() as lkb->lkb_resource is not assigned yetnonly after validate_lock_args() by calling attach_lkb(). Another issuenis that a resource name could be a non printable bytearray and we cannotnassume to be ASCII coded.nnThe log functionality is probably never being hit when DLM is used innnormal way and no debug logging is enabled. The null pointer dereferencencan only occur on a new created lkb that does not have the resourcenassigned yet it probably never hits the null pointer dereference but wenshould be sure that other changes might not change this behaviour and wenactually can hit the mentioned null pointer dereference.nnIn this patch we just drop the printout of the resource name the lkb idnis enough to make a possible connection to a resource name if thisnexists.,CVE-2024-47809,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbtrfs: don't take dev_replace rwsem on task already holding itnnRunning fstests btrfs/011 with MKFS_OPTIONS=-O rst to force the usage ofnthe RAID stripe-tree we get the following splat from lockdep:nn BTRFS info (device sdd): dev_replace from /dev/sdd (devid 1) to /dev/sdb startednn ============================================n WARNING: possible recursive locking detectedn 6.11.0-rc3-btrfs-for-next #599 Not taintedn --------------------------------------------n btrfs/2326 is trying to acquire lock:n ffff88810f215c98 (&fs_info->dev_replace.rwsem){++++}-{3:3} at: btrfs_map_block+0x39f/0x2250nn but task is already holding lock:n ffff88810f215c98 (&fs_info->dev_replace.rwsem){++++}-{3:3} at: btrfs_map_block+0x39f/0x2250nn other info that might help us debug this:n Possible unsafe locking scenario:nn CPU0n ----n lock(&fs_info->dev_replace.rwsem);n lock(&fs_info->dev_replace.rwsem);nn output.log scan_tyk_dockerimages.sh vulnerabilities.csv DEADLOCK ***nn May be due to missing lock nesting notationnn 1 lock held by btrfs/2326:n #0: ffff88810f215c98 (&fs_info->dev_replace.rwsem){++++}-{3:3} at: btrfs_map_block+0x39f/0x2250nn stack backtrace:n CPU: 1 UID: 0 PID: 2326 Comm: btrfs Not tainted 6.11.0-rc3-btrfs-for-next #599n Hardware name: Bochs Bochs BIOS Bochs 01/01/2011n Call Trace:n <TASK>n dump_stack_lvl+0x5b/0x80n __lock_acquire+0x2798/0x69d0n ? __pfx___lock_acquire+0x10/0x10n ? __pfx___lock_acquire+0x10/0x10n lock_acquire+0x19d/0x4a0n ? btrfs_map_block+0x39f/0x2250n ? __pfx_lock_acquire+0x10/0x10n ? find_held_lock+0x2d/0x110n ? lock_is_held_type+0x8f/0x100n down_read+0x8e/0x440n ? btrfs_map_block+0x39f/0x2250n ? __pfx_down_read+0x10/0x10n ? do_raw_read_unlock+0x44/0x70n ? _raw_read_unlock+0x23/0x40n btrfs_map_block+0x39f/0x2250n ? btrfs_dev_replace_by_ioctl+0xd69/0x1d00n ? btrfs_bio_counter_inc_blocked+0xd9/0x2e0n ? __kasan_slab_alloc+0x6e/0x70n ? __pfx_btrfs_map_block+0x10/0x10n ? __pfx_btrfs_bio_counter_inc_blocked+0x10/0x10n ? kmem_cache_alloc_noprof+0x1f2/0x300n ? mempool_alloc_noprof+0xed/0x2b0n btrfs_submit_chunk+0x28d/0x17e0n ? __pfx_btrfs_submit_chunk+0x10/0x10n ? bvec_alloc+0xd7/0x1b0n ? bio_add_folio+0x171/0x270n ? __pfx_bio_add_folio+0x10/0x10n ? __kasan_check_read+0x20/0x20n btrfs_submit_bio+0x37/0x80n read_extent_buffer_pages+0x3df/0x6c0n btrfs_read_extent_buffer+0x13e/0x5f0n read_tree_block+0x81/0xe0n read_block_for_search+0x4bd/0x7a0n ? __pfx_read_block_for_search+0x10/0x10n btrfs_search_slot+0x78d/0x2720n ? __pfx_btrfs_search_slot+0x10/0x10n ? lock_is_held_type+0x8f/0x100n ? kasan_save_track+0x14/0x30n ? __kasan_slab_alloc+0x6e/0x70n ? kmem_cache_alloc_noprof+0x1f2/0x300n btrfs_get_raid_extent_offset+0x181/0x820n ? __pfx_lock_acquire+0x10/0x10n ? __pfx_btrfs_get_raid_extent_offset+0x10/0x10n ? down_read+0x194/0x440n ? __pfx_down_read+0x10/0x10n ? do_raw_read_unlock+0x44/0x70n ? _raw_read_unlock+0x23/0x40n btrfs_map_block+0x5b5/0x2250n ? __pfx_btrfs_map_block+0x10/0x10n scrub_submit_initial_read+0x8fe/0x11b0n ? __pfx_scrub_submit_initial_read+0x10/0x10n submit_initial_group_read+0x161/0x3a0n ? lock_release+0x20e/0x710n ? __pfx_submit_initial_group_read+0x10/0x10n ? __pfx_lock_release+0x10/0x10n scrub_simple_mirror.isra.0+0x3eb/0x580n scrub_stripe+0xe4d/0x1440n ? lock_release+0x20e/0x710n ? __pfx_scrub_stripe+0x10/0x10n ? __pfx_lock_release+0x10/0x10n ? do_raw_read_unlock+0x44/0x70n ? _raw_read_unlock+0x23/0x40n scrub_chunk+0x257/0x4a0n scrub_enumerate_chunks+0x64c/0xf70n ? __mutex_unlock_slowpath+0x147/0x5f0n ? __pfx_scrub_enumerate_chunks+0x10/0x10n ? bit_wait_timeout+0xb0/0x170n ? __up_read+0x189/0x700n ? scrub_workers_get+0x231/0x300n ? up_write+0x490/0x4f0n btrfs_scrub_dev+0x52e/0xcd0n ? create_pending_snapshots+0x230/0x250n ? __pfx_btrfs_scrub_dev+0x10/0x10n btrfs_dev_replace_by_ioctl+0xd69/0x1d00n ? lock_acquire+0x19d/0x4a0n ? __pfx_btrfs_dev_replace_by_ioctl+0x10/0x10n ?n---truncated---,CVE-2024-48875,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet/smc: check v2_ext_offset/eid_cnt/ism_gid_cnt when receiving proposal msgnnWhen receiving proposal msg in server the fields v2_ext_offset/neid_cnt/ism_gid_cnt in proposal msg are from the remote clientnand can not be fully trusted. Especially the field v2_ext_offsetnonce exceed the max value there has the chance to access wrongnaddress and crash may happen.nnThis patch checks the fields v2_ext_offset/eid_cnt/ism_gid_cntnbefore using them.,CVE-2024-49568,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnvme-rdma: unquiesce admin_q before destroy itnnKernel will hang on destroy admin_q while we create ctrl failed suchnas following calltrace:nnPID: 23644 TASK: ff2d52b40f439fc0 CPU: 2 COMMAND: nvmen #0 [ff61d23de260fb78] __schedule at ffffffff8323bc15n #1 [ff61d23de260fc08] schedule at ffffffff8323c014n #2 [ff61d23de260fc28] blk_mq_freeze_queue_wait at ffffffff82a3dba1n #3 [ff61d23de260fc78] blk_freeze_queue at ffffffff82a4113an #4 [ff61d23de260fc90] blk_cleanup_queue at ffffffff82a33006n #5 [ff61d23de260fcb0] nvme_rdma_destroy_admin_queue at ffffffffc12686cen #6 [ff61d23de260fcc8] nvme_rdma_setup_ctrl at ffffffffc1268cedn #7 [ff61d23de260fd28] nvme_rdma_create_ctrl at ffffffffc126919bn #8 [ff61d23de260fd68] nvmf_dev_write at ffffffffc024f362n #9 [ff61d23de260fe38] vfs_write at ffffffff827d5f25n RIP: 00007fda7891d574 RSP: 00007ffe2ef06958 RFLAGS: 00000202n RAX: ffffffffffffffda RBX: 000055e8122a4d90 RCX: 00007fda7891d574n RDX: 000000000000012b RSI: 000055e8122a4d90 RDI: 0000000000000004n RBP: 00007ffe2ef079c0 R8: 000000000000012b R9: 000055e8122a4d90n R10: 0000000000000000 R11: 0000000000000202 R12: 0000000000000004n R13: 000055e8122923c0 R14: 000000000000012b R15: 00007fda78a54500n ORIG_RAX: 0000000000000001 CS: 0033 SS: 002bnnThis due to we have quiesced admi_q before cancel requests but forgotnto unquiesce before destroy it as a result we fail to drain thenpending requests and hang on blk_mq_freeze_queue_wait() forever. Herentry to reuse nvme_rdma_teardown_admin_queue() to fix this issue andnsimplify the code.,CVE-2024-49569,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet/smc: check iparea_offset and ipv6_prefixes_cnt when receiving proposal msgnnWhen receiving proposal msg in server the field iparea_offsetnand the field ipv6_prefixes_cnt in proposal msg are from thenremote client and can not be fully trusted. Especially thenfield iparea_offset once exceed the max value there has thenchance to access wrong address and crash may happen.nnThis patch checks iparea_offset and ipv6_prefixes_cnt before using them.,CVE-2024-49571,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnblock bfq: fix uaf for accessing waker_bfqq after splittingnnAfter commit 42c306ed7233 (block bfq: don't break merge chain innbfq_split_bfqq()) if the current procress is the last holder of bfqqnthe bfqq can be freed after bfq_split_bfqq(). Hence recored the bfqq andnthen access bfqq->waker_bfqq may trigger UAF. What's more the waker_bfqqnmay in the merge chain of bfqq hence just recored waker_bfqq is stillnnot safe.nnFix the problem by adding a helper bfq_waker_bfqq() to check ifnbfqq->waker_bfqq is in the merge chain and current procress is the onlynholder.,CVE-2024-49854,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnf2fs: fix to check atomic_file in f2fs ioctl interfacesnnSome f2fs ioctl interfaces like f2fs_ioc_set_pin_file()nf2fs_move_file_range() and f2fs_defragment_range() missed toncheck atomic_write status which may cause potential race issuenfix it.,CVE-2024-49859,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbpf: Fix helper writes to read-only mapsnnLonial found an issue that despite user- and BPF-side frozen BPF mapn(like in case of .rodata) it was still possible to write into it fromna BPF program side through specific helpers having ARG_PTR_TO_{LONGINT}nas arguments.nnIn check_func_arg() when the argument is as mentioned the meta->raw_modenis never set. Later check_helper_mem_access() under the case ofnPTR_TO_MAP_VALUE as register base type it assumes BPF_READ for thensubsequent call to check_map_access_type() and given the BPF map isnread-only it succeeds.nnThe helpers really need to be annotated as ARG_PTR_TO_{LONGINT} | MEM_UNINITnwhen results are written into them as opposed to read out of them. Thenlatter indicates that it's okay to pass a pointer to uninitialized memorynas the memory is written to anyway.nnHowever ARG_PTR_TO_{LONGINT} is a special case of ARG_PTR_TO_FIXED_SIZE_MEMnjust with additional alignment requirement. So it is better to just getnrid of the ARG_PTR_TO_{LONGINT} special cases altogether and reuse thenfixed size memory types. For this add MEM_ALIGNED to additionally ensurenalignment given these helpers write directly into the args via *<ptr> = val.nThe .arg*_size has been initialized reflecting the actual sizeof(*<ptr>).nnMEM_ALIGNED can only be used in combination with MEM_FIXED_SIZE annotatednargument types since in !MEM_FIXED_SIZE cases the verifier does not knownthe buffer size a priori and therefore cannot blindly write *<ptr> = val.,CVE-2024-49861,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnscsi: lpfc: Validate hdwq pointers before dereferencing in reset/errata pathsnnWhen the HBA is undergoing a reset or is handling an errata event NULL ptrndereference crashes may occur in routines such asnlpfc_sli_flush_io_rings() lpfc_dev_loss_tmo_callbk() ornlpfc_abort_handler().nnAdd NULL ptr checks before dereferencing hdwq pointers that may have beennfreed due to operations colliding with a reset or errata event handler.,CVE-2024-49891,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Check stream_status before it is usednn[WHAT & HOW]ndc_state_get_stream_status can return null and therefore null must benchecked before stream_status is used.nnThis fixes 1 NULL_RETURNS issue reported by Coverity.,CVE-2024-49893,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Check phantom_stream before it is usednndcn32_enable_phantom_stream can return null so returned valuenmust be checked before used.nnThis fixes 1 NULL_RETURNS issue reported by Coverity.,CVE-2024-49897,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Check null-initialized variablesnn[WHAT & HOW]ndrr_timing and subvp_pipe are initialized to null and they are notnalways assigned new values. It is necessary to check for null beforendereferencing.nnThis fixes 2 FORWARD_NULL issues reported by Coverity.,CVE-2024-49898,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Initialize denominators' default to 1nn[WHAT & HOW]nVariables used as denominators and maybe not assigned to other valuesnshould not be 0. Change their default to 1 so they are never 0.nnThis fixes 10 DIVIDE_BY_ZERO issues reported by Coverity.,CVE-2024-49899,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/msm/adreno: Assign msm_gpu->pdev earlier to avoid nullptrsnnThere are some cases such as the one uncovered by Commit 46d4efcccc68n(drm/msm/a6xx: Avoid a nullptr dereference when speedbin setting fails)nwherennmsm_gpu_cleanup() : platform_set_drvdata(gpu->pdev NULL);nnis called on gpu->pdev == NULL as the GPU device has not been fullyninitialized yet.nnTurns out that there's more than just the aforementioned path thatncauses this to happen (e.g. the case when there's speedbin data in thencatalog but opp-supported-hw is missing in DT).nnAssigning msm_gpu->pdev earlier seems like the least painful solutionnto this therefore do so.nnPatchwork: https://patchwork.freedesktop.org/patch/602742/,CVE-2024-49901,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Add null check for 'afb' in amdgpu_dm_plane_handle_cursor_update (v2)nnThis commit adds a null check for the 'afb' variable in thenamdgpu_dm_plane_handle_cursor_update function. Previously 'afb' wasnassumed to be null but was used later in the code without a null check.nThis could potentially lead to a null pointer dereference.nnChanges since v1:n- Moved the null check for 'afb' to the line where 'afb' is used. (Alex)nnFixes the below:ndrivers/gpu/drm/amd/amdgpu/../display/amdgpu_dm/amdgpu_dm_plane.c:1298 amdgpu_dm_plane_handle_cursor_update() error: we previously assumed 'afb' could be null (see line 1252),CVE-2024-49905,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Check null pointer before try to access itnn[why & how]nChange the order of the pipe_ctx->plane_state check to ensure thatnplane_state is not null before accessing it.,CVE-2024-49906,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Add null check for 'afb' in amdgpu_dm_update_cursor (v2)nnThis commit adds a null check for the 'afb' variable in thenamdgpu_dm_update_cursor function. Previously 'afb' was assumed to bennull at line 8388 but was used later in the code without a null check.nThis could potentially lead to a null pointer dereference.nnChanges since v1:n- Moved the null check for 'afb' to the line where 'afb' is used. (Alex)nnFixes the below:ndrivers/gpu/drm/amd/amdgpu/../display/amdgpu_dm/amdgpu_dm.c:8433 amdgpu_dm_update_cursor()nterror: we previously assumed 'afb' could be null (see line 8388),CVE-2024-49908,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Add NULL check for function pointer in dcn32_set_output_transfer_funcnnThis commit adds a null check for the set_output_gamma function pointernin the dcn32_set_output_transfer_func function. Previouslynset_output_gamma was being checked for null but then it was beingndereferenced without any null check. This could lead to a null pointerndereference if set_output_gamma is null.nnTo fix this we now ensure that set_output_gamma is not null beforendereferencing it. We do this by adding a null check for set_output_gammanbefore the call to set_output_gamma.,CVE-2024-49909,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Add NULL check for function pointer in dcn401_set_output_transfer_funcnnThis commit adds a null check for the set_output_gamma function pointernin the dcn401_set_output_transfer_func function. Previouslynset_output_gamma was being checked for null but then it was beingndereferenced without any null check. This could lead to a null pointerndereference if set_output_gamma is null.nnTo fix this we now ensure that set_output_gamma is not null beforendereferencing it. We do this by adding a null check for set_output_gammanbefore the call to set_output_gamma.,CVE-2024-49910,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Add NULL check for function pointer in dcn20_set_output_transfer_funcnnThis commit adds a null check for the set_output_gamma function pointernin the dcn20_set_output_transfer_func function. Previouslynset_output_gamma was being checked for null at line 1030 but then itnwas being dereferenced without any null check at line 1048. This couldnpotentially lead to a null pointer dereference error if set_output_gammanis null.nnTo fix this we now ensure that set_output_gamma is not null beforendereferencing it. We do this by adding a null check for set_output_gammanbefore the call to set_output_gamma at line 1048.,CVE-2024-49911,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Handle null 'stream_status' in 'planes_changed_for_existing_stream'nnThis commit adds a null check for 'stream_status' in the functionn'planes_changed_for_existing_stream'. Previously the code assumedn'stream_status' could be null but did not handle the case where it wasnactually null. This could lead to a null pointer dereference.nnReported by smatch:ndrivers/gpu/drm/amd/amdgpu/../display/dc/core/dc_resource.c:3784 planes_changed_for_existing_stream() error: we previously assumed 'stream_status' could be null (see line 3774),CVE-2024-49912,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Add null check for pipe_ctx->plane_state in dcn20_program_pipennThis commit addresses a null pointer dereference issue in then`dcn20_program_pipe` function. The issue could occur whenn`pipe_ctx->plane_state` is null.nnThe fix adds a check to ensure `pipe_ctx->plane_state` is not nullnbefore accessing. This prevents a null pointer dereference.nnReported by smatch:ndrivers/gpu/drm/amd/amdgpu/../display/dc/hwss/dcn20/dcn20_hwseq.c:1925 dcn20_program_pipe() error: we previously assumed 'pipe_ctx->plane_state' could be null (see line 1877),CVE-2024-49914,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Add NULL check for clk_mgr in dcn32_init_hwnnThis commit addresses a potential null pointer dereference issue in then`dcn32_init_hw` function. The issue could occur when `dc->clk_mgr` isnnull.nnThe fix adds a check to ensure `dc->clk_mgr` is not null beforenaccessing its functions. This prevents a potential null pointerndereference.nnReported by smatch:ndrivers/gpu/drm/amd/amdgpu/../display/dc/hwss/dcn32/dcn32_hwseq.c:961 dcn32_init_hw() error: we previously assumed 'dc->clk_mgr' could be null (see line 782),CVE-2024-49915,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Add NULL check for clk_mgr and clk_mgr->funcs in dcn401_init_hwnnThis commit addresses a potential null pointer dereference issue in then`dcn401_init_hw` function. The issue could occur when `dc->clk_mgr` orn`dc->clk_mgr->funcs` is null.nnThe fix adds a check to ensure `dc->clk_mgr` and `dc->clk_mgr->funcs` isnnot null before accessing its functions. This prevents a potential nullnpointer dereference.nnReported by smatch:ndrivers/gpu/drm/amd/amdgpu/../display/dc/hwss/dcn401/dcn401_hwseq.c:416 dcn401_init_hw() error: we previously assumed 'dc->clk_mgr' could be null (see line 225),CVE-2024-49916,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Add NULL check for clk_mgr and clk_mgr->funcs in dcn30_init_hwnnThis commit addresses a potential null pointer dereference issue in then`dcn30_init_hw` function. The issue could occur when `dc->clk_mgr` orn`dc->clk_mgr->funcs` is null.nnThe fix adds a check to ensure `dc->clk_mgr` and `dc->clk_mgr->funcs` isnnot null before accessing its functions. This prevents a potential nullnpointer dereference.nnReported by smatch:ndrivers/gpu/drm/amd/amdgpu/../display/dc/hwss/dcn30/dcn30_hwseq.c:789 dcn30_init_hw() error: we previously assumed 'dc->clk_mgr' could be null (see line 628),CVE-2024-49917,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Add null check for head_pipe in dcn32_acquire_idle_pipe_for_head_pipe_in_layernnThis commit addresses a potential null pointer dereference issue in then`dcn32_acquire_idle_pipe_for_head_pipe_in_layer` function. The issuencould occur when `head_pipe` is null.nnThe fix adds a check to ensure `head_pipe` is not null before assertingnit. If `head_pipe` is null the function returns NULL to prevent anpotential null pointer dereference.nnReported by smatch:ndrivers/gpu/drm/amd/amdgpu/../display/dc/resource/dcn32/dcn32_resource.c:2690 dcn32_acquire_idle_pipe_for_head_pipe_in_layer() error: we previously assumed 'head_pipe' could be null (see line 2681),CVE-2024-49918,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Add null check for head_pipe in dcn201_acquire_free_pipe_for_layernnThis commit addresses a potential null pointer dereference issue in then`dcn201_acquire_free_pipe_for_layer` function. The issue could occurnwhen `head_pipe` is null.nnThe fix adds a check to ensure `head_pipe` is not null before assertingnit. If `head_pipe` is null the function returns NULL to prevent anpotential null pointer dereference.nnReported by smatch:ndrivers/gpu/drm/amd/amdgpu/../display/dc/resource/dcn201/dcn201_resource.c:1016 dcn201_acquire_free_pipe_for_layer() error: we previously assumed 'head_pipe' could be null (see line 1010),CVE-2024-49919,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Check null pointers before multiple usesnn[WHAT & HOW]nPoniters such as stream_enc and dc->bw_vbios are null checked previouslynin the same function so Coverity warns implies that stream_enc andndc->bw_vbios might be null. They are used multiple times in thensubsequent code and need to be checked.nnThis fixes 10 FORWARD_NULL issues reported by Coverity.,CVE-2024-49920,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Check null pointers before usednn[WHAT & HOW]nPoniters such as dc->clk_mgr are null checked previously in the samenfunction so Coverity warns implies that dc->clk_mgr might be null.nAs a result these pointers need to be checked when used again.nnThis fixes 10 FORWARD_NULL issues reported by Coverity.,CVE-2024-49921,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Check null pointers before using themnn[WHAT & HOW]nThese pointers are null checked previously in the same functionnindicating they might be null as reported by Coverity. As a resultnthey need to be checked when used again.nnThis fixes 3 FORWARD_NULL issue reported by Coverity.,CVE-2024-49922,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Pass non-null to dcn20_validate_apply_pipe_split_flagsnn[WHAT & HOW]ndcn20_validate_apply_pipe_split_flags dereferences merge and thus itncannot be a null pointer. Let's pass a valid pointer to avoid nullndereference.nnThis fixes 2 FORWARD_NULL issues reported by Coverity.,CVE-2024-49923,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnfbdev: pxafb: Fix possible use after free in pxafb_task()nnIn the pxafb_probe function it calls the pxafb_init_fbinfo functionnafter which &fbi->task is associated with pxafb_task. Moreovernwithin this pxafb_init_fbinfo function the pxafb_blank functionnwithin the &pxafb_ops struct is capable of scheduling work.nnIf we remove the module which will call pxafb_remove to make cleanupnit will call unregister_framebuffer function which can callndo_unregister_framebuffer to free fbi->fb throughnput_fb_info(fb_info) while the work mentioned above will be used.nThe sequence of operations that may lead to a UAF bug is as follows:nnCPU0 CPU1nn | pxafb_tasknpxafb_remove |nunregister_framebuffer(info) |ndo_unregister_framebuffer(fb_info) |nput_fb_info(fb_info) |n// free fbi->fb | set_ctrlr_state(fbi state)n | __pxafb_lcd_power(fbi 0)n | fbi->lcd_power(on &fbi->fb.var)n | //use fbi->fbnnFix it by ensuring that the work is canceled before proceedingnwith the cleanup in pxafb_remove.nnNote that only root user can remove the driver at runtime.,CVE-2024-49924,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnfbdev: efifb: Register sysfs groups through driver corennThe driver core can register and cleanup sysfs groups already.nMake use of that functionality to simplify the error handling andncleanup.nnAlso avoid a UAF race during unregistering where the sysctl attributesnwere usable after the info struct was freed.,CVE-2024-49925,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnrcu-tasks: Fix access non-existent percpu rtpcp variable in rcu_tasks_need_gpcb()nnFor kernels built with CONFIG_FORCE_NR_CPUS=y the nr_cpu_ids isndefined as NR_CPUS instead of the number of possible cpus thisnwill cause the following system panic:nnsmpboot: Allowing 4 CPUs 0 hotplug CPUsn...nsetup_percpu: NR_CPUS:512 nr_cpumask_bits:512 nr_cpu_ids:512 nr_node_ids:1n...nBUG: unable to handle page fault for address: ffffffff9911c8c8nOops: 0000 [#1] PREEMPT SMP PTInCPU: 0 PID: 15 Comm: rcu_tasks_trace Tainted: G Wn6.6.21 #1 5dc7acf91a5e8e9ac9dcfc35bee0245691283ea6nRIP: 0010:rcu_tasks_need_gpcb+0x25d/0x2c0nRSP: 0018:ffffa371c00a3e60 EFLAGS: 00010082nCR2: ffffffff9911c8c8 CR3: 000000040fa20005 CR4: 00000000001706f0nCall Trace:n<TASK>n? __die+0x23/0x80n? page_fault_oops+0xa4/0x180n? exc_page_fault+0x152/0x180n? asm_exc_page_fault+0x26/0x40n? rcu_tasks_need_gpcb+0x25d/0x2c0n? __pfx_rcu_tasks_kthread+0x40/0x40nrcu_tasks_one_gp+0x69/0x180nrcu_tasks_kthread+0x94/0xc0nkthread+0xe8/0x140n? __pfx_kthread+0x40/0x40nret_from_fork+0x34/0x80n? __pfx_kthread+0x40/0x40nret_from_fork_asm+0x1b/0x80n</TASK>nnConsidering that there may be holes in the CPU numbers use thenmaximum possible cpu number instead of nr_cpu_ids for configuringnenqueue and dequeue limits.nn[ neeraj.upadhyay: Fix htmldocs build error reported by Stephen Rothwell ],CVE-2024-49926,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnx86/ioapic: Handle allocation failures gracefullynnBreno observed panics when using failslab under certain conditions duringnruntime:nn can not alloc irq_pin_list (-1020)n Kernel panic - not syncing: IO-APIC: failed to add irq-pin. Can not proceednn panic+0x4e9/0x590n mp_irqdomain_alloc+0x9ab/0xa80n irq_domain_alloc_irqs_locked+0x25d/0x8d0n __irq_domain_alloc_irqs+0x80/0x110n mp_map_pin_to_irq+0x645/0x890n acpi_register_gsi_ioapic+0xe6/0x150n hpet_open+0x313/0x480nnThat's a pointless panic which is a leftover of the historic IO/APIC codenwhich panic'ed during early boot when the interrupt allocation failed.nnThe only place which might justify panic is the PIT/HPET timer_check() codenwhich tries to figure out whether the timer interrupt is delivered throughnthe IO/APIC. But that code does not require to handle interrupt allocationnfailures. If the interrupt cannot be allocated then timer delivery failsnand it either panics due to that or falls back to legacy mode.nnCure this by removing the panic wrapper around __add_pin_to_irq_node() andnmaking mp_irqdomain_alloc() aware of the failure condition and handle it asnany other failure in this function gracefully.,CVE-2024-49927,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnwifi: iwlwifi: mvm: avoid NULL pointer dereferencenniwl_mvm_tx_skb_sta() and iwl_mvm_tx_mpdu() verify that the mvmvstanpointer is not NULL.nIt retrieves this pointer using iwl_mvm_sta_from_mac80211 which isndereferencing the ieee80211_sta pointer.nIf sta is NULL iwl_mvm_sta_from_mac80211 will dereference a NULLnpointer.nFix this by checking the sta pointer before retrieving the mvmstanfrom it. If sta is not NULL then mvmsta isn't either.,CVE-2024-49929,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbtrfs: don't readahead the relocation inode on RSTnnOn relocation we're doing readahead on the relocation inode but if thenfilesystem is backed by a RAID stripe tree we can get ENOENT (e.g. due tonpreallocated extents not being mapped in the RST) from the lookup.nnBut readahead doesn't handle the error and submits invalid reads to thendevice causing an assertion in the scatter-gather list code:nn BTRFS info (device nvme1n1): balance: start -d -m -sn BTRFS info (device nvme1n1): relocating block group 6480920576 flags data|raid0n BTRFS error (device nvme1n1): cannot find raid-stripe for logical [6481928192 6481969152] devid 2 profile raid0n ------------[ cut here ]------------n kernel BUG at include/linux/scatterlist.h:115!n Oops: invalid opcode: 0000 [#1] PREEMPT SMP PTIn CPU: 0 PID: 1012 Comm: btrfs Not tainted 6.10.0-rc7+ #567n RIP: 0010:__blk_rq_map_sg+0x339/0x4a0n RSP: 0018:ffffc90001a43820 EFLAGS: 00010202n RAX: 0000000000000000 RBX: 0000000000000000 RCX: ffffea00045d4802n RDX: 0000000117520000 RSI: 0000000000000000 RDI: ffff8881027d1000n RBP: 0000000000003000 R08: ffffea00045d4902 R09: 0000000000000000n R10: 0000000000000000 R11: 0000000000001000 R12: ffff8881003d10b8n R13: ffffc90001a438f0 R14: 0000000000000000 R15: 0000000000003000n FS: 00007fcc048a6900(0000) GS:ffff88813bc00000(0000) knlGS:0000000000000000n CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033n CR2: 000000002cd11000 CR3: 00000001109ea001 CR4: 0000000000370eb0n Call Trace:n <TASK>n ? __die_body.cold+0x14/0x25n ? die+0x2e/0x50n ? do_trap+0xca/0x110n ? do_error_trap+0x65/0x80n ? __blk_rq_map_sg+0x339/0x4a0n ? exc_invalid_op+0x50/0x70n ? __blk_rq_map_sg+0x339/0x4a0n ? asm_exc_invalid_op+0x1a/0x20n ? __blk_rq_map_sg+0x339/0x4a0n nvme_prep_rq.part.0+0x9d/0x770n nvme_queue_rq+0x7d/0x1e0n __blk_mq_issue_directly+0x2a/0x90n ? blk_mq_get_budget_and_tag+0x61/0x90n blk_mq_try_issue_list_directly+0x56/0xf0n blk_mq_flush_plug_list.part.0+0x52b/0x5d0n __blk_flush_plug+0xc6/0x110n blk_finish_plug+0x28/0x40n read_pages+0x160/0x1c0n page_cache_ra_unbounded+0x109/0x180n relocate_file_extent_cluster+0x611/0x6a0n ? btrfs_search_slot+0xba4/0xd20n ? balance_dirty_pages_ratelimited_flags+0x26/0xb00n relocate_data_extent.constprop.0+0x134/0x160n relocate_block_group+0x3f2/0x500n btrfs_relocate_block_group+0x250/0x430n btrfs_relocate_chunk+0x3f/0x130n btrfs_balance+0x71b/0xef0n ? kmalloc_trace_noprof+0x13b/0x280n btrfs_ioctl+0x2c2e/0x3030n ? kvfree_call_rcu+0x1e6/0x340n ? list_lru_add_obj+0x66/0x80n ? mntput_no_expire+0x3a/0x220n __x64_sys_ioctl+0x96/0xc0n do_syscall_64+0x54/0x110n entry_SYSCALL_64_after_hwframe+0x76/0x7en RIP: 0033:0x7fcc04514f9bn Code: Unable to access opcode bytes at 0x7fcc04514f71.n RSP: 002b:00007ffeba923370 EFLAGS: 00000246 ORIG_RAX: 0000000000000010n RAX: ffffffffffffffda RBX: 0000000000000003 RCX: 00007fcc04514f9bn RDX: 00007ffeba923460 RSI: 00000000c4009420 RDI: 0000000000000003n RBP: 0000000000000000 R08: 0000000000000013 R09: 0000000000000001n R10: 00007fcc043fbba8 R11: 0000000000000246 R12: 00007ffeba924fc5n R13: 00007ffeba923460 R14: 0000000000000002 R15: 00000000004d4bb0n </TASK>n Modules linked in:n ---[ end trace 0000000000000000 ]---n RIP: 0010:__blk_rq_map_sg+0x339/0x4a0n RSP: 0018:ffffc90001a43820 EFLAGS: 00010202n RAX: 0000000000000000 RBX: 0000000000000000 RCX: ffffea00045d4802n RDX: 0000000117520000 RSI: 0000000000000000 RDI: ffff8881027d1000n RBP: 0000000000003000 R08: ffffea00045d4902 R09: 0000000000000000n R10: 0000000000000000 R11: 0000000000001000 R12: ffff8881003d10b8n R13: ffffc90001a438f0 R14: 0000000000000000 R15: 0000000000003000n FS: 00007fcc048a6900(0000) GS:ffff88813bc00000(0000) knlGS:0000000000000000n CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033n CR2: 00007fcc04514f71 CR3: 00000001109ea001 CR4: 0000000000370eb0n Kernel pn---truncated---,CVE-2024-49932,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnfs/inode: Prevent dump_mapping() accessing invalid dentry.d_name.namennIt's observed that a crash occurs during hot-remove a memory devicenin which user is accessing the hugetlb. See calltrace as following:nn------------[ cut here ]------------nWARNING: CPU: 1 PID: 14045 at arch/x86/mm/fault.c:1278 do_user_addr_fault+0x2a0/0x790nModules linked in: kmem device_dax cxl_mem cxl_pmem cxl_port cxl_pci dax_hmem dax_pmem nd_pmem cxl_acpi nd_btt cxl_core crc32c_intel nvme virtiofs fuse nvme_core nfit libnvdimm dm_multipath scsi_dh_rdac scsi_dh_emc snmirror dm_region_hash dm_log dm_modnCPU: 1 PID: 14045 Comm: daxctl Not tainted 6.10.0-rc2-lizhijian+ #492nHardware name: QEMU Standard PC (Q35 + ICH9 2009) BIOS rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org 04/01/2014nRIP: 0010:do_user_addr_fault+0x2a0/0x790nCode: 48 8b 00 a8 04 0f 84 b5 fe ff ff e9 1c ff ff ff 4c 89 e9 4c 89 e2 be 01 00 00 00 bf 02 00 00 00 e8 b5 ef 24 00 e9 42 fe ff ff <0f> 0b 48 83 c4 08 4c 89 ea 48 89 ee 4c 89 e7 5b 5d 41 5c 41 5d 41nRSP: 0000:ffffc90000a575f0 EFLAGS: 00010046nRAX: ffff88800c303600 RBX: 0000000000000000 RCX: 0000000000000000nRDX: 0000000000001000 RSI: ffffffff82504162 RDI: ffffffff824b2c36nRBP: 0000000000000000 R08: 0000000000000000 R09: 0000000000000000nR10: 0000000000000000 R11: 0000000000000000 R12: ffffc90000a57658nR13: 0000000000001000 R14: ffff88800bc2e040 R15: 0000000000000000nFS: 00007f51cb57d880(0000) GS:ffff88807fd00000(0000) knlGS:0000000000000000nCS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033nCR2: 0000000000001000 CR3: 00000000072e2004 CR4: 00000000001706f0nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400nCall Trace:n <TASK>n ? __warn+0x8d/0x190n ? do_user_addr_fault+0x2a0/0x790n ? report_bug+0x1c3/0x1d0n ? handle_bug+0x3c/0x70n ? exc_invalid_op+0x14/0x70n ? asm_exc_invalid_op+0x16/0x20n ? do_user_addr_fault+0x2a0/0x790n ? exc_page_fault+0x31/0x200n exc_page_fault+0x68/0x200n<...snip...>nBUG: unable to handle page fault for address: 0000000000001000n #PF: supervisor read access in kernel moden #PF: error_code(0x0000) - not-present pagen PGD 800000000ad92067 P4D 800000000ad92067 PUD 7677067 PMD 0n Oops: Oops: 0000 [#1] PREEMPT SMP PTIn ---[ end trace 0000000000000000 ]---n BUG: unable to handle page fault for address: 0000000000001000n #PF: supervisor read access in kernel moden #PF: error_code(0x0000) - not-present pagen PGD 800000000ad92067 P4D 800000000ad92067 PUD 7677067 PMD 0n Oops: Oops: 0000 [#1] PREEMPT SMP PTIn CPU: 1 PID: 14045 Comm: daxctl Kdump: loaded Tainted: G W 6.10.0-rc2-lizhijian+ #492n Hardware name: QEMU Standard PC (Q35 + ICH9 2009) BIOS rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org 04/01/2014n RIP: 0010:dentry_name+0x1f4/0x440n<...snip...>n? dentry_name+0x2fa/0x440nvsnprintf+0x1f3/0x4f0nvprintk_store+0x23a/0x540nvprintk_emit+0x6d/0x330n_printk+0x58/0x80ndump_mapping+0x10b/0x1a0n? __pfx_free_object_rcu+0x10/0x10n__dump_page+0x26b/0x3e0n? vprintk_emit+0xe0/0x330n? _printk+0x58/0x80n? dump_page+0x17/0x50ndump_page+0x17/0x50ndo_migrate_range+0x2f7/0x7f0n? do_migrate_range+0x42/0x7f0n? offline_pages+0x2f4/0x8c0noffline_pages+0x60a/0x8c0nmemory_subsys_offline+0x9f/0x1c0n? lockdep_hardirqs_on+0x77/0x100n? _raw_spin_unlock_irqrestore+0x38/0x60ndevice_offline+0xe3/0x110nstate_store+0x6e/0xc0nkernfs_fop_write_iter+0x143/0x200nvfs_write+0x39f/0x560nksys_write+0x65/0xf0ndo_syscall_64+0x62/0x130nnPreviously some sanity check have been done in dump_mapping() beforenthe print facility parsing '%pd' though it's still possible to run intonan invalid dentry.d_name.name.nnSince dump_mapping() only needs to dump the filename only retrieve itnby itself in a safer way to prevent an unnecessary crash.nnNote that either retrieving the filename with '%pd' ornstrncpy_from_kernel_nofault() the filename could be unreliable.,CVE-2024-49934,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnACPI: PAD: fix crash in exit_round_robin()nnThe kernel occasionally crashes in cpumask_clear_cpu() which is callednwithin exit_round_robin() because when executing clear_bit(nr addr) withnnr set to 0xffffffff the address calculation may cause misalignment withinnthe memory leading to access to an invalid memory address.nn----------nBUG: unable to handle kernel paging request at ffffffffe0740618n ...nCPU: 3 PID: 2919323 Comm: acpi_pad/14 Kdump: loaded Tainted: G OE X --------- - - 4.18.0-425.19.2.el8_7.x86_64 #1n ...nRIP: 0010:power_saving_thread+0x313/0x411 [acpi_pad]nCode: 89 cd 48 89 d3 eb d1 48 c7 c7 55 70 72 c0 e8 64 86 b0 e4 c6 05 0d a1 02 00 01 e9 bc fd ff ff 45 89 e4 42 8b 04 a5 20 82 72 c0 <f0> 48 0f b3 05 f4 9c 01 00 42 c7 04 a5 20 82 72 c0 ff ff ff ff 31nRSP: 0018:ff72a5d51fa77ec8 EFLAGS: 00010202nRAX: 00000000ffffffff RBX: ff462981e5d8cb80 RCX: 0000000000000000nRDX: 0000000000000000 RSI: 0000000000000246 RDI: 0000000000000246nRBP: ff46297556959d80 R08: 0000000000000382 R09: ff46297c8d0f38d8nR10: 0000000000000000 R11: 0000000000000001 R12: 000000000000000enR13: 0000000000000000 R14: ffffffffffffffff R15: 000000000000000enFS: 0000000000000000(0000) GS:ff46297a800c0000(0000) knlGS:0000000000000000nCS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033nCR2: ffffffffe0740618 CR3: 0000007e20410004 CR4: 0000000000771ee0nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400nPKRU: 55555554nCall Trace:n ? acpi_pad_add+0x120/0x120 [acpi_pad]n kthread+0x10b/0x130n ? set_kthread_struct+0x50/0x50n ret_from_fork+0x1f/0x40n ...nCR2: ffffffffe0740618nncrash> dis -lr ffffffffc0726923n ...n/usr/src/debug/kernel-4.18.0-425.19.2.el8_7/linux-4.18.0-425.19.2.el8_7.x86_64/./include/linux/cpumask.h: 114n0xffffffffc0726918 <power_saving_thread+776>:tmov %r12d%r12dn/usr/src/debug/kernel-4.18.0-425.19.2.el8_7/linux-4.18.0-425.19.2.el8_7.x86_64/./include/linux/cpumask.h: 325n0xffffffffc072691b <power_saving_thread+779>:tmov -0x3f8d7de0(%r124)%eaxn/usr/src/debug/kernel-4.18.0-425.19.2.el8_7/linux-4.18.0-425.19.2.el8_7.x86_64/./arch/x86/include/asm/bitops.h: 80n0xffffffffc0726923 <power_saving_thread+787>:tlock btr %rax0x19cf4(%rip) # 0xffffffffc0740620 <pad_busy_cpus_bits>nncrash> px tsk_in_cpu[14]n$66 = 0xffffffffnncrash> px 0xffffffffc072692c+0x19cf4n$99 = 0xffffffffc0740620nncrash> sym 0xffffffffc0740620nffffffffc0740620 (b) pad_busy_cpus_bits [acpi_pad]nncrash> px pad_busy_cpus_bits[0]n$42 = 0xfffc0n----------nnTo fix this ensure that tsk_in_cpu[tsk_index] != -1 before callingncpumask_clear_cpu() in exit_round_robin() just as it is done innround_robin_cpu().nn[ rjw: Subject edit avoid updates to the same value ],CVE-2024-49935,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnwifi: cfg80211: Set correct chandef when starting CACnnWhen starting CAC in a mode other than AP mode it return anWARNING: CPU: 0 PID: 63 at cfg80211_chandef_dfs_usable+0x20/0xaf [cfg80211]ncaused by the chandef.chan being null at the end of CAC.nnSolution: Ensure the channel definition is set for the different modesnwhen starting CAC to avoid getting a NULL 'chan' at the end of CAC.nn Call Trace:n ? show_regs.part.0+0x14/0x16n ? __warn+0x67/0xc0n ? cfg80211_chandef_dfs_usable+0x20/0xaf [cfg80211]n ? report_bug+0xa7/0x130n ? exc_overflow+0x30/0x30n ? handle_bug+0x27/0x50n ? exc_invalid_op+0x18/0x60n ? handle_exception+0xf6/0xf6n ? exc_overflow+0x30/0x30n ? cfg80211_chandef_dfs_usable+0x20/0xaf [cfg80211]n ? exc_overflow+0x30/0x30n ? cfg80211_chandef_dfs_usable+0x20/0xaf [cfg80211]n ? regulatory_propagate_dfs_state.cold+0x1b/0x4c [cfg80211]n ? cfg80211_propagate_cac_done_wk+0x1a/0x30 [cfg80211]n ? process_one_work+0x165/0x280n ? worker_thread+0x120/0x3f0n ? kthread+0xc2/0xf0n ? process_one_work+0x280/0x280n ? kthread_complete_and_exit+0x20/0x20n ? ret_from_fork+0x19/0x24nn[shorten subject remove OCB reorder cases to match previous list],CVE-2024-49937,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnl2tp: prevent possible tunnel refcount underflownnWhen a session is created it sets a backpointer to its tunnel. Whennthe session refcount drops to 0 l2tp_session_free drops the tunnelnrefcount if session->tunnel is non-NULL. However session->tunnel isnset in l2tp_session_create before the tunnel refcount is incrementednby l2tp_session_register which leaves a small window wherensession->tunnel is non-NULL when the tunnel refcount hasn't beennbumped.nnMoving the assignment to l2tp_session_register is trivial butnl2tp_session_create calls l2tp_session_set_header_len which usesnsession->tunnel to get the tunnel's encap. Add an encap arg tonl2tp_session_set_header_len to avoid using session->tunnel.nnIf l2tpv3 sessions have colliding IDs it is possible fornl2tp_v3_session_get to race with l2tp_session_register and fetch ansession which doesn't yet have session->tunnel set. Add a check fornthis case.,CVE-2024-49940,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet/ncsi: Disable the ncsi work before freeing the associated structurennThe work function can run after the ncsi device is freed resultingnin use-after-free bugs or kernel panic.,CVE-2024-49945,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnBluetooth: L2CAP: Fix uaf in l2cap_connectnn[Syzbot reported]nBUG: KASAN: slab-use-after-free in l2cap_connect.constprop.0+0x10d8/0x1270 net/bluetooth/l2cap_core.c:3949nRead of size 8 at addr ffff8880241e9800 by task kworker/u9:0/54nnCPU: 0 UID: 0 PID: 54 Comm: kworker/u9:0 Not tainted 6.11.0-rc6-syzkaller-00268-g788220eee30d #0nHardware name: Google Google Compute Engine/Google Compute Engine BIOS Google 08/06/2024nWorkqueue: hci2 hci_rx_worknCall Trace:n <TASK>n __dump_stack lib/dump_stack.c:93 [inline]n dump_stack_lvl+0x116/0x1f0 lib/dump_stack.c:119n print_address_description mm/kasan/report.c:377 [inline]n print_report+0xc3/0x620 mm/kasan/report.c:488n kasan_report+0xd9/0x110 mm/kasan/report.c:601n l2cap_connect.constprop.0+0x10d8/0x1270 net/bluetooth/l2cap_core.c:3949n l2cap_connect_req net/bluetooth/l2cap_core.c:4080 [inline]n l2cap_bredr_sig_cmd net/bluetooth/l2cap_core.c:4772 [inline]n l2cap_sig_channel net/bluetooth/l2cap_core.c:5543 [inline]n l2cap_recv_frame+0xf0b/0x8eb0 net/bluetooth/l2cap_core.c:6825n l2cap_recv_acldata+0x9b4/0xb70 net/bluetooth/l2cap_core.c:7514n hci_acldata_packet net/bluetooth/hci_core.c:3791 [inline]n hci_rx_work+0xaab/0x1610 net/bluetooth/hci_core.c:4028n process_one_work+0x9c5/0x1b40 kernel/workqueue.c:3231n process_scheduled_works kernel/workqueue.c:3312 [inline]n worker_thread+0x6c8/0xed0 kernel/workqueue.c:3389n kthread+0x2c1/0x3a0 kernel/kthread.c:389n ret_from_fork+0x45/0x80 arch/x86/kernel/process.c:147n ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244n...nnFreed by task 5245:n kasan_save_stack+0x33/0x60 mm/kasan/common.c:47n kasan_save_track+0x14/0x30 mm/kasan/common.c:68n kasan_save_free_info+0x3b/0x60 mm/kasan/generic.c:579n poison_slab_object+0xf7/0x160 mm/kasan/common.c:240n __kasan_slab_free+0x32/0x50 mm/kasan/common.c:256n kasan_slab_free include/linux/kasan.h:184 [inline]n slab_free_hook mm/slub.c:2256 [inline]n slab_free mm/slub.c:4477 [inline]n kfree+0x12a/0x3b0 mm/slub.c:4598n l2cap_conn_free net/bluetooth/l2cap_core.c:1810 [inline]n kref_put include/linux/kref.h:65 [inline]n l2cap_conn_put net/bluetooth/l2cap_core.c:1822 [inline]n l2cap_conn_del+0x59d/0x730 net/bluetooth/l2cap_core.c:1802n l2cap_connect_cfm+0x9e6/0xf80 net/bluetooth/l2cap_core.c:7241n hci_connect_cfm include/net/bluetooth/hci_core.h:1960 [inline]n hci_conn_failed+0x1c3/0x370 net/bluetooth/hci_conn.c:1265n hci_abort_conn_sync+0x75a/0xb50 net/bluetooth/hci_sync.c:5583n abort_conn_sync+0x197/0x360 net/bluetooth/hci_conn.c:2917n hci_cmd_sync_work+0x1a4/0x410 net/bluetooth/hci_sync.c:328n process_one_work+0x9c5/0x1b40 kernel/workqueue.c:3231n process_scheduled_works kernel/workqueue.c:3312 [inline]n worker_thread+0x6c8/0xed0 kernel/workqueue.c:3389n kthread+0x2c1/0x3a0 kernel/kthread.c:389n ret_from_fork+0x45/0x80 arch/x86/kernel/process.c:147n ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244,CVE-2024-49950,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnstatic_call: Replace pointless WARN_ON() in static_call_module_notify()nnstatic_call_module_notify() triggers a WARN_ON() when memory allocationnfails in __static_call_add_module().nnThat's not really justified because the failure case must be correctlynhandled by the well known call chain and the error code is passednthrough to the initiating userspace application.nnA memory allocation fail is not a fatal problem but the WARN_ON() takesnthe machine out when panic_on_warn is set.nnReplace it with a pr_warn().,CVE-2024-49954,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnext4: fix timer use-after-free on failed mountnnSyzbot has found an ODEBUG bug in ext4_fill_supernnThe del_timer_sync function cancels the s_err_report timernwhich reminds about filesystem errors daily. We shouldnguarantee the timer is no longer active before kfree(sbi).nnWhen filesystem mounting fails the flow goes to failed_mount3nwhere an error occurs when ext4_stop_mmpd is called causingna read I/O failure. This triggers the ext4_handle_error functionnthat ultimately re-arms the timernleaving the s_err_report timer active before kfree(sbi) is called.nnFix the issue by canceling the s_err_report timer after calling ext4_stop_mmpd.,CVE-2024-49960,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnext4: filesystems without casefold feature cannot be mounted with siphashnnWhen mounting the ext4 filesystem if the default hash version is set tonDX_HASH_SIPHASH but the casefold feature is not set exit the mounting.,CVE-2024-49968,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Implement bounds check for stream encoder creation in DCN401nn'stream_enc_regs' array is an array of dcn10_stream_enc_registersnstructures. The array is initialized with four elements correspondingnto the four calls to stream_enc_regs() in the array initializer. Thisnmeans that valid indices for this array are 0 1 2 and 3.nnThe error message 'stream_enc_regs' 4 <= 5 below is indicating thatnthere is an attempt to access this array with an index of 5 which isnout of bounds. This could lead to undefined behaviornnHere eng_id is used as an index to access the stream_enc_regs array. Ifneng_id is 5 this would result in an out-of-bounds access on thenstream_enc_regs array.nnThus fixing Buffer overflow error in dcn401_stream_encoder_creatennFound by smatch:ndrivers/gpu/drm/amd/amdgpu/../display/dc/resource/dcn401/dcn401_resource.c:1209 dcn401_stream_encoder_create() error: buffer overflow 'stream_enc_regs' 4 <= 5,CVE-2024-49970,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Deallocate DML memory if allocation failsnn[Why]nWhen DC state create DML memory allocation fails memory is notndeallocated subsequently resulting in uninitialized structurenthat is not NULL.nn[How]nDeallocate memory if DML memory allocation fails.,CVE-2024-49972,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nngso: fix udp gso fraglist segmentation after pull from frag_listnnDetect gso fraglist skbs with corrupted geometry (see below) andnpass these to skb_segment instead of skb_segment_list as the firstncan segment them correctly.nnValid SKB_GSO_FRAGLIST skbsn- consist of two or more segmentsn- the head_skb holds the protocol headers plus first gso_sizen- one or more frag_list skbs hold exactly one segmentn- all but the last must be gso_sizennOptional datapath hooks such as NAT and BPF (bpf_skb_pull_data) cannmodify these skbs breaking these invariants.nnIn extreme cases they pull all data into skb linear. For UDP thisncauses a NULL ptr deref in __udpv4_gso_segment_list_csum atnudp_hdr(seg->next)->dest.nnDetect invalid geometry due to pull by checking head_skb size.nDon't just drop as this may blackhole a destination. Convert to benable to pass to regular skb_segment.,CVE-2024-49978,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbpftool: Fix undefined behavior in qsort(NULL 0 ...)nnWhen netfilter has no entry to display qsort is called withnqsort(NULL 0 ...). This results in undefined behavior as UBSannreports:nnnet.c:827:2: runtime error: null pointer passed as argument 1 which is declared to never be nullnnAlthough the C standard does not explicitly state whether calling qsortnwith a NULL pointer when the size is 0 constitutes undefined behaviornSection 7.1.4 of the C standard (Use of library functions) mentions:nnEach of the following statements applies unless explicitly statednotherwise in the detailed descriptions that follow: If an argument to anfunction has an invalid value (such as a value outside the domain ofnthe function or a pointer outside the address space of the program orna null pointer or a pointer to non-modifiable storage when thencorresponding parameter is not const-qualified) or a type (afternpromotion) not expected by a function with variable number ofnarguments the behavior is undefined.nnTo avoid this add an early return when nf_link_info is NULL to preventncalling qsort with a NULL pointer.,CVE-2024-49987,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: fix double free issue during amdgpu module unloadnnFlexible endpoints use DIGs from available inflexible endpointsnso only the encoders of inflexible links need to be freed.nOtherwise a double free issue may occur when unloading thenamdgpu module.nn[ 279.190523] RIP: 0010:__slab_free+0x152/0x2f0n[ 279.190577] Call Trace:n[ 279.190580] <TASK>n[ 279.190582] ? show_regs+0x69/0x80n[ 279.190590] ? die+0x3b/0x90n[ 279.190595] ? do_trap+0xc8/0xe0n[ 279.190601] ? do_error_trap+0x73/0xa0n[ 279.190605] ? __slab_free+0x152/0x2f0n[ 279.190609] ? exc_invalid_op+0x56/0x70n[ 279.190616] ? __slab_free+0x152/0x2f0n[ 279.190642] ? asm_exc_invalid_op+0x1f/0x30n[ 279.190648] ? dcn10_link_encoder_destroy+0x19/0x30 [amdgpu]n[ 279.191096] ? __slab_free+0x152/0x2f0n[ 279.191102] ? dcn10_link_encoder_destroy+0x19/0x30 [amdgpu]n[ 279.191469] kfree+0x260/0x2b0n[ 279.191474] dcn10_link_encoder_destroy+0x19/0x30 [amdgpu]n[ 279.191821] link_destroy+0xd7/0x130 [amdgpu]n[ 279.192248] dc_destruct+0x90/0x270 [amdgpu]n[ 279.192666] dc_destroy+0x19/0x40 [amdgpu]n[ 279.193020] amdgpu_dm_fini+0x16e/0x200 [amdgpu]n[ 279.193432] dm_hw_fini+0x26/0x40 [amdgpu]n[ 279.193795] amdgpu_device_fini_hw+0x24c/0x400 [amdgpu]n[ 279.194108] amdgpu_driver_unload_kms+0x4f/0x70 [amdgpu]n[ 279.194436] amdgpu_pci_remove+0x40/0x80 [amdgpu]n[ 279.194632] pci_device_remove+0x3a/0xa0n[ 279.194638] device_remove+0x40/0x70n[ 279.194642] device_release_driver_internal+0x1ad/0x210n[ 279.194647] driver_detach+0x4e/0xa0n[ 279.194650] bus_remove_driver+0x6f/0xf0n[ 279.194653] driver_unregister+0x33/0x60n[ 279.194657] pci_unregister_driver+0x44/0x90n[ 279.194662] amdgpu_exit+0x19/0x1f0 [amdgpu]n[ 279.194939] __do_sys_delete_module.isra.0+0x198/0x2f0n[ 279.194946] __x64_sys_delete_module+0x16/0x20n[ 279.194950] do_syscall_64+0x58/0x120n[ 279.194954] entry_SYSCALL_64_after_hwframe+0x6e/0x76n[ 279.194980] </TASK>,CVE-2024-49989,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amdkfd: amdkfd_free_gtt_mem clear the correct pointernnPass pointer reference to amdgpu_bo_unref to clear the correct pointernotherwise amdgpu_bo_unref clear the local variable the original pointernnot set to NULL this could cause use-after-free bug.,CVE-2024-49991,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/stm: Avoid use-after-free issues with crtc and planennltdc_load() calls functions drm_crtc_init_with_planes()ndrm_universal_plane_init() and drm_encoder_init(). These functionsnshould not be called with parameters allocated with devm_kzalloc()nto avoid use-after-free issues [1].nnUse allocations managed by the DRM framework.nnFound by Linux Verification Center (linuxtesting.org).nn[1]nhttps://lore.kernel.org/lkml/u366i76e3qhh3ra5oxrtngjtm2u5lterkekcz6y2jkndhuxzli@diujon4h7qwb/,CVE-2024-49992,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet: ethernet: lantiq_etop: fix memory disclosurennWhen applying padding the buffer is not zeroed which results in memoryndisclosure. The mentioned data is observed on the wire. This patch usesnskb_put_padto() to pad Ethernet frames properly. The mentioned functionnzeroes the expanded buffer.nnIn case the packet cannot be padded it is silently dropped. Statisticsnare also not incremented. This driver does not support statistics in thenold 32-bit format or the new 64-bit format. These will be added in thenfuture. In its current form the patch should be easily backported tonstable versions.nnEthernet MACs on Amazon-SE and Danube cannot do padding of the packetsnin hardware so software padding must be applied.,CVE-2024-49997,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnstatic_call: Handle module init failure correctly in static_call_del_module()nnModule insertion invokes static_call_add_module() to initialize the staticncalls in a module. static_call_add_module() invokes __static_call_init()nwhich allocates a struct static_call_mod to either encapsulate the built-innstatic call sites of the associated key into it so further modules can benadded or to append the module to the module chain.nnIf that allocation fails the function returns with an error code and thenmodule core invokes static_call_del_module() to clean up eventually addednstatic_call_mod entries.nnThis works correctly when all keys used by the module were converted overnto a module chain before the failure. If not then static_call_del_module()ncauses a #GP as it blindly assumes that key::mods points to a valid structnstatic_call_mod.nnThe problem is that key::mods is not a individual struct member of structnstatic_call_key it's part of a union to save space:nn union {n /bin /boot /config /dev /etc /home /lib /media /mnt /opt /proc /root /run /sbin /shared /srv /sys /tmp /usr /utils /var bit 0: 0 = mods 1 = sites */n unsigned long type;n struct static_call_mod *mods;n struct static_call_site *sites;nt};nnkey::sites is a pointer to the list of built-in usage sites of the staticncall. The type of the pointer is differentiated by bit 0. A mods pointernhas the bit clear the sites pointer has the bit set.nnAs static_call_del_module() blidly assumes that the pointer is a validnstatic_call_mod type it fails to check for this failure case andndereferences the pointer to the list of built-in call sites which isnobviously bogus.nnCure it by checking whether the key has a sites or a mods pointer.nnIf it's a sites pointer then the key is not to be touched. As the sites arenwalked in the same order as in __static_call_init() the site walk can benterminated because all subsequent sites have not been touched by the initncode due to the error exit.nnIf it was converted before the allocation fail then the inner loop whichnsearches for a module match will find nothing.nnA fail in the second allocation in __static_call_init() is harmless andndoes not require special treatment. The first allocation succeeded andnconverted the key to a module chain. That first entry has mod::mod == NULLnand mod::next == NULL so the inner loop of static_call_del_module() willnneither find a module match nor a module chain. The next site in the walknwas either already converted but can't match the module or it will exitnthe outer loop because it has a static_call_site pointer and not anstatic_call_mod pointer.,CVE-2024-50002,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Fix system hang while resume with TBT monitornn[Why]nConnected with a Thunderbolt monitor and do the suspend and the systemnmay hang while resume.nnThe TBT monitor HPD will be triggered during the resume procedurenand call the drm_client_modeset_probe() whilenstruct drm_connector connector->dev->master is NULL.nnIt will mess up the pipe topology after resume.nn[How]nSkip the TBT monitor HPD during the resume procedure because wencurrently will probe the connectors after resume by default.nn(cherry picked from commit 453f86a26945207a16b8f66aaed5962dc2b95b85),CVE-2024-50003,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nncpufreq: Avoid a bad reference count on CPU nodennIn the parse_perf_domain function if the call tonof_parse_phandle_with_args returns an error then the reference to thenCPU device node that was acquired at the start of the function would notnbe properly decremented.nnAddress this by declaring the variable with the __free(device_node)ncleanup attribute.,CVE-2024-50012,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnext4: fix access to uninitialised lock in fc replay pathnnThe following kernel trace can be triggered with fstest generic/629 whennexecuted against a filesystem with fast-commit feature enabled:nnINFO: trying to register non-static key.nThe code is fine but needs lockdep annotation or maybenyou didn't initialize this object before use?nturning off the locking correctness validator.nCPU: 0 PID: 866 Comm: mount Not tainted 6.10.0+ #11nHardware name: QEMU Standard PC (i440FX + PIIX 1996) BIOS rel-1.16.2-3-gd478f380-prebuilt.qemu.org 04/01/2014nCall Trace:n <TASK>n dump_stack_lvl+0x66/0x90n register_lock_class+0x759/0x7d0n __lock_acquire+0x85/0x2630n ? __find_get_block+0xb4/0x380n lock_acquire+0xd1/0x2d0n ? __ext4_journal_get_write_access+0xd5/0x160n _raw_spin_lock+0x33/0x40n ? __ext4_journal_get_write_access+0xd5/0x160n __ext4_journal_get_write_access+0xd5/0x160n ext4_reserve_inode_write+0x61/0xb0n __ext4_mark_inode_dirty+0x79/0x270n ? ext4_ext_replay_set_iblocks+0x2f8/0x450n ext4_ext_replay_set_iblocks+0x330/0x450n ext4_fc_replay+0x14c8/0x1540n ? jread+0x88/0x2e0n ? rcu_is_watching+0x11/0x40n do_one_pass+0x447/0xd00n jbd2_journal_recover+0x139/0x1b0n jbd2_journal_load+0x96/0x390n ext4_load_and_init_journal+0x253/0xd40n ext4_fill_super+0x2cc6/0x3180n...nnIn the replay path there's an attempt to lock sbi->s_bdev_wb_lock innfunction ext4_check_bdev_write_error(). Unfortunately at this point thisnspinlock has not been initialized yet. Moving it's initialization to annearlier point in __ext4_fill_super() fixes this splat.,CVE-2024-50014,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnx86/mm/ident_map: Use gbpages only where full GB page should be mapped.nnWhen ident_pud_init() uses only GB pages to create identity maps largenranges of addresses not actually requested can be included in the resultingntable; a 4K request will map a full GB. This can include a lot of extranaddress space past that requested including areas marked reserved by thenBIOS. That allows processor speculation into reserved regions that on UVnsystems can cause system halts.nnOnly use GB pages when map creation requests include the full GB page ofnspace. Fall back to using smaller 2M pages when only portions of a GB pagenare included in the request.nnNo attempt is made to coalesce mapping requests. If a request requires anmap entry at the 2M (pmd) level subsequent mapping requests within thensame 1G region will also be at the pmd level even if adjacent ornoverlapping such requests could have been combined to map a full GB page.nExisting usage starts with larger regions and then adds smaller regions sonthis should not have any great consequence.,CVE-2024-50017,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnthermal: core: Reference count the zone in thermal_zone_get_by_id()nnThere are places in the thermal netlink code where nothing preventsnthe thermal zone object from going away while being accessed after itnhas been returned by thermal_zone_get_by_id().nnTo address this make thermal_zone_get_by_id() get a reference on thenthermal zone device object to be returned with the help of get_device()nunder thermal_list_lock and adjust all of its callers to this changenwith the help of the cleanup.h infrastructure.,CVE-2024-50028,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnetfilter: xtables: avoid NFPROTO_UNSPEC where needednnsyzbot managed to call xt_cluster match via ebtables:nn WARNING: CPU: 0 PID: 11 at net/netfilter/xt_cluster.c:72 xt_cluster_mt+0x196/0x780n [..]n ebt_do_table+0x174b/0x2a40nnModule registers to NFPROTO_UNSPEC but it assumes ipv4/ipv6 packetnprocessing. As this is only useful to restrict locally terminatingnTCP/UDP traffic register this for ipv4 and ipv6 family only.nnPablo points out that this is a general issue direct users of thenset/getsockopt interface can call into targets/matches that were onlynintended for use with ip(6)tables.nnCheck all UNSPEC matches and targets for similar issues:nn- matches and targets are fine except if they assume skb_network_header()n is valid -- this is only true when called from inet layer: ip(6) stackn pulls the ip/ipv6 header into linear data area.n- targets that return XT_CONTINUE or other xtables verdicts must ben restricted too they are incompatbile with the ebtables traverser e.g.n EBT_CONTINUE is a completely different value than XT_CONTINUE.nnMost matches/targets are changed to register for NFPROTO_IPV4/IPV6 asnthey are provided for use by ip(6)tables.nnThe MARK target is also used by arptables so register for NFPROTO_ARP too.nnWhile at it bail out if connbytes fails to enable the correspondingnconntrack family.nnThis change passes the selftests in iptables.git.,CVE-2024-50038,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnsmb: client: fix UAF in async decryptionnnDoing an async decryption (large read) crashes with anslab-use-after-free way down in the crypto API.nnReproducer:n # mount.cifs -o ...sealesize=1 //srv/share /mntn # dd if=/mnt/largefile of=/dev/nulln ...n [ 194.196391] ==================================================================n [ 194.196844] BUG: KASAN: slab-use-after-free in gf128mul_4k_lle+0xc1/0x110n [ 194.197269] Read of size 8 at addr ffff888112bd0448 by task kworker/u77:2/899n [ 194.197707]n [ 194.197818] CPU: 12 UID: 0 PID: 899 Comm: kworker/u77:2 Not tainted 6.11.0-lku-00028-gfca3ca14a17a-dirty #43n [ 194.198400] Hardware name: QEMU Standard PC (Q35 + ICH9 2009) BIOS rel-1.16.2-3-gd478f380-prebuilt.qemu.org 04/01/2014n [ 194.199046] Workqueue: smb3decryptd smb2_decrypt_offload [cifs]n [ 194.200032] Call Trace:n [ 194.200191] <TASK>n [ 194.200327] dump_stack_lvl+0x4e/0x70n [ 194.200558] ? gf128mul_4k_lle+0xc1/0x110n [ 194.200809] print_report+0x174/0x505n [ 194.201040] ? __pfx__raw_spin_lock_irqsave+0x10/0x10n [ 194.201352] ? srso_return_thunk+0x5/0x5fn [ 194.201604] ? __virt_addr_valid+0xdf/0x1c0n [ 194.201868] ? gf128mul_4k_lle+0xc1/0x110n [ 194.202128] kasan_report+0xc8/0x150n [ 194.202361] ? gf128mul_4k_lle+0xc1/0x110n [ 194.202616] gf128mul_4k_lle+0xc1/0x110n [ 194.202863] ghash_update+0x184/0x210n [ 194.203103] shash_ahash_update+0x184/0x2a0n [ 194.203377] ? __pfx_shash_ahash_update+0x10/0x10n [ 194.203651] ? srso_return_thunk+0x5/0x5fn [ 194.203877] ? crypto_gcm_init_common+0x1ba/0x340n [ 194.204142] gcm_hash_assoc_remain_continue+0x10a/0x140n [ 194.204434] crypt_message+0xec1/0x10a0 [cifs]n [ 194.206489] ? __pfx_crypt_message+0x10/0x10 [cifs]n [ 194.208507] ? srso_return_thunk+0x5/0x5fn [ 194.209205] ? srso_return_thunk+0x5/0x5fn [ 194.209925] ? srso_return_thunk+0x5/0x5fn [ 194.210443] ? srso_return_thunk+0x5/0x5fn [ 194.211037] decrypt_raw_data+0x15f/0x250 [cifs]n [ 194.212906] ? __pfx_decrypt_raw_data+0x10/0x10 [cifs]n [ 194.214670] ? srso_return_thunk+0x5/0x5fn [ 194.215193] smb2_decrypt_offload+0x12a/0x6c0 [cifs]nnThis is because TFM is being used in parallel.nnFix this by allocating a new AEAD TFM for async decryption but keepnthe existing one for synchronous READ cases (similar to what is donenin smb3_calc_signature()).nnAlso remove the calls to aead_request_set_callback() andncrypto_wait_req() since it's always going to be a synchronous operation.,CVE-2024-50047,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnfbcon: Fix a NULL pointer dereference issue in fbcon_putcsnnsyzbot has found a NULL pointer dereference bug in fbcon.nHere is the simplified C reproducer:nnstruct param {ntuint8_t type;ntstruct tiocl_selection ts;n};nnint main()n{ntstruct fb_con2fbmap con2fb;ntstruct param param;nntint fd = open(/dev/fb1 0 0);nntcon2fb.console = 0x19;ntcon2fb.framebuffer = 0;ntioctl(fd FBIOPUT_CON2FBMAP &con2fb);nntparam.type = 2;ntparam.ts.xs = 0; param.ts.ys = 0;ntparam.ts.xe = 0; param.ts.ye = 0;ntparam.ts.sel_mode = 0;nntint fd1 = open(/dev/tty1 O_RDWR 0);ntioctl(fd1 TIOCLINUX &param);nntcon2fb.console = 1;ntcon2fb.framebuffer = 0;ntioctl(fd FBIOPUT_CON2FBMAP &con2fb);nntreturn 0;n}nnAfter calling ioctl(fd1 TIOCLINUX &param) the subsequent ioctl(fd FBIOPUT_CON2FBMAP &con2fb)ncauses the kernel to follow a different execution path:nn set_con2fb_mapn -> con2fb_init_displayn -> fbcon_set_dispn -> redraw_screenn -> hide_cursorn -> clear_selectionn -> highlightn -> invert_screenn -> do_update_regionn -> fbcon_putcsn -> ops->putcsnnSince ops->putcs is a NULL pointer this leads to a kernel panic.nTo prevent this we need to call set_blitting_type() within set_con2fb_map()nto properly initialize ops->putcs.,CVE-2024-50048,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnspi: mpc52xx: Add cancel_work_sync before module removennIf we remove the module which will call mpc52xx_spi_removenit will free 'ms' through spi_unregister_controller.nwhile the work ms->work will be used. The sequence of operationsnthat may lead to a UAF bug.nnFix it by ensuring that the work is canceled before proceeding withnthe cleanup in mpc52xx_spi_remove.,CVE-2024-50051,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnusb: gadget: uvc: Fix ERR_PTR dereference in uvc_v4l2.cnnFix potential dereferencing of ERR_PTR() in find_format_by_pix()nand uvc_v4l2_enum_format().nnFix the following smatch errors:nndrivers/usb/gadget/function/uvc_v4l2.c:124 find_format_by_pix()nerror: 'fmtdesc' dereferencing possible ERR_PTR()nndrivers/usb/gadget/function/uvc_v4l2.c:392 uvc_v4l2_enum_format()nerror: 'fmtdesc' dereferencing possible ERR_PTR()nnAlso fix similar issue in uvc_v4l2_try_format() for potentialndereferencing of ERR_PTR().,CVE-2024-50056,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnusb: typec: tipd: Free IRQ only if it was requested beforennIn polling mode if no IRQ was requested there is no need to free it.nCall devm_free_irq() only if client->irq is set. This fixes the warningncaused by the tps6598x module removal:nnWARNING: CPU: 2 PID: 333 at kernel/irq/devres.c:144 devm_free_irq+0x80/0x8cn...n...nCall trace:n devm_free_irq+0x80/0x8cn tps6598x_remove+0x28/0x88 [tps6598x]n i2c_device_remove+0x2c/0x9cn device_remove+0x4c/0x80n device_release_driver_internal+0x1cc/0x228n driver_detach+0x50/0x98n bus_remove_driver+0x6c/0xbcn driver_unregister+0x30/0x60n i2c_del_driver+0x54/0x64n tps6598x_i2c_driver_exit+0x18/0xc3c [tps6598x]n __arm64_sys_delete_module+0x184/0x264n invoke_syscall+0x48/0x110n el0_svc_common.constprop.0+0xc8/0xe8n do_el0_svc+0x20/0x2cn el0_svc+0x28/0x98n el0t_64_sync_handler+0x13c/0x158n el0t_64_sync+0x190/0x194,CVE-2024-50057,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnio_uring: check if we need to reschedule during overflow flushnnIn terms of normal application usage this list will always be empty.nAnd if an application does overflow a bit it'll have a few entries.nHowever nothing obviously prevents syzbot from running a test casenthat generates a ton of overflow entries and then flushing them canntake quite a while.nnCheck for needing to reschedule while flushing and drop our locks andndo so if necessary. There's no state to maintain here as overflowsnalways prune from head-of-list hence it's fine to drop and reacquirenthe locks at the end of the loop.,CVE-2024-50060,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nni3c: master: cdns: Fix use after free vulnerability in cdns_i3c_master Driver Due to Race ConditionnnIn the cdns_i3c_master_probe function &master->hj_work is bound withncdns_i3c_master_hj. And cdns_i3c_master_interrupt can callncnds_i3c_master_demux_ibis function to start the work.nnIf we remove the module which will call cdns_i3c_master_remove tonmake cleanup it will free master->base through i3c_master_unregisternwhile the work mentioned above will be used. The sequence of operationsnthat may lead to a UAF bug is as follows:nnCPU0 CPU1nn | cdns_i3c_master_hjncdns_i3c_master_remove |ni3c_master_unregister(&master->base) |ndevice_unregister(&master->dev) |ndevice_release |n//free master->base |n | i3c_master_do_daa(&master->base)n | //use master->basennFix it by ensuring that the work is canceled before proceeding withnthe cleanup in cdns_i3c_master_remove.,CVE-2024-50061,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnRDMA/rtrs-srv: Avoid null pointer deref during path establishmentnnFor RTRS path establishment RTRS client initiates and completes con_numnof connections. After establishing all its connections the informationnis exchanged between the client and server through the info_req message.nDuring this exchange it is essential that all connections have beennestablished and the state of the RTRS srv path is CONNECTED.nnSo add these sanity checks to make sure we detect and abort process innerror scenarios to avoid null pointer deref.,CVE-2024-50062,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbpf: Prevent tail call between progs attached to different hooksnnbpf progs can be attached to kernel functions and the attached functionsncan take different parameters or return different return values. Ifnprog attached to one kernel function tail calls prog attached to anothernkernel function the ctx access or return value verification could benbypassed.nnFor example if prog1 is attached to func1 which takes only 1 parameternand prog2 is attached to func2 which takes two parameters. Since verifiernassumes the bpf ctx passed to prog2 is constructed based on func2'snprototype verifier allows prog2 to access the second parameter fromnthe bpf ctx passed to it. The problem is that verifier does not preventnprog1 from passing its bpf ctx to prog2 via tail call. In this casenthe bpf ctx passed to prog2 is constructed from func1 instead of func2nthat is the assumption for ctx access verification is bypassed.nnAnother example if BPF LSM prog1 is attached to hook file_alloc_securitynand BPF LSM prog2 is attached to hook bpf_lsm_audit_rule_known. Verifiernknows the return value rules for these two hooks e.g. it is legal fornbpf_lsm_audit_rule_known to return positive number 1 and it is illegalnfor file_alloc_security to return positive number. So verifier allowsnprog2 to return positive number 1 but does not allow prog1 to returnnpositive number. The problem is that verifier does not prevent prog1nfrom calling prog2 via tail call. In this case prog2's return value 1nwill be used as the return value for prog1's hook file_alloc_security.nThat is the return value rule is bypassed.nnThis patch adds restriction for tail call to prevent such bypasses.,CVE-2024-50063,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnuprobe: avoid out-of-bounds memory access of fetching argsnnUprobe needs to fetch args into a percpu buffer and then copy to ringnbuffer to avoid non-atomic context problem.nnSometimes user-space strings arrays can be very large but the size ofnpercpu buffer is only page size. And store_trace_args() won't checknwhether these data exceeds a single page or not caused out-of-boundsnmemory access.nnIt could be reproduced by following steps:n1. build kernel with CONFIG_KASAN enabledn2. save follow program as test.cnn```n#include <stdio.h>n#include <stdlib.h>n#include <string.h>nn// If string length large than MAX_STRING_SIZE the fetch_store_strlen()n// will return 0 cause __get_data_size() return shorter size andn// store_trace_args() will not trigger out-of-bounds access.n// So make string length less than 4096.n#define STRLEN 4093nnvoid generate_string(char *str int n)n{n int i;n for (i = 0; i < n; ++i)n {n char c = i % 26 + 'a';n str[i] = c;n }n str[n-1] = '0';n}nnvoid print_string(char *str)n{n printf(%sn str);n}nnint main()n{n char tmp[STRLEN];nn generate_string(tmp STRLEN);n print_string(tmp);nn return 0;n}n```n3. compile programn`gcc -o test test.c`nn4. get the offset of `print_string()`n```nobjdump -t test | grep -w print_stringn0000000000401199 g F .text 000000000000001b print_stringn```nn5. configure uprobe with offset 0x1199n```noff=0x1199nncd /sys/kernel/debug/tracing/necho p /root/test:${off} arg1=+0(%di):ustring arg2=$comm arg3=+0(%di):ustringn > uprobe_eventsnecho 1 > events/uprobes/enablenecho 1 > tracing_onn```nn6. run `test` and kasan will report error.n==================================================================nBUG: KASAN: use-after-free in strncpy_from_user+0x1d6/0x1f0nWrite of size 8 at addr ffff88812311c004 by task test/499CPU: 0 UID: 0 PID: 499 Comm: test Not tainted 6.12.0-rc3+ #18nHardware name: Red Hat KVM BIOS 1.16.0-4.al8 04/01/2014nCall Trace:n <TASK>n dump_stack_lvl+0x55/0x70n print_address_description.constprop.0+0x27/0x310n kasan_report+0x10f/0x120n ? strncpy_from_user+0x1d6/0x1f0n strncpy_from_user+0x1d6/0x1f0n ? rmqueue.constprop.0+0x70d/0x2ad0n process_fetch_insn+0xb26/0x1470n ? __pfx_process_fetch_insn+0x10/0x10n ? _raw_spin_lock+0x85/0xe0n ? __pfx__raw_spin_lock+0x10/0x10n ? __pte_offset_map+0x1f/0x2d0n ? unwind_next_frame+0xc5f/0x1f80n ? arch_stack_walk+0x68/0xf0n ? is_bpf_text_address+0x23/0x30n ? kernel_text_address.part.0+0xbb/0xd0n ? __kernel_text_address+0x66/0xb0n ? unwind_get_return_address+0x5e/0xa0n ? __pfx_stack_trace_consume_entry+0x10/0x10n ? arch_stack_walk+0xa2/0xf0n ? _raw_spin_lock_irqsave+0x8b/0xf0n ? __pfx__raw_spin_lock_irqsave+0x10/0x10n ? depot_alloc_stack+0x4c/0x1f0n ? _raw_spin_unlock_irqrestore+0xe/0x30n ? stack_depot_save_flags+0x35d/0x4f0n ? kasan_save_stack+0x34/0x50n ? kasan_save_stack+0x24/0x50n ? mutex_lock+0x91/0xe0n ? __pfx_mutex_lock+0x10/0x10n prepare_uprobe_buffer.part.0+0x2cd/0x500n uprobe_dispatcher+0x2c3/0x6a0n ? __pfx_uprobe_dispatcher+0x10/0x10n ? __kasan_slab_alloc+0x4d/0x90n handler_chain+0xdd/0x3e0n handle_swbp+0x26e/0x3d0n ? __pfx_handle_swbp+0x10/0x10n ? uprobe_pre_sstep_notifier+0x151/0x1b0n irqentry_exit_to_user_mode+0xe2/0x1b0n asm_exc_int3+0x39/0x40nRIP: 0033:0x401199nCode: 01 c2 0f b6 45 fb 88 02 83 45 fc 01 8b 45 fc 3b 45 e4 7c b7 8b 45 e4 48 98 48 8d 50 ff 48 8b 45 e8 48 01 d0 cenRSP: 002b:00007ffdf00576a8 EFLAGS: 00000206nRAX: 00007ffdf00576b0 RBX: 0000000000000000 RCX: 0000000000000ff2nRDX: 0000000000000ffc RSI: 0000000000000ffd RDI: 00007ffdf00576b0nRBP: 00007ffdf00586b0 R08: 00007feb2f9c0d20 R09: 00007feb2f9c0d20nR10: 0000000000000001 R11: 0000000000000202 R12: 0000000000401040nR13: 00007ffdf0058780 R14: 0000000000000000 R15: 0000000000000000n </TASK>nnThis commit enforces the buffer's maxlen less than a page-size to avoidnstore_trace_args() out-of-memory access.,CVE-2024-50067,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nntty: n_gsm: Fix use-after-free in gsm_cleanup_muxnnBUG: KASAN: slab-use-after-free in gsm_cleanup_mux+0x77b/0x7b0ndrivers/tty/n_gsm.c:3160 [n_gsm]nRead of size 8 at addr ffff88815fe99c00 by task poc/3379nCPU: 0 UID: 0 PID: 3379 Comm: poc Not tainted 6.11.0+ #56nHardware name: VMware Inc. VMware Virtual Platform/440BXnDesktop Reference Platform BIOS 6.00 11/12/2020nCall Trace:n <TASK>n gsm_cleanup_mux+0x77b/0x7b0 drivers/tty/n_gsm.c:3160 [n_gsm]n __pfx_gsm_cleanup_mux+0x10/0x10 drivers/tty/n_gsm.c:3124 [n_gsm]n __pfx_sched_clock_cpu+0x10/0x10 kernel/sched/clock.c:389n update_load_avg+0x1c1/0x27b0 kernel/sched/fair.c:4500n __pfx_min_vruntime_cb_rotate+0x10/0x10 kernel/sched/fair.c:846n __rb_insert_augmented+0x492/0xbf0 lib/rbtree.c:161n gsmld_ioctl+0x395/0x1450 drivers/tty/n_gsm.c:3408 [n_gsm]n _raw_spin_lock_irqsave+0x92/0xf0 arch/x86/include/asm/atomic.h:107n __pfx_gsmld_ioctl+0x10/0x10 drivers/tty/n_gsm.c:3822 [n_gsm]n ktime_get+0x5e/0x140 kernel/time/timekeeping.c:195n ldsem_down_read+0x94/0x4e0 arch/x86/include/asm/atomic64_64.h:79n __pfx_ldsem_down_read+0x10/0x10 drivers/tty/tty_ldsem.c:338n __pfx_do_vfs_ioctl+0x10/0x10 fs/ioctl.c:805n tty_ioctl+0x643/0x1100 drivers/tty/tty_io.c:2818nnAllocated by task 65:n gsm_data_alloc.constprop.0+0x27/0x190 drivers/tty/n_gsm.c:926 [n_gsm]n gsm_send+0x2c/0x580 drivers/tty/n_gsm.c:819 [n_gsm]n gsm1_receive+0x547/0xad0 drivers/tty/n_gsm.c:3038 [n_gsm]n gsmld_receive_buf+0x176/0x280 drivers/tty/n_gsm.c:3609 [n_gsm]n tty_ldisc_receive_buf+0x101/0x1e0 drivers/tty/tty_buffer.c:391n tty_port_default_receive_buf+0x61/0xa0 drivers/tty/tty_port.c:39n flush_to_ldisc+0x1b0/0x750 drivers/tty/tty_buffer.c:445n process_scheduled_works+0x2b0/0x10d0 kernel/workqueue.c:3229n worker_thread+0x3dc/0x950 kernel/workqueue.c:3391n kthread+0x2a3/0x370 kernel/kthread.c:389n ret_from_fork+0x2d/0x70 arch/x86/kernel/process.c:147n ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:257nnFreed by task 3367:n kfree+0x126/0x420 mm/slub.c:4580n gsm_cleanup_mux+0x36c/0x7b0 drivers/tty/n_gsm.c:3160 [n_gsm]n gsmld_ioctl+0x395/0x1450 drivers/tty/n_gsm.c:3408 [n_gsm]n tty_ioctl+0x643/0x1100 drivers/tty/tty_io.c:2818nn[Analysis]ngsm_msg on the tx_ctrl_list or tx_data_list of gsm_muxncan be freed by multi threads through ioctlwhich leadsnto the occurrence of uaf. Protect it by gsm tx lock.,CVE-2024-50073,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnvt: prevent kernel-infoleak in con_font_get()nnfont.data may not initialize all memory spaces depending on the implementationnof vc->vc_sw->con_font_get. This may cause info-leak so to prevent this itnis safest to modify it to initialize the allocated memory space to 0 and itngenerally does not affect the overall performance of the system.,CVE-2024-50076,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Disable PSR-SU on Parade 08-01 TCON toonnStuart Hayhurst has found that both at bootup and fullscreen VA-API videonis leading to black screens for around 1 second and kernel WARNING [1] tracesnwhen calling dmub_psr_enable() with Parade 08-01 TCON.nnThese symptoms all go away with PSR-SU disabled for this TCON so disablenit for now while DMUB traces [2] from the failure can be analyzed and the failurenstate properly root caused.nn(cherry picked from commit afb634a6823d8d9db23c5fb04f79c5549349628b),CVE-2024-50108,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnx86/lam: Disable ADDRESS_MASKING in most casesnnLinear Address Masking (LAM) has a weakness related to transientnexecution as described in the SLAM paper[1]. Unless Linear AddressnSpace Separation (LASS) is enabled this weakness may be exploitable.nnUntil kernel adds support for LASS[2] only allow LAM for COMPILE_TESTnor when speculation mitigations have been disabled at compile timenotherwise keep LAM disabled.nnThere are no processors in market that support LAM yet so currentlynnobody is affected by this issue.nn[1] SLAM: https://download.vusec.net/papers/slam_sp24.pdfn[2] LASS: https://lore.kernel.org/lkml/20230609183632.48706-1-alexander.shishkin@linux.intel.com/nn[ dhansen: update SPECULATION_MITIGATIONS -> CPU_MITIGATIONS ],CVE-2024-50112,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnBluetooth: SCO: Fix UAF on sco_sock_timeoutnnconn->sk maybe have been unlinked/freed while waiting for sco_conn_locknso this checks if the conn->sk is still valid by checking if it part ofnsco_sk_list.,CVE-2024-50125,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnvme-pci: fix race condition between reset and nvme_dev_disable()nnnvme_dev_disable() modifies the dev->online_queues field thereforennvme_pci_update_nr_queues() should avoid racing against it otherwisenwe could end up passing invalid values to blk_mq_update_nr_hw_queues().nn WARNING: CPU: 39 PID: 61303 at drivers/pci/msi/api.c:347n pci_irq_get_affinity+0x187/0x210n Workqueue: nvme-reset-wq nvme_reset_work [nvme]n RIP: 0010:pci_irq_get_affinity+0x187/0x210n Call Trace:n <TASK>n ? blk_mq_pci_map_queues+0x87/0x3c0n ? pci_irq_get_affinity+0x187/0x210n blk_mq_pci_map_queues+0x87/0x3c0n nvme_pci_map_queues+0x189/0x460 [nvme]n blk_mq_update_nr_hw_queues+0x2a/0x40n nvme_reset_work+0x1be/0x2a0 [nvme]nnFix the bug by locking the shutdown_lock mutex before usingndev->online_queues. Give up if nvme_dev_disable() is running or ifnit has been executed already.,CVE-2024-50135,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbpf: Use raw_spinlock_t in ringbufnnThe function __bpf_ringbuf_reserve is invoked from a tracepoint whichndisables preemption. Using spinlock_t in this context can lead to ansleep in atomic warning in the RT variant. This issue is illustratednin the example below:nnBUG: sleeping function called from invalid context at kernel/locking/spinlock_rt.c:48nin_atomic(): 1 irqs_disabled(): 0 non_block: 0 pid: 556208 name: test_progsnpreempt_count: 1 expected: 0nRCU nest depth: 1 expected: 1nINFO: lockdep is turned off.nPreemption disabled at:n[<ffffd33a5c88ea44>] migrate_enable+0xc0/0x39cnCPU: 7 PID: 556208 Comm: test_progs Tainted: GnHardware name: Qualcomm SA8775P Ride (DT)nCall trace:n dump_backtrace+0xac/0x130n show_stack+0x1c/0x30n dump_stack_lvl+0xac/0xe8n dump_stack+0x18/0x30n __might_resched+0x3bc/0x4fcn rt_spin_lock+0x8c/0x1a4n __bpf_ringbuf_reserve+0xc4/0x254n bpf_ringbuf_reserve_dynptr+0x5c/0xdcn bpf_prog_ac3d15160d62622a_test_read_write+0x104/0x238n trace_call_bpf+0x238/0x774n perf_call_bpf_enter.isra.0+0x104/0x194n perf_syscall_enter+0x2f8/0x510n trace_sys_enter+0x39c/0x564n syscall_trace_enter+0x220/0x3c0n do_el0_svc+0x138/0x1dcn el0_svc+0x54/0x130n el0t_64_sync_handler+0x134/0x150n el0t_64_sync+0x17c/0x180nnSwitch the spinlock to raw_spinlock_t to avoid this error.,CVE-2024-50138,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnudf: fix uninit-value use in udf_get_fileshortadnnCheck for overflow when computing alen in udf_current_aext to mitigatenlater uninit-value use in udf_get_fileshortad KMSAN bug[1].nAfter applying the patch reproducer did not trigger any issue[2].nn[1] https://syzkaller.appspot.com/bug?extid=8901c4560b7ab5c2f9dfn[2] https://syzkaller.appspot.com/x/log.txt?x=10242227980000,CVE-2024-50143,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nntcp/dccp: Don't use timer_pending() in reqsk_queue_unlink().nnMartin KaFai Lau reported use-after-free [0] in reqsk_timer_handler().nn n We are seeing a use-after-free from a bpf prog attached ton trace_tcp_retransmit_synack. The program passes the req->sk to then bpf_sk_storage_get_tracing kernel helper which does check for nulln before using it.n nnThe commit 83fccfc3940c (inet: fix potential deadlock innreqsk_queue_unlink()) added timer_pending() in reqsk_queue_unlink() notnto call del_timer_sync() from reqsk_timer_handler() but it introduced ansmall race window.nnBefore the timer is called expire_timers() calls detach_timer(timer true)nto clear timer->entry.pprev and marks it as not pending.nnIf reqsk_queue_unlink() checks timer_pending() just after expire_timers()ncalls detach_timer() TCP will miss del_timer_sync(); the reqsk timer willncontinue running and send multiple SYN+ACKs until it expires.nnThe reported UAF could happen if req->sk is close()d earlier than the timernexpiration which is 63s by default.nnThe scenario would benn 1. inet_csk_complete_hashdance() calls inet_csk_reqsk_queue_drop()n but del_timer_sync() is missednn 2. reqsk timer is executed and scheduled againnn 3. req->sk is accept()ed and reqsk_put() decrements rsk_refcnt butn reqsk timer still has another one and inet_csk_accept() does notn clear req->sk for non-TFO socketsnn 4. sk is close()dnn 5. reqsk timer is executed again and BPF touches req->sknnLet's not use timer_pending() by passing the caller context ton__inet_csk_reqsk_queue_drop().nnNote that reqsk timer is pinned so the issue does not happen in mostnuse cases. [1]nn[0]nBUG: KFENCE: use-after-free read in bpf_sk_storage_get_tracing+0x2e/0x1b0nnUse-after-free read at 0x00000000a891fb3a (in kfence-#1):nbpf_sk_storage_get_tracing+0x2e/0x1b0nbpf_prog_5ea3e95db6da0438_tcp_retransmit_synack+0x1d20/0x1ddanbpf_trace_run2+0x4c/0xc0ntcp_rtx_synack+0xf9/0x100nreqsk_timer_handler+0xda/0x3d0nrun_timer_softirq+0x292/0x8a0nirq_exit_rcu+0xf5/0x320nsysvec_apic_timer_interrupt+0x6d/0x80nasm_sysvec_apic_timer_interrupt+0x16/0x20nintel_idle_irq+0x5a/0xa0ncpuidle_enter_state+0x94/0x273ncpu_startup_entry+0x15e/0x260nstart_secondary+0x8a/0x90nsecondary_startup_64_no_verify+0xfa/0xfbnnkfence-#1: 0x00000000a72cc7b6-0x00000000d97616d9 size=2376 cache=TCPv6nnallocated by task 0 on cpu 9 at 260507.901592s:nsk_prot_alloc+0x35/0x140nsk_clone_lock+0x1f/0x3f0ninet_csk_clone_lock+0x15/0x160ntcp_create_openreq_child+0x1f/0x410ntcp_v6_syn_recv_sock+0x1da/0x700ntcp_check_req+0x1fb/0x510ntcp_v6_rcv+0x98b/0x1420nipv6_list_rcv+0x2258/0x26e0nnapi_complete_done+0x5b1/0x2990nmlx5e_napi_poll+0x2ae/0x8d0nnet_rx_action+0x13e/0x590nirq_exit_rcu+0xf5/0x320ncommon_interrupt+0x80/0x90nasm_common_interrupt+0x22/0x40ncpuidle_enter_state+0xfb/0x273ncpu_startup_entry+0x15e/0x260nstart_secondary+0x8a/0x90nsecondary_startup_64_no_verify+0xfa/0xfbnnfreed by task 0 on cpu 9 at 260507.927527s:nrcu_core_si+0x4ff/0xf10nirq_exit_rcu+0xf5/0x320nsysvec_apic_timer_interrupt+0x6d/0x80nasm_sysvec_apic_timer_interrupt+0x16/0x20ncpuidle_enter_state+0xfb/0x273ncpu_startup_entry+0x15e/0x260nstart_secondary+0x8a/0x90nsecondary_startup_64_no_verify+0xfa/0xfb,CVE-2024-50154,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnfsl/fman: Fix refcount handling of fman-related devicesnnIn mac_probe() there are multiple calls to of_find_device_by_node()nfman_bind() and fman_port_bind() which takes references to of_dev->dev.nNot all references taken by these calls are released later on error pathnin mac_probe() and in mac_remove() which lead to reference leaks.nnAdd references release.,CVE-2024-50166,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet/sun3_82586: fix potential memory leak in sun3_82586_send_packet()nnThe sun3_82586_send_packet() returns NETDEV_TX_OK without freeing skbnin case of skb->len being too long add dev_kfree_skb() to fix it.,CVE-2024-50168,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnscsi: lpfc: Ensure DA_ID handling completion before deleting an NPIV instancennDeleting an NPIV instance requires all fabric ndlps to be released beforenan NPIV's resources can be torn down. Failure to release fabric ndlpsnbeforehand opens kref imbalance race conditions. Fix by forcing the DA_IDnto complete synchronously with usage of wait_queue.,CVE-2024-50183,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/vc4: Stop the active perfmon before being destroyednnUpon closing the file descriptor the active performance monitor is notnstopped. Although all perfmons are destroyed in `vc4_perfmon_close_file()`nthe active performance monitor's pointer (`vc4->active_perfmon`) is stillnretained.nnIf we open a new file descriptor and submit a few jobs with performancenmonitors the driver will attempt to stop the active performance monitornusing the stale pointer in `vc4->active_perfmon`. However this pointernis no longer valid because the previous process has already terminatednand all performance monitors associated with it have been destroyed andnfreed.nnTo fix this when the active performance monitor belongs to a givennprocess explicitly stop it before destroying and freeing it.,CVE-2024-50187,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnext4: don't set SB_RDONLY after filesystem errorsnnWhen the filesystem is mounted with errors=remount-ro we were settingnSB_RDONLY flag to stop all filesystem modifications. We knew this missesnproper locking (sb->s_umount) and does not go through proper filesystemnremount procedure but it has been the way this worked since early ext2ndays and it was good enough for catastrophic situation damagenmitigation. Recently syzbot has found a way (see link) to triggernwarnings in filesystem freezing because the code got confused bynSB_RDONLY changing under its hands. Since these days we setnEXT4_FLAGS_SHUTDOWN on the superblock which is enough to stop allnfilesystem modifications modifying SB_RDONLY shouldn't be needed. Sonstop doing that.,CVE-2024-50191,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnpinctrl: ocelot: fix system hang on level based interruptsnnThe current implementation only calls chained_irq_enter() andnchained_irq_exit() if it detects pending interrupts.nn```nfor (i = 0; i < info->stride; i++) {nturegmap_read(info->map id_reg + 4 output.log scan_tyk_dockerimages.sh vulnerabilities.csv i &reg);ntif (!reg)nttcontinue;nntchained_irq_enter(parent_chip desc);n```nnHowever in case of GPIO pin configured in level mode and the parentncontroller configured in edge mode GPIO interrupt might be lowered by thenhardware. In the result if the interrupt is short enough the parentninterrupt is still pending while the GPIO interrupt is cleared;nchained_irq_enter() never gets called and the system hangs trying tonservice the parent interrupt.nnMoving chained_irq_enter() and chained_irq_exit() outside the for loopnensures that they are called even when GPIO interrupt is lowered by thenhardware.nnThe similar code with chained_irq_enter() / chained_irq_exit() functionsnwrapping interrupt checking loop may be found in many other drivers:n```ngrep -r -A 10 chained_irq_enter drivers/pinctrln```,CVE-2024-50196,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnudf: refactor inode_bmap() to handle errornnRefactor inode_bmap() to handle error since udf_next_aext() can returnnerror now. On situations like ftruncate udf_extend_file() can nowndetect errors and bail out early without resorting to checking fornparticular offsets and assuming internal behavior of these functions.,CVE-2024-50211,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbtrfs: fix use-after-free of block device file in __btrfs_free_extra_devids()nnMounting btrfs from two images (which have the same one fsid and twondifferent dev_uuids) in certain executing order may trigger an UAF fornvariable 'device->bdev_file' in __btrfs_free_extra_devids(). Andnfollowing are the details:nn1. Attach image_1 to loop0 attach image_2 to loop1 and scan btrfsn devices by ioctl(BTRFS_IOC_SCAN_DEV):nn / btrfs_device_1  loop0n fs_devicen  btrfs_device_2  loop1n2. mount /dev/loop0 /mntn btrfs_open_devicesn btrfs_device_1->bdev_file = btrfs_get_bdev_and_sb(loop0)n btrfs_device_2->bdev_file = btrfs_get_bdev_and_sb(loop1)n btrfs_fill_supern open_ctreen fail: btrfs_close_devices // -ENOMEMnt btrfs_close_bdev(btrfs_device_1)n fput(btrfs_device_1->bdev_file)nt // btrfs_device_1->bdev_file is freednt btrfs_close_bdev(btrfs_device_2)n fput(btrfs_device_2->bdev_file)nn3. mount /dev/loop1 /mntn btrfs_open_devicesn btrfs_get_bdev_and_sb(&bdev_file)n // EIO btrfs_device_1->bdev_file is not assignedn // which points to a freed memory arean btrfs_device_2->bdev_file = btrfs_get_bdev_and_sb(loop1)n btrfs_fill_supern open_ctreen btrfs_free_extra_devidsn if (btrfs_device_1->bdev_file)n fput(btrfs_device_1->bdev_file) // UAF !nnFix it by setting 'device->bdev_file' as 'NULL' after closing thenbtrfs_device in btrfs_close_one_device().,CVE-2024-50217,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnetfilter: nf_reject_ipv6: fix potential crash in nf_send_reset6()nnI got a syzbot report without a repro [1] crashing in nf_send_reset6()nnI think the issue is that dev->hard_header_len is zero and we attemptnlater to push an Ethernet header.nnUse LL_MAX_HEADER as other functions in net/ipv6/netfilter/nf_reject_ipv6.c.nn[1]nnskbuff: skb_under_panic: text:ffffffff89b1d008 len:74 put:14 head:ffff88803123aa00 data:ffff88803123a9f2 tail:0x3c end:0x140 dev:syz_tunn kernel BUG at net/core/skbuff.c:206 !nOops: invalid opcode: 0000 [#1] PREEMPT SMP KASAN PTInCPU: 0 UID: 0 PID: 7373 Comm: syz.1.568 Not tainted 6.12.0-rc2-syzkaller-00631-g6d858708d465 #0nHardware name: Google Google Compute Engine/Google Compute Engine BIOS Google 09/13/2024n RIP: 0010:skb_panic net/core/skbuff.c:206 [inline]n RIP: 0010:skb_under_panic+0x14b/0x150 net/core/skbuff.c:216nCode: 0d 8d 48 c7 c6 60 a6 29 8e 48 8b 54 24 08 8b 0c 24 44 8b 44 24 04 4d 89 e9 50 41 54 41 57 41 56 e8 ba 30 38 02 48 83 c4 20 90 <0f> 0b 0f 1f 00 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 f3nRSP: 0018:ffffc900045269b0 EFLAGS: 00010282nRAX: 0000000000000088 RBX: dffffc0000000000 RCX: cd66dacdc5d8e800nRDX: 0000000000000000 RSI: 0000000000000200 RDI: 0000000000000000nRBP: ffff88802d39a3d0 R08: ffffffff8174afec R09: 1ffff920008a4cccnR10: dffffc0000000000 R11: fffff520008a4ccd R12: 0000000000000140nR13: ffff88803123aa00 R14: ffff88803123a9f2 R15: 000000000000003cnFS: 00007fdbee5ff6c0(0000) GS:ffff8880b8600000(0000) knlGS:0000000000000000nCS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033nCR2: 0000000000000000 CR3: 000000005d322000 CR4: 00000000003526f0nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400nCall Trace:n <TASK>n skb_push+0xe5/0x100 net/core/skbuff.c:2636n eth_header+0x38/0x1f0 net/ethernet/eth.c:83n dev_hard_header include/linux/netdevice.h:3208 [inline]n nf_send_reset6+0xce6/0x1270 net/ipv6/netfilter/nf_reject_ipv6.c:358n nft_reject_inet_eval+0x3b9/0x690 net/netfilter/nft_reject_inet.c:48n expr_call_ops_eval net/netfilter/nf_tables_core.c:240 [inline]n nft_do_chain+0x4ad/0x1da0 net/netfilter/nf_tables_core.c:288n nft_do_chain_inet+0x418/0x6b0 net/netfilter/nft_chain_filter.c:161n nf_hook_entry_hookfn include/linux/netfilter.h:154 [inline]n nf_hook_slow+0xc3/0x220 net/netfilter/core.c:626n nf_hook include/linux/netfilter.h:269 [inline]n NF_HOOK include/linux/netfilter.h:312 [inline]n br_nf_pre_routing_ipv6+0x63e/0x770 net/bridge/br_netfilter_ipv6.c:184n nf_hook_entry_hookfn include/linux/netfilter.h:154 [inline]n nf_hook_bridge_pre net/bridge/br_input.c:277 [inline]n br_handle_frame+0x9fd/0x1530 net/bridge/br_input.c:424n __netif_receive_skb_core+0x13e8/0x4570 net/core/dev.c:5562n __netif_receive_skb_one_core net/core/dev.c:5666 [inline]n __netif_receive_skb+0x12f/0x650 net/core/dev.c:5781n netif_receive_skb_internal net/core/dev.c:5867 [inline]n netif_receive_skb+0x1e8/0x890 net/core/dev.c:5926n tun_rx_batched+0x1b7/0x8f0 drivers/net/tun.c:1550n tun_get_user+0x3056/0x47e0 drivers/net/tun.c:2007n tun_chr_write_iter+0x10d/0x1f0 drivers/net/tun.c:2053n new_sync_write fs/read_write.c:590 [inline]n vfs_write+0xa6d/0xc90 fs/read_write.c:683n ksys_write+0x183/0x2b0 fs/read_write.c:736n do_syscall_x64 arch/x86/entry/common.c:52 [inline]n do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83n entry_SYSCALL_64_after_hwframe+0x77/0x7fnRIP: 0033:0x7fdbeeb7d1ffnCode: 89 54 24 18 48 89 74 24 10 89 7c 24 08 e8 c9 8d 02 00 48 8b 54 24 18 48 8b 74 24 10 41 89 c0 8b 7c 24 08 b8 01 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 31 44 89 c7 48 89 44 24 08 e8 1c 8e 02 00 48nRSP: 002b:00007fdbee5ff000 EFLAGS: 00000293 ORIG_RAX: 0000000000000001nRAX: ffffffffffffffda RBX: 00007fdbeed36058 RCX: 00007fdbeeb7d1ffnRDX: 000000000000008e RSI: 0000000020000040 RDI: 00000000000000c8nRBP: 00007fdbeebf12be R08: 0000000n---truncated---,CVE-2024-50256,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet: fix crash when config small gso_max_size/gso_ipv4_max_sizennConfig a small gso_max_size/gso_ipv4_max_size will lead to an underflownin sk_dst_gso_max_size() which may trigger a BUG_ON crashnbecause sk->sk_gso_max_size would be much bigger than device limits.nCall Trace:ntcp_write_xmitn tso_segs = tcp_init_tso_segs(skb mss_now);n tcp_set_skb_tso_segsn tcp_skb_pcount_setn // skb->len = 524288 mss_now = 8n // u16 tso_segs = 524288/8 = 65535 -> 0n tso_segs = DIV_ROUND_UP(skb->len mss_now)n BUG_ON(!tso_segs)nAdd check for the minimum value of gso_max_size and gso_ipv4_max_size.,CVE-2024-50258,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnfilemap: Fix bounds checking in filemap_read()nnIf the caller supplies an iocb->ki_pos value that is close to thenfilesystem upper limit and an iterator with a count that causes us tonoverflow that limit then filemap_read() enters an infinite loop.nnThis behaviour was discovered when testing xfstests generic/525 with thenlocalio optimisation for loopback NFS mounts.,CVE-2024-50272,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndm: fix a crash if blk_alloc_disk failsnnIf blk_alloc_disk fails the variable md->disk is set to an error value.ncleanup_mapped_device will see that md->disk is non-NULL and it willnattempt to access it causing a crash on this statementnmd->disk->private_data = NULL;.,CVE-2024-50277,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndm cache: fix flushing uninitialized delayed_work on cache_ctr errornnAn unexpected WARN_ON from flush_work() may occur when cache creationnfails caused by destroying the uninitialized delayed_work waker in thenerror path of cache_create(). For example the warning appears on thensuperblock checksum error.nnReproduce steps:nndmsetup create cmeta --table 0 8192 linear /dev/sdc 0ndmsetup create cdata --table 0 65536 linear /dev/sdc 8192ndmsetup create corig --table 0 524288 linear /dev/sdc 262144ndd if=/dev/urandom of=/dev/mapper/cmeta bs=4k count=1 oflag=directndmsetup create cache --table 0 524288 cache /dev/mapper/cmeta n/dev/mapper/cdata /dev/mapper/corig 128 2 metadata2 writethrough smq 0nnKernel logs:nn(snip)nWARNING: CPU: 0 PID: 84 at kernel/workqueue.c:4178 __flush_work+0x5d4/0x890nnFix by pulling out the cancel_delayed_work_sync() from the constructor'snerror path. This patch doesn't affect the use-after-free fix fornconcurrent dm_resume and dm_destroy (commit 6a459d8edbdb (dm cache: FixnUAF in destroy())) as cache_dtr is not changed.,CVE-2024-50280,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnmedia: av7110: fix a spectre vulnerabilitynnAs warned by smatch:ntdrivers/staging/media/av7110/av7110_ca.c:270 dvb_ca_ioctl() warn: potential spectre issue 'av7110->ci_slot' [w] (local cap)nnThere is a spectre-related vulnerability at the code. Fix it.,CVE-2024-50289,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet: enetc: allocate vf_state during PF probesnnIn the previous implementation vf_state is allocated memory only when VFnis enabled. However net_device_ops::ndo_set_vf_mac() may be called beforenVF is enabled to configure the MAC address of VF. If this is the casenenetc_pf_set_vf_mac() will access vf_state resulting in access to a nullnpointer. The simplified error log is as follows.nnroot@ls1028ardb:~# ip link set eno0 vf 1 mac 00:0c:e7:66:77:89n[ 173.543315] Unable to handle kernel NULL pointer dereference at virtual address 0000000000000004n[ 173.637254] pc : enetc_pf_set_vf_mac+0x3c/0x80 Message from syn[ 173.641973] lr : do_setlink+0x4a8/0xec8n[ 173.732292] Call trace:n[ 173.734740] enetc_pf_set_vf_mac+0x3c/0x80n[ 173.738847] __rtnl_newlink+0x530/0x89cn[ 173.742692] rtnl_newlink+0x50/0x7cn[ 173.746189] rtnetlink_rcv_msg+0x128/0x390n[ 173.750298] netlink_rcv_skb+0x60/0x130n[ 173.754145] rtnetlink_rcv+0x18/0x24n[ 173.757731] netlink_unicast+0x318/0x380n[ 173.761665] netlink_sendmsg+0x17c/0x3c8,CVE-2024-50298,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/msm/gem: prevent integer overflow in msm_ioctl_gem_submit()nnThe submit->cmd[i].size and submit->cmd[i].offset variables are u32nvalues that come from the user via the submit_lookup_cmds() function.nThis addition could lead to an integer wrapping bug so use size_add()nto prevent that.nnPatchwork: https://patchwork.freedesktop.org/patch/624696/,CVE-2024-52559,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/i915/hdcp: Add encoder check in hdcp2_get_capabilitynnAdd encoder check in intel_hdcp2_get_capability to avoidnnull pointer error.,CVE-2024-53050,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/i915/hdcp: Add encoder check in intel_hdcp_get_capabilitynnSometimes during hotplug scenario or suspend/resume scenario encoder isnnot always initialized when intel_hdcp_get_capability addna check to avoid kernel null pointer dereference.,CVE-2024-53051,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet: stmmac: TSO: Fix unbalanced DMA map/unmap for non-paged SKB datannIn case the non-paged data of a SKB carries protocol header and protocolnpayload to be transmitted on a certain platform that the DMA AXI addressnwidth is configured to 40-bit/48-bit or the size of the non-paged datanis bigger than TSO_MAX_BUFF_SIZE on a certain platform that the DMA AXInaddress width is configured to 32-bit then this SKB requires at leastntwo DMA transmit descriptors to serve it.nnFor example three descriptors are allocated to split one DMA buffernmapped from one piece of non-paged data:n dma_desc[N + 0]n dma_desc[N + 1]n dma_desc[N + 2].nThen three elements of tx_q->tx_skbuff_dma[] will be allocated to holdnextra information to be reused in stmmac_tx_clean():n tx_q->tx_skbuff_dma[N + 0]n tx_q->tx_skbuff_dma[N + 1]n tx_q->tx_skbuff_dma[N + 2].nNow we focus on tx_q->tx_skbuff_dma[entry].buf which is the DMA buffernaddress returned by DMA mapping call. stmmac_tx_clean() will try tonunmap the DMA buffer _ONLY_IF_ tx_q->tx_skbuff_dma[entry].bufnis a valid buffer address.nnThe expected behavior that saves DMA buffer address of this non-pagedndata to tx_q->tx_skbuff_dma[entry].buf is:n tx_q->tx_skbuff_dma[N + 0].buf = NULL;n tx_q->tx_skbuff_dma[N + 1].buf = NULL;n tx_q->tx_skbuff_dma[N + 2].buf = dma_map_single();nUnfortunately the current code misbehaves like this:n tx_q->tx_skbuff_dma[N + 0].buf = dma_map_single();n tx_q->tx_skbuff_dma[N + 1].buf = NULL;n tx_q->tx_skbuff_dma[N + 2].buf = NULL;nnOn the stmmac_tx_clean() side when dma_desc[N + 0] is closed by thenDMA engine tx_q->tx_skbuff_dma[N + 0].buf is a valid buffer addressnobviously then the DMA buffer will be unmapped immediately.nThere may be a rare case that the DMA engine does not finish thenpending dma_desc[N + 1] dma_desc[N + 2] yet. Now things will gonhorribly wrong DMA is going to access a unmapped/unreferenced memorynregion corrupted data will be transmited or iommu fault will bentriggered :(nnIn contrast the for-loop that maps SKB fragments behaves perfectlynas expected and that is how the driver should do for both non-pagedndata and paged frags actually.nnThis patch corrects DMA map/unmap sequences by fixing the array indexnfor tx_q->tx_skbuff_dma[entry].buf when assigning DMA buffer address.nnTested and verified on DWXGMAC CORE 3.20a,CVE-2024-53058,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnfirmware: arm_scmi: Fix slab-use-after-free in scmi_bus_notifier()nnThe scmi_dev->name is released prematurely in __scmi_device_destroy()nwhich causes slab-use-after-free when accessing scmi_dev->name innscmi_bus_notifier(). So move the release of scmi_dev->name tonscmi_device_release() to avoid slab-use-after-free.nn | BUG: KASAN: slab-use-after-free in strncmp+0xe4/0xecn | Read of size 1 at addr ffffff80a482bcc0 by task swapper/0/1n |n | CPU: 1 PID: 1 Comm: swapper/0 Not tainted 6.6.38-debug #1n | Hardware name: Qualcomm Technologies Inc. SA8775P Ride (DT)n | Call trace:n | dump_backtrace+0x94/0x114n | show_stack+0x18/0x24n | dump_stack_lvl+0x48/0x60n | print_report+0xf4/0x5b0n | kasan_report+0xa4/0xecn | __asan_report_load1_noabort+0x20/0x2cn | strncmp+0xe4/0xecn | scmi_bus_notifier+0x5c/0x54cn | notifier_call_chain+0xb4/0x31cn | blocking_notifier_call_chain+0x68/0x9cn | bus_notify+0x54/0x78n | device_del+0x1bc/0x840n | device_unregister+0x20/0xb4n | __scmi_device_destroy+0xac/0x280n | scmi_device_destroy+0x94/0xd0n | scmi_chan_setup+0x524/0x750n | scmi_probe+0x7fc/0x1508n | platform_probe+0xc4/0x19cn | really_probe+0x32c/0x99cn | __driver_probe_device+0x15c/0x3c4n | driver_probe_device+0x5c/0x170n | __driver_attach+0x1c8/0x440n | bus_for_each_dev+0xf4/0x178n | driver_attach+0x3c/0x58n | bus_add_driver+0x234/0x4d4n | driver_register+0xf4/0x3c0n | __platform_driver_register+0x60/0x88n | scmi_driver_init+0xb0/0x104n | do_one_initcall+0xb4/0x664n | kernel_init_freeable+0x3c8/0x894n | kernel_init+0x24/0x1e8n | ret_from_fork+0x10/0x20n |n | Allocated by task 1:n | kasan_save_stack+0x2c/0x54n | kasan_set_track+0x2c/0x40n | kasan_save_alloc_info+0x24/0x34n | __kasan_kmalloc+0xa0/0xb8n | __kmalloc_node_track_caller+0x6c/0x104n | kstrdup+0x48/0x84n | kstrdup_const+0x34/0x40n | __scmi_device_create.part.0+0x8c/0x408n | scmi_device_create+0x104/0x370n | scmi_chan_setup+0x2a0/0x750n | scmi_probe+0x7fc/0x1508n | platform_probe+0xc4/0x19cn | really_probe+0x32c/0x99cn | __driver_probe_device+0x15c/0x3c4n | driver_probe_device+0x5c/0x170n | __driver_attach+0x1c8/0x440n | bus_for_each_dev+0xf4/0x178n | driver_attach+0x3c/0x58n | bus_add_driver+0x234/0x4d4n | driver_register+0xf4/0x3c0n | __platform_driver_register+0x60/0x88n | scmi_driver_init+0xb0/0x104n | do_one_initcall+0xb4/0x664n | kernel_init_freeable+0x3c8/0x894n | kernel_init+0x24/0x1e8n | ret_from_fork+0x10/0x20n |n | Freed by task 1:n | kasan_save_stack+0x2c/0x54n | kasan_set_track+0x2c/0x40n | kasan_save_free_info+0x38/0x5cn | __kasan_slab_free+0xe8/0x164n | __kmem_cache_free+0x11c/0x230n | kfree+0x70/0x130n | kfree_const+0x20/0x40n | __scmi_device_destroy+0x70/0x280n | scmi_device_destroy+0x94/0xd0n | scmi_chan_setup+0x524/0x750n | scmi_probe+0x7fc/0x1508n | platform_probe+0xc4/0x19cn | really_probe+0x32c/0x99cn | __driver_probe_device+0x15c/0x3c4n | driver_probe_device+0x5c/0x170n | __driver_attach+0x1c8/0x440n | bus_for_each_dev+0xf4/0x178n | driver_attach+0x3c/0x58n | bus_add_driver+0x234/0x4d4n | driver_register+0xf4/0x3c0n | __platform_driver_register+0x60/0x88n | scmi_driver_init+0xb0/0x104n | do_one_initcall+0xb4/0x664n | kernel_init_freeable+0x3c8/0x894n | kernel_init+0x24/0x1e8n | ret_from_fork+0x10/0x20,CVE-2024-53068,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnmm/thp: fix deferred split unqueue naming and lockingnnRecent changes are putting more pressure on THP deferred split queues:nunder load revealing long-standing races causing list_del corruptionsnBad page states and worse (I keep BUGs in both of those so usuallyndon't get to see how badly they end up without). The relevant recentnchanges being 6.8's mTHP 6.10's mTHP swapout and 6.12's mTHP swapinnimproved swap allocation and underused THP splitting.nnBefore fixing locking: rename misleading folio_undo_large_rmappable()nwhich does not undo large_rmappable to folio_unqueue_deferred_split()nwhich is what it does. But that and its out-of-line __callee are mmninternals of very limited usability: add comment and WARN_ON_ONCEs toncheck usage; and return a bool to say if a deferred split was unqueuednwhich can then be used in WARN_ON_ONCEs around safety checks (sparingncallers the arcane conditionals in __folio_unqueue_deferred_split()).nnJust omit the folio_unqueue_deferred_split() from free_unref_folios() allnof whose callers now call it beforehand (and if any forget then bad_page()nwill tell) - except for its caller put_pages_list() which itself nonlonger has any callers (and will be deleted separately).nnSwapout: mem_cgroup_swapout() has been resetting folio->memcg_data 0nwithout checking and unqueueing a THP folio from deferred split list;nwhich is unfortunate since the split_queue_lock depends on the memcgn(when memcg is enabled); so swapout has been unqueueing such THPs laternwhen freeing the folio using the pgdat's lock instead: potentiallyncorrupting the memcg's list. __remove_mapping() has frozen refcount to 0nhere so no problem with calling folio_unqueue_deferred_split() beforenresetting memcg_data.nnThat goes back to 5.4 commit 87eaceb3faa5 (mm: thp: make deferred splitnshrinker memcg aware): which included a check on swapcache before addingnto deferred queue but no check on deferred queue before adding THP tonswapcache. That worked fine with the usual sequence of events in reclaimn(though there were a couple of rare ways in which a THP on deferred queuencould have been swapped out) but 6.12 commit dafff3f4c850 (mm: splitnunderused THPs) avoids splitting underused THPs in reclaim which makesnswapcache THPs on deferred queue commonplace.nnKeep the check on swapcache before adding to deferred queue? Yes: it isnno longer essential but preserves the existing behaviour and is likelynto be a worthwhile optimization (vmstat showed much more traffic on thenqueue under swapping load if the check was removed); update its comment.nnMemcg-v1 move (deprecated): mem_cgroup_move_account() has been changingnfolio->memcg_data without checking and unqueueing a THP folio from thendeferred list sometimes corrupting from memcg's list like swapout. nRefcount is non-zero here so folio_unqueue_deferred_split() can only benused in a WARN_ON_ONCE to validate the fix which must be done earlier:nmem_cgroup_move_charge_pte_range() first try to split the THP (splittingnof course unqueues) or skip it if that fails. Not ideal but movingncharge has been requested and khugepaged should repair the THP later:nnobody wants new custom unqueueing code just for this deprecated case.nnThe 87eaceb3faa5 commit did have the code to move from one deferred listnto another (but was not conscious of its unsafety while refcount non-0);nbut that was removed by 5.6 commit fac0516b5534 (mm: thp: don't need carendeferred split queue in memcg charge move path) which argued that thenexistence of a PMD mapping guarantees that the THP cannot be on a deferrednlist. As above false in rare cases and now commonly false.nnBackport to 6.11 should be straightforward. Earlier backports must takencare that other _deferred_list fixes and dependencies are included. Therenis not a strong case for backports but they can fix cornercases.,CVE-2024-53079,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nni40e: fix race condition by adding filter's intermediate sync statennFix a race condition in the i40e driver that leads to MAC/VLAN filtersnbecoming corrupted and leaking. Address the issue that occurs undernheavy load when multiple threads are concurrently modifying MAC/VLANnfilters by setting mac and port VLAN.nn1. Thread T0 allocates a filter in i40e_add_filter() withinn i40e_ndo_set_vf_port_vlan().n2. Thread T1 concurrently frees the filter in __i40e_del_filter() withinn i40e_ndo_set_vf_mac().n3. Subsequently i40e_service_task() calls i40e_sync_vsi_filters() whichn refers to the already freed filter memory causing corruption.nnReproduction steps:n1. Spawn multiple VFs.n2. Apply a concurrent heavy load by running parallel operations to changen MAC addresses on the VFs and change port VLANs on the host.n3. Observe errors in dmesg:nError I40E_AQ_RC_ENOSPC adding RX filters on VF XXntplease set promiscuous on manually for VF XX.nnExact code for stable reproduction Intel can't open-source now.nnThe fix involves implementing a new intermediate filter statenI40E_FILTER_NEW_SYNC for the time when a filter is on a tmp_add_list.nThese filters cannot be deleted from the hash list directly butnmust be removed using the full process.,CVE-2024-53088,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnafs: Fix lock recursionnnafs_wake_up_async_call() can incur lock recursion. The problem is that itnis called from AF_RXRPC whilst holding the ->notify_lock but it tries tontake a ref on the afs_call struct in order to pass it to a work queue - butnif the afs_call is already queued we then have an extraneous ref that mustnbe put... calling afs_put_call() may call back down into AF_RXRPC throughnrxrpc_kernel_shutdown_call() however which might try taking then->notify_lock again.nnThis case isn't very common however so defer it to a workqueue. The oopsnlooks something like:nn BUG: spinlock recursion on CPU#0 krxrpcio/7001/1646n lock: 0xffff888141399b30 .magic: dead4ead .owner: krxrpcio/7001/1646 .owner_cpu: 0n CPU: 0 UID: 0 PID: 1646 Comm: krxrpcio/7001 Not tainted 6.12.0-rc2-build3+ #4351n Hardware name: ASUS All Series/H97-PLUS BIOS 2306 10/09/2014n Call Trace:n <TASK>n dump_stack_lvl+0x47/0x70n do_raw_spin_lock+0x3c/0x90n rxrpc_kernel_shutdown_call+0x83/0xb0n afs_put_call+0xd7/0x180n rxrpc_notify_socket+0xa0/0x190n rxrpc_input_split_jumbo+0x198/0x1d0n rxrpc_input_data+0x14b/0x1e0n ? rxrpc_input_call_packet+0xc2/0x1f0n rxrpc_input_call_event+0xad/0x6b0n rxrpc_input_packet_on_conn+0x1e1/0x210n rxrpc_input_packet+0x3f2/0x4d0n rxrpc_io_thread+0x243/0x410n ? __pfx_rxrpc_io_thread+0x10/0x10n kthread+0xcf/0xe0n ? __pfx_kthread+0x10/0x10n ret_from_fork+0x24/0x40n ? __pfx_kthread+0x10/0x10n ret_from_fork_asm+0x1a/0x30n </TASK>,CVE-2024-53090,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnvme-multipath: defer partition scanningnnWe need to suppress the partition scan from occuring within thencontroller's scan_work context. If a path error occurs here the IO willnwait until a path becomes available or all paths are torn down but thatnaction also occurs within scan_work so it would deadlock. Defer thenpartion scan to a different context that does not block scan_work.,CVE-2024-53093,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnRDMA/siw: Add sendpage_ok() check to disable MSG_SPLICE_PAGESnnWhile running ISER over SIW the initiator machine encounters a warningnfrom skb_splice_from_iter() indicating that a slab page is being used innsend_page. To address this it is better to add a sendpage_ok() checknwithin the driver itself and if it returns 0 then MSG_SPLICE_PAGES flagnshould be disabled before entering the network stack.nnA similar issue has been discussed for NVMe in this thread:nhttps://lore.kernel.org/all/20240530142417.146696-1-ofir.gal@volumez.com/nn WARNING: CPU: 0 PID: 5342 at net/core/skbuff.c:7140 skb_splice_from_iter+0x173/0x320n Call Trace:n tcp_sendmsg_locked+0x368/0xe40n siw_tx_hdt+0x695/0xa40 [siw]n siw_qp_sq_process+0x102/0xb00 [siw]n siw_sq_resume+0x39/0x110 [siw]n siw_run_sq+0x74/0x160 [siw]n kthread+0xd2/0x100n ret_from_fork+0x34/0x40n ret_from_fork_asm+0x1a/0x30,CVE-2024-53094,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnsmb: client: Fix use-after-free of network namespace.nnRecently we got a customer report that CIFS triggers oops whilenreconnecting to a server. [0]nnThe workload runs on Kubernetes and some pods mount CIFS serversnin non-root network namespaces. The problem rarely happened butnit was always while the pod was dying.nnThe root cause is wrong reference counting for network namespace.nnCIFS uses kernel sockets which do not hold refcnt of the netns thatnthe socket belongs to. That means CIFS must ensure the socket isnalways freed before its netns; otherwise use-after-free happens.nnThe repro steps are roughly:nn 1. mount CIFS in a non-root netnsn 2. drop packets from the netnsn 3. destroy the netnsn 4. unmount CIFSnnWe can reproduce the issue quickly with the script [1] below and seenthe splat [2] if CONFIG_NET_NS_REFCNT_TRACKER is enabled.nnWhen the socket is TCP it is hard to guarantee the netns lifetimenwithout holding refcnt due to async timers.nnLet's hold netns refcnt for each socket as done for SMC in commitn9744d2bf1976 (smc: Fix use-after-free in tcp_write_timer_handler().).nnNote that we need to move put_net() from cifs_put_tcp_session() tonclean_demultiplex_info(); otherwise __sock_create() still could touch anfreed netns while cifsd tries to reconnect from cifs_demultiplex_thread().nnAlso maybe_get_net() cannot be put just before __sock_create() becausenthe code is not under RCU and there is a small chance that the samenaddress happened to be reallocated to another netns.nn[0]:nCIFS: VFS: XXXXXXXXXXX has not responded in 15 seconds. Reconnecting...nCIFS: Serverclose failed 4 times giving upnUnable to handle kernel paging request at virtual address 14de99e461f84a07nMem abort info:n ESR = 0x0000000096000004n EC = 0x25: DABT (current EL) IL = 32 bitsn SET = 0 FnV = 0n EA = 0 S1PTW = 0n FSC = 0x04: level 0 translation faultnData abort info:n ISV = 0 ISS = 0x00000004n CM = 0 WnR = 0n[14de99e461f84a07] address between user and kernel address rangesnInternal error: Oops: 0000000096000004 [#1] SMPnModules linked in: cls_bpf sch_ingress nls_utf8 cifs cifs_arc4 cifs_md4 dns_resolver tcp_diag inet_diag veth xt_state xt_connmark nf_conntrack_netlink xt_nat xt_statistic xt_MASQUERADE xt_mark xt_addrtype ipt_REJECT nf_reject_ipv4 nft_chain_nat nf_nat xt_conntrack nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 xt_comment nft_compat nf_tables nfnetlink overlay nls_ascii nls_cp437 sunrpc vfat fat aes_ce_blk aes_ce_cipher ghash_ce sm4_ce_cipher sm4 sm3_ce sm3 sha3_ce sha512_ce sha512_arm64 sha1_ce ena button sch_fq_codel loop fuse configfs dmi_sysfs sha2_ce sha256_arm64 dm_mirror dm_region_hash dm_log dm_mod dax efivarfsnCPU: 5 PID: 2690970 Comm: cifsd Not tainted 6.1.103-109.184.amzn2023.aarch64 #1nHardware name: Amazon EC2 r7g.4xlarge/ BIOS 1.0 11/1/2018npstate: 00400005 (nzcv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)npc : fib_rules_lookup+0x44/0x238nlr : __fib_lookup+0x64/0xbcnsp : ffff8000265db790nx29: ffff8000265db790 x28: 0000000000000000 x27: 000000000000bd01nx26: 0000000000000000 x25: ffff000b4baf8000 x24: ffff00047b5e4580nx23: ffff8000265db7e0 x22: 0000000000000000 x21: ffff00047b5e4500nx20: ffff0010e3f694f8 x19: 14de99e461f849f7 x18: 0000000000000000nx17: 0000000000000000 x16: 0000000000000000 x15: 0000000000000000nx14: 0000000000000000 x13: 0000000000000000 x12: 3f92800abd010002nx11: 0000000000000001 x10: ffff0010e3f69420 x9 : ffff800008a6f294nx8 : 0000000000000000 x7 : 0000000000000006 x6 : 0000000000000000nx5 : 0000000000000001 x4 : ffff001924354280 x3 : ffff8000265db7e0nx2 : 0000000000000000 x1 : ffff0010e3f694f8 x0 : ffff00047b5e4500nCall trace:n fib_rules_lookup+0x44/0x238n __fib_lookup+0x64/0xbcn ip_route_output_key_hash_rcu+0x2c4/0x398n ip_route_output_key_hash+0x60/0x8cn tcp_v4_connect+0x290/0x488n __inet_stream_connect+0x108/0x3d0n inet_stream_connect+0x50/0x78n kernel_connect+0x6c/0xacn generic_ip_connen---truncated---,CVE-2024-53095,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnvme: tcp: avoid race between queue_lock lock and destroynnCommit 76d54bf20cdc (nvme-tcp: don't access released socket duringnerror recovery) added a mutex_lock() call for the queue->queue_locknin nvme_tcp_get_address(). However the mutex_lock() races withnmutex_destroy() in nvme_tcp_free_queue() and causes the WARN below.nnDEBUG_LOCKS_WARN_ON(lock->magic != lock)nWARNING: CPU: 3 PID: 34077 at kernel/locking/mutex.c:587 __mutex_lock+0xcf0/0x1220nModules linked in: nvmet_tcp nvmet nvme_tcp nvme_fabrics iw_cm ib_cm ib_core pktcdvd nft_fib_inet nft_fib_ipv4 nft_fib_ipv6 nft_fib nft_reject_inet nf_reject_ipv4 nf_reject_ipv6 nft_reject nft_ct nft_chain_nat nf_nat nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 ip_set nf_tables qrtr sunrpc ppdev 9pnet_virtio 9pnet pcspkr netfs parport_pc parport e1000 i2c_piix4 i2c_smbus loop fuse nfnetlink zram bochs drm_vram_helper drm_ttm_helper ttm drm_kms_helper xfs drm sym53c8xx floppy nvme scsi_transport_spi nvme_core nvme_auth serio_raw ata_generic pata_acpi dm_multipath qemu_fw_cfg [last unloaded: ib_uverbs]nCPU: 3 UID: 0 PID: 34077 Comm: udisksd Not tainted 6.11.0-rc7 #319nHardware name: QEMU Standard PC (i440FX + PIIX 1996) BIOS 1.16.3-2.fc40 04/01/2014nRIP: 0010:__mutex_lock+0xcf0/0x1220nCode: 08 84 d2 0f 85 c8 04 00 00 8b 15 ef b6 c8 01 85 d2 0f 85 78 f4 ff ff 48 c7 c6 20 93 ee af 48 c7 c7 60 91 ee af e8 f0 a7 6d fd <0f> 0b e9 5e f4 ff ff 48 b8 00 00 00 00 00 fc ff df 4c 89 f2 48 c1nRSP: 0018:ffff88811305f760 EFLAGS: 00010286nRAX: 0000000000000000 RBX: ffff88812c652058 RCX: 0000000000000000nRDX: 0000000000000000 RSI: 0000000000000004 RDI: 0000000000000001nRBP: ffff88811305f8b0 R08: 0000000000000001 R09: ffffed1075c36341nR10: ffff8883ae1b1a0b R11: 0000000000010498 R12: 0000000000000000nR13: 0000000000000000 R14: dffffc0000000000 R15: ffff88812c652058nFS: 00007f9713ae4980(0000) GS:ffff8883ae180000(0000) knlGS:0000000000000000nCS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033nCR2: 00007fcd78483c7c CR3: 0000000122c38000 CR4: 00000000000006f0nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400nCall Trace:n <TASK>n ? __warn.cold+0x5b/0x1afn ? __mutex_lock+0xcf0/0x1220n ? report_bug+0x1ec/0x390n ? handle_bug+0x3c/0x80n ? exc_invalid_op+0x13/0x40n ? asm_exc_invalid_op+0x16/0x20n ? __mutex_lock+0xcf0/0x1220n ? nvme_tcp_get_address+0xc2/0x1e0 [nvme_tcp]n ? __pfx___mutex_lock+0x10/0x10n ? __lock_acquire+0xd6a/0x59e0n ? nvme_tcp_get_address+0xc2/0x1e0 [nvme_tcp]n nvme_tcp_get_address+0xc2/0x1e0 [nvme_tcp]n ? __pfx_nvme_tcp_get_address+0x10/0x10 [nvme_tcp]n nvme_sysfs_show_address+0x81/0xc0 [nvme_core]n dev_attr_show+0x42/0x80n ? __asan_memset+0x1f/0x40n sysfs_kf_seq_show+0x1f0/0x370n seq_read_iter+0x2cb/0x1130n ? rw_verify_area+0x3b1/0x590n ? __mutex_lock+0x433/0x1220n vfs_read+0x6a6/0xa20n ? lockdep_hardirqs_on+0x78/0x100n ? __pfx_vfs_read+0x10/0x10n ksys_read+0xf7/0x1d0n ? __pfx_ksys_read+0x10/0x10n ? __x64_sys_openat+0x105/0x1d0n do_syscall_64+0x93/0x180n ? lockdep_hardirqs_on_prepare+0x16d/0x400n ? do_syscall_64+0x9f/0x180n ? lockdep_hardirqs_on+0x78/0x100n ? do_syscall_64+0x9f/0x180n ? __pfx_ksys_read+0x10/0x10n ? lockdep_hardirqs_on_prepare+0x16d/0x400n ? do_syscall_64+0x9f/0x180n ? lockdep_hardirqs_on+0x78/0x100n ? do_syscall_64+0x9f/0x180n ? lockdep_hardirqs_on_prepare+0x16d/0x400n ? do_syscall_64+0x9f/0x180n ? lockdep_hardirqs_on+0x78/0x100n ? do_syscall_64+0x9f/0x180n ? lockdep_hardirqs_on_prepare+0x16d/0x400n ? do_syscall_64+0x9f/0x180n ? lockdep_hardirqs_on+0x78/0x100n ? do_syscall_64+0x9f/0x180n ? lockdep_hardirqs_on_prepare+0x16d/0x400n ? do_syscall_64+0x9f/0x180n ? lockdep_hardirqs_on+0x78/0x100n ? do_syscall_64+0x9f/0x180n ? do_syscall_64+0x9f/0x180n entry_SYSCALL_64_after_hwframe+0x76/0x7enRIP: 0033:0x7f9713f55cfanCode: 55 48 89 e5 48 83 ec 20 48 89 55 e8 48 89 75 f0 89 7d f8 e8 e8 74 f8 ff 48 8b 55 e8 48 8b 75 f0 4n---truncated---,CVE-2024-53100,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Adjust VSDB parser for replay featurennAt some point the IEEE ID identification for the replay check in thenAMD EDID was added. However this check causes the followingnout-of-bounds issues when using KASAN:nn[ 27.804016] BUG: KASAN: slab-out-of-bounds in amdgpu_dm_update_freesync_caps+0xefa/0x17a0 [amdgpu]n[ 27.804788] Read of size 1 at addr ffff8881647fdb00 by task systemd-udevd/383nn...nn[ 27.821207] Memory state around the buggy address:n[ 27.821215] ffff8881647fda00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00n[ 27.821224] ffff8881647fda80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00n[ 27.821234] >ffff8881647fdb00: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fcn[ 27.821243] ^n[ 27.821250] ffff8881647fdb80: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fcn[ 27.821259] ffff8881647fdc00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00n[ 27.821268] ==================================================================nnThis is caused because the ID extraction happens outside of the range ofnthe edid lenght. This commit addresses this issue by considering thenamd_vsdb_block size.nn(cherry picked from commit b7e381b1ccd5e778e3d9c44c669ad38439a861d8),CVE-2024-53108,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnx86/CPU/AMD: Clear virtualized VMLOAD/VMSAVE on Zen4 clientnnA number of Zen4 client SoCs advertise the ability to use virtualizednVMLOAD/VMSAVE but using these instructions is reported to be a causenof a random host reboot.nnThese instructions aren't intended to be advertised on Zen4 clientnso clear the capability.,CVE-2024-53114,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnmptcp: cope racing subflow creation in mptcp_rcv_space_adjustnnAdditional active subflows - i.e. created by the in kernel pathnmanager - are included into the subflow list before starting then3whs.nnA racing recvmsg() spooling data received on an already establishednsubflow would unconditionally call tcp_cleanup_rbuf() on all thencurrent subflows potentially hitting a divide by zero error onnthe newly created ones.nnExplicitly check that the subflow is in a suitable state beforeninvoking tcp_cleanup_rbuf().,CVE-2024-53122,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnsched/task_stack: fix object_is_on_stack() for KASAN tagged pointersnnWhen CONFIG_KASAN_SW_TAGS and CONFIG_KASAN_STACK are enabled thenobject_is_on_stack() function may produce incorrect results due to thenpresence of tags in the obj pointer while the stack pointer does not haventags. This discrepancy can lead to incorrect stack object detection andnsubsequently trigger warnings if CONFIG_DEBUG_OBJECTS is also enabled.nnExample of the warning:nnODEBUG: object 3eff800082ea7bb0 is NOT on stack ffff800082ea0000 but annotated.n------------[ cut here ]------------nWARNING: CPU: 0 PID: 1 at lib/debugobjects.c:557 __debug_object_init+0x330/0x364nModules linked in:nCPU: 0 UID: 0 PID: 1 Comm: swapper/0 Not tainted 6.12.0-rc5 #4nHardware name: linuxdummy-virt (DT)npstate: 600000c5 (nZCv daIF -PAN -UAO -TCO -DIT -SSBS BTYPE=--)npc : __debug_object_init+0x330/0x364nlr : __debug_object_init+0x330/0x364nsp : ffff800082ea7b40nx29: ffff800082ea7b40 x28: 98ff0000c0164518 x27: 98ff0000c0164534nx26: ffff800082d93ec8 x25: 0000000000000001 x24: 1cff0000c00172a0nx23: 0000000000000000 x22: ffff800082d93ed0 x21: ffff800081a24418nx20: 3eff800082ea7bb0 x19: efff800000000000 x18: 0000000000000000nx17: 00000000000000ff x16: 0000000000000047 x15: 206b63617473206enx14: 0000000000000018 x13: ffff800082ea7780 x12: 0ffff800082ea78enx11: 0ffff800082ea790 x10: 0ffff800082ea79d x9 : 34d77febe173e800nx8 : 34d77febe173e800 x7 : 0000000000000001 x6 : 0000000000000001nx5 : feff800082ea74b8 x4 : ffff800082870a90 x3 : ffff80008018d3c4nx2 : 0000000000000001 x1 : ffff800082858810 x0 : 0000000000000050nCall trace:n __debug_object_init+0x330/0x364n debug_object_init_on_stack+0x30/0x3cn schedule_hrtimeout_range_clock+0xac/0x26cn schedule_hrtimeout+0x1c/0x30n wait_task_inactive+0x1d4/0x25cn kthread_bind_mask+0x28/0x98n init_rescuer+0x1e8/0x280n workqueue_init+0x1a0/0x3ccn kernel_init_freeable+0x118/0x200n kernel_init+0x28/0x1f0n ret_from_fork+0x10/0x20n---[ end trace 0000000000000000 ]---nODEBUG: object 3eff800082ea7bb0 is NOT on stack ffff800082ea0000 but annotated.n------------[ cut here ]------------,CVE-2024-53128,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Handle dml allocation failure to avoid crashnn[Why]nIn the case where a dml allocation fails for any reason thencurrent state's dml contexts would no longer be valid. Thennsubsequent calls dc_state_copy_internal would shallow copyninvalid memory and if the new state was released a doublenfree would occur.nn[How]nReset dml pointers in new_state to NULL and avoid invalidnpointernn(cherry picked from commit bcafdc61529a48f6f06355d78eb41b3aeda5296c),CVE-2024-53133,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnBluetooth: hci_event: Align BR/EDR JUST_WORKS paring with LEnnThis aligned BR/EDR JUST_WORKS method with LE which since 92516cd97fd4n(Bluetooth: Always request for user confirmation for Just Works)nalways request user confirmation with confirm_hint set since thenlikes of bluetoothd have dedicated policy around JUST_WORKS methodn(e.g. main.conf:JustWorksRepairing).nnCVE: CVE-2024-8805,CVE-2024-53144,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnexfat: fix out-of-bounds access of directory entriesnnIn the case of the directory size is greater than or equal tonthe cluster size if start_clu becomes an EOF cluster(an invalidncluster) due to file system corruption then the directory entrynwhere ei->hint_femp.eidx hint is outside the directory resultingnin an out-of-bounds access which may cause further file systemncorruption.nnThis commit adds a check for start_clu if it is an invalid clusternthe file or directory will be treated as empty.,CVE-2024-53147,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnsh: intc: Fix use-after-free bug in register_intc_controller()nnIn the error handling for this function d is freed without evernremoving it from intc_list which would lead to a use after free.nTo fix this let's only add it to the list after everything hasnsucceeded.,CVE-2024-53165,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnsunrpc: fix one UAF issue caused by sunrpc kernel tcp socketnnBUG: KASAN: slab-use-after-free in tcp_write_timer_handler+0x156/0x3e0nRead of size 1 at addr ffff888111f322cd by task swapper/0/0nnCPU: 0 UID: 0 PID: 0 Comm: swapper/0 Not tainted 6.12.0-rc4-dirty #7nHardware name: QEMU Standard PC (i440FX + PIIX 1996) BIOS 1.15.0-1nCall Trace:n <IRQ>n dump_stack_lvl+0x68/0xa0n print_address_description.constprop.0+0x2c/0x3d0n print_report+0xb4/0x270n kasan_report+0xbd/0xf0n tcp_write_timer_handler+0x156/0x3e0n tcp_write_timer+0x66/0x170n call_timer_fn+0xfb/0x1d0n __run_timers+0x3f8/0x480n run_timer_softirq+0x9b/0x100n handle_softirqs+0x153/0x390n __irq_exit_rcu+0x103/0x120n irq_exit_rcu+0xe/0x20n sysvec_apic_timer_interrupt+0x76/0x90n </IRQ>n <TASK>n asm_sysvec_apic_timer_interrupt+0x1a/0x20nRIP: 0010:default_idle+0xf/0x20nCode: 4c 01 c7 4c 29 c2 e9 72 ff ff ff 90 90 90 90 90 90 90 90 90 90 90 90n 90 90 90 90 f3 0f 1e fa 66 90 0f 00 2d 33 f8 25 00 fb f4 <fa> c3 cc cc ccn cc 66 66 2e 0f 1f 84 00 00 00 00 00 90 90 90 90 90nRSP: 0018:ffffffffa2007e28 EFLAGS: 00000242nRAX: 00000000000f3b31 RBX: 1ffffffff4400fc7 RCX: ffffffffa09c3196nRDX: 0000000000000000 RSI: 0000000000000000 RDI: ffffffff9f00590fnRBP: 0000000000000000 R08: 0000000000000001 R09: ffffed102360835dnR10: ffff88811b041aeb R11: 0000000000000001 R12: 0000000000000000nR13: ffffffffa202d7c0 R14: 0000000000000000 R15: 00000000000147d0n default_idle_call+0x6b/0xa0n cpuidle_idle_call+0x1af/0x1f0n do_idle+0xbc/0x130n cpu_startup_entry+0x33/0x40n rest_init+0x11f/0x210n start_kernel+0x39a/0x420n x86_64_start_reservations+0x18/0x30n x86_64_start_kernel+0x97/0xa0n common_startup_64+0x13e/0x141n </TASK>nnAllocated by task 595:n kasan_save_stack+0x24/0x50n kasan_save_track+0x14/0x30n __kasan_slab_alloc+0x87/0x90n kmem_cache_alloc_noprof+0x12b/0x3f0n copy_net_ns+0x94/0x380n create_new_namespaces+0x24c/0x500n unshare_nsproxy_namespaces+0x75/0xf0n ksys_unshare+0x24e/0x4f0n __x64_sys_unshare+0x1f/0x30n do_syscall_64+0x70/0x180n entry_SYSCALL_64_after_hwframe+0x76/0x7ennFreed by task 100:n kasan_save_stack+0x24/0x50n kasan_save_track+0x14/0x30n kasan_save_free_info+0x3b/0x60n __kasan_slab_free+0x54/0x70n kmem_cache_free+0x156/0x5d0n cleanup_net+0x5d3/0x670n process_one_work+0x776/0xa90n worker_thread+0x2e2/0x560n kthread+0x1a8/0x1f0n ret_from_fork+0x34/0x60n ret_from_fork_asm+0x1a/0x30nnReproduction script:nnmkdir -p /mnt/nfssharenmkdir -p /mnt/nfs/netns_1nmkfs.ext4 /dev/sdbnmount /dev/sdb /mnt/nfssharensystemctl restart nfs-servernchmod 777 /mnt/nfssharenexportfs -i -o rwno_root_squash *:/mnt/nfssharennip netns add netns_1nip link add name veth_1_peer type veth peer veth_1nifconfig veth_1_peer 11.11.0.254 upnip link set veth_1 netns netns_1nip netns exec netns_1 ifconfig veth_1 11.11.0.1nnip netns exec netns_1 /root/iptables -A OUTPUT -d 11.11.0.254 -p tcp nt--tcp-flags FIN FIN -j DROPnn(note: In my environment a DESTROY_CLIENTID operation is always sentn immediately breaking the nfs tcp connection.)nip netns exec netns_1 timeout -s 9 300 mount -t nfs -o proto=tcpvers=4.1 nt11.11.0.254:/mnt/nfsshare /mnt/nfs/netns_1nnip netns del netns_1nnThe reason here is that the tcp socket in netns_1 (nfs side) has beennshutdown and closed (done in xs_destroy) but the FIN message (with ack)nis discarded and the nfsd side keeps sending retransmission messages.nAs a result when the tcp sock in netns_1 processes the received messagenit sends the message (FIN message) in the sending queue and the tcp timernis re-established. When the network namespace is deleted the net structurenaccessed by tcp's timer handler function causes problems.nnTo fix this problem let's hold netns refcnt for the tcp kernel socket asndone in other modules. This is an ugly hack which can easily be backportednto earlier kernels. A proper fix which cleans up the interfaces willnfollow but may not be so easy to backport.,CVE-2024-53168,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnsmb: prevent use-after-free due to open_cached_dir error pathsnnIf open_cached_dir() encounters an error parsing the lease from thenserver the error handling may race with receiving a lease breaknresulting in open_cached_dir() freeing the cfid while the queued work isnpending.nnUpdate open_cached_dir() to drop refs rather than directly freeing thencfid.nnHave cached_dir_lease_break() cfids_laundromat_worker() andninvalidate_all_cached_dirs() clear has_lease immediately while stillnholding cfids->cfid_list_lock and then use this to also simplify thenreference counting in cfids_laundromat_worker() andninvalidate_all_cached_dirs().nnFixes this KASAN splat (which manually injects an error and lease breaknin open_cached_dir()):nn==================================================================nBUG: KASAN: slab-use-after-free in smb2_cached_lease_break+0x27/0xb0nRead of size 8 at addr ffff88811cc24c10 by task kworker/3:1/65nnCPU: 3 UID: 0 PID: 65 Comm: kworker/3:1 Not tainted 6.12.0-rc6-g255cf264e6e5-dirty #87nHardware name: VMware Inc. VMware Virtual Platform/440BX Desktop Reference Platform BIOS 6.00 11/12/2020nWorkqueue: cifsiod smb2_cached_lease_breaknCall Trace:n <TASK>n dump_stack_lvl+0x77/0xb0n print_report+0xce/0x660n kasan_report+0xd3/0x110n smb2_cached_lease_break+0x27/0xb0n process_one_work+0x50a/0xc50n worker_thread+0x2ba/0x530n kthread+0x17c/0x1c0n ret_from_fork+0x34/0x60n ret_from_fork_asm+0x1a/0x30n </TASK>nnAllocated by task 2464:n kasan_save_stack+0x33/0x60n kasan_save_track+0x14/0x30n __kasan_kmalloc+0xaa/0xb0n open_cached_dir+0xa7d/0x1fb0n smb2_query_path_info+0x43c/0x6e0n cifs_get_fattr+0x346/0xf10n cifs_get_inode_info+0x157/0x210n cifs_revalidate_dentry_attr+0x2d1/0x460n cifs_getattr+0x173/0x470n vfs_statx_path+0x10f/0x160n vfs_statx+0xe9/0x150n vfs_fstatat+0x5e/0xc0n __do_sys_newfstatat+0x91/0xf0n do_syscall_64+0x95/0x1a0n entry_SYSCALL_64_after_hwframe+0x76/0x7ennFreed by task 2464:n kasan_save_stack+0x33/0x60n kasan_save_track+0x14/0x30n kasan_save_free_info+0x3b/0x60n __kasan_slab_free+0x51/0x70n kfree+0x174/0x520n open_cached_dir+0x97f/0x1fb0n smb2_query_path_info+0x43c/0x6e0n cifs_get_fattr+0x346/0xf10n cifs_get_inode_info+0x157/0x210n cifs_revalidate_dentry_attr+0x2d1/0x460n cifs_getattr+0x173/0x470n vfs_statx_path+0x10f/0x160n vfs_statx+0xe9/0x150n vfs_fstatat+0x5e/0xc0n __do_sys_newfstatat+0x91/0xf0n do_syscall_64+0x95/0x1a0n entry_SYSCALL_64_after_hwframe+0x76/0x7ennLast potentially related work creation:n kasan_save_stack+0x33/0x60n __kasan_record_aux_stack+0xad/0xc0n insert_work+0x32/0x100n __queue_work+0x5c9/0x870n queue_work_on+0x82/0x90n open_cached_dir+0x1369/0x1fb0n smb2_query_path_info+0x43c/0x6e0n cifs_get_fattr+0x346/0xf10n cifs_get_inode_info+0x157/0x210n cifs_revalidate_dentry_attr+0x2d1/0x460n cifs_getattr+0x173/0x470n vfs_statx_path+0x10f/0x160n vfs_statx+0xe9/0x150n vfs_fstatat+0x5e/0xc0n __do_sys_newfstatat+0x91/0xf0n do_syscall_64+0x95/0x1a0n entry_SYSCALL_64_after_hwframe+0x76/0x7ennThe buggy address belongs to the object at ffff88811cc24c00n which belongs to the cache kmalloc-1k of size 1024nThe buggy address is located 16 bytes inside ofn freed 1024-byte region [ffff88811cc24c00 ffff88811cc25000),CVE-2024-53177,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnsmb: client: fix use-after-free of signing keynnCustomers have reported use-after-free in @ses->auth_key.response withnSMB2.1 + sign mounts which occurs due to following race:nntask A task Bncifs_mount()n dfs_mount_share()n get_session()n cifs_mount_get_session() cifs_send_recv()n cifs_get_smb_ses() compound_send_recv()n cifs_setup_session() smb2_setup_request()n kfree_sensitive() smb2_calc_signature()n crypto_shash_setkey() *UAF*nnFix this by ensuring that we have a valid @ses->auth_key.response bynchecking whether @ses->ses_status is SES_GOOD or SES_EXITING withn@ses->ses_lock held. After commit 24a9799aa8ef (smb: client: fix UAFnin smb2_reconnect_server()) we made sure to call ->logoff() onlynwhen @ses was known to be good (e.g. valid ->auth_key.response) sonit's safe to access signing key when @ses->ses_status == SES_EXITING.,CVE-2024-53179,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnALSA: pcm: Add sanity NULL check for the default mmap fault handlernnA driver might allow the mmap access before initializing itsnruntime->dma_area properly. Add a proper NULL check before passing tonvirt_to_page() for avoiding a panic.,CVE-2024-53180,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnio_uring: check for overflows in io_pin_pagesnnWARNING: CPU: 0 PID: 5834 at io_uring/memmap.c:144 io_pin_pages+0x149/0x180 io_uring/memmap.c:144nCPU: 0 UID: 0 PID: 5834 Comm: syz-executor825 Not tainted 6.12.0-next-20241118-syzkaller #0nCall Trace:n <TASK>n __io_uaddr_map+0xfb/0x2d0 io_uring/memmap.c:183n io_rings_map io_uring/io_uring.c:2611 [inline]n io_allocate_scq_urings+0x1c0/0x650 io_uring/io_uring.c:3470n io_uring_create+0x5b5/0xc00 io_uring/io_uring.c:3692n io_uring_setup io_uring/io_uring.c:3781 [inline]n ...n </TASK>nnio_pin_pages()'s uaddr parameter came directly from the user and can bengarbage. Don't just add size to it as it can overflow.,CVE-2024-53187,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnwifi: rtlwifi: Drastically reduce the attempts to read efuse in case of failuresnnSyzkaller reported a hung task with uevent_show() on stack trace. Thatnspecific issue was addressed by another commit [0] but even with thatnfix applied (for example running v6.12-rc5) we face another type of hungntask that comes from the same reproducer [1]. By investigating that wencould narrow it to the following path:nn(a) Syzkaller emulates a Realtek USB WiFi adapter using raw-gadget andndummy_hcd infrastructure.nn(b) During the probe of rtl8192cu the driver ends-up performing an efusenread procedure (which is related to EEPROM load IIUC) and here lies thenissue: the function read_efuse() calls read_efuse_byte() many times asnloop iterations depending on the efuse size (in our example 512 in total).nnThis procedure for reading efuse bytes relies in a loop that performs annI/O read up to *10k* times in case of failures. We measured the time ofnthe loop inside read_efuse_byte() alone and in this reproducer (whichninvolves the dummy_hcd emulation layer) it takes 15 seconds each. As anconsequence we have the driver stuck in its probe routine for big timenexposing a stack trace like below if we attempt to reboot the system fornexample:nntask:kworker/0:3 state:D stack:0 pid:662 tgid:662 ppid:2 flags:0x00004000nWorkqueue: usb_hub_wq hub_eventnCall Trace:n __schedule+0xe22/0xeb6n schedule_timeout+0xe7/0x132n __wait_for_common+0xb5/0x12en usb_start_wait_urb+0xc5/0x1efn ? usb_alloc_urb+0x95/0xa4n usb_control_msg+0xff/0x184n _usbctrl_vendorreq_sync+0xa0/0x161n _usb_read_sync+0xb3/0xc5n read_efuse_byte+0x13c/0x146n read_efuse+0x351/0x5f0n efuse_read_all_map+0x42/0x52n rtl_efuse_shadow_map_update+0x60/0xefn rtl_get_hwinfo+0x5d/0x1c2n rtl92cu_read_eeprom_info+0x10a/0x8d5n ? rtl92c_read_chip_version+0x14f/0x17en rtl_usb_probe+0x323/0x851n usb_probe_interface+0x278/0x34bn really_probe+0x202/0x4a4n __driver_probe_device+0x166/0x1b2n driver_probe_device+0x2f/0xd8n [...]nnWe propose hereby to drastically reduce the attempts of doing the I/Onreads in case of failures restricted to USB devices (given thatnthey're inherently slower than PCIe ones). By retrying up to 10 timesn(instead of 10000) we got reponsiveness in the reproducer while seemsnreasonable to believe that there's no sane USB device implementation innthe field requiring this amount of retries at every I/O read in ordernto properly work. Based on that assumption it'd be good to have itnbackported to stable but maybe not since driver implementation (the 10knnumber comes from day 0) perhaps up to 6.x series makes sense.nn[0] Commit 15fffc6a5624 (driver core: Fix uevent_show() vs driver detach race)nn[1] A note about that: this syzkaller report presents multiple reproducersnthat differs by the type of emulated USB device. For this specific casencheck the entry from 2024/08/08 06:23 in the list of crashes; the C repronis available at https://syzkaller.appspot.com/text?tag=ReproC&x=1521fc83980000.,CVE-2024-53190,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnKVM: arm64: Get rid of userspace_irqchip_in_usennImproper use of userspace_irqchip_in_use led to syzbot hitting thenfollowing WARN_ON() in kvm_timer_update_irq():nnWARNING: CPU: 0 PID: 3281 at arch/arm64/kvm/arch_timer.c:459nkvm_timer_update_irq+0x21c/0x394nCall trace:n kvm_timer_update_irq+0x21c/0x394 arch/arm64/kvm/arch_timer.c:459n kvm_timer_vcpu_reset+0x158/0x684 arch/arm64/kvm/arch_timer.c:968n kvm_reset_vcpu+0x3b4/0x560 arch/arm64/kvm/reset.c:264n kvm_vcpu_set_target arch/arm64/kvm/arm.c:1553 [inline]n kvm_arch_vcpu_ioctl_vcpu_init arch/arm64/kvm/arm.c:1573 [inline]n kvm_arch_vcpu_ioctl+0x112c/0x1b3c arch/arm64/kvm/arm.c:1695n kvm_vcpu_ioctl+0x4ec/0xf74 virt/kvm/kvm_main.c:4658n vfs_ioctl fs/ioctl.c:51 [inline]n __do_sys_ioctl fs/ioctl.c:907 [inline]n __se_sys_ioctl fs/ioctl.c:893 [inline]n __arm64_sys_ioctl+0x108/0x184 fs/ioctl.c:893n __invoke_syscall arch/arm64/kernel/syscall.c:35 [inline]n invoke_syscall+0x78/0x1b8 arch/arm64/kernel/syscall.c:49n el0_svc_common+0xe8/0x1b0 arch/arm64/kernel/syscall.c:132n do_el0_svc+0x40/0x50 arch/arm64/kernel/syscall.c:151n el0_svc+0x54/0x14c arch/arm64/kernel/entry-common.c:712n el0t_64_sync_handler+0x84/0xfc arch/arm64/kernel/entry-common.c:730n el0t_64_sync+0x190/0x194 arch/arm64/kernel/entry.S:598nnThe following sequence led to the scenario:n - Userspace creates a VM and a vCPU.n - The vCPU is initialized with KVM_ARM_VCPU_PMU_V3 duringn KVM_ARM_VCPU_INIT.n - Without any other setup such as vGIC or vPMU userspace issuesn KVM_RUN on the vCPU. Since the vPMU is requested but not setupn kvm_arm_pmu_v3_enable() fails in kvm_arch_vcpu_run_pid_change().n As a result KVM_RUN returns after enabling the timer but beforen incrementing 'userspace_irqchip_in_use':n kvm_arch_vcpu_run_pid_change()n ret = kvm_arm_pmu_v3_enable()n if (!vcpu->arch.pmu.created)n return -EINVAL;n if (ret)n return ret;n [...]n if (!irqchip_in_kernel(kvm))n static_branch_inc(&userspace_irqchip_in_use);n - Userspace ignores the error and issues KVM_ARM_VCPU_INIT again.n Since the timer is already enabled control moves through then following flow ultimately hitting the WARN_ON():n kvm_timer_vcpu_reset()n if (timer->enabled)n kvm_timer_update_irq()n if (!userspace_irqchip())n ret = kvm_vgic_inject_irq()n ret = vgic_lazy_init()n if (unlikely(!vgic_initialized(kvm)))n if (kvm->arch.vgic.vgic_model !=n KVM_DEV_TYPE_ARM_VGIC_V2)n return -EBUSY;n WARN_ON(ret);nnTheoretically since userspace_irqchip_in_use's functionality can bensimply replaced by '!irqchip_in_kernel()' get rid of the static keynto avoid the mismanagement which also helps with the syzbot issue.,CVE-2024-53195,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnKVM: arm64: Don't retire aborted MMIO instructionnnReturning an abort to the guest for an unsupported MMIO access is andocumented feature of the KVM UAPI. Nevertheless it's clear that thisnplumbing has seen limited testing since userspace can trivially cause anWARN in the MMIO return:nn WARNING: CPU: 0 PID: 30558 at arch/arm64/include/asm/kvm_emulate.h:536 kvm_handle_mmio_return+0x46c/0x5c4 arch/arm64/include/asm/kvm_emulate.h:536n Call trace:n kvm_handle_mmio_return+0x46c/0x5c4 arch/arm64/include/asm/kvm_emulate.h:536n kvm_arch_vcpu_ioctl_run+0x98/0x15b4 arch/arm64/kvm/arm.c:1133n kvm_vcpu_ioctl+0x75c/0xa78 virt/kvm/kvm_main.c:4487n __do_sys_ioctl fs/ioctl.c:51 [inline]n __se_sys_ioctl fs/ioctl.c:893 [inline]n __arm64_sys_ioctl+0x14c/0x1c8 fs/ioctl.c:893n __invoke_syscall arch/arm64/kernel/syscall.c:35 [inline]n invoke_syscall+0x98/0x2b8 arch/arm64/kernel/syscall.c:49n el0_svc_common+0x1e0/0x23c arch/arm64/kernel/syscall.c:132n do_el0_svc+0x48/0x58 arch/arm64/kernel/syscall.c:151n el0_svc+0x38/0x68 arch/arm64/kernel/entry-common.c:712n el0t_64_sync_handler+0x90/0xfc arch/arm64/kernel/entry-common.c:730n el0t_64_sync+0x190/0x194 arch/arm64/kernel/entry.S:598nnThe splat is complaining that KVM is advancing PC while an exception isnpending i.e. that KVM is retiring the MMIO instruction despite anpending synchronous external abort. Womp womp.nnFix the glaring UAPI bug by skipping over all the MMIO emulation inncase there is a pending synchronous exception. Note that while userspacenis capable of pending an asynchronous exception (SError IRQ or FIQ)nit is still safe to retire the MMIO instruction in this case as (1) theynare by definition asynchronous and (2) KVM relies on hardware supportnfor pending/delivering these exceptions instead of the software statenmachine for advancing PC.,CVE-2024-53196,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnusb: typec: fix potential array underflow in ucsi_ccg_sync_control()nnThe command variable can be controlled by the user via debugfs. Thenworry is that if con_index is zero then &uc->ucsi->connector[con_indexn- 1] would be an array underflow.,CVE-2024-53203,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nns390/iucv: MSG_PEEK causes memory leak in iucv_sock_destruct()nnPassing MSG_PEEK flag to skb_recv_datagram() increments skb refcountn(skb->users) and iucv_sock_recvmsg() does not decrement skb refcountnat exit.nThis results in skb memory leak in skb_queue_purge() and WARN_ON inniucv_sock_destruct() during socket close. To fix this decreasenskb refcount by one if MSG_PEEK is set in order to prevent memorynleak and WARN_ON.nnWARNING: CPU: 2 PID: 6292 at net/iucv/af_iucv.c:286 iucv_sock_destruct+0x144/0x1a0 [af_iucv]nCPU: 2 PID: 6292 Comm: afiucv_test_msg Kdump: loaded Tainted: G W 6.10.0-rc7 #1nHardware name: IBM 3931 A01 704 (z/VM 7.3.0)nCall Trace:n [<001587c682c4aa98>] iucv_sock_destruct+0x148/0x1a0 [af_iucv]n [<001587c682c4a9d0>] iucv_sock_destruct+0x80/0x1a0 [af_iucv]n [<001587c704117a32>] __sk_destruct+0x52/0x550n [<001587c704104a54>] __sock_release+0xa4/0x230n [<001587c704104c0c>] sock_close+0x2c/0x40n [<001587c702c5f5a8>] __fput+0x2e8/0x970n [<001587c7024148c4>] task_work_run+0x1c4/0x2c0n [<001587c7023b0716>] do_exit+0x996/0x1050n [<001587c7023b13aa>] do_group_exit+0x13a/0x360n [<001587c7023b1626>] __s390x_sys_exit_group+0x56/0x60n [<001587c7022bccca>] do_syscall+0x27a/0x380n [<001587c7049a6a0c>] __do_syscall+0x9c/0x160n [<001587c7049ce8a8>] system_call+0x70/0x98n Last Breaking-Event-Address:n [<001587c682c4a9d4>] iucv_sock_destruct+0x84/0x1a0 [af_iucv],CVE-2024-53210,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnfsd: release svc_expkey/svc_export with rcu_worknnThe last reference for `cache_head` can be reduced to zero in `c_show`nand `e_show`(using `rcu_read_lock` and `rcu_read_unlock`). Consequentlyn`svc_export_put` and `expkey_put` will be invoked leading to twonissues:nn1. The `svc_export_put` will directly free ex_uuid. Howevern `e_show`/`c_show` will access `ex_uuid` after `cache_put` which cann trigger a use-after-free issue shown below.nn ==================================================================n BUG: KASAN: slab-use-after-free in svc_export_show+0x362/0x430 [nfsd]n Read of size 1 at addr ff11000010fdc120 by task cat/870nn CPU: 1 UID: 0 PID: 870 Comm: cat Not tainted 6.12.0-rc3+ #1n Hardware name: QEMU Standard PC (i440FX + PIIX 1996) BIOSn 1.16.1-2.fc37 04/01/2014n Call Trace:n <TASK>n dump_stack_lvl+0x53/0x70n print_address_description.constprop.0+0x2c/0x3a0n print_report+0xb9/0x280n kasan_report+0xae/0xe0n svc_export_show+0x362/0x430 [nfsd]n c_show+0x161/0x390 [sunrpc]n seq_read_iter+0x589/0x770n seq_read+0x1e5/0x270n proc_reg_read+0xe1/0x140n vfs_read+0x125/0x530n ksys_read+0xc1/0x160n do_syscall_64+0x5f/0x170n entry_SYSCALL_64_after_hwframe+0x76/0x7enn Allocated by task 830:n kasan_save_stack+0x20/0x40n kasan_save_track+0x14/0x30n __kasan_kmalloc+0x8f/0xa0n __kmalloc_node_track_caller_noprof+0x1bc/0x400n kmemdup_noprof+0x22/0x50n svc_export_parse+0x8a9/0xb80 [nfsd]n cache_do_downcall+0x71/0xa0 [sunrpc]n cache_write_procfs+0x8e/0xd0 [sunrpc]n proc_reg_write+0xe1/0x140n vfs_write+0x1a5/0x6d0n ksys_write+0xc1/0x160n do_syscall_64+0x5f/0x170n entry_SYSCALL_64_after_hwframe+0x76/0x7enn Freed by task 868:n kasan_save_stack+0x20/0x40n kasan_save_track+0x14/0x30n kasan_save_free_info+0x3b/0x60n __kasan_slab_free+0x37/0x50n kfree+0xf3/0x3e0n svc_export_put+0x87/0xb0 [nfsd]n cache_purge+0x17f/0x1f0 [sunrpc]n nfsd_destroy_serv+0x226/0x2d0 [nfsd]n nfsd_svc+0x125/0x1e0 [nfsd]n write_threads+0x16a/0x2a0 [nfsd]n nfsctl_transaction_write+0x74/0xa0 [nfsd]n vfs_write+0x1a5/0x6d0n ksys_write+0xc1/0x160n do_syscall_64+0x5f/0x170n entry_SYSCALL_64_after_hwframe+0x76/0x7enn2. We cannot sleep while using `rcu_read_lock`/`rcu_read_unlock`.n However `svc_export_put`/`expkey_put` will call path_put whichn subsequently triggers a sleeping operation due to the followingn `dput`.nn =============================n WARNING: suspicious RCU usagen 5.10.0-dirty #141 Not taintedn -----------------------------n ...n Call Trace:n dump_stack+0x9a/0xd0n ___might_sleep+0x231/0x240n dput+0x39/0x600n path_put+0x1b/0x30n svc_export_put+0x17/0x80n e_show+0x1c9/0x200n seq_read_iter+0x63f/0x7c0n seq_read+0x226/0x2d0n vfs_read+0x113/0x2c0n ksys_read+0xc9/0x170n do_syscall_64+0x33/0x40n entry_SYSCALL_64_after_hwframe+0x67/0xd1nnFix these issues by using `rcu_work` to help releasen`svc_expkey`/`svc_export`. This approach allows for an asynchronousncontext to invoke `path_put` and also facilitates the freeing ofn`uuid/exp/key` after an RCU grace period.,CVE-2024-53216,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnf2fs: fix race in concurrent f2fs_stop_gc_threadnnIn my test case concurrent calls to f2fs shutdown report the followingnstack trace:nn Oops: general protection fault probably for non-canonical address 0xc6cfff63bb5513fc: 0000 [#1] PREEMPT SMP PTIn CPU: 0 UID: 0 PID: 678 Comm: f2fs_rep_shutdo Not tainted 6.12.0-rc5-next-20241029-g6fb2fa9805c5-dirty #85n Call Trace:n <TASK>n ? show_regs+0x8b/0xa0n ? __die_body+0x26/0xa0n ? die_addr+0x54/0x90n ? exc_general_protection+0x24b/0x5c0n ? asm_exc_general_protection+0x26/0x30n ? kthread_stop+0x46/0x390n f2fs_stop_gc_thread+0x6c/0x110n f2fs_do_shutdown+0x309/0x3a0n f2fs_ioc_shutdown+0x150/0x1c0n __f2fs_ioctl+0xffd/0x2ac0n f2fs_ioctl+0x76/0xe0n vfs_ioctl+0x23/0x60n __x64_sys_ioctl+0xce/0xf0n x64_sys_call+0x2b1b/0x4540n do_syscall_64+0xa7/0x240n entry_SYSCALL_64_after_hwframe+0x76/0x7ennThe root cause is a race condition in f2fs_stop_gc_thread() called fromndifferent f2fs shutdown paths:nn [CPU0] [CPU1]n ---------------------- -----------------------n f2fs_stop_gc_thread f2fs_stop_gc_threadn gc_th = sbi->gc_threadn gc_th = sbi->gc_threadn kfree(gc_th)n sbi->gc_thread = NULLn < gc_th != NULL >n kthread_stop(gc_th->f2fs_gc_task) //UAFnnThe commit c7f114d864ac (f2fs: fix to avoid use-after-free innf2fs_stop_gc_thread()) attempted to fix this issue by using a readnsemaphore to prevent races between shutdown and remount threads butnit fails to prevent all race conditions.nnFix it by converting to write lock of s_umount in f2fs_do_shutdown().,CVE-2024-53218,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnvirtiofs: use pages instead of pointer for kernel direct IOnnWhen trying to insert a 10MB kernel module kept in a virtio-fs with cachendisabled the following warning was reported:nn ------------[ cut here ]------------n WARNING: CPU: 1 PID: 404 at mm/page_alloc.c:4551 ......n Modules linked in:n CPU: 1 PID: 404 Comm: insmod Not tainted 6.9.0-rc5+ #123n Hardware name: QEMU Standard PC (i440FX + PIIX 1996) ......n RIP: 0010:__alloc_pages+0x2bf/0x380n ......n Call Trace:n <TASK>n ? __warn+0x8e/0x150n ? __alloc_pages+0x2bf/0x380n __kmalloc_large_node+0x86/0x160n __kmalloc+0x33c/0x480n virtio_fs_enqueue_req+0x240/0x6d0n virtio_fs_wake_pending_and_unlock+0x7f/0x190n queue_request_and_unlock+0x55/0x60n fuse_simple_request+0x152/0x2b0n fuse_direct_io+0x5d2/0x8c0n fuse_file_read_iter+0x121/0x160n __kernel_read+0x151/0x2d0n kernel_read+0x45/0x50n kernel_read_file+0x1a9/0x2a0n init_module_from_file+0x6a/0xe0n idempotent_init_module+0x175/0x230n __x64_sys_finit_module+0x5d/0xb0n x64_sys_call+0x1c3/0x9e0n do_syscall_64+0x3d/0xc0n entry_SYSCALL_64_after_hwframe+0x4b/0x53n ......n </TASK>n ---[ end trace 0000000000000000 ]---nnThe warning is triggered as follows:nn1) syscall finit_module() handles the module insertion and it invokesnkernel_read_file() to read the content of the module first.nn2) kernel_read_file() allocates a 10MB buffer by using vmalloc() andnpasses it to kernel_read(). kernel_read() constructs a kvec iter bynusing iov_iter_kvec() and passes it to fuse_file_read_iter().nn3) virtio-fs disables the cache so fuse_file_read_iter() invokesnfuse_direct_io(). As for now the maximal read size for kvec iter isnonly limited by fc->max_read. For virtio-fs max_read is UINT_MAX sonfuse_direct_io() doesn't split the 10MB buffer. It saves the address andnthe size of the 10MB-sized buffer in out_args[0] of a fuse request andnpasses the fuse request to virtio_fs_wake_pending_and_unlock().nn4) virtio_fs_wake_pending_and_unlock() uses virtio_fs_enqueue_req() tonqueue the request. Because virtiofs need DMA-able address sonvirtio_fs_enqueue_req() uses kmalloc() to allocate a bounce buffer fornall fuse args copies these args into the bounce buffer and passed thenphysical address of the bounce buffer to virtiofsd. The total length ofnthese fuse args for the passed fuse request is about 10MB soncopy_args_to_argbuf() invokes kmalloc() with a 10MB size parameter andnit triggers the warning in __alloc_pages():nntif (WARN_ON_ONCE_GFP(order > MAX_PAGE_ORDER gfp))nttreturn NULL;nn5) virtio_fs_enqueue_req() will retry the memory allocation in ankworker but it won't help because kmalloc() will always return NULLndue to the abnormal size and finit_module() will hang forever.nnA feasible solution is to limit the value of max_read for virtio-fs sonthe length passed to kmalloc() will be limited. However it will affectnthe maximal read size for normal read. And for virtio-fs write initiatednfrom kernel it has the similar problem but now there is no way to limitnfc->max_write in kernel.nnSo instead of limiting both the values of max_read and max_write innkernel introducing use_pages_for_kvec_io in fuse_conn and setting it asntrue in virtiofs. When use_pages_for_kvec_io is enabled fuse will usenpages instead of pointer to pass the KVEC_IO data.nnAfter switching to pages for KVEC_IO data these pages will be used fornDMA through virtio-fs. If these pages are backed by vmalloc()n{flush|invalidate}_kernel_vmap_range() are necessary to flush orninvalidate the cache before the DMA operation. So add two new fields innfuse_args_pages to record the base address of vmalloc area and thencondition indicating whether invalidation is needed. Perform the flushnin fuse_get_user_pages() for write operations and the invalidation innfuse_release_user_pages() for read operations.nnIt may seem necessary to introduce another fien---truncated---,CVE-2024-53219,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnf2fs: fix to account dirty data in __get_secs_required()nnIt will trigger system panic w/ testcase in [1]:nn------------[ cut here ]------------nkernel BUG at fs/f2fs/segment.c:2752!nRIP: 0010:new_curseg+0xc81/0x2110nCall Trace:n f2fs_allocate_data_block+0x1c91/0x4540n do_write_page+0x163/0xdf0n f2fs_outplace_write_data+0x1aa/0x340n f2fs_do_write_data_page+0x797/0x2280n f2fs_write_single_data_page+0x16cd/0x2190n f2fs_write_cache_pages+0x994/0x1c80n f2fs_write_data_pages+0x9cc/0xea0n do_writepages+0x194/0x7a0n filemap_fdatawrite_wbc+0x12b/0x1a0n __filemap_fdatawrite_range+0xbb/0xf0n file_write_and_wait_range+0xa1/0x110n f2fs_do_sync_file+0x26f/0x1c50n f2fs_sync_file+0x12b/0x1d0n vfs_fsync_range+0xfa/0x230n do_fsync+0x3d/0x80n __x64_sys_fsync+0x37/0x50n x64_sys_call+0x1e88/0x20d0n do_syscall_64+0x4b/0x110n entry_SYSCALL_64_after_hwframe+0x76/0x7ennThe root cause is if checkpoint_disabling and lfs_mode are both onnit will trigger OPU for all overwritten data it may cost more freensegment than expected so f2fs must account those data correctly toncalculate cosumed free segments later and return ENOSPC earlier tonavoid run out of free segment during block allocation.nn[1] https://lore.kernel.org/fstests/20241015025106.3203676-1-chao@kernel.org/,CVE-2024-53220,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnf2fs: fix null-ptr-deref in f2fs_submit_page_bio()nnThere's issue as follows when concurrently installing the f2fs.konmodule and mounting the f2fs file system:nKASAN: null-ptr-deref in range [0x0000000000000020-0x0000000000000027]nRIP: 0010:__bio_alloc+0x2fb/0x6c0 [f2fs]nCall Trace:n <TASK>n f2fs_submit_page_bio+0x126/0x8b0 [f2fs]n __get_meta_page+0x1d4/0x920 [f2fs]n get_checkpoint_version.constprop.0+0x2b/0x3c0 [f2fs]n validate_checkpoint+0xac/0x290 [f2fs]n f2fs_get_valid_checkpoint+0x207/0x950 [f2fs]n f2fs_fill_super+0x1007/0x39b0 [f2fs]n mount_bdev+0x183/0x250n legacy_get_tree+0xf4/0x1e0n vfs_get_tree+0x88/0x340n do_new_mount+0x283/0x5e0n path_mount+0x2b2/0x15b0n __x64_sys_mount+0x1fe/0x270n do_syscall_64+0x5f/0x170n entry_SYSCALL_64_after_hwframe+0x76/0x7ennAbove issue happens as the biset of the f2fs file system is notninitialized before register f2fs_fs_type.nTo address above issue just register f2fs_fs_type at the last inninit_f2fs_fs(). Ensure that all f2fs file system resources areninitialized.,CVE-2024-53221,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnRDMA/mlx5: Move events notifier registration to be after device registrationnnMove pkey change work initialization and cleanup from device resourcesnstage to notifier stage since this is the stage which handles this worknevents.nnFix a race between the device deregistration and pkey change work by movingnMLX5_IB_STAGE_DEVICE_NOTIFIER to be after MLX5_IB_STAGE_IB_REG in order tonensure that the notifier is deregistered before the device during cleanup.nWhich ensures there are no works that are being executed after thendevice has already unregistered which can cause the panic below.nnBUG: kernel NULL pointer dereference address: 0000000000000000nPGD 0 P4D 0nOops: 0000 [#1] PREEMPT SMP PTInCPU: 1 PID: 630071 Comm: kworker/1:2 Kdump: loaded Tainted: G W OE --------- --- 5.14.0-162.6.1.el9_1.x86_64 #1nHardware name: Microsoft Corporation Virtual Machine/Virtual Machine BIOS 090008 02/27/2023nWorkqueue: events pkey_change_handler [mlx5_ib]nRIP: 0010:setup_qp+0x38/0x1f0 [mlx5_ib]nCode: ee 41 54 45 31 e4 55 89 f5 53 48 89 fb 48 83 ec 20 8b 77 08 65 48 8b 04 25 28 00 00 00 48 89 44 24 18 48 8b 07 48 8d 4c 24 16 <4c> 8b 38 49 8b 87 80 0b 00 00 4c 89 ff 48 8b 80 08 05 00 00 8b 40nRSP: 0018:ffffbcc54068be20 EFLAGS: 00010282nRAX: 0000000000000000 RBX: ffff954054494128 RCX: ffffbcc54068be36nRDX: ffff954004934000 RSI: 0000000000000001 RDI: ffff954054494128nRBP: 0000000000000023 R08: ffff954001be2c20 R09: 0000000000000001nR10: ffff954001be2c20 R11: ffff9540260133c0 R12: 0000000000000000nR13: 0000000000000023 R14: 0000000000000000 R15: ffff9540ffcb0905nFS: 0000000000000000(0000) GS:ffff9540ffc80000(0000) knlGS:0000000000000000nCS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033nCR2: 0000000000000000 CR3: 000000010625c001 CR4: 00000000003706e0nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400nCall Trace:nmlx5_ib_gsi_pkey_change+0x20/0x40 [mlx5_ib]nprocess_one_work+0x1e8/0x3c0nworker_thread+0x50/0x3b0n? rescuer_thread+0x380/0x380nkthread+0x149/0x170n? set_kthread_struct+0x50/0x50nret_from_fork+0x22/0x30nModules linked in: rdma_ucm(OE) rdma_cm(OE) iw_cm(OE) ib_ipoib(OE) ib_cm(OE) ib_umad(OE) mlx5_ib(OE) mlx5_fwctl(OE) fwctl(OE) ib_uverbs(OE) mlx5_core(OE) mlxdevm(OE) ib_core(OE) mlx_compat(OE) psample mlxfw(OE) tls knem(OE) netconsole nfsv3 nfs_acl nfs lockd grace fscache netfs qrtr rfkill sunrpc intel_rapl_msr intel_rapl_common rapl hv_balloon hv_utils i2c_piix4 pcspkr joydev fuse ext4 mbcache jbd2 sr_mod sd_mod cdrom t10_pi sg ata_generic pci_hyperv pci_hyperv_intf hyperv_drm drm_shmem_helper drm_kms_helper hv_storvsc syscopyarea hv_netvsc sysfillrect sysimgblt hid_hyperv fb_sys_fops scsi_transport_fc hyperv_keyboard drm ata_piix crct10dif_pclmul crc32_pclmul crc32c_intel libata ghash_clmulni_intel hv_vmbus serio_raw [last unloaded: ib_core]nCR2: 0000000000000000n---[ end trace f6f8be4eae12f7bc ]---,CVE-2024-53224,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnerofs: handle NONHEAD !delta[1] lclusters gracefullynnsyzbot reported a WARNING in iomap_iter_done:n iomap_fiemap+0x73b/0x9b0 fs/iomap/fiemap.c:80n ioctl_fiemap fs/ioctl.c:220 [inline]nnGenerally NONHEAD lclusters won't have delta[1]==0 except for craftednimages and filesystems created by pre-1.0 mkfs versions.nnPreviously it would immediately bail out if delta[1]==0 which led toninadequate decompressed lengths (thus FIEMAP is impacted). Treat it asndelta[1]=1 to work around these legacy mkfs versions.nn`lclusterbits > 14` is illegal for compact indexes error out too.,CVE-2024-53234,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnNFS: Fix potential buffer overflowin nfs_sysfs_link_rpc_client()nnname is char[64] where the size of clnt->cl_program->name remainsnunknown. Invoking strcat() directly will also lead to potential buffernoverflow. Change them to strscpy() and strncat() to fix potentialnissues.,CVE-2024-54456,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnscsi: ufs: bsg: Set bsg_queue to NULL after removalnnCurrently this does not cause any issues but I believe it is necessary tonset bsg_queue to NULL after removing it to prevent potential use-after-freen(UAF) access.,CVE-2024-54458,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnetfilter: IDLETIMER: Fix for possible ABBA deadlocknnDeletion of the last rule referencing a given idletimer may happen atnthe same time as a read of its file in sysfs:nn| ======================================================n| WARNING: possible circular locking dependency detectedn| 6.12.0-rc7-01692-g5e9a28f41134-dirty #594 Not taintedn| ------------------------------------------------------n| iptables/3303 is trying to acquire lock:n| ffff8881057e04b8 (kn->active#48){++++}-{0:0} at: __kernfs_remove+0x20n|n| but task is already holding lock:n| ffffffffa0249068 (list_mutex){+.+.}-{3:3} at: idletimer_tg_destroy_v]n|n| which lock already depends on the new lock.nnA simple reproducer is:nn| #!/bin/bashn|n| while true; don| iptables -A INPUT -i foo -j IDLETIMER --timeout 10 --label testmen| iptables -D INPUT -i foo -j IDLETIMER --timeout 10 --label testmen| done &n| while true; don| cat /sys/class/xt_idletimer/timers/testme >/dev/nulln| donennAvoid this by freeing list_mutex right after deleting the element fromnthe list then continuing with the teardown.,CVE-2024-54683,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/modes: Avoid divide by zero harder in drm_mode_vrefresh()nndrm_mode_vrefresh() is trying to avoid divide by zeronby checking whether htotal or vtotal are zero. But we maynstill end up with a div-by-zero of vtotal*htotal*...,CVE-2024-56369,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm: zynqmp_kms: Unplug DRM device before removalnnPrevent userspace accesses to the DRM device from causingnuse-after-frees by unplugging the device before we remove it. Thisncauses any further userspace accesses to result in an error withoutnfurther calls into this driver's internals.,CVE-2024-56538,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnudmabuf: change folios array from kmalloc to kvmallocnnWhen PAGE_SIZE 4096 MAX_PAGE_ORDER 10 64bit machinenpage_alloc only support 4MB.nIf above this trigger this warn and return NULL.nnudmabuf can change size limit if change it to 3072(3GB) and then allocn3GB udmabuf will fail create.nn[ 4080.876581] ------------[ cut here ]------------n[ 4080.876843] WARNING: CPU: 3 PID: 2015 at mm/page_alloc.c:4556 __alloc_pages+0x2c8/0x350n[ 4080.878839] RIP: 0010:__alloc_pages+0x2c8/0x350n[ 4080.879470] Call Trace:n[ 4080.879473] <TASK>n[ 4080.879473] ? __alloc_pages+0x2c8/0x350n[ 4080.879475] ? __warn.cold+0x8e/0xe8n[ 4080.880647] ? __alloc_pages+0x2c8/0x350n[ 4080.880909] ? report_bug+0xff/0x140n[ 4080.881175] ? handle_bug+0x3c/0x80n[ 4080.881556] ? exc_invalid_op+0x17/0x70n[ 4080.881559] ? asm_exc_invalid_op+0x1a/0x20n[ 4080.882077] ? udmabuf_create+0x131/0x400nnBecause MAX_PAGE_ORDER kmalloc can max alloc 4096 output.log scan_tyk_dockerimages.sh vulnerabilities.csv (1 << 10) 4MBnmemory each array entry is pointer(8byte) so can save 524288 pages(2GB).nnFurther more costly order(order 3) may not be guaranteed that it can benapplied for due to fragmentation.nnThis patch change udmabuf array use kvmalloc_array this can fallbacknalloc into vmalloc which can guarantee allocation for any size and doesnnot affect the performance of kmalloc allocations.,CVE-2024-56544,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amdgpu: fix usage slab after freenn[ +0.000021] BUG: KASAN: slab-use-after-free in drm_sched_entity_flush+0x6cb/0x7a0 [gpu_sched]n[ +0.000027] Read of size 8 at addr ffff8881b8605f88 by task amd_pci_unplug/2147nn[ +0.000023] CPU: 6 PID: 2147 Comm: amd_pci_unplug Not tainted 6.10.0+ #1n[ +0.000016] Hardware name: ASUS System Product Name/ROG STRIX B550-F GAMING (WI-FI) BIOS 1401 12/03/2020n[ +0.000016] Call Trace:n[ +0.000008] <TASK>n[ +0.000009] dump_stack_lvl+0x76/0xa0n[ +0.000017] print_report+0xce/0x5f0n[ +0.000017] ? drm_sched_entity_flush+0x6cb/0x7a0 [gpu_sched]n[ +0.000019] ? srso_return_thunk+0x5/0x5fn[ +0.000015] ? kasan_complete_mode_report_info+0x72/0x200n[ +0.000016] ? drm_sched_entity_flush+0x6cb/0x7a0 [gpu_sched]n[ +0.000019] kasan_report+0xbe/0x110n[ +0.000015] ? drm_sched_entity_flush+0x6cb/0x7a0 [gpu_sched]n[ +0.000023] __asan_report_load8_noabort+0x14/0x30n[ +0.000014] drm_sched_entity_flush+0x6cb/0x7a0 [gpu_sched]n[ +0.000020] ? srso_return_thunk+0x5/0x5fn[ +0.000013] ? __kasan_check_write+0x14/0x30n[ +0.000016] ? __pfx_drm_sched_entity_flush+0x10/0x10 [gpu_sched]n[ +0.000020] ? srso_return_thunk+0x5/0x5fn[ +0.000013] ? __kasan_check_write+0x14/0x30n[ +0.000013] ? srso_return_thunk+0x5/0x5fn[ +0.000013] ? enable_work+0x124/0x220n[ +0.000015] ? __pfx_enable_work+0x10/0x10n[ +0.000013] ? srso_return_thunk+0x5/0x5fn[ +0.000014] ? free_large_kmalloc+0x85/0xf0n[ +0.000016] drm_sched_entity_destroy+0x18/0x30 [gpu_sched]n[ +0.000020] amdgpu_vce_sw_fini+0x55/0x170 [amdgpu]n[ +0.000735] ? __kasan_check_read+0x11/0x20n[ +0.000016] vce_v4_0_sw_fini+0x80/0x110 [amdgpu]n[ +0.000726] amdgpu_device_fini_sw+0x331/0xfc0 [amdgpu]n[ +0.000679] ? mutex_unlock+0x80/0xe0n[ +0.000017] ? __pfx_amdgpu_device_fini_sw+0x10/0x10 [amdgpu]n[ +0.000662] ? srso_return_thunk+0x5/0x5fn[ +0.000014] ? __kasan_check_write+0x14/0x30n[ +0.000013] ? srso_return_thunk+0x5/0x5fn[ +0.000013] ? mutex_unlock+0x80/0xe0n[ +0.000016] amdgpu_driver_release_kms+0x16/0x80 [amdgpu]n[ +0.000663] drm_minor_release+0xc9/0x140 [drm]n[ +0.000081] drm_release+0x1fd/0x390 [drm]n[ +0.000082] __fput+0x36c/0xad0n[ +0.000018] __fput_sync+0x3c/0x50n[ +0.000014] __x64_sys_close+0x7d/0xe0n[ +0.000014] x64_sys_call+0x1bc6/0x2680n[ +0.000014] do_syscall_64+0x70/0x130n[ +0.000014] ? srso_return_thunk+0x5/0x5fn[ +0.000014] ? irqentry_exit_to_user_mode+0x60/0x190n[ +0.000015] ? srso_return_thunk+0x5/0x5fn[ +0.000014] ? irqentry_exit+0x43/0x50n[ +0.000012] ? srso_return_thunk+0x5/0x5fn[ +0.000013] ? exc_page_fault+0x7c/0x110n[ +0.000015] entry_SYSCALL_64_after_hwframe+0x76/0x7en[ +0.000014] RIP: 0033:0x7ffff7b14f67n[ +0.000013] Code: ff e8 0d 16 02 00 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 00 f3 0f 1e fa 64 8b 04 25 18 00 00 00 85 c0 75 10 b8 03 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 41 c3 48 83 ec 18 89 7c 24 0c e8 73 ba f7 ffn[ +0.000026] RSP: 002b:00007fffffffe378 EFLAGS: 00000246 ORIG_RAX: 0000000000000003n[ +0.000019] RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007ffff7b14f67n[ +0.000014] RDX: 0000000000000000 RSI: 00007ffff7f6f47a RDI: 0000000000000003n[ +0.000014] RBP: 00007fffffffe3a0 R08: 0000555555569890 R09: 0000000000000000n[ +0.000014] R10: 0000000000000000 R11: 0000000000000246 R12: 00007fffffffe5c8n[ +0.000013] R13: 00005555555552a9 R14: 0000555555557d48 R15: 00007ffff7ffd040n[ +0.000020] </TASK>nn[ +0.000016] Allocated by task 383 on cpu 7 at 26.880319s:n[ +0.000014] kasan_save_stack+0x28/0x60n[ +0.000008] kasan_save_track+0x18/0x70n[ +0.000007] kasan_save_alloc_info+0x38/0x60n[ +0.000007] __kasan_kmalloc+0xc1/0xd0n[ +0.000007] kmalloc_trace_noprof+0x180/0x380n[ +0.000007] drm_sched_init+0x411/0xec0 [gpu_sched]n[ +0.000012] amdgpu_device_init+0x695f/0xa610 [amdgpu]n[ +0.000658] amdgpu_driver_load_kms+0x1a/0x120 [amdgpu]n[ +0.000662] amdgpu_pci_pn---truncated---,CVE-2024-56551,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nniio: adc: ad7923: Fix buffer overflow for tx_buf and ring_xfernnThe AD7923 was updated to support devices with 8 channels but the sizenof tx_buf and ring_xfer was not increased accordingly leading to anpotential buffer overflow in ad7923_update_scan_mode().,CVE-2024-56557,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnf2fs: fix to drop all discards after creating snapshot on lvm devicennPiergiorgio reported a bug in bugzilla as below:nn------------[ cut here ]------------nWARNING: CPU: 2 PID: 969 at fs/f2fs/segment.c:1330nRIP: 0010:__submit_discard_cmd+0x27d/0x400 [f2fs]nCall Trace:n __issue_discard_cmd+0x1ca/0x350 [f2fs]n issue_discard_thread+0x191/0x480 [f2fs]n kthread+0xcf/0x100n ret_from_fork+0x31/0x50n ret_from_fork_asm+0x1a/0x30nnw/ below testcase it can reproduce this bug quickly:n- pvcreate /dev/vdbn- vgcreate myvg1 /dev/vdbn- lvcreate -L 1024m -n mylv1 myvg1n- mount /dev/myvg1/mylv1 /mnt/f2fsn- dd if=/dev/zero of=/mnt/f2fs/file bs=1M count=20n- syncn- rm /mnt/f2fs/filen- syncn- lvcreate -L 1024m -s -n mylv1-snapshot /dev/myvg1/mylv1n- umount /mnt/f2fsnnThe root cause is: it will update discard_max_bytes of mounted lvmndevice to zero after creating snapshot on this lvm device thenn__submit_discard_cmd() will pass parameter @nr_sects w/ zero valuento __blkdev_issue_discard() it returns a NULL bio pointer resultnin panic.nnThis patch changes as below for fixing:n1. Let's drop all remained discards in f2fs_unfreeze() if snapshotnof lvm device is created.n2. Checking discard_max_bytes before submitting discard duringn__submit_discard_cmd().,CVE-2024-56565,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnmm/slub: Avoid list corruption when removing a slab from the full listnnBoot with slub_debug=UFPZ.nnIf allocated object failed in alloc_consistency_checks all objects ofnthe slab will be marked as used and then the slab will be removed fromnthe partial list.nnWhen an object belonging to the slab got freed later the remove_full()nfunction is called. Because the slab is neither on the partial list nornon the full list it eventually lead to a list corruption (actually anlist poison being detected).nnSo we need to mark and isolate the slab page with metadata corruptionndo not put it back in circulation.nnBecause the debug caches avoid all the fastpaths reusing the frozen bitnto mark slab page with metadata corruption seems to be fine.nn[ 4277.385669] list_del corruption ffffea00044b3e50->next is LIST_POISON1 (dead000000000100)n[ 4277.387023] ------------[ cut here ]------------n[ 4277.387880] kernel BUG at lib/list_debug.c:56!n[ 4277.388680] invalid opcode: 0000 [#1] PREEMPT SMP PTIn[ 4277.389562] CPU: 5 PID: 90 Comm: kworker/5:1 Kdump: loaded Tainted: G OE 6.6.1-1 #1n[ 4277.392113] Workqueue: xfs-inodegc/vda1 xfs_inodegc_worker [xfs]n[ 4277.393551] RIP: 0010:__list_del_entry_valid_or_report+0x7b/0xc0n[ 4277.394518] Code: 48 91 82 e8 37 f9 9a ff 0f 0b 48 89 fe 48 c7 c7 28 49 91 82 e8 26 f9 9a ff 0f 0b 48 89 fe 48 c7 c7 58 49 91n[ 4277.397292] RSP: 0018:ffffc90000333b38 EFLAGS: 00010082n[ 4277.398202] RAX: 000000000000004e RBX: ffffea00044b3e50 RCX: 0000000000000000n[ 4277.399340] RDX: 0000000000000002 RSI: ffffffff828f8715 RDI: 00000000ffffffffn[ 4277.400545] RBP: ffffea00044b3e40 R08: 0000000000000000 R09: ffffc900003339f0n[ 4277.401710] R10: 0000000000000003 R11: ffffffff82d44088 R12: ffff888112cf9910n[ 4277.402887] R13: 0000000000000001 R14: 0000000000000001 R15: ffff8881000424c0n[ 4277.404049] FS: 0000000000000000(0000) GS:ffff88842fd40000(0000) knlGS:0000000000000000n[ 4277.405357] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033n[ 4277.406389] CR2: 00007f2ad0b24000 CR3: 0000000102a3a006 CR4: 00000000007706e0n[ 4277.407589] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000n[ 4277.408780] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400n[ 4277.410000] PKRU: 55555554n[ 4277.410645] Call Trace:n[ 4277.411234] <TASK>n[ 4277.411777] ? die+0x32/0x80n[ 4277.412439] ? do_trap+0xd6/0x100n[ 4277.413150] ? __list_del_entry_valid_or_report+0x7b/0xc0n[ 4277.414158] ? do_error_trap+0x6a/0x90n[ 4277.414948] ? __list_del_entry_valid_or_report+0x7b/0xc0n[ 4277.415915] ? exc_invalid_op+0x4c/0x60n[ 4277.416710] ? __list_del_entry_valid_or_report+0x7b/0xc0n[ 4277.417675] ? asm_exc_invalid_op+0x16/0x20n[ 4277.418482] ? __list_del_entry_valid_or_report+0x7b/0xc0n[ 4277.419466] ? __list_del_entry_valid_or_report+0x7b/0xc0n[ 4277.420410] free_to_partial_list+0x515/0x5e0n[ 4277.421242] ? xfs_iext_remove+0x41a/0xa10 [xfs]n[ 4277.422298] xfs_iext_remove+0x41a/0xa10 [xfs]n[ 4277.423316] ? xfs_inodegc_worker+0xb4/0x1a0 [xfs]n[ 4277.424383] xfs_bmap_del_extent_delay+0x4fe/0x7d0 [xfs]n[ 4277.425490] __xfs_bunmapi+0x50d/0x840 [xfs]n[ 4277.426445] xfs_itruncate_extents_flags+0x13a/0x490 [xfs]n[ 4277.427553] xfs_inactive_truncate+0xa3/0x120 [xfs]n[ 4277.428567] xfs_inactive+0x22d/0x290 [xfs]n[ 4277.429500] xfs_inodegc_worker+0xb4/0x1a0 [xfs]n[ 4277.430479] process_one_work+0x171/0x340n[ 4277.431227] worker_thread+0x277/0x390n[ 4277.431962] ? __pfx_worker_thread+0x10/0x10n[ 4277.432752] kthread+0xf0/0x120n[ 4277.433382] ? __pfx_kthread+0x10/0x10n[ 4277.434134] ret_from_fork+0x2d/0x50n[ 4277.434837] ? __pfx_kthread+0x10/0x10n[ 4277.435566] ret_from_fork_asm+0x1b/0x30n[ 4277.436280] </TASK>,CVE-2024-56566,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnmedia: platform: allegro-dvt: Fix possible memory leak in allocate_buffers_internal()nnThe buffer in the loop should be released under the exception pathnotherwise there may be a memory leak here.nnTo mitigate this free the buffer when allegro_alloc_buffer fails.,CVE-2024-56572,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnsched/deadline: Fix warning in migrate_enable for boosted tasksnnWhen running the following command:nnwhile true; don stress-ng --cyclic 30 --timeout 30s --minimize --quietndonenna warning is eventually triggered:nnWARNING: CPU: 43 PID: 2848 at kernel/sched/deadline.c:794nsetup_new_dl_entity+0x13e/0x180n...nCall Trace:n <TASK>n ? show_trace_log_lvl+0x1c4/0x2dfn ? enqueue_dl_entity+0x631/0x6e0n ? setup_new_dl_entity+0x13e/0x180n ? __warn+0x7e/0xd0n ? report_bug+0x11a/0x1a0n ? handle_bug+0x3c/0x70n ? exc_invalid_op+0x14/0x70n ? asm_exc_invalid_op+0x16/0x20n enqueue_dl_entity+0x631/0x6e0n enqueue_task_dl+0x7d/0x120n __do_set_cpus_allowed+0xe3/0x280n __set_cpus_allowed_ptr_locked+0x140/0x1d0n __set_cpus_allowed_ptr+0x54/0xa0n migrate_enable+0x7e/0x150n rt_spin_unlock+0x1c/0x90n group_send_sig_info+0xf7/0x1a0n ? kill_pid_info+0x1f/0x1d0n kill_pid_info+0x78/0x1d0n kill_proc_info+0x5b/0x110n __x64_sys_kill+0x93/0xc0n do_syscall_64+0x5c/0xf0n entry_SYSCALL_64_after_hwframe+0x6e/0x76n RIP: 0033:0x7f0dab31f92bnnThis warning occurs because set_cpus_allowed dequeues and enqueues tasksnwith the ENQUEUE_RESTORE flag set. If the task is boosted the warningnis triggered. A boosted task already had its parameters set bynrt_mutex_setprio and a new call to setup_new_dl_entity is unnecessarynhence the WARN_ON call.nnCheck if we are requeueing a boosted task and avoid callingnsetup_new_dl_entity if that's the case.,CVE-2024-56583,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnio_uring/tctx: work around xa_store() allocation error issuennsyzbot triggered the following WARN_ON:nnWARNING: CPU: 0 PID: 16 at io_uring/tctx.c:51 __io_uring_free+0xfa/0x140 io_uring/tctx.c:51nnwhich is thennWARN_ON_ONCE(!xa_empty(&tctx->xa));nnsanity check in __io_uring_free() when a io_uring_task is going throughnits final put. The syzbot test case includes injecting memory allocationnfailures and it very much looks like xa_store() can fail one of itsnmemory allocations and end up with ->head being non-NULL even though nonentries exist in the xarray.nnUntil this issue gets sorted out work around it by attempting toniterate entries in our xarray and WARN_ON_ONCE() if one is found.,CVE-2024-56584,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnscsi: hisi_sas: Create all dump files during debugfs initializationnnFor the current debugfs of hisi_sas after user triggers dump thendriver allocate memory space to save the register information and createndebugfs files to display the saved information. In this process thendebugfs files created after each dump.nnTherefore when the dump is triggered while the driver is unbind thenfollowing hang occurs:nn[67840.853907] Unable to handle kernel NULL pointer dereference at virtual address 00000000000000a0n[67840.862947] Mem abort info:n[67840.865855] ESR = 0x0000000096000004n[67840.869713] EC = 0x25: DABT (current EL) IL = 32 bitsn[67840.875125] SET = 0 FnV = 0n[67840.878291] EA = 0 S1PTW = 0n[67840.881545] FSC = 0x04: level 0 translation faultn[67840.886528] Data abort info:n[67840.889524] ISV = 0 ISS = 0x00000004 ISS2 = 0x00000000n[67840.895117] CM = 0 WnR = 0 TnD = 0 TagAccess = 0n[67840.900284] GCS = 0 Overlay = 0 DirtyBit = 0 Xs = 0n[67840.905709] user pgtable: 4k pages 48-bit VAs pgdp=0000002803a1f000n[67840.912263] [00000000000000a0] pgd=0000000000000000 p4d=0000000000000000n[67840.919177] Internal error: Oops: 0000000096000004 [#1] PREEMPT SMPn[67840.996435] pstate: 80400009 (Nzcv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)n[67841.003628] pc : down_write+0x30/0x98n[67841.007546] lr : start_creating.part.0+0x60/0x198n[67841.012495] sp : ffff8000b979ba20n[67841.016046] x29: ffff8000b979ba20 x28: 0000000000000010 x27: 0000000000024b40n[67841.023412] x26: 0000000000000012 x25: ffff20202b355ae8 x24: ffff20202b35a8c8n[67841.030779] x23: ffffa36877928208 x22: ffffa368b4972240 x21: ffff8000b979bb18n[67841.038147] x20: ffff00281dc1e3c0 x19: fffffffffffffffe x18: 0000000000000020n[67841.045515] x17: 0000000000000000 x16: ffffa368b128a530 x15: ffffffffffffffffn[67841.052888] x14: ffff8000b979bc18 x13: ffffffffffffffff x12: ffff8000b979bb18n[67841.060263] x11: 0000000000000000 x10: 0000000000000000 x9 : ffffa368b1289b18n[67841.067640] x8 : 0000000000000012 x7 : 0000000000000000 x6 : 00000000000003a9n[67841.075014] x5 : 0000000000000000 x4 : ffff002818c5cb00 x3 : 0000000000000001n[67841.082388] x2 : 0000000000000000 x1 : ffff002818c5cb00 x0 : 00000000000000a0n[67841.089759] Call trace:n[67841.092456] down_write+0x30/0x98n[67841.096017] start_creating.part.0+0x60/0x198n[67841.100613] debugfs_create_dir+0x48/0x1f8n[67841.104950] debugfs_create_files_v3_hw+0x88/0x348 [hisi_sas_v3_hw]n[67841.111447] debugfs_snapshot_regs_v3_hw+0x708/0x798 [hisi_sas_v3_hw]n[67841.118111] debugfs_trigger_dump_v3_hw_write+0x9c/0x120 [hisi_sas_v3_hw]n[67841.125115] full_proxy_write+0x68/0xc8n[67841.129175] vfs_write+0xd8/0x3f0n[67841.132708] ksys_write+0x70/0x108n[67841.136317] __arm64_sys_write+0x24/0x38n[67841.140440] invoke_syscall+0x50/0x128n[67841.144385] el0_svc_common.constprop.0+0xc8/0xf0n[67841.149273] do_el0_svc+0x24/0x38n[67841.152773] el0_svc+0x38/0xd8n[67841.156009] el0t_64_sync_handler+0xc0/0xc8n[67841.160361] el0t_64_sync+0x1a4/0x1a8n[67841.164189] Code: b9000882 d2800002 d2800023 f9800011 (c85ffc05)n[67841.170443] ---[ end trace 0000000000000000 ]---nnTo fix this issue create all directories and files during debugfsninitialization. In this way the driver only needs to allocate memorynspace to save information each time the user triggers dumping.,CVE-2024-56588,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnBluetooth: hci_core: Fix not checking skb length on hci_acldata_packetnnThis fixes not checking if skb really contains an ACL header otherwisenthe code may attempt to access some uninitilized/invalid memory past thenvalid skb->data.,CVE-2024-56590,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnBluetooth: hci_conn: Use disable_delayed_work_syncnnThis makes use of disable_delayed_work_sync insteadncancel_delayed_work_sync as it not only cancel the ongoing work but alsondisables new submit which is disarable since the object holding the worknis about to be freed.,CVE-2024-56591,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbpf: Call free_htab_elem() after htab_unlock_bucket()nnFor htab of maps when the map is removed from the htab it may hold thenlast reference of the map. bpf_map_fd_put_ptr() will invokenbpf_map_free_id() to free the id of the removed map element. Howevernbpf_map_fd_put_ptr() is invoked while holding a bucket lockn(raw_spin_lock_t) and bpf_map_free_id() attempts to acquire map_idr_lockn(spinlock_t) triggering the following lockdep warning:nn =============================n [ BUG: Invalid wait context ]n 6.11.0-rc4+ #49 Not taintedn -----------------------------n test_maps/4881 is trying to lock:n ffffffff84884578 (map_idr_lock){+...}-{3:3} at: bpf_map_free_id.part.0+0x21/0x70n other info that might help us debug this:n context-{5:5}n 2 locks held by test_maps/4881:n #0: ffffffff846caf60 (rcu_read_lock){....}-{1:3} at: bpf_fd_htab_map_update_elem+0xf9/0x270n #1: ffff888149ced148 (&htab->lockdep_key#2){....}-{2:2} at: htab_map_update_elem+0x178/0xa80n stack backtrace:n CPU: 0 UID: 0 PID: 4881 Comm: test_maps Not tainted 6.11.0-rc4+ #49n Hardware name: QEMU Standard PC (i440FX + PIIX 1996) ...n Call Trace:n <TASK>n dump_stack_lvl+0x6e/0xb0n dump_stack+0x10/0x20n __lock_acquire+0x73e/0x36c0n lock_acquire+0x182/0x450n _raw_spin_lock_irqsave+0x43/0x70n bpf_map_free_id.part.0+0x21/0x70n bpf_map_put+0xcf/0x110n bpf_map_fd_put_ptr+0x9a/0xb0n free_htab_elem+0x69/0xe0n htab_map_update_elem+0x50f/0xa80n bpf_fd_htab_map_update_elem+0x131/0x270n htab_map_update_elem+0x50f/0xa80n bpf_fd_htab_map_update_elem+0x131/0x270n bpf_map_update_value+0x266/0x380n __sys_bpf+0x21bb/0x36b0n __x64_sys_bpf+0x45/0x60n x64_sys_call+0x1b2a/0x20d0n do_syscall_64+0x5d/0x100n entry_SYSCALL_64_after_hwframe+0x76/0x7ennOne way to fix the lockdep warning is using raw_spinlock_t fornmap_idr_lock as well. However bpf_map_alloc_id() invokesnidr_alloc_cyclic() after acquiring map_idr_lock it will trigger ansimilar lockdep warning because the slab's lock (s->cpu_slab->lock) isnstill a spinlock.nnInstead of changing map_idr_lock's type fix the issue by invokingnhtab_put_fd_value() after htab_unlock_bucket(). However only deferringnthe invocation of htab_put_fd_value() is not enough because the old mapnpointers in htab of maps can not be saved during batched deletion.nTherefore also defer the invocation of free_htab_elem() so thesento-be-freed elements could be linked together similar to lru map.nnThere are four callers for ->map_fd_put_ptr:nn(1) alloc_htab_elem() (through htab_put_fd_value())nIt invokes ->map_fd_put_ptr() under a raw_spinlock_t. The invocation ofnhtab_put_fd_value() can not simply move after htab_unlock_bucket()nbecause the old element has already been stashed in htab->extra_elems.nIt may be reused immediately after htab_unlock_bucket() and theninvocation of htab_put_fd_value() after htab_unlock_bucket() may releasenthe newly-added element incorrectly. Therefore saving the map pointernof the old element for htab of maps before unlocking the bucket andnreleasing the map_ptr after unlock. Beside the map pointer in the oldnelement should do the same thing for the special fields in the oldnelement as well.nn(2) free_htab_elem() (through htab_put_fd_value())nIts caller includes __htab_map_lookup_and_delete_elem()nhtab_map_delete_elem() and __htab_map_lookup_and_delete_batch().nnFor htab_map_delete_elem() simply invoke free_htab_elem() afternhtab_unlock_bucket(). For __htab_map_lookup_and_delete_batch() justnlike lru map linking the to-be-freed element into node_to_free listnand invoking free_htab_elem() for these element after unlock. It is safento reuse batch_flink as the link for node_to_free because thesenelements have been removed from the hash llist.nnBecause htab of maps doesn't support lookup_and_delete operationn__htab_map_lookup_and_delete_elem() doesn't have the problem so keptnit asn---truncated---,CVE-2024-56592,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnwifi: ath10k: avoid NULL pointer error during sdio removennWhen running 'rmmod ath10k' ath10k_sdio_remove() will free sdionworkqueue by destroy_workqueue(). But if CONFIG_INIT_ON_FREE_DEFAULT_ONnis set to yes kernel panic will happen:nCall trace:n destroy_workqueue+0x1c/0x258n ath10k_sdio_remove+0x84/0x94n sdio_bus_remove+0x50/0x16cn device_release_driver_internal+0x188/0x25cn device_driver_detach+0x20/0x2cnnThis is because during 'rmmod ath10k' ath10k_sdio_remove() will callnath10k_core_destroy() before destroy_workqueue(). wiphy_dev_release()nwill finally be called in ath10k_core_destroy(). This function will freenstruct cfg80211_registered_device *rdev and all its members includingnwiphy dev and the pointer of sdio workqueue. Then the pointer of sdionworkqueue will be set to NULL due to CONFIG_INIT_ON_FREE_DEFAULT_ON.nnAfter device release destroy_workqueue() will use NULL pointer then thenkernel panic happen.nnCall trace:nath10k_sdio_removen ->ath10k_core_unregistern n ->ath10k_core_stopn ->ath10k_hif_stopn ->ath10k_sdio_irq_disablen ->ath10k_hif_power_downn ->del_timer_sync(&ar_sdio->sleep_timer)n ->ath10k_core_destroyn ->ath10k_mac_destroyn ->ieee80211_free_hwn ->wiphy_freen n ->wiphy_dev_releasen ->destroy_workqueuennNeed to call destroy_workqueue() before ath10k_core_destroy() freenthe work queue buffer first and then free pointer of work queue bynath10k_core_destroy(). This order matches the error path order innath10k_sdio_probe().nnNo work will be queued on sdio workqueue between it is destroyed andnath10k_core_destroy() is called. Based on the call_stack above thenreason is:nOnly ath10k_sdio_sleep_timer_handler() ath10k_sdio_hif_tx_sg() andnath10k_sdio_irq_disable() will queue work on sdio workqueue.nSleep timer will be deleted before ath10k_core_destroy() innath10k_hif_power_down().nath10k_sdio_irq_disable() only be called in ath10k_hif_stop().nath10k_core_unregister() will call ath10k_hif_power_down() to stop hifnbus so ath10k_sdio_hif_tx_sg() won't be called anymore.nnTested-on: QCA6174 hw3.2 SDIO WLAN.RMH.4.4.1-00189,CVE-2024-56599,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnBluetooth: RFCOMM: avoid leaving dangling sk pointer in rfcomm_sock_alloc()nnbt_sock_alloc() attaches allocated sk object to the provided sock object.nIf rfcomm_dlc_alloc() fails we release the sk object but leave thendangling pointer in the sock object which may cause use-after-free.nnFix this by swapping calls to bt_sock_alloc() and rfcomm_dlc_alloc().,CVE-2024-56604,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Fix out-of-bounds access in 'dcn21_link_encoder_create'nnAn issue was identified in the dcn21_link_encoder_create function wherenan out-of-bounds access could occur when the hpd_source index was usednto reference the link_enc_hpd_regs array. This array has a fixed sizenand the index was not being checked against the array's bounds beforenaccessing it.nnThis fix adds a conditional check to ensure that the hpd_source index isnwithin the valid range of the link_enc_hpd_regs array. If the index isnout of bounds the function now returns NULL to prevent undefinednbehavior.nnReferences:nn[ 65.920507] ------------[ cut here ]------------n[ 65.920510] UBSAN: array-index-out-of-bounds in drivers/gpu/drm/amd/amdgpu/../display/dc/resource/dcn21/dcn21_resource.c:1312:29n[ 65.920519] index 7 is out of range for type 'dcn10_link_enc_hpd_registers [5]'n[ 65.920523] CPU: 3 PID: 1178 Comm: modprobe Tainted: G OE 6.8.0-cleanershaderfeatureresetasdntipmi200nv2132 #13n[ 65.920525] Hardware name: AMD Majolica-RN/Majolica-RN BIOS WMJ0429N_Weekly_20_04_2 04/29/2020n[ 65.920527] Call Trace:n[ 65.920529] <TASK>n[ 65.920532] dump_stack_lvl+0x48/0x70n[ 65.920541] dump_stack+0x10/0x20n[ 65.920543] __ubsan_handle_out_of_bounds+0xa2/0xe0n[ 65.920549] dcn21_link_encoder_create+0xd9/0x140 [amdgpu]n[ 65.921009] link_create+0x6d3/0xed0 [amdgpu]n[ 65.921355] create_links+0x18a/0x4e0 [amdgpu]n[ 65.921679] dc_create+0x360/0x720 [amdgpu]n[ 65.921999] ? dmi_matches+0xa0/0x220n[ 65.922004] amdgpu_dm_init+0x2b6/0x2c90 [amdgpu]n[ 65.922342] ? console_unlock+0x77/0x120n[ 65.922348] ? dev_printk_emit+0x86/0xb0n[ 65.922354] dm_hw_init+0x15/0x40 [amdgpu]n[ 65.922686] amdgpu_device_init+0x26a8/0x33a0 [amdgpu]n[ 65.922921] amdgpu_driver_load_kms+0x1b/0xa0 [amdgpu]n[ 65.923087] amdgpu_pci_probe+0x1b7/0x630 [amdgpu]n[ 65.923087] local_pci_probe+0x4b/0xb0n[ 65.923087] pci_device_probe+0xc8/0x280n[ 65.923087] really_probe+0x187/0x300n[ 65.923087] __driver_probe_device+0x85/0x130n[ 65.923087] driver_probe_device+0x24/0x110n[ 65.923087] __driver_attach+0xac/0x1d0n[ 65.923087] ? __pfx___driver_attach+0x10/0x10n[ 65.923087] bus_for_each_dev+0x7d/0xd0n[ 65.923087] driver_attach+0x1e/0x30n[ 65.923087] bus_add_driver+0xf2/0x200n[ 65.923087] driver_register+0x64/0x130n[ 65.923087] ? __pfx_amdgpu_init+0x10/0x10 [amdgpu]n[ 65.923087] __pci_register_driver+0x61/0x70n[ 65.923087] amdgpu_init+0x7d/0xff0 [amdgpu]n[ 65.923087] do_one_initcall+0x49/0x310n[ 65.923087] ? kmalloc_trace+0x136/0x360n[ 65.923087] do_init_module+0x6a/0x270n[ 65.923087] load_module+0x1fce/0x23a0n[ 65.923087] init_module_from_file+0x9c/0xe0n[ 65.923087] ? init_module_from_file+0x9c/0xe0n[ 65.923087] idempotent_init_module+0x179/0x230n[ 65.923087] __x64_sys_finit_module+0x5d/0xa0n[ 65.923087] do_syscall_64+0x76/0x120n[ 65.923087] entry_SYSCALL_64_after_hwframe+0x6e/0x76n[ 65.923087] RIP: 0033:0x7f2d80f1e88dn[ 65.923087] Code: 5b 41 5c c3 66 0f 1f 84 00 00 00 00 00 f3 0f 1e fa 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 8b 0d 73 b5 0f 00 f7 d8 64 89 01 48n[ 65.923087] RSP: 002b:00007ffc7bc1aa78 EFLAGS: 00000246 ORIG_RAX: 0000000000000139n[ 65.923087] RAX: ffffffffffffffda RBX: 0000564c9c1db130 RCX: 00007f2d80f1e88dn[ 65.923087] RDX: 0000000000000000 RSI: 0000564c9c1e5480 RDI: 000000000000000fn[ 65.923087] RBP: 0000000000040000 R08: 0000000000000000 R09: 0000000000000002n[ 65.923087] R10: 000000000000000f R11: 0000000000000246 R12: 0000564c9c1e5480n[ 65.923087] R13: 0000564c9c1db260 R14: 0000000000000000 R15: 0000564c9c1e54b0n[ 65.923087] </TASK>n[ 65.923927] ---[ end trace ]---,CVE-2024-56608,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnwifi: rtw88: use ieee80211_purge_tx_queue() to purge TX skbnnWhen removing kernel modules by:n rmmod rtw88_8723cs rtw88_8703b rtw88_8723x rtw88_sdio rtw88_corennDriver uses skb_queue_purge() to purge TX skb but not report tx statusncausing Have pending ack frames! warning. Use ieee80211_purge_tx_queue()nto correct this.nnSince ieee80211_purge_tx_queue() doesn't take locks to prevent racingnbetween TX work and purge TX queue flush and destroy TX work in advance.nn wlan0: deauthenticating from aa:f5:fd:60:4c:a8 by localn choice (Reason: 3=DEAUTH_LEAVING)n ------------[ cut here ]------------n Have pending ack frames!n WARNING: CPU: 3 PID: 9232 at net/mac80211/main.c:1691n ieee80211_free_ack_frame+0x5c/0x90 [mac80211]n CPU: 3 PID: 9232 Comm: rmmod Tainted: G Cn 6.10.1-200.fc40.aarch64 #1n Hardware name: pine64 Pine64 PinePhone Braveheartn (1.1)/Pine64 PinePhone Braveheart (1.1) BIOS 2024.01 01/01/2024n pstate: 60400005 (nZCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)n pc : ieee80211_free_ack_frame+0x5c/0x90 [mac80211]n lr : ieee80211_free_ack_frame+0x5c/0x90 [mac80211]n sp : ffff80008c1b37b0n x29: ffff80008c1b37b0 x28: ffff000003be8000 x27: 0000000000000000n x26: 0000000000000000 x25: ffff000003dc14b8 x24: ffff80008c1b37d0n x23: ffff000000ff9f80 x22: 0000000000000000 x21: 000000007fffffffn x20: ffff80007c7e93d8 x19: ffff00006e66f400 x18: 0000000000000000n x17: ffff7ffffd2b3000 x16: ffff800083fc0000 x15: 0000000000000000n x14: 0000000000000000 x13: 2173656d61726620 x12: 6b636120676e6964n x11: 0000000000000000 x10: 000000000000005d x9 : ffff8000802af2b0n x8 : ffff80008c1b3430 x7 : 0000000000000001 x6 : 0000000000000001n x5 : 0000000000000000 x4 : 0000000000000000 x3 : 0000000000000000n x2 : 0000000000000000 x1 : 0000000000000000 x0 : ffff000003be8000n Call trace:n ieee80211_free_ack_frame+0x5c/0x90 [mac80211]n idr_for_each+0x74/0x110n ieee80211_free_hw+0x44/0xe8 [mac80211]n rtw_sdio_remove+0x9c/0xc0 [rtw88_sdio]n sdio_bus_remove+0x44/0x180n device_remove+0x54/0x90n device_release_driver_internal+0x1d4/0x238n driver_detach+0x54/0xc0n bus_remove_driver+0x78/0x108n driver_unregister+0x38/0x78n sdio_unregister_driver+0x2c/0x40n rtw_8723cs_driver_exit+0x18/0x1000 [rtw88_8723cs]n __do_sys_delete_module.isra.0+0x190/0x338n __arm64_sys_delete_module+0x1c/0x30n invoke_syscall+0x74/0x100n el0_svc_common.constprop.0+0x48/0xf0n do_el0_svc+0x24/0x38n el0_svc+0x3c/0x158n el0t_64_sync_handler+0x120/0x138n el0t_64_sync+0x194/0x198n ---[ end trace 0000000000000000 ]---,CVE-2024-56609,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnmm/mempolicy: fix migrate_to_node() assuming there is at least one VMA in a MMnnWe currently assume that there is at least one VMA in a MM which isn'tntrue.nnSo we might end up having find_vma() return NULL to then de-referencenNULL. So properly handle find_vma() returning NULL.nnThis fixes the report:nnOops: general protection fault probably for non-canonical address 0xdffffc0000000000: 0000 [#1] PREEMPT SMP KASAN PTInKASAN: null-ptr-deref in range [0x0000000000000000-0x0000000000000007]nCPU: 1 UID: 0 PID: 6021 Comm: syz-executor284 Not tainted 6.12.0-rc7-syzkaller-00187-gf868cd251776 #0nHardware name: Google Google Compute Engine/Google Compute Engine BIOS Google 10/30/2024nRIP: 0010:migrate_to_node mm/mempolicy.c:1090 [inline]nRIP: 0010:do_migrate_pages+0x403/0x6f0 mm/mempolicy.c:1194nCode: ...nRSP: 0018:ffffc9000375fd08 EFLAGS: 00010246nRAX: 0000000000000000 RBX: ffffc9000375fd78 RCX: 0000000000000000nRDX: ffff88807e171300 RSI: dffffc0000000000 RDI: ffff88803390c044nRBP: ffff88807e171428 R08: 0000000000000014 R09: fffffbfff2039ef1nR10: ffffffff901cf78f R11: 0000000000000000 R12: 0000000000000003nR13: ffffc9000375fe90 R14: ffffc9000375fe98 R15: ffffc9000375fdf8nFS: 00005555919e1380(0000) GS:ffff8880b8700000(0000) knlGS:0000000000000000nCS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033nCR2: 00005555919e1ca8 CR3: 000000007f12a000 CR4: 00000000003526f0nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400nCall Trace:n <TASK>n kernel_migrate_pages+0x5b2/0x750 mm/mempolicy.c:1709n __do_sys_migrate_pages mm/mempolicy.c:1727 [inline]n __se_sys_migrate_pages mm/mempolicy.c:1723 [inline]n __x64_sys_migrate_pages+0x96/0x100 mm/mempolicy.c:1723n do_syscall_x64 arch/x86/entry/common.c:52 [inline]n do_syscall_64+0xcd/0x250 arch/x86/entry/common.c:83n entry_SYSCALL_64_after_hwframe+0x77/0x7fnn[akpm@linux-foundation.org: add unlikely()],CVE-2024-56611,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnxsk: fix OOB map writes when deleting elementsnnJordy says:nnnIn the xsk_map_delete_elem function an unsigned integern(map->max_entries) is compared with a user-controlled signed integern(k). Due to implicit type conversion a large unsigned value fornmap->max_entries can bypass the intended bounds check:nntif (k >= map->max_entries)nttreturn -EINVAL;nnThis allows k to hold a negative value (between -2147483648 and -2)nwhich is then used as an array index in m->xsk_map[k] which resultsnin an out-of-bounds access.nntspin_lock_bh(&m->lock);ntmap_entry = &m->xsk_map[k]; // Out-of-bounds map_entryntold_xs = unrcu_pointer(xchg(map_entry NULL)); // Oob writentif (old_xs)nttxsk_map_sock_delete(old_xs map_entry);ntspin_unlock_bh(&m->lock);nnThe xchg operation can then be used to cause an out-of-bounds write.nMoreover the invalid map_entry passed to xsk_map_sock_delete can leadnto further memory corruption.nnnIt indeed results in following splat:nn[76612.897343] BUG: unable to handle page fault for address: ffffc8fc2e461108n[76612.904330] #PF: supervisor write access in kernel moden[76612.909639] #PF: error_code(0x0002) - not-present pagen[76612.914855] PGD 0 P4D 0n[76612.917431] Oops: Oops: 0002 [#1] PREEMPT SMPn[76612.921859] CPU: 11 UID: 0 PID: 10318 Comm: a.out Not tainted 6.12.0-rc1+ #470n[76612.929189] Hardware name: Intel Corporation S2600WFT/S2600WFT BIOS SE5C620.86B.02.01.0008.031920191559 03/19/2019n[76612.939781] RIP: 0010:xsk_map_delete_elem+0x2d/0x60n[76612.944738] Code: 00 00 41 54 55 53 48 63 2e 3b 6f 24 73 38 4c 8d a7 f8 00 00 00 48 89 fb 4c 89 e7 e8 2d bf 05 00 48 8d b4 eb 00 01 00 00 31 ff <48> 87 3e 48 85 ff 74 05 e8 16 ff ff ff 4c 89 e7 e8 3e bc 05 00 31n[76612.963774] RSP: 0018:ffffc9002e407df8 EFLAGS: 00010246n[76612.969079] RAX: 0000000000000000 RBX: ffffc9002e461000 RCX: 0000000000000000n[76612.976323] RDX: 0000000000000001 RSI: ffffc8fc2e461108 RDI: 0000000000000000n[76612.983569] RBP: ffffffff80000001 R08: 0000000000000000 R09: 0000000000000007n[76612.990812] R10: ffffc9002e407e18 R11: ffff888108a38858 R12: ffffc9002e4610f8n[76612.998060] R13: ffff888108a38858 R14: 00007ffd1ae0ac78 R15: ffffc9002e4610c0n[76613.005303] FS: 00007f80b6f59740(0000) GS:ffff8897e0ec0000(0000) knlGS:0000000000000000n[76613.013517] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033n[76613.019349] CR2: ffffc8fc2e461108 CR3: 000000011e3ef001 CR4: 00000000007726f0n[76613.026595] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000n[76613.033841] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400n[76613.041086] PKRU: 55555554n[76613.043842] Call Trace:n[76613.046331] <TASK>n[76613.048468] ? __die+0x20/0x60n[76613.051581] ? page_fault_oops+0x15a/0x450n[76613.055747] ? search_extable+0x22/0x30n[76613.059649] ? search_bpf_extables+0x5f/0x80n[76613.063988] ? exc_page_fault+0xa9/0x140n[76613.067975] ? asm_exc_page_fault+0x22/0x30n[76613.072229] ? xsk_map_delete_elem+0x2d/0x60n[76613.076573] ? xsk_map_delete_elem+0x23/0x60n[76613.080914] __sys_bpf+0x19b7/0x23c0n[76613.084555] __x64_sys_bpf+0x1a/0x20n[76613.088194] do_syscall_64+0x37/0xb0n[76613.091832] entry_SYSCALL_64_after_hwframe+0x4b/0x53n[76613.096962] RIP: 0033:0x7f80b6d1e88dn[76613.100592] Code: 5b 41 5c c3 66 0f 1f 84 00 00 00 00 00 f3 0f 1e fa 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 8b 0d 73 b5 0f 00 f7 d8 64 89 01 48n[76613.119631] RSP: 002b:00007ffd1ae0ac68 EFLAGS: 00000206 ORIG_RAX: 0000000000000141n[76613.131330] RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007f80b6d1e88dn[76613.142632] RDX: 0000000000000098 RSI: 00007ffd1ae0ad20 RDI: 0000000000000003n[76613.153967] RBP: 00007ffd1ae0adc0 R08: 0000000000000000 R09: 0000000000000000n[76613.166030] R10: 00007f80b6f77040 R11: 0000000000000206 R12: 00007ffd1ae0aed8n[76613.177130] R13: 000055ddf42ce1e9 R14: 000055ddf42d0d98 R15: 00n---truncated---,CVE-2024-56614,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet/smc: fix LGR and link use-after-free issuennWe encountered a LGR/link use-after-free issue which manifested asnthe LGR/link refcnt reaching 0 early and entering the clear processnmaking resource access unsafe.nn refcount_t: addition on 0; use-after-free.n WARNING: CPU: 14 PID: 107447 at lib/refcount.c:25 refcount_warn_saturate+0x9c/0x140n Workqueue: events smc_lgr_terminate_work [smc]n Call trace:n refcount_warn_saturate+0x9c/0x140n __smc_lgr_terminate.part.45+0x2a8/0x370 [smc]n smc_lgr_terminate_work+0x28/0x30 [smc]n process_one_work+0x1b8/0x420n worker_thread+0x158/0x510n kthread+0x114/0x118nnornn refcount_t: underflow; use-after-free.n WARNING: CPU: 6 PID: 93140 at lib/refcount.c:28 refcount_warn_saturate+0xf0/0x140n Workqueue: smc_hs_wq smc_listen_work [smc]n Call trace:n refcount_warn_saturate+0xf0/0x140n smcr_link_put+0x1cc/0x1d8 [smc]n smc_conn_free+0x110/0x1b0 [smc]n smc_conn_abort+0x50/0x60 [smc]n smc_listen_find_device+0x75c/0x790 [smc]n smc_listen_work+0x368/0x8a0 [smc]n process_one_work+0x1b8/0x420n worker_thread+0x158/0x510n kthread+0x114/0x118nnIt is caused by repeated release of LGR/link refcnt. One suspect is thatnsmc_conn_free() is called repeatedly because some smc_conn_free() fromnserver listening path are not protected by sock lock.nne.g.nnCalls under socklock | smc_listen_workn-------------------------------------------------------nlock_sock(sk) | smc_conn_abortnsmc_conn_free | - smc_conn_freen- smcr_link_put | - smcr_link_put (duplicated)nrelease_sock(sk)nnSo here add sock lock protection in smc_listen_work() path making itnexclusive with other connection operations.,CVE-2024-56640,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet/smc: initialize close_work early to avoid warningnnWe encountered a warning that close_work was canceled beforeninitialization.nn WARNING: CPU: 7 PID: 111103 at kernel/workqueue.c:3047 __flush_work+0x19e/0x1b0n Workqueue: events smc_lgr_terminate_work [smc]n RIP: 0010:__flush_work+0x19e/0x1b0n Call Trace:n ? __wake_up_common+0x7a/0x190n ? work_busy+0x80/0x80n __cancel_work_timer+0xe3/0x160n smc_close_cancel_work+0x1a/0x70 [smc]n smc_close_active_abort+0x207/0x360 [smc]n __smc_lgr_terminate.part.38+0xc8/0x180 [smc]n process_one_work+0x19e/0x340n worker_thread+0x30/0x370n ? process_one_work+0x340/0x340n kthread+0x117/0x130n ? __kthread_cancel_work+0x50/0x50n ret_from_fork+0x22/0x30nnThis is because when smc_close_cancel_work is triggered e.g. the RDMAndriver is rmmod and the LGR is terminated the conn->close_work isnflushed before initialization resulting in WARN_ON(!work->func).nn__smc_lgr_terminate | smc_connect_{rdma|ism}n-------------------------------------------------------------n | smc_conn_createntttt| - smc_lgr_register_connnfor conn in lgr->conns_all |n- smc_conn_kill |n - smc_close_active_abort |n - smc_close_cancel_work |n - cancel_work_sync |n - __flush_work |nt (close_work) |nt | smc_close_initnt | - INIT_WORK(&close_work)nnSo fix this by initializing close_work before establishing thenconnection.,CVE-2024-56641,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet: Fix icmp host relookup triggering ip_rt_bugnnarp link failure may trigger ip_rt_bug while xfrm enabled call trace is:nnWARNING: CPU: 0 PID: 0 at net/ipv4/route.c:1241 ip_rt_bug+0x14/0x20nModules linked in:nCPU: 0 UID: 0 PID: 0 Comm: swapper/0 Not tainted 6.12.0-rc6-00077-g2e1b3cc9d7f7nHardware name: QEMU Standard PC (i440FX + PIIX 1996)nBIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014nRIP: 0010:ip_rt_bug+0x14/0x20nCall Trace:n <IRQ>n ip_send_skb+0x14/0x40n __icmp_send+0x42d/0x6a0n ipv4_link_failure+0xe2/0x1d0n arp_error_report+0x3c/0x50n neigh_invalidate+0x8d/0x100n neigh_timer_handler+0x2e1/0x330n call_timer_fn+0x21/0x120n __run_timer_base.part.0+0x1c9/0x270n run_timer_softirq+0x4c/0x80n handle_softirqs+0xac/0x280n irq_exit_rcu+0x62/0x80n sysvec_apic_timer_interrupt+0x77/0x90nnThe script below reproduces this scenario:nip xfrm policy add src 0.0.0.0/0 dst 0.0.0.0/0 ntdir out priority 0 ptype main flag localok icmpnip l a veth1 type vethnip a a 192.168.141.111/24 dev veth0nip l s veth0 upnping 192.168.141.155 -c 1nnicmp_route_lookup() create input routes for locally generated packetsnwhile xfrm relookup ICMP traffic.Then it will set input routen(dst->out = ip_rt_bug) to skb for DESTUNREACH.nnFor ICMP err triggered by locally generated packets dst->dev of outputnroute is loopback. Generally xfrm relookup verification is not requirednon loopback interfaces (net.ipv4.conf.lo.disable_xfrm = 1).nnSkip icmp relookup for locally generated packets to fix it.,CVE-2024-56647,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nncan: hi311x: hi3110_can_ist(): fix potential use-after-freennThe commit a22bd630cfff (can: hi311x: do not report txerr and rxerrnduring bus-off) removed the reporting of rxerr and txerr even in casenof correct operation (i. e. not bus-off).nnThe error count information added to the CAN frame after netif_rx() isna potential use after free since there is no guarantee that the skbnis in the same state. It might be freed or reused.nnFix the issue by postponing the netif_rx() call in case of txerr andnrxerr reporting.,CVE-2024-56651,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet: defer final 'struct net' free in netns dismantlennIlya reported a slab-use-after-free in dst_destroy [1]nnIssue is in xfrm6_net_init() and xfrm4_net_init() :nnThey copy xfrm[46]_dst_ops_template into net->xfrm.xfrm[46]_dst_ops.nnBut net structure might be freed before all the dst callbacks arencalled. So when dst_destroy() calls later :nnif (dst->ops->destroy)n dst->ops->destroy(dst);nndst->ops points to the old net->xfrm.xfrm[46]_dst_ops which has been freed.nnSee a relevant issue fixed in :nnac888d58869b (net: do not delay dst_entries_add() in dst_release())nnA fix is to queue the 'struct net' to be freed after onenanother cleanup_net() round (and existing rcu_barrier())nn[1]nnBUG: KASAN: slab-use-after-free in dst_destroy (net/core/dst.c:112)nRead of size 8 at addr ffff8882137ccab0 by task swapper/37/0nDec 03 05:46:18 kernel:nCPU: 37 UID: 0 PID: 0 Comm: swapper/37 Kdump: loaded Not tainted 6.12.0 #67nHardware name: Red Hat KVM/RHEL BIOS 1.16.1-1.el9 04/01/2014nCall Trace:n <IRQ>ndump_stack_lvl (lib/dump_stack.c:124)nprint_address_description.constprop.0 (mm/kasan/report.c:378)n? dst_destroy (net/core/dst.c:112)nprint_report (mm/kasan/report.c:489)n? dst_destroy (net/core/dst.c:112)n? kasan_addr_to_slab (mm/kasan/common.c:37)nkasan_report (mm/kasan/report.c:603)n? dst_destroy (net/core/dst.c:112)n? rcu_do_batch (kernel/rcu/tree.c:2567)ndst_destroy (net/core/dst.c:112)nrcu_do_batch (kernel/rcu/tree.c:2567)n? __pfx_rcu_do_batch (kernel/rcu/tree.c:2491)n? lockdep_hardirqs_on_prepare (kernel/locking/lockdep.c:4339 kernel/locking/lockdep.c:4406)nrcu_core (kernel/rcu/tree.c:2825)nhandle_softirqs (kernel/softirq.c:554)n__irq_exit_rcu (kernel/softirq.c:589 kernel/softirq.c:428 kernel/softirq.c:637)nirq_exit_rcu (kernel/softirq.c:651)nsysvec_apic_timer_interrupt (arch/x86/kernel/apic/apic.c:1049 arch/x86/kernel/apic/apic.c:1049)n </IRQ>n <TASK>nasm_sysvec_apic_timer_interrupt (./arch/x86/include/asm/idtentry.h:702)nRIP: 0010:default_idle (./arch/x86/include/asm/irqflags.h:37 ./arch/x86/include/asm/irqflags.h:92 arch/x86/kernel/process.c:743)nCode: 00 4d 29 c8 4c 01 c7 4c 29 c2 e9 6e ff ff ff 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 66 90 0f 00 2d c7 c9 27 00 fb f4 <fa> c3 cc cc cc cc 66 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 90nRSP: 0018:ffff888100d2fe00 EFLAGS: 00000246nRAX: 00000000001870ed RBX: 1ffff110201a5fc2 RCX: ffffffffb61a3e46nRDX: 0000000000000000 RSI: 0000000000000000 RDI: ffffffffb3d4d123nRBP: 0000000000000000 R08: 0000000000000001 R09: ffffed11c7e1835dnR10: ffff888e3f0c1aeb R11: 0000000000000000 R12: 0000000000000000nR13: ffff888100d20000 R14: dffffc0000000000 R15: 0000000000000000n? ct_kernel_exit.constprop.0 (kernel/context_tracking.c:148)n? cpuidle_idle_call (kernel/sched/idle.c:186)ndefault_idle_call (./include/linux/cpuidle.h:143 kernel/sched/idle.c:118)ncpuidle_idle_call (kernel/sched/idle.c:186)n? __pfx_cpuidle_idle_call (kernel/sched/idle.c:168)n? lock_release (kernel/locking/lockdep.c:467 kernel/locking/lockdep.c:5848)n? lockdep_hardirqs_on_prepare (kernel/locking/lockdep.c:4347 kernel/locking/lockdep.c:4406)n? tsc_verify_tsc_adjust (arch/x86/kernel/tsc_sync.c:59)ndo_idle (kernel/sched/idle.c:326)ncpu_startup_entry (kernel/sched/idle.c:423 (discriminator 1))nstart_secondary (arch/x86/kernel/smpboot.c:202 arch/x86/kernel/smpboot.c:282)n? __pfx_start_secondary (arch/x86/kernel/smpboot.c:232)n? soft_restart_cpu (arch/x86/kernel/head_64.S:452)ncommon_startup_64 (arch/x86/kernel/head_64.S:414)n </TASK>nDec 03 05:46:18 kernel:nAllocated by task 12184:nkasan_save_stack (mm/kasan/common.c:48)nkasan_save_track (./arch/x86/include/asm/current.h:49 mm/kasan/common.c:60 mm/kasan/common.c:69)n__kasan_slab_alloc (mm/kasan/common.c:319 mm/kasan/common.c:345)nkmem_cache_alloc_noprof (mm/slub.c:4085 mm/slub.c:4134 mm/slub.c:4141)ncopy_net_ns (net/core/net_namespace.c:421 net/core/net_namespace.c:480)ncreate_new_namespacesn---truncated---,CVE-2024-56658,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbpf sockmap: Fix race between element replace and close()nnElement replace (with a socket different from the one stored) may racenwith socket's close() link popping & unlinking. __sock_map_delete()nunconditionally unrefs the (wrong) element:nn// set map[0] = s0nmap_update_elem(map 0 s0)nn// drop fd of s0nclose(s0)n sock_map_close()n lock_sock(sk) (s0!)n sock_map_remove_links(sk)n link = sk_psock_link_pop()n sock_map_unlink(sk link)n sock_map_delete_from_linkn // replace map[0] with s1n map_update_elem(map 0 s1)n sock_map_update_elemn (s1!) lock_sock(sk)n sock_map_update_commonn psock = sk_psock(sk)n spin_lock(&stab->lock)n osk = stab->sks[idx]n sock_map_add_link(... &stab->sks[idx])n sock_map_unref(osk &stab->sks[idx])n psock = sk_psock(osk)n sk_psock_put(sk psock)n if (refcount_dec_and_test(&psock))n sk_psock_drop(sk psock)n spin_unlock(&stab->lock)n unlock_sock(sk)n __sock_map_deleten spin_lock(&stab->lock)n sk = *psk // s1 replaced s0; sk == s1n if (!sk_test || sk_test == sk) // sk_test (s0) != sk (s1); no branchn sk = xchg(psk NULL)n if (sk)n sock_map_unref(sk psk) // unref s1; sks[idx] will danglen psock = sk_psock(sk)n sk_psock_put(sk psock)n if (refcount_dec_and_test())n sk_psock_drop(sk psock)n spin_unlock(&stab->lock)n release_sock(sk)nnThen close(map) enqueues bpf_map_free_deferred which finally callsnsock_map_free(). This results in some refcount_t warnings along withna KASAN splat [1].nnFix __sock_map_delete() do not allow sock_map_unref() on elements thatnmay have been replaced.nn[1]:nBUG: KASAN: slab-use-after-free in sock_map_free+0x10e/0x330nWrite of size 4 at addr ffff88811f5b9100 by task kworker/u64:12/1063nnCPU: 14 UID: 0 PID: 1063 Comm: kworker/u64:12 Not tainted 6.12.0+ #125nHardware name: QEMU Standard PC (i440FX + PIIX 1996) BIOS Arch Linux 1.16.3-1-1 04/01/2014nWorkqueue: events_unbound bpf_map_free_deferrednCall Trace:n <TASK>n dump_stack_lvl+0x68/0x90n print_report+0x174/0x4f6n kasan_report+0xb9/0x190n kasan_check_range+0x10f/0x1e0n sock_map_free+0x10e/0x330n bpf_map_free_deferred+0x173/0x320n process_one_work+0x846/0x1420n worker_thread+0x5b3/0xf80n kthread+0x29e/0x360n ret_from_fork+0x2d/0x70n ret_from_fork_asm+0x1a/0x30n </TASK>nnAllocated by task 1202:n kasan_save_stack+0x1e/0x40n kasan_save_track+0x10/0x30n __kasan_slab_alloc+0x85/0x90n kmem_cache_alloc_noprof+0x131/0x450n sk_prot_alloc+0x5b/0x220n sk_alloc+0x2c/0x870n unix_create1+0x88/0x8a0n unix_create+0xc5/0x180n __sock_create+0x241/0x650n __sys_socketpair+0x1ce/0x420n __x64_sys_socketpair+0x92/0x100n do_syscall_64+0x93/0x180n entry_SYSCALL_64_after_hwframe+0x76/0x7ennFreed by task 46:n kasan_save_stack+0x1e/0x40n kasan_save_track+0x10/0x30n kasan_save_free_info+0x37/0x60n __kasan_slab_free+0x4b/0x70n kmem_cache_free+0x1a1/0x590n __sk_destruct+0x388/0x5a0n sk_psock_destroy+0x73e/0xa50n process_one_work+0x846/0x1420n worker_thread+0x5b3/0xf80n kthread+0x29e/0x360n ret_from_fork+0x2d/0x70n ret_from_fork_asm+0x1a/0x30nnThe bun---truncated---,CVE-2024-56664,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnf2fs: fix to do sanity check on node blkaddr in truncate_node()nnsyzbot reports a f2fs bug as below:nn------------[ cut here ]------------nkernel BUG at fs/f2fs/segment.c:2534!nRIP: 0010:f2fs_invalidate_blocks+0x35f/0x370 fs/f2fs/segment.c:2534nCall Trace:n truncate_node+0x1ae/0x8c0 fs/f2fs/node.c:909n f2fs_remove_inode_page+0x5c2/0x870 fs/f2fs/node.c:1288n f2fs_evict_inode+0x879/0x15c0 fs/f2fs/inode.c:856n evict+0x4e8/0x9b0 fs/inode.c:723n f2fs_handle_failed_inode+0x271/0x2e0 fs/f2fs/inode.c:986n f2fs_create+0x357/0x530 fs/f2fs/namei.c:394n lookup_open fs/namei.c:3595 [inline]n open_last_lookups fs/namei.c:3694 [inline]n path_openat+0x1c03/0x3590 fs/namei.c:3930n do_filp_open+0x235/0x490 fs/namei.c:3960n do_sys_openat2+0x13e/0x1d0 fs/open.c:1415n do_sys_open fs/open.c:1430 [inline]n __do_sys_openat fs/open.c:1446 [inline]n __se_sys_openat fs/open.c:1441 [inline]n __x64_sys_openat+0x247/0x2a0 fs/open.c:1441n do_syscall_x64 arch/x86/entry/common.c:52 [inline]n do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83n entry_SYSCALL_64_after_hwframe+0x77/0x7fnRIP: 0010:f2fs_invalidate_blocks+0x35f/0x370 fs/f2fs/segment.c:2534nnThe root cause is: on a fuzzed image blkaddr in nat entry may bencorrupted then it will cause system panic when using it innf2fs_invalidate_blocks() to avoid this let's add sanity check onnnat blkaddr in truncate_node().,CVE-2024-56692,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnpowerpc/pseries: Fix dtl_access_lock to be a rw_semaphorennThe dtl_access_lock needs to be a rw_sempahore a sleeping lock becausenthe code calls kmalloc() while holding it which can sleep:nn # echo 1 > /proc/powerpc/vcpudispatch_statsn BUG: sleeping function called from invalid context at include/linux/sched/mm.h:337n in_atomic(): 1 irqs_disabled(): 0 non_block: 0 pid: 199 name: shn preempt_count: 1 expected: 0n 3 locks held by sh/199:n #0: c00000000a0743f8 (sb_writers#3){.+.+}-{0:0} at: vfs_write+0x324/0x438n #1: c0000000028c7058 (dtl_enable_mutex){+.+.}-{3:3} at: vcpudispatch_stats_write+0xd4/0x5f4n #2: c0000000028c70b8 (dtl_access_lock){+.+.}-{2:2} at: vcpudispatch_stats_write+0x220/0x5f4n CPU: 0 PID: 199 Comm: sh Not tainted 6.10.0-rc4 #152n Hardware name: IBM pSeries (emulated by qemu) POWER9 (raw) 0x4e1202 0xf000005 of:SLOFHEAD hv:linuxkvm pSeriesn Call Trace:n dump_stack_lvl+0x130/0x148 (unreliable)n __might_resched+0x174/0x410n kmem_cache_alloc_noprof+0x340/0x3d0n alloc_dtl_buffers+0x124/0x1acn vcpudispatch_stats_write+0x2a8/0x5f4n proc_reg_write+0xf4/0x150n vfs_write+0xfc/0x438n ksys_write+0x88/0x148n system_call_exception+0x1c4/0x5a0n system_call_common+0xf4/0x258,CVE-2024-56701,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnipv6: Fix soft lockups in fib6_select_path under high next hop churnnnSoft lockups have been observed on a cluster of Linux-based edge routersnlocated in a highly dynamic environment. Using the `bird` service thesenrouters continuously update BGP-advertised routes due to frequentlynchanging nexthop destinations while also managing significant IPv6ntraffic. The lockups occur during the traversal of the multipathncircular linked-list in the `fib6_select_path` function particularlynwhile iterating through the siblings in the list. The issue typicallynarises when the nodes of the linked list are unexpectedly deletednconcurrently on a different coreindicated by their 'next' andn'previous' elements pointing back to the node itself and their referencencount dropping to zero. This results in an infinite loop leading to ansoft lockup that triggers a system panic via the watchdog timer.nnApply RCU primitives in the problematic code sections to resolve thenissue. Where necessary update the references to fib6_siblings tonannotate or use the RCU APIs.nnInclude a test script that reproduces the issue. The scriptnperiodically updates the routing table while generating a heavy loadnof outgoing IPv6 traffic through multiple iperf3 clients. Itnconsistently induces infinite soft lockups within a couple of minutes.nnKernel log:nn 0 [ffffbd13003e8d30] machine_kexec at ffffffff8ceaf3ebn 1 [ffffbd13003e8d90] __crash_kexec at ffffffff8d0120e3n 2 [ffffbd13003e8e58] panic at ffffffff8cef65d4n 3 [ffffbd13003e8ed8] watchdog_timer_fn at ffffffff8d05cb03n 4 [ffffbd13003e8f08] __hrtimer_run_queues at ffffffff8cfec62fn 5 [ffffbd13003e8f70] hrtimer_interrupt at ffffffff8cfed756n 6 [ffffbd13003e8fd0] __sysvec_apic_timer_interrupt at ffffffff8cea01afn 7 [ffffbd13003e8ff0] sysvec_apic_timer_interrupt at ffffffff8df1b83dn-- <IRQ stack> --n 8 [ffffbd13003d3708] asm_sysvec_apic_timer_interrupt at ffffffff8e000ecbn [exception RIP: fib6_select_path+299]n RIP: ffffffff8ddafe7b RSP: ffffbd13003d37b8 RFLAGS: 00000287n RAX: ffff975850b43600 RBX: ffff975850b40200 RCX: 0000000000000000n RDX: 000000003fffffff RSI: 0000000051d383e4 RDI: ffff975850b43618n RBP: ffffbd13003d3800 R8: 0000000000000000 R9: ffff975850b40200n R10: 0000000000000000 R11: 0000000000000000 R12: ffffbd13003d3830n R13: ffff975850b436a8 R14: ffff975850b43600 R15: 0000000000000007n ORIG_RAX: ffffffffffffffff CS: 0010 SS: 0018n 9 [ffffbd13003d3808] ip6_pol_route at ffffffff8ddb030cn10 [ffffbd13003d3888] ip6_pol_route_input at ffffffff8ddb068cn11 [ffffbd13003d3898] fib6_rule_lookup at ffffffff8ddf02b5n12 [ffffbd13003d3928] ip6_route_input at ffffffff8ddb0f47n13 [ffffbd13003d3a18] ip6_rcv_finish_core.constprop.0 at ffffffff8dd950d0n14 [ffffbd13003d3a30] ip6_list_rcv_finish.constprop.0 at ffffffff8dd96274n15 [ffffbd13003d3a98] ip6_sublist_rcv at ffffffff8dd96474n16 [ffffbd13003d3af8] ipv6_list_rcv at ffffffff8dd96615n17 [ffffbd13003d3b60] __netif_receive_skb_list_core at ffffffff8dc16fecn18 [ffffbd13003d3be0] netif_receive_skb_list_internal at ffffffff8dc176b3n19 [ffffbd13003d3c50] napi_gro_receive at ffffffff8dc565b9n20 [ffffbd13003d3c80] ice_receive_skb at ffffffffc087e4f5 [ice]n21 [ffffbd13003d3c90] ice_clean_rx_irq at ffffffffc0881b80 [ice]n22 [ffffbd13003d3d20] ice_napi_poll at ffffffffc088232f [ice]n23 [ffffbd13003d3d80] __napi_poll at ffffffff8dc18000n24 [ffffbd13003d3db8] net_rx_action at ffffffff8dc18581n25 [ffffbd13003d3e40] __do_softirq at ffffffff8df352e9n26 [ffffbd13003d3eb0] run_ksoftirqd at ffffffff8ceffe47n27 [ffffbd13003d3ec0] smpboot_thread_fn at ffffffff8cf36a30n28 [ffffbd13003d3ee8] kthread at ffffffff8cf2b39fn29 [ffffbd13003d3f28] ret_from_fork at ffffffff8ce5fa64n30 [ffffbd13003d3f50] ret_from_fork_asm at ffffffff8ce03cbb,CVE-2024-56703,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnudmabuf: fix memory leak on last export_udmabuf() error pathnnIn export_udmabuf() if dma_buf_fd() fails because the FD table is full andma_buf owning the udmabuf has already been created; but the error handlingnin udmabuf_create() will tear down the udmabuf without doing anything aboutnthe containing dma_buf.nnThis leaves a dma_buf in memory that contains a dangling pointer; thoughnthat doesn't seem to lead to anything bad except a memory leak.nnFix it by moving the dma_buf_fd() call out of export_udmabuf() so that wencan give it different error handling.nnNote that the shape of this code changed a lot in commit 5e72b2b41a21n(udmabuf: convert udmabuf driver to use folios); but the memory leaknseems to have existed since the introduction of udmabuf.,CVE-2024-56712,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnionic: Fix netdev notifier unregister on failurennIf register_netdev() fails then the driver leaks the netdev notifier.nFix this by calling ionic_lif_unregister() on register_netdev()nfailure. This will also call ionic_lif_unregister_phc() if it hasnalready been registered.,CVE-2024-56715,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet/smc: protect link down work from execute after lgr freednnlink down work may be scheduled before lgr freed but executenafter lgr freed which may result in crash. So it is need tonhold a reference before shedule link down work and put thenreference after work executed or canceled.nnThe relevant crash call stack as follows:n list_del corruption. prev->next should be ffffb638c9c0fe20n but was 0000000000000000n ------------[ cut here ]------------n kernel BUG at lib/list_debug.c:51!n invalid opcode: 0000 [#1] SMP NOPTIn CPU: 6 PID: 978112 Comm: kworker/6:119 Kdump: loaded Tainted: G #1n Hardware name: Alibaba Cloud Alibaba Cloud ECS BIOS 2221b89 04/01/2014n Workqueue: events smc_link_down_work [smc]n RIP: 0010:__list_del_entry_valid.cold+0x31/0x47n RSP: 0018:ffffb638c9c0fdd8 EFLAGS: 00010086n RAX: 0000000000000054 RBX: ffff942fb75e5128 RCX: 0000000000000000n RDX: ffff943520930aa0 RSI: ffff94352091fc80 RDI: ffff94352091fc80n RBP: 0000000000000000 R08: 0000000000000000 R09: ffffb638c9c0fc38n R10: ffffb638c9c0fc30 R11: ffffffffa015eb28 R12: 0000000000000002n R13: ffffb638c9c0fe20 R14: 0000000000000001 R15: ffff942f9cd051c0n FS: 0000000000000000(0000) GS:ffff943520900000(0000) knlGS:0000000000000000n CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033n CR2: 00007f4f25214000 CR3: 000000025fbae004 CR4: 00000000007706e0n DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000n DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400n PKRU: 55555554n Call Trace:n rwsem_down_write_slowpath+0x17e/0x470n smc_link_down_work+0x3c/0x60 [smc]n process_one_work+0x1ac/0x350n worker_thread+0x49/0x2f0n ? rescuer_thread+0x360/0x360n kthread+0x118/0x140n ? __kthread_bind_mask+0x60/0x60n ret_from_fork+0x1f/0x30,CVE-2024-56718,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnRDMA/hns: Fix cpu stuck caused by printings during resetnnDuring reset cmd to destroy resources such as qp cq and mr may failnand error logs will be printed. When a large number of resources arendestroyed there will be lots of printings and it may lead to a cpunstuck.nnDelete some unnecessary printings and replace other printing functionsnin these paths with the ratelimited version.,CVE-2024-56722,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnfbdev: sh7760fb: Fix a possible memory leak in sh7760fb_alloc_mem()nnWhen information such as info->screen_base is not ready callingnsh7760fb_free_mem() does not release memory correctly. Callndma_free_coherent() instead.,CVE-2024-56746,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnBluetooth: btusb: mediatek: add intf release flow when usb disconnectnnMediaTek claim an special usb intr interface for ISO data transmission.nThe interface need to be released before unregistering hci device whennusb disconnect. Removing BT usb dongle without properly releasing theninterface may cause Kernel panic while unregister hci device.,CVE-2024-56757,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Fix handling of plane refcountnn[Why]nThe mechanism to backup and restore plane states doesn't maintainnrefcount which can cause issues if the refcount of the plane changesnin between backup and restore operations such as memory leaks if thenrefcount was supposed to go down or double frees / invalid memorynaccesses if the refcount was supposed to go up.nn[How]nCache and re-apply current refcount when restoring plane states.,CVE-2024-56775,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/sti: avoid potential dereference of error pointersnnThe return value of drm_atomic_get_crtc_state() needs to benchecked. To avoid use of error pointer 'crtc_state' in casenof the failure.,CVE-2024-56776,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/sti: avoid potential dereference of error pointers in sti_gdp_atomic_checknnThe return value of drm_atomic_get_crtc_state() needs to benchecked. To avoid use of error pointer 'crtc_state' in casenof the failure.,CVE-2024-56777,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/sti: avoid potential dereference of error pointers in sti_hqvdp_atomic_checknnThe return value of drm_atomic_get_crtc_state() needs to benchecked. To avoid use of error pointer 'crtc_state' in casenof the failure.,CVE-2024-56778,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnpowerpc/prom_init: Fixup missing powermac #size-cellsnnOn some powermacs `escc` nodes are missing `#size-cells` propertiesnwhich is deprecated and now triggers a warning at boot since commitn045b14ca5c36 (of: WARN on deprecated #address-cells/#size-cellsnhandling).nnFor example:nn Missing '#size-cells' in /pci@f2000000/mac-io@c/escc@13000n WARNING: CPU: 0 PID: 0 at drivers/of/base.c:133 of_bus_n_size_cells+0x98/0x108n Hardware name: PowerMac31 7400 0xc0209 PowerMacn ...n Call Trace:n of_bus_n_size_cells+0x98/0x108 (unreliable)n of_bus_default_count_cells+0x40/0x60n __of_get_address+0xc8/0x21cn __of_address_to_resource+0x5c/0x228n pmz_init_port+0x5c/0x2ecn pmz_probe.isra.0+0x144/0x1e4n pmz_console_init+0x10/0x48n console_init+0xcc/0x138n start_kernel+0x5c4/0x694nnAs powermacs boot via prom_init it's possible to add the missingnproperties to the device tree during boot avoiding the warning. Notenthat `escc-legacy` nodes are also missing `#size-cells` properties butnthey are skipped by the macio driver so leave them alone.nnDepends-on: 045b14ca5c36 (of: WARN on deprecated #address-cells/#size-cells handling),CVE-2024-56781,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnACPI: x86: Add adev NULL check to acpi_quirk_skip_serdev_enumeration()nnacpi_dev_hid_match() does not check for adev == NULL dereferencingnit unconditional.nnAdd a check for adev being NULL before calling acpi_dev_hid_match().nnAt the moment acpi_quirk_skip_serdev_enumeration() is never called withna controller_parent without an ACPI companion but better safe than sorry.,CVE-2024-56782,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnMIPS: Loongson64: DTS: Really fix PCIe port nodes for ls7annFix the dtc warnings:nn arch/mips/boot/dts/loongson/ls7a-pch.dtsi:68.16-416.5: Warning (interrupt_provider): /bus@10000000/pci@1a000000: '#interrupt-cells' found but node is not an interrupt providern arch/mips/boot/dts/loongson/ls7a-pch.dtsi:68.16-416.5: Warning (interrupt_provider): /bus@10000000/pci@1a000000: '#interrupt-cells' found but node is not an interrupt providern arch/mips/boot/dts/loongson/loongson64g_4core_ls7a.dtb: Warning (interrupt_map): Failed prerequisite 'interrupt_provider'nnAnd a runtime warning introduced in commit 045b14ca5c36 (of: WARN onndeprecated #address-cells/#size-cells handling):nn WARNING: CPU: 0 PID: 1 at drivers/of/base.c:106 of_bus_n_addr_cells+0x9c/0xe0n Missing '#address-cells' in /bus@10000000/pci@1a000000/pci_bridge@90nnThe fix is similar to commit d89a415ff8d5 (MIPS: Loongson64: DTS: Fix PCIenport nodes for ls7a) which has fixed the issue for ls2k (despite itsnsubject mentions ls7a).,CVE-2024-56785,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbpf: put bpf_link's program when link is safe to be deallocatednnIn general BPF link's underlying BPF program should be considered to benreachable through attach hook -> link -> prog chain and pessimisticallynwe have to assume that as long as link's memory is not safe to freenattach hook's code might hold a pointer to BPF program and use it.nnAs such it's not (generally) correct to put link's program early beforenwaiting for RCU GPs to go through. More eager bpf_prog_put() that wencurrently do is mostly correct due to BPF program's release code doingnsimilar RCU GP waiting but as will be shown in the following patchesnBPF program can be non-sleepable (and thus reliant on only classicnRCU GP) while BPF link's attach hook can have sleepable semantics andnneeds to be protected by RCU Tasks Trace and for such cases BPF linknhas to go through RCU Tasks Trace + classic RCU GPs before beingndeallocated. And so if we put BPF program early we might free BPFnprogram before we free BPF link leading to use-after-free situation.nnSo this patch defers bpf_prog_put() until we are ready to performnbpf_link's deallocation. At worst this delays BPF program freeing bynone extra RCU GP but that seems completely acceptable. Alternativelynwe'd need more elaborate ways to determine BPF hook BPF link and BPFnprogram lifetimes and how they relate to each other which seems likenan unnecessary complication.nnNote for most BPF links we still will perform eager bpf_prog_put() andnlink dealloc so for those BPF links there are no observable changesnwhatsoever. Only BPF links that use deferred dealloc might noticenslightly delayed freeing of BPF programs.nnAlso to reduce code and logic duplication extract program put + linkndealloc logic into bpf_link_dealloc() helper.,CVE-2024-56786,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnsoc: imx8m: Probe the SoC driver as platform drivernnWith driver_async_probe=* on kernel command line the following trace isnproduced because on i.MX8M Plus hardware because the soc-imx8m.c driverncalls of_clk_get_by_name() which returns -EPROBE_DEFER because the clockndriver is not yet probed. This was not detected during regular testingnwithout driver_async_probe.nnConvert the SoC code to platform driver and instantiate a platform devicenin its current device_initcall() to probe the platform driver. Reworkn.soc_revision callback to always return valid error code and return SoCnrevision via parameter. This way if anything in the .soc_revision callbacknreturn -EPROBE_DEFER it gets propagated to .probe and the .probe will getnretried later.nnn------------[ cut here ]------------nWARNING: CPU: 1 PID: 1 at drivers/soc/imx/soc-imx8m.c:115 imx8mm_soc_revision+0xdc/0x180nCPU: 1 UID: 0 PID: 1 Comm: swapper/0 Not tainted 6.11.0-next-20240924-00002-g2062bb554dea #603nHardware name: DH electronics i.MX8M Plus DHCOM Premium Developer Kit (3) (DT)npstate: 20000005 (nzCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)npc : imx8mm_soc_revision+0xdc/0x180nlr : imx8mm_soc_revision+0xd0/0x180nsp : ffff8000821fbcc0nx29: ffff8000821fbce0 x28: 0000000000000000 x27: ffff800081810120nx26: ffff8000818a9970 x25: 0000000000000006 x24: 0000000000824311nx23: ffff8000817f42c8 x22: ffff0000df8be210 x21: fffffffffffffdfbnx20: ffff800082780000 x19: 0000000000000001 x18: ffffffffffffffffnx17: ffff800081fff418 x16: ffff8000823e1000 x15: ffff0000c03b65e8nx14: ffff0000c00051b0 x13: ffff800082790000 x12: 0000000000000801nx11: ffff80008278ffff x10: ffff80008209d3a6 x9 : ffff80008062e95cnx8 : ffff8000821fb9a0 x7 : 0000000000000000 x6 : 00000000000080e3nx5 : ffff0000df8c03d8 x4 : 0000000000000000 x3 : 0000000000000000nx2 : 0000000000000000 x1 : fffffffffffffdfb x0 : fffffffffffffdfbnCall trace:n imx8mm_soc_revision+0xdc/0x180n imx8_soc_init+0xb0/0x1e0n do_one_initcall+0x94/0x1a8n kernel_init_freeable+0x240/0x2a8n kernel_init+0x28/0x140n ret_from_fork+0x10/0x20n---[ end trace 0000000000000000 ]---nSoC: i.MX8MP revision 1.1n,CVE-2024-56787,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnRDMA/rxe: Remove the direct link to net_devicennThe similar patch in siw is in the link:nhttps://git.kernel.org/rdma/rdma/c/16b87037b48889nnThis problem also occurred in RXE. The following analyze this problem.nIn the following Call Traces:nnBUG: KASAN: slab-use-after-free in dev_get_flags+0x188/0x1d0 net/core/dev.c:8782nRead of size 4 at addr ffff8880554640b0 by task kworker/1:4/5295nnCPU: 1 UID: 0 PID: 5295 Comm: kworker/1:4 Not taintedn6.12.0-rc3-syzkaller-00399-g9197b73fd7bb #0nHardware name: Google Compute Engine/Google Compute EnginenBIOS Google 09/13/2024nWorkqueue: infiniband ib_cache_event_tasknCall Trace:n <TASK>n __dump_stack lib/dump_stack.c:94 [inline]n dump_stack_lvl+0x241/0x360 lib/dump_stack.c:120n print_address_description mm/kasan/report.c:377 [inline]n print_report+0x169/0x550 mm/kasan/report.c:488n kasan_report+0x143/0x180 mm/kasan/report.c:601n dev_get_flags+0x188/0x1d0 net/core/dev.c:8782n rxe_query_port+0x12d/0x260 drivers/infiniband/sw/rxe/rxe_verbs.c:60n __ib_query_port drivers/infiniband/core/device.c:2111 [inline]n ib_query_port+0x168/0x7d0 drivers/infiniband/core/device.c:2143n ib_cache_update+0x1a9/0xb80 drivers/infiniband/core/cache.c:1494n ib_cache_event_task+0xf3/0x1e0 drivers/infiniband/core/cache.c:1568n process_one_work kernel/workqueue.c:3229 [inline]n process_scheduled_works+0xa65/0x1850 kernel/workqueue.c:3310n worker_thread+0x870/0xd30 kernel/workqueue.c:3391n kthread+0x2f2/0x390 kernel/kthread.c:389n ret_from_fork+0x4d/0x80 arch/x86/kernel/process.c:147n ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244n </TASK>nnn1). In the link [1]nnn infiniband syz2: set downnnnThis means that on 839.350575 the event ib_cache_event_task was sent andinqueued in ib_wq.nn2). In the link [1]nnn team0 (unregistering): Port device team_slave_0 removednnnIt indicates that before 843.251853 the net device should be freed.nn3). In the link [1]nnn BUG: KASAN: slab-use-after-free in dev_get_flags+0x188/0x1d0nnnThis means that on 850.559070 this slab-use-after-free problem occurred.nnIn all on 839.350575 the event ib_cache_event_task was sent and queuednin ib_wqnnbefore 843.251853 the net device veth was freed.nnon 850.559070 this event was executed and the mentioned freed net devicenwas called. Thus the above call trace occurred.nn[1] https://syzkaller.appspot.com/x/log.txt?x=12e7025f980000,CVE-2024-57795,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/dp_mst: Ensure mst_primary pointer is valid in drm_dp_mst_handle_up_req()nnWhile receiving an MST up request message from one thread inndrm_dp_mst_handle_up_req() the MST topology could be removed fromnanother thread via drm_dp_mst_topology_mgr_set_mst(false) freeingnmst_primary and setting drm_dp_mst_topology_mgr::mst_primary to NULL.nThis could lead to a NULL deref/use-after-free of mst_primary inndrm_dp_mst_handle_up_req().nnAvoid the above by holding a reference for mst_primary inndrm_dp_mst_handle_up_req() while it's used.nnv2: Fix kfreeing the request if getting an mst_primary reference fails.,CVE-2024-57798,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnPCI: imx6: Fix suspend/resume support on i.MX6QDLnnThe suspend/resume functionality is currently broken on the i.MX6QDLnplatform as documented in the NXP errata (ERR005723):nn https://www.nxp.com/docs/en/errata/IMX6DQCE.pdfnnThis patch addresses the issue by sharing most of the suspend/resumensequences used by other i.MX devices while avoiding modifications toncritical registers that disrupt the PCIe functionality. It targets thensame problem as the following downstream commit:nn https://github.com/nxp-imx/linux-imx/commit/4e92355e1f79d225ea842511fcfd42b343b32995nnUnlike the downstream commit this patch also resets the connected PCIendevice if possible. Without this reset certain drivers such as ath10knor iwlwifi will crash on resume. The device reset is also done by thendriver on other i.MX platforms making this patch consistent withnexisting practices.nnUpon resuming the kernel will hang and display an error. Here's annexample of the error encountered with the ath10k driver:nn ath10k_pci 0000:01:00.0: Unable to change power state from D3hot to D0 device inaccessiblen Unhandled fault: imprecise external abort (0x1406) at 0x0106f944nnWithout this patch suspend/resume will fail on i.MX6QDL devices if anPCIe device is connected.nn[kwilczynski: commit log added tag for stable releases],CVE-2024-57809,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnmedia: vidtv: Fix a null-ptr-deref in vidtv_mux_stop_threadnnsyzbot report a null-ptr-deref in vidtv_mux_stop_thread. [1]nnIf dvb->mux is not initialized successfully by vidtv_mux_init() in thenvidtv_start_streaming() it will trigger null pointer dereference about muxnin vidtv_mux_stop_thread().nnAdjust the timing of streaming initialization and check it beforenstopping it.nn[1]nKASAN: null-ptr-deref in range [0x0000000000000128-0x000000000000012f]nCPU: 0 UID: 0 PID: 5842 Comm: syz-executor248 Not tainted 6.13.0-rc4-syzkaller-00012-g9b2ffa6148b1 #0nHardware name: Google Google Compute Engine/Google Compute Engine BIOS Google 09/13/2024nRIP: 0010:vidtv_mux_stop_thread+0x26/0x80 drivers/media/test-drivers/vidtv/vidtv_mux.c:471nCode: 90 90 90 90 66 0f 1f 00 55 53 48 89 fb e8 82 2e c8 f9 48 8d bb 28 01 00 00 48 b8 00 00 00 00 00 fc ff df 48 89 fa 48 c1 ea 03 <0f> b6 04 02 84 c0 74 02 7e 3b 0f b6 ab 28 01 00 00 31 ff 89 ee e8nRSP: 0018:ffffc90003f2faa8 EFLAGS: 00010202nRAX: dffffc0000000000 RBX: 0000000000000000 RCX: ffffffff87cfb125nRDX: 0000000000000025 RSI: ffffffff87d120ce RDI: 0000000000000128nRBP: ffff888029b8d220 R08: 0000000000000005 R09: 0000000000000000nR10: 0000000000000000 R11: 0000000000000003 R12: ffff888029b8d188nR13: ffffffff8f590aa0 R14: ffffc9000581c5c8 R15: ffff888029a17710nFS: 00007f7eef5156c0(0000) GS:ffff8880b8600000(0000) knlGS:0000000000000000nCS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033nCR2: 00007f7eef5e635c CR3: 0000000076ca6000 CR4: 00000000003526f0nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400nCall Trace:n <TASK>n vidtv_stop_streaming drivers/media/test-drivers/vidtv/vidtv_bridge.c:209 [inline]n vidtv_stop_feed+0x151/0x250 drivers/media/test-drivers/vidtv/vidtv_bridge.c:252n dmx_section_feed_stop_filtering+0x90/0x160 drivers/media/dvb-core/dvb_demux.c:1000n dvb_dmxdev_feed_stop.isra.0+0x1ee/0x270 drivers/media/dvb-core/dmxdev.c:486n dvb_dmxdev_filter_stop+0x22a/0x3a0 drivers/media/dvb-core/dmxdev.c:559n dvb_dmxdev_filter_free drivers/media/dvb-core/dmxdev.c:840 [inline]n dvb_demux_release+0x92/0x550 drivers/media/dvb-core/dmxdev.c:1246n __fput+0x3f8/0xb60 fs/file_table.c:450n task_work_run+0x14e/0x250 kernel/task_work.c:239n get_signal+0x1d3/0x2610 kernel/signal.c:2790n arch_do_signal_or_restart+0x90/0x7e0 arch/x86/kernel/signal.c:337n exit_to_user_mode_loop kernel/entry/common.c:111 [inline]n exit_to_user_mode_prepare include/linux/entry-common.h:329 [inline]n __syscall_exit_to_user_mode_work kernel/entry/common.c:207 [inline]n syscall_exit_to_user_mode+0x150/0x2a0 kernel/entry/common.c:218n do_syscall_64+0xda/0x250 arch/x86/entry/common.c:89n entry_SYSCALL_64_after_hwframe+0x77/0x7f,CVE-2024-57834,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nns390/entry: Mark IRQ entries to fix stack depot warningsnnThe stack depot filters out everything outside of the top interruptncontext as an uninteresting or irrelevant part of the stack traces. Thisnhelps with stack trace de-duplication avoiding an explosion of savednstack traces that share the same IRQ context code path but originatenfrom different randomly interrupted points eventually exhausting thenstack depot.nnFiltering uses in_irqentry_text() to identify functions within then.irqentry.text and .softirqentry.text sections which then become thenlast stack trace entries being saved.nnWhile __do_softirq() is placed into the .softirqentry.text section byncommon code populating .irqentry.text is architecture-specific.nnCurrently the .irqentry.text section on s390 is empty which preventsnstack depot filtering and de-duplication and could result in warningsnlike:nnStack depot reached limit capacitynWARNING: CPU: 0 PID: 286113 at lib/stackdepot.c:252 depot_alloc_stack+0x39a/0x3c8nnwith PREEMPT and KASAN enabled.nnFix this by moving the IO/EXT interrupt handlers from .kprobes.text intonthe .irqentry.text section and updating the kprobes blacklist to includenthe .irqentry.text section.nnThis is done only for asynchronous interrupts and explicitly not fornprogram checks which are synchronous and where the context beyond thenprogram check is important to preserve. Despite machine checks beingnsomewhat in between they are extremely rare and preserving contextnwhen possible is also of value.nnSVCs and Restart Interrupts are not relevant one being always at thenboundary to user space and the other being a one-time thing.nnIRQ entries filtering is also optionally used in ftrace function graphnwhere the same logic applies.,CVE-2024-57838,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnvirtio-net: fix overflow inside virtnet_rq_allocnnWhen the frag just got a page then may lead to regression on VM.nSpecially if the sysctl net.core.high_order_alloc_disable value is 1nthen the frag always get a page when do refill.nnWhich could see reliable crashes or scp failure (scp a file 100M in sizento VM).nnThe issue is that the virtnet_rq_dma takes up 16 bytes at the beginningnof a new frag. When the frag size is larger than PAGE_SIZEneverything is fine. However if the frag is only one page and thentotal size of the buffer and virtnet_rq_dma is larger than one page annoverflow may occur.nnThe commit f9dac92ba908 (virtio_ring: enable premapped mode whatevernuse_dma_api) introduced this problem. And we reverted some commits tonfix this in last linux version. Now we try to enable it and fix thisnbug directly.nnHere when the frag size is not enough we reduce the buffer len to fixnthis problem.,CVE-2024-57843,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nns390/cpum_sf: Handle CPU hotplug remove during samplingnnCPU hotplug remove handling triggers the following functionncall sequence:nn CPUHP_AP_PERF_S390_SF_ONLINE --> s390_pmu_sf_offline_cpu()n ...n CPUHP_AP_PERF_ONLINE --> perf_event_exit_cpu()nnThe s390 CPUMF sampling CPU hotplug handler invokes:nn s390_pmu_sf_offline_cpu()n +--> cpusf_pmu_setup()n +--> setup_pmc_cpu()n +--> deallocate_buffers()nnThis function de-allocates all sampling data buffers (SDBs) allocatednfor that CPU at event initialization. It also clears thenPMU_F_RESERVED bit. The CPU is gone and can not be sampled.nnWith the event still being active on the removed CPU the CPU eventnhotplug support in kernel performance subsystem triggers thenfollowing function calls on the removed CPU:nn perf_event_exit_cpu()n +--> perf_event_exit_cpu_context()n +--> __perf_event_exit_context()nt +--> __perf_remove_from_context()nt +--> event_sched_out()nt +--> cpumsf_pmu_del()nt +--> cpumsf_pmu_stop()n +--> hw_perf_event_update()nnto stop and remove the event. During removal of the event thensampling device driver tries to read out the remaining samples fromnthe sample data buffers (SDBs). But they have already been freedn(and may have been re-assigned). This may lead to a use after freensituation in which case the samples are most likely invalid. In thenbest case the memory has not been reassigned and still containsnvalid data.nnRemedy this situation and check if the CPU is still in reservednstate (bit PMU_F_RESERVED set). In this case the SDBs have not beennreleased an contain valid data. This is always the case whennthe event is removed (and no CPU hotplug off occured).nIf the PMU_F_RESERVED bit is not set the SDB buffers are gone.,CVE-2024-57849,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnfirmware: qcom: scm: smc: Handle missing SCM devicennCommit ca61d6836e6f (firmware: qcom: scm: fix a NULL-pointerndereference) makes it explicit that qcom_scm_get_tzmem_pool() cannreturn NULL therefore its users should handle this.,CVE-2024-57852,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnRDMA/siw: Remove direct link to net_devicennDo not manage a per device direct link to net_device. Relynon associated ib_devices net_device management not doublingnthe effort locally. A badly managed local link to net_devicenwas causing a 'KASAN: slab-use-after-free' exception duringnsiw_query_port() call.,CVE-2024-57857,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnscsi: ufs: pltfrm: Dellocate HBA during ufshcd_pltfrm_remove()nnThis will ensure that the scsi host is cleaned up properly usingnscsi_host_dev_release(). Otherwise it may lead to memory leaks.,CVE-2024-57872,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnblock: RCU protect disk->conv_zones_bitmapnnEnsure that a disk revalidation changing the conventional zones bitmapnof a disk does not cause invalid memory references when using thendisk_zone_is_conv() helper by RCU protecting the disk->conv_zones_bitmapnpointer.nndisk_zone_is_conv() is modified to operate under the RCU read lock andnthe function disk_set_conv_zones_bitmap() is added to update a disknconv_zones_bitmap pointer using rcu_replace_pointer() with the disknzone_wplugs_lock spinlock held.nndisk_free_zone_resources() is modified to callndisk_update_zone_resources() with a NULL bitmap pointer to free the disknconv_zones_bitmap. disk_set_conv_zones_bitmap() is also used inndisk_update_zone_resources() to set the new (revalidated) bitmap andnfree the old one.,CVE-2024-57875,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/dp_mst: Fix resetting msg rx state after topology removalnnIf the MST topology is removed during the reception of an MST down replynor MST up request sideband message thendrm_dp_mst_topology_mgr::up_req_recv/down_rep_recv states could be resetnfrom one thread via drm_dp_mst_topology_mgr_set_mst(false) racing withnthe reading/parsing of the message from another thread viandrm_dp_mst_handle_down_rep() or drm_dp_mst_handle_up_req(). The race isnpossible since the reader/parser doesn't hold any lock while accessingnthe reception state. This in turn can lead to a memory corruption in thenreader/parser as described by commit bd2fccac61b4 (drm/dp_mst: Fix MSTnsideband message body length check).nnFix the above by resetting the message reception state if needed beforenreading/parsing a message. Another solution would be to hold thendrm_dp_mst_topology_mgr::lock for the whole duration of the messagenreception/parsing in drm_dp_mst_handle_down_rep() andndrm_dp_mst_handle_up_req() however this would require a bigger change.nSince the fix is also needed for stable opting for the simpler solutionnin this patch.,CVE-2024-57876,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnmm: hugetlb: independent PMD page table shared countnnThe folio refcount may be increased unexpectly through try_get_folio() byncaller such as split_huge_pages. In huge_pmd_unshare() we use refcountnto check whether a pmd page table is shared. The check is incorrect ifnthe refcount is increased by the above caller and this can cause the pagentable leaked:nn BUG: Bad page state in process sh pfn:109324n page: refcount:0 mapcount:0 mapping:0000000000000000 index:0x66 pfn:0x109324n flags: 0x17ffff800000000(node=0|zone=2|lastcpupid=0xfffff)n page_type: f2(table)n raw: 017ffff800000000 0000000000000000 0000000000000000 0000000000000000n raw: 0000000000000066 0000000000000000 00000000f2000000 0000000000000000n page dumped because: nonzero mapcountn ...n CPU: 31 UID: 0 PID: 7515 Comm: sh Kdump: loaded Tainted: G B 6.13.0-rc2master+ #7n Tainted: [B]=BAD_PAGEn Hardware name: QEMU KVM Virtual Machine BIOS 0.0.0 02/06/2015n Call trace:n show_stack+0x20/0x38 (C)n dump_stack_lvl+0x80/0xf8n dump_stack+0x18/0x28n bad_page+0x8c/0x130n free_page_is_bad_report+0xa4/0xb0n free_unref_page+0x3cc/0x620n __folio_put+0xf4/0x158n split_huge_pages_all+0x1e0/0x3e8n split_huge_pages_write+0x25c/0x2d8n full_proxy_write+0x64/0xd8n vfs_write+0xcc/0x280n ksys_write+0x70/0x110n __arm64_sys_write+0x24/0x38n invoke_syscall+0x50/0x120n el0_svc_common.constprop.0+0xc8/0xf0n do_el0_svc+0x24/0x38n el0_svc+0x34/0x128n el0t_64_sync_handler+0xc8/0xd0n el0t_64_sync+0x190/0x198nnThe issue may be triggered by damon offline_page page_idle etc whichnwill increase the refcount of page table.nn1. The page table itself will be discarded after reporting then nonzero mapcount.nn2. The HugeTLB page mapped by the page table miss freeing since wen treat the page table as shared and a shared page table will not ben unmapped.nnFix it by introducing independent PMD page table shared count. Asndescribed by comment pt_index/pt_mm/pt_frag_refcount are used for s390ngmap x86 pgds and powerpc pt_share_count is used for x86/arm64/riscvnpmds so we can reuse the field as pt_share_count.,CVE-2024-57883,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnworkqueue: Do not warn when cancelling WQ_MEM_RECLAIM work from !WQ_MEM_RECLAIM workernnAfter commitn746ae46c1113 (drm/sched: Mark scheduler work queues with WQ_MEM_RECLAIM)namdgpu started seeing the following warning:nn [ ] workqueue: WQ_MEM_RECLAIM sdma0:drm_sched_run_job_work [gpu_sched] is flushing !WQ_MEM_RECLAIM events:amdgpu_device_delay_enable_gfx_off [amdgpu]n...n [ ] Workqueue: sdma0 drm_sched_run_job_work [gpu_sched]n...n [ ] Call Trace:n [ ] <TASK>n...n [ ] ? check_flush_dependency+0xf5/0x110n...n [ ] cancel_delayed_work_sync+0x6e/0x80n [ ] amdgpu_gfx_off_ctrl+0xab/0x140 [amdgpu]n [ ] amdgpu_ring_alloc+0x40/0x50 [amdgpu]n [ ] amdgpu_ib_schedule+0xf4/0x810 [amdgpu]n [ ] ? drm_sched_run_job_work+0x22c/0x430 [gpu_sched]n [ ] amdgpu_job_run+0xaa/0x1f0 [amdgpu]n [ ] drm_sched_run_job_work+0x257/0x430 [gpu_sched]n [ ] process_one_work+0x217/0x720n...n [ ] </TASK>nnThe intent of the verifcation done in check_flush_depedency is to ensurenforward progress during memory reclaim by flagging cases when either anmemory reclaim process or a memory reclaim work item is flushed from ancontext not marked as memory reclaim safe.nnThis is correct when flushing but when called from thencancel(_delayed)_work_sync() paths it is a false positive because work isneither already running or will not be running at all. Thereforencancelling it is safe and we can relax the warning criteria by letting thenhelper know of the calling context.nnReferences: 746ae46c1113 (drm/sched: Mark scheduler work queues with WQ_MEM_RECLAIM),CVE-2024-57888,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnALSA: seq: oss: Fix races at processing SysEx messagesnnOSS sequencer handles the SysEx messages split in 6 bytes packets andnALSA sequencer OSS layer tries to combine those. It stores the datanin the internal buffer and this access is racy as of now which maynlead to the out-of-bounds access.nnAs a temporary band-aid fix introduce a mutex for serializing thenprocess of the SysEx message packets.,CVE-2024-57893,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amdkfd: Correct the migration DMA map directionnnThe SVM DMA device map direction should be set the same asnthe DMA unmap setting otherwise the DMA core will reportnthe following warning.nnBefore finialize this solution there're some discussion onnthe DMA mapping type(stream-based or coherent) in this KFDnmigration case followed by https://lore.kernel.org/all/04d4ab32n-45a1-4b88-86ee-fb0f35a0ca40@amd.com/T/.nnAs there's no dma_sync_single_for_*() in the DMA buffer accessednthat because this migration operation should be sync properly andnautomatically. Give that there's might not be a performance problemnin various cache sync policy of DMA sync. Therefore in order tonsimplify the DMA direction setting alignment let's set the DMA mapndirection as BIDIRECTIONAL.nn[ 150.834218] WARNING: CPU: 8 PID: 1812 at kernel/dma/debug.c:1028 check_unmap+0x1cc/0x930n[ 150.834225] Modules linked in: amdgpu(OE) amdxcp drm_exec(OE) gpu_sched drm_buddy(OE) drm_ttm_helper(OE) ttm(OE) drm_suballoc_helper(OE) drm_display_helper(OE) drm_kms_helper(OE) i2c_algo_bit rpcsec_gss_krb5 auth_rpcgss nfsv4 nfs lockd grace netfs xt_conntrack xt_MASQUERADE nf_conntrack_netlink xfrm_user xfrm_algo iptable_nat xt_addrtype iptable_filter br_netfilter nvme_fabrics overlay nfnetlink_cttimeout nfnetlink openvswitch nsh nf_conncount nf_nat nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 libcrc32c bridge stp llc sch_fq_codel intel_rapl_msr amd_atl intel_rapl_common snd_hda_codec_realtek snd_hda_codec_generic snd_hda_scodec_component snd_hda_codec_hdmi snd_hda_intel snd_intel_dspcfg edac_mce_amd snd_pci_acp6x snd_hda_codec snd_acp_config snd_hda_core snd_hwdep snd_soc_acpi kvm_amd sunrpc snd_pcm kvm binfmt_misc snd_seq_midi crct10dif_pclmul snd_seq_midi_event ghash_clmulni_intel sha512_ssse3 snd_rawmidi nls_iso8859_1 sha256_ssse3 sha1_ssse3 snd_seq aesni_intel snd_seq_device crypto_simd snd_timer cryptd input_ledsn[ 150.834310] wmi_bmof serio_raw k10temp rapl snd sp5100_tco ipmi_devintf soundcore ccp ipmi_msghandler cm32181 industrialio mac_hid msr parport_pc ppdev lp parport efi_pstore drm(OE) ip_tables x_tables pci_stub crc32_pclmul nvme ahci libahci i2c_piix4 r8169 nvme_core i2c_designware_pci realtek i2c_ccgx_ucsi video wmi hid_generic cdc_ether usbnet usbhid hid r8152 miin[ 150.834354] CPU: 8 PID: 1812 Comm: rocrtst64 Tainted: G OE 6.10.0-custom #492n[ 150.834358] Hardware name: AMD Majolica-RN/Majolica-RN BIOS RMJ1009A 06/13/2021n[ 150.834360] RIP: 0010:check_unmap+0x1cc/0x930n[ 150.834363] Code: c0 4c 89 4d c8 e8 34 bf 86 00 4c 8b 4d c8 4c 8b 45 c0 48 8b 4d b8 48 89 c6 41 57 4c 89 ea 48 c7 c7 80 49 b4 84 e8 b4 81 f3 ff <0f> 0b 48 c7 c7 04 83 ac 84 e8 76 ba fc ff 41 8b 76 4c 49 8d 7e 50n[ 150.834365] RSP: 0018:ffffaac5023739e0 EFLAGS: 00010086n[ 150.834368] RAX: 0000000000000000 RBX: ffffffff8566a2e0 RCX: 0000000000000027n[ 150.834370] RDX: ffff8f6a8f621688 RSI: 0000000000000001 RDI: ffff8f6a8f621680n[ 150.834372] RBP: ffffaac502373a30 R08: 00000000000000c9 R09: ffffaac502373850n[ 150.834373] R10: ffffaac502373848 R11: ffffffff84f46328 R12: ffffaac502373a40n[ 150.834375] R13: ffff8f6741045330 R14: ffff8f6741a77700 R15: ffffffff84ac831bn[ 150.834377] FS: 00007faf0fc94c00(0000) GS:ffff8f6a8f600000(0000) knlGS:0000000000000000n[ 150.834379] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033n[ 150.834381] CR2: 00007faf0b600020 CR3: 000000010a52e000 CR4: 0000000000350ef0n[ 150.834383] Call Trace:n[ 150.834385] <TASK>n[ 150.834387] ? show_regs+0x6d/0x80n[ 150.834393] ? __warn+0x8c/0x140n[ 150.834397] ? check_unmap+0x1cc/0x930n[ 150.834400] ? report_bug+0x193/0x1a0n[ 150.834406] ? handle_bug+0x46/0x80n[ 150.834410] ? exc_invalid_op+0x1d/0x80n[ 150.834413] ? asm_exc_invalid_op+0x1f/0x30n[ 150.834420] ? check_unmap+0x1cc/0x930n[ 150.834425] debug_dma_unmap_page+0x86/0x90n[ 150.834431] ? srso_return_thunk+0x5/0x5fn[ 150.834435] n---truncated---,CVE-2024-57897,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnwifi: cfg80211: clear link ID from bitmap during link delete after clean upnnCurrently during link deletion the link ID is first removed from thenvalid_links bitmap before performing any clean-up operations. However somenfunctions require the link ID to remain in the valid_links bitmap. Onensuch example is cfg80211_cac_event(). The flow is -nnnl80211_remove_link()n cfg80211_remove_link()n ieee80211_del_intf_link()n ieee80211_vif_set_links()n ieee80211_vif_update_links()n ieee80211_link_stop()n cfg80211_cac_event()nncfg80211_cac_event() requires link ID to be present but it is clearednalready in cfg80211_remove_link(). Ultimately WARN_ON() is hit.nnTherefore clear the link ID from the bitmap only after completing the linknclean-up.,CVE-2024-57898,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnwifi: mac80211: fix mbss changed flags corruption on 32 bit systemsnnOn 32-bit systems the size of an unsigned long is 4 bytesnwhile a u64 is 8 bytes. Therefore when usingnor_each_set_bit(bit &bits sizeof(changed) output.log scan_tyk_dockerimages.sh vulnerabilities.csv BITS_PER_BYTE)nthe code is incorrectly searching for a bit in a 32-bitnvariable that is expected to be 64 bits in sizenleading to incorrect bit finding.nnSolution: Ensure that the size of the bits variable is correctlynadjusted for each architecture.nn Call Trace:n ? show_regs+0x54/0x58n ? __warn+0x6b/0xd4n ? ieee80211_link_info_change_notify+0xcc/0xd4 [mac80211]n ? report_bug+0x113/0x150n ? exc_overflow+0x30/0x30n ? handle_bug+0x27/0x44n ? exc_invalid_op+0x18/0x50n ? handle_exception+0xf6/0xf6n ? exc_overflow+0x30/0x30n ? ieee80211_link_info_change_notify+0xcc/0xd4 [mac80211]n ? exc_overflow+0x30/0x30n ? ieee80211_link_info_change_notify+0xcc/0xd4 [mac80211]n ? ieee80211_mesh_work+0xff/0x260 [mac80211]n ? cfg80211_wiphy_work+0x72/0x98 [cfg80211]n ? process_one_work+0xf1/0x1fcn ? worker_thread+0x2c0/0x3b4n ? kthread+0xc7/0xf0n ? mod_delayed_work_on+0x4c/0x4cn ? kthread_complete_and_exit+0x14/0x14n ? ret_from_fork+0x24/0x38n ? kthread_complete_and_exit+0x14/0x14n ? ret_from_fork_asm+0xf/0x14n ? entry_INT80_32+0xf0/0xf0nn[restore no-op path for no changes],CVE-2024-57899,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet: restrict SO_REUSEPORT to inet socketsnnAfter blamed commit crypto sockets could accidentally be destroyednfrom RCU call back as spotted by zyzbot [1].nnTrying to acquire a mutex in RCU callback is not allowed.nnRestrict SO_REUSEPORT socket option to inet sockets.nnv1 of this patch supported TCP UDP and SCTP socketsnbut fcnal-test.sh test needed RAW and ICMP support.nn[1]nBUG: sleeping function called from invalid context at kernel/locking/mutex.c:562nin_atomic(): 1 irqs_disabled(): 0 non_block: 0 pid: 24 name: ksoftirqd/1npreempt_count: 100 expected: 0nRCU nest depth: 0 expected: 0n1 lock held by ksoftirqd/1/24:n #0: ffffffff8e937ba0 (rcu_callback){....}-{0:0} at: rcu_lock_acquire include/linux/rcupdate.h:337 [inline]n #0: ffffffff8e937ba0 (rcu_callback){....}-{0:0} at: rcu_do_batch kernel/rcu/tree.c:2561 [inline]n #0: ffffffff8e937ba0 (rcu_callback){....}-{0:0} at: rcu_core+0xa37/0x17a0 kernel/rcu/tree.c:2823nPreemption disabled at:n [<ffffffff8161c8c8>] softirq_handle_begin kernel/softirq.c:402 [inline]n [<ffffffff8161c8c8>] handle_softirqs+0x128/0x9b0 kernel/softirq.c:537nCPU: 1 UID: 0 PID: 24 Comm: ksoftirqd/1 Not tainted 6.13.0-rc3-syzkaller-00174-ga024e377efed #0nHardware name: Google Google Compute Engine/Google Compute Engine BIOS Google 09/13/2024nCall Trace:n <TASK>n __dump_stack lib/dump_stack.c:94 [inline]n dump_stack_lvl+0x241/0x360 lib/dump_stack.c:120n __might_resched+0x5d4/0x780 kernel/sched/core.c:8758n __mutex_lock_common kernel/locking/mutex.c:562 [inline]n __mutex_lock+0x131/0xee0 kernel/locking/mutex.c:735n crypto_put_default_null_skcipher+0x18/0x70 crypto/crypto_null.c:179n aead_release+0x3d/0x50 crypto/algif_aead.c:489n alg_do_release crypto/af_alg.c:118 [inline]n alg_sock_destruct+0x86/0xc0 crypto/af_alg.c:502n __sk_destruct+0x58/0x5f0 net/core/sock.c:2260n rcu_do_batch kernel/rcu/tree.c:2567 [inline]n rcu_core+0xaaa/0x17a0 kernel/rcu/tree.c:2823n handle_softirqs+0x2d4/0x9b0 kernel/softirq.c:561n run_ksoftirqd+0xca/0x130 kernel/softirq.c:950n smpboot_thread_fn+0x544/0xa30 kernel/smpboot.c:164n kthread+0x2f0/0x390 kernel/kthread.c:389n ret_from_fork+0x4b/0x80 arch/x86/kernel/process.c:147n ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244n </TASK>,CVE-2024-57903,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnfs: relax assertions on failure to encode file handlesnnEncoding file handles is usually performed by a filesystem >encode_fh()nmethod that may fail for various reasons.nnThe legacy users of exportfs_encode_fh() namely nfsd andnname_to_handle_at(2) syscall are ready to cope with the possibilitynof failure to encode a file handle.nnThere are a few other users of exportfs_encode_{fhfid}() thatncurrently have a WARN_ON() assertion when ->encode_fh() fails.nRelax those assertions because they are wrong.nnThe second linked bug report states commit 16aac5ad1fa9 (ovl: supportnencoding non-decodable file handles) in v6.6 as the regressing commitnbut this is not accurate.nnThe aforementioned commit only increases the chances of the assertionnand allows triggering the assertion with the reproducer using overlayfsninotify and drop_caches.nnTriggering this assertion was always possible with other filesystems andnother reasons of ->encode_fh() failures and more particularly it wasnalso possible with the exact same reproducer using overlayfs that isnmounted with options index=onnfs_export=on also on kernels < v6.6.nTherefore I am not listing the aforementioned commit as a Fixes commit.nnBackport hint: this patch will have a trivial conflict applying tonv6.6.y and other trivial conflicts applying to stable kernels < v6.6.,CVE-2024-57924,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnriscv: Fix sleeping in invalid context in die()nndie() can be called in exception handler and therefore cannot sleep.nHowever die() takes spinlock_t which can sleep with PREEMPT_RT enabled.nThat causes the following warning:nnBUG: sleeping function called from invalid context at kernel/locking/spinlock_rt.c:48nin_atomic(): 1 irqs_disabled(): 1 non_block: 0 pid: 285 name: mutexnpreempt_count: 110001 expected: 0nRCU nest depth: 0 expected: 0nCPU: 0 UID: 0 PID: 285 Comm: mutex Not tainted 6.12.0-rc7-00022-ge19049cf7d56-dirty #234nHardware name: riscv-virtioqemu (DT)nCall Trace:n dump_backtrace+0x1c/0x24n show_stack+0x2c/0x38n dump_stack_lvl+0x5a/0x72n dump_stack+0x14/0x1cn __might_resched+0x130/0x13an rt_spin_lock+0x2a/0x5cn die+0x24/0x112n do_trap_insn_illegal+0xa0/0xean _new_vmalloc_restore_context_a0+0xcc/0xd8nOops - illegal instruction [#1]nnSwitch to use raw_spinlock_t which does not sleep even with PREEMPT_RTnenabled.,CVE-2024-57939,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnriscv: mm: Fix the out of bound issue of vmemmap addressnnIn sparse vmemmap model the virtual address of vmemmap is calculated as:n((struct page *)VMEMMAP_START - (phys_ram_base >> PAGE_SHIFT)).nAnd the struct page's va can be calculated with an offset:n(vmemmap + (pfn)).nnHowever when initializing struct pages kernel actually starts from thenfirst page from the same section that phys_ram_base belongs to. If thenfirst page's physical address is not (phys_ram_base >> PAGE_SHIFT) thennwe get an va below VMEMMAP_START when calculating va for it's struct page.nnFor example if phys_ram_base starts from 0x82000000 with pfn 0x82000 thenfirst page in the same section is actually pfn 0x80000. Duringninit_unavailable_range() we will initialize struct page for pfn 0x80000nwith virtual address ((struct page *)VMEMMAP_START - 0x2000) which isnbelow VMEMMAP_START as well as PCI_IO_END.nnThis commit fixes this bug by introducing a new variablen'vmemmap_start_pfn' which is aligned with memory section size and usingnit to calculate vmemmap address instead of phys_ram_base.,CVE-2024-57945,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnetfilter: nf_set_pipapo: fix initial map fillnnThe initial buffer has to be inited to all-ones but it must restrictnit to the size of the first field not the total field size.nnAfter each round in the map search step the result and the fill mapnare swapped so if we have a set where f->bsize of the first elementnis smaller than m->bsize_max those one-bits are leaked into futurenrounds result map.nnThis makes pipapo find an incorrect matching results for sets wherenfirst field size is not the largest.nnFollowup patch adds a test case to nft_concat_range.sh selftest script.nnThanks to Stefano Brivio for pointing out that we need to zero outnthe remainder explicitly only correcting memset() argument isn't enough.,CVE-2024-57947,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Initialize denominator defaults to 1nn[WHAT & HOW]nVariables used as denominators and maybe not assigned to other valuesnshould be initialized to non-zero to avoid DIVIDE_BY_ZERO as reportednby Coverity.nn(cherry picked from commit e2c4c6c10542ccfe4a0830bb6c9fd5b177b7bbb7),CVE-2024-57950,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnRevert libfs: fix infinite directory reads for offset dirnnThe current directory offset allocator (based on mtree_alloc_cyclic)nstores the next offset value to return in octx->next_offset. Thisnmechanism typically returns values that increase monotonically overntime. Eventually though the newly allocated offset value wrapsnback to a low number (say 2) which is smaller than other already-nallocated offset values.nnYu Kuai <yukuai3@huawei.com> reports that after commit 64a7ce76fb90n(libfs: fix infinite directory reads for offset dir) if andirectory's offset allocator wraps existing entries are no longernvisible via readdir/getdents because offset_readdir() stops listingnentries once an entry's offset is larger than octx->next_offset.nThese entries vanish persistently -- they can be looked up but willnnever again appear in readdir(3) output.nnThe reason for this is that the commit treats directory offsets asnmonotonically increasing integer values rather than opaque cookiesnand introduces this comparison:nntif (dentry2offset(dentry) >= last_index) {nnOn 64-bit platforms the directory offset value upper bound isn2^63 - 1. Directory offsets will monotonically increase for millionsnof years without wrapping.nnOn 32-bit platforms however LONG_MAX is 2^31 - 1. The allocatorncan wrap after only a few weeks (at worst).nnRevert commit 64a7ce76fb90 (libfs: fix infinite directory reads fornoffset dir) to prepare for a fix that can work properly on 32-bitnsystems and might apply to recent LTS kernels where shmem employsnthe simple_offset mechanism.,CVE-2024-57952,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnrdma/cxgb4: Prevent potential integer overflow on 32bitnnThe gl->tot_len variable is controlled by the user. It comes fromnprocess_responses(). On 32bit systems the gl->tot_len + sizeof(structncpl_pass_accept_req) + sizeof(struct rss_header) addition could have anninteger wrapping bug. Use size_add() to prevent this.,CVE-2024-57973,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnudp: Deal with race between UDP socket address change and rehashnnIf a UDP socket changes its local address while it's receivingndatagrams as a result of connect() there is a period during whichna lookup operation might fail to find it after the address is changednbut before the secondary hash (port and address) and the four-tuplenhash (local and remote ports and addresses) are updated.nnSecondary hash chains were introduced by commit 30fff9231fad (udp:nbind() optimisation) and as a result a rehash operation becamenneeded to make a bound socket reachable again after a connect().nnThis operation was introduced by commit 719f835853a9 (udp: addnrehash on connect()) which isn't however a complete fix: thensocket will be found once the rehashing completes but not whilenit's pending.nnThis is noticeable with a socat(1) server in UDP4-LISTEN mode and anclient sending datagrams to it. After the server receives the firstndatagram (cf. _xioopen_ipdgram_listen()) it issues a connect() tonthe address of the sender in order to set up a directed flow.nnNow if the client running on a different CPU thread happens tonsend a (subsequent) datagram while the server's socket changes itsnaddress but is not rehashed yet this will result in a failednlookup and a port unreachable error delivered to the client asnapparent from the following reproducer:nn LEN=$(($(cat /proc/sys/net/core/wmem_default) / 4))n dd if=/dev/urandom bs=1 count=${LEN} of=tmp.innn while :; don ttaskset -c 1 socat UDP4-LISTEN:1337null-eof OPEN:tmp.outcreatetrunc &n tsleep 0.1 || sleep 1n ttaskset -c 2 socat OPEN:tmp.in UDP4:localhost:1337shut-nulln twaitn donennwhere the client will eventually get ECONNREFUSED on a write()n(typically the second or third one of a given iteration):nn 2024/11/13 21:28:23 socat[46901] E write(6 0x556db2e3c000 8192): Connection refusednnThis issue was first observed as a seldom failure in Podman's testsnchecking UDP functionality while using pasta(1) to connect thencontainer's network namespace which leads us to a reproducer withnthe lookup error resulting in an ICMP packet on a tap device:nn LOCAL_ADDR=$(ip -j -4 addr show|jq -rM '.[] | .addr_info[0] | select(.scope == global).local')nn while :; don t./pasta --config-net -p pasta.pcap -u 1337 socat UDP4-LISTEN:1337null-eof OPEN:tmp.outcreatetrunc &n tsleep 0.2 || sleep 1n tsocat OPEN:tmp.in UDP4:${LOCAL_ADDR}:1337shut-nulln twaitn tcmp tmp.in tmp.outn donennOnce this fails:nn tmp.in tmp.out differ: char 8193 line 29nnwe can finally have a look at what's going on:nn $ tshark -r pasta.pcapn 1 0.000000 :: ? ff02::16 ICMPv6 110 Multicast Listener Report Message v2n 2 0.168690 88.198.0.161 ? 88.198.0.164 UDP 8234 60260 ? 1337 Len=8192n 3 0.168767 88.198.0.161 ? 88.198.0.164 UDP 8234 60260 ? 1337 Len=8192n 4 0.168806 88.198.0.161 ? 88.198.0.164 UDP 8234 60260 ? 1337 Len=8192n 5 0.168827 c6:47:05:8d:dc:04 ? Broadcast ARP 42 Who has 88.198.0.161? Tell 88.198.0.164n 6 0.168851 9a:55:9a:55:9a:55 ? c6:47:05:8d:dc:04 ARP 42 88.198.0.161 is at 9a:55:9a:55:9a:55n 7 0.168875 88.198.0.161 ? 88.198.0.164 UDP 8234 60260 ? 1337 Len=8192n 8 0.168896 88.198.0.164 ? 88.198.0.161 ICMP 590 Destination unreachable (Port unreachable)n 9 0.168926 88.198.0.161 ? 88.198.0.164 UDP 8234 60260 ? 1337 Len=8192n 10 0.168959 88.198.0.161 ? 88.198.0.164 UDP 8234 60260 ? 1337 Len=8192n 11 0.168989 88.198.0.161 ? 88.198.0.164 UDP 4138 60260 ? 1337 Len=4096n 12 0.169010 88.198.0.161 ? 88.198.0.164 UDP 42 60260 ? 1337 Len=0nnOn the third datagram received the network namespace of the containerninitiates an ARP lookup to deliver the ICMP message.nnIn another variant of this reproducer starting the client with:nn strace -f pasta --config-net -u 1337 socat UDP4-LISTEN:1337null-eof OPEN:tmp.outcreatetrun---truncated---,CVE-2024-57974,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbtrfs: do proper folio cleanup when run_delalloc_nocow() failednn[BUG]nWith CONFIG_DEBUG_VM set test case generic/476 has some chance to crashnwith the following VM_BUG_ON_FOLIO():nn BTRFS error (device dm-3): cow_file_range failed start 1146880 end 1253375 len 106496 ret -28n BTRFS error (device dm-3): run_delalloc_nocow failed start 1146880 end 1253375 len 106496 ret -28n page: refcount:4 mapcount:0 mapping:00000000592787cc index:0x12 pfn:0x10664n aops:btrfs_aops [btrfs] ino:101 dentry name(?):f1774n flags: 0x2fffff80004028(uptodate|lru|private|node=0|zone=2|lastcpupid=0xfffff)n page dumped because: VM_BUG_ON_FOLIO(!folio_test_locked(folio))n ------------[ cut here ]------------n kernel BUG at mm/page-writeback.c:2992!n Internal error: Oops - BUG: 00000000f2000800 [#1] SMPn CPU: 2 UID: 0 PID: 3943513 Comm: kworker/u24:15 Tainted: G OE 6.12.0-rc7-custom+ #87n Tainted: [O]=OOT_MODULE [E]=UNSIGNED_MODULEn Hardware name: QEMU KVM Virtual Machine BIOS unknown 2/2/2022n Workqueue: events_unbound btrfs_async_reclaim_data_space [btrfs]n pc : folio_clear_dirty_for_io+0x128/0x258n lr : folio_clear_dirty_for_io+0x128/0x258n Call trace:n folio_clear_dirty_for_io+0x128/0x258n btrfs_folio_clamp_clear_dirty+0x80/0xd0 [btrfs]n __process_folios_contig+0x154/0x268 [btrfs]n extent_clear_unlock_delalloc+0x5c/0x80 [btrfs]n run_delalloc_nocow+0x5f8/0x760 [btrfs]n btrfs_run_delalloc_range+0xa8/0x220 [btrfs]n writepage_delalloc+0x230/0x4c8 [btrfs]n extent_writepage+0xb8/0x358 [btrfs]n extent_write_cache_pages+0x21c/0x4e8 [btrfs]n btrfs_writepages+0x94/0x150 [btrfs]n do_writepages+0x74/0x190n filemap_fdatawrite_wbc+0x88/0xc8n start_delalloc_inodes+0x178/0x3a8 [btrfs]n btrfs_start_delalloc_roots+0x174/0x280 [btrfs]n shrink_delalloc+0x114/0x280 [btrfs]n flush_space+0x250/0x2f8 [btrfs]n btrfs_async_reclaim_data_space+0x180/0x228 [btrfs]n process_one_work+0x164/0x408n worker_thread+0x25c/0x388n kthread+0x100/0x118n ret_from_fork+0x10/0x20n Code: 910a8021 a90363f7 a9046bf9 94012379 (d4210000)n ---[ end trace 0000000000000000 ]---nn[CAUSE]nThe first two lines of extra debug messages show the problem is causednby the error handling of run_delalloc_nocow().nnE.g. we have the following dirtied range (4K blocksize 4K page size):nn 0 16K 32Kn |//////////////////////////////////////|n | Pre-allocated |nnAnd the range [0 16K) has a preallocated extent.nn- Enter run_delalloc_nocow() for range [0 16K)n Which found range [0 16K) is preallocated can do the proper NOCOWn write.nn- Enter fallback_to_fow() for range [16K 32K)n Since the range [16K 32K) is not backed by preallocated extent wen have to go COW.nn- cow_file_range() failed for range [16K 32K)n So cow_file_range() will do the clean up by clearing folio dirtyn unlock the folios.nn Now the folios in range [16K 32K) is unlocked.nn- Enter extent_clear_unlock_delalloc() from run_delalloc_nocow()n Which is called with PAGE_START_WRITEBACK to start page writeback.n But folios can only be marked writeback when it's properly lockedn thus this triggered the VM_BUG_ON_FOLIO().nnFurthermore there is another hidden but common bug thatnrun_delalloc_nocow() is not clearing the folio dirty flags in its errornhandling path.nThis is the common bug shared between run_delalloc_nocow() andncow_file_range().nn[FIX]n- Clear folio dirty for range [@start @cur_offset)n Introduce a helper cleanup_dirty_folios() whichn will find and lock the folio in the range clear the dirty flag andn start/end the writeback with the extra handling for then @locked_folio.nn- Introduce a helper to clear folio dirty start and end writebacknn- Introduce a helper to record the last failed COW range endn This is to trace which range we should skip to avoid doublen unlocking.nn- Skip the failed COW range for the en---truncated---,CVE-2024-57975,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbtrfs: do proper folio cleanup when cow_file_range() failednn[BUG]nWhen testing with COW fixup marked as BUG_ON() (this is involved with thennew pin_user_pages*() change which should not result new out-of-bandndirty pages) I hit a crash triggered by the BUG_ON() from hitting COWnfixup path.nnThis BUG_ON() happens just after a failed btrfs_run_delalloc_range():nn BTRFS error (device dm-2): failed to run delalloc range root 348 ino 405 folio 65536 submit_bitmap 6-15 start 90112 len 106496: -28n ------------[ cut here ]------------n kernel BUG at fs/btrfs/extent_io.c:1444!n Internal error: Oops - BUG: 00000000f2000800 [#1] SMPn CPU: 0 UID: 0 PID: 434621 Comm: kworker/u24:8 Tainted: G OE 6.12.0-rc7-custom+ #86n Hardware name: QEMU KVM Virtual Machine BIOS unknown 2/2/2022n Workqueue: events_unbound btrfs_async_reclaim_data_space [btrfs]n pc : extent_writepage_io+0x2d4/0x308 [btrfs]n lr : extent_writepage_io+0x2d4/0x308 [btrfs]n Call trace:n extent_writepage_io+0x2d4/0x308 [btrfs]n extent_writepage+0x218/0x330 [btrfs]n extent_write_cache_pages+0x1d4/0x4b0 [btrfs]n btrfs_writepages+0x94/0x150 [btrfs]n do_writepages+0x74/0x190n filemap_fdatawrite_wbc+0x88/0xc8n start_delalloc_inodes+0x180/0x3b0 [btrfs]n btrfs_start_delalloc_roots+0x174/0x280 [btrfs]n shrink_delalloc+0x114/0x280 [btrfs]n flush_space+0x250/0x2f8 [btrfs]n btrfs_async_reclaim_data_space+0x180/0x228 [btrfs]n process_one_work+0x164/0x408n worker_thread+0x25c/0x388n kthread+0x100/0x118n ret_from_fork+0x10/0x20n Code: aa1403e1 9402f3ef aa1403e0 9402f36f (d4210000)n ---[ end trace 0000000000000000 ]---nn[CAUSE]nThat failure is mostly from cow_file_range() where we can hit -ENOSPC.nnAlthough the -ENOSPC is already a bug related to our space reservationncode let's just focus on the error handling.nnFor example we have the following dirty range [0 64K) of an inodenwith 4K sector size and 4K page size:nn 0 16K 32K 48K 64Kn |///////////////////////////////////////|n |#######################################|nnWhere |///| means page are still dirty and |###| means the extent iontree has EXTENT_DELALLOC flag.nn- Enter extent_writepage() for page 0nn- Enter btrfs_run_delalloc_range() for range [0 64K)nn- Enter cow_file_range() for range [0 64K)nn- Function btrfs_reserve_extent() only reserved one 16K extentn So we created extent map and ordered extent for range [0 16K)nn 0 16K 32K 48K 64Kn |////////|//////////////////////////////|n |<- OE ->|##############################|nn And range [0 16K) has its delalloc flag cleared.n But since we haven't yet submit any bio involved 4 pages are stilln dirty.nn- Function btrfs_reserve_extent() returns with -ENOSPCn Now we have to run error cleanup which will clear alln EXTENT_DELALLOC* flags and clear the dirty flags for the remainingn ranges:nn 0 16K 32K 48K 64Kn |////////| |n | | |nn Note that range [0 16K) still has its pages dirty.nn- Some time later writeback is triggered again for the range [0 16K)n since the page range still has dirty flags.nn- btrfs_run_delalloc_range() will do nothing because there is non EXTENT_DELALLOC flag.nn- extent_writepage_io() finds page 0 has no ordered flagn Which falls into the COW fixup path triggering the BUG_ON().nnUnfortunately this error handling bug dates back to the introduction ofnbtrfs. Thankfully with the abuse of COW fixup at least it won't crashnthe kernel.nn[FIX]nInstead of immediately unlocking the extent and folios we keep the extentnand folios locked until either erroring out or the whole delalloc rangenfinished.nnWhen the whole delalloc range finished without error we just unlock thenwhole range with PAGE_SET_ORDERED (and PAGE_UNLOCK for !keep_lockedncases)n---truncated---,CVE-2024-57976,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnmemcg: fix soft lockup in the OOM processnnA soft lockup issue was found in the product with about 56000 tasks werenin the OOM cgroup it was traversing them when the soft lockup wasntriggered.nnwatchdog: BUG: soft lockup - CPU#2 stuck for 23s! [VM Thread:1503066]nCPU: 2 PID: 1503066 Comm: VM Thread Kdump: loaded Tainted: GnHardware name: Huawei Cloud OpenStack Nova BIOSnRIP: 0010:console_unlock+0x343/0x540nRSP: 0000:ffffb751447db9a0 EFLAGS: 00000247 ORIG_RAX: ffffffffffffff13nRAX: 0000000000000001 RBX: 0000000000000000 RCX: 00000000ffffffffnRDX: 0000000000000000 RSI: 0000000000000004 RDI: 0000000000000247nRBP: ffffffffafc71f90 R08: 0000000000000000 R09: 0000000000000040nR10: 0000000000000080 R11: 0000000000000000 R12: ffffffffafc74bd0nR13: ffffffffaf60a220 R14: 0000000000000247 R15: 0000000000000000nCS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033nCR2: 00007f2fe6ad91f0 CR3: 00000004b2076003 CR4: 0000000000360ee0nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400nCall Trace:n vprintk_emit+0x193/0x280n printk+0x52/0x6en dump_task+0x114/0x130n mem_cgroup_scan_tasks+0x76/0x100n dump_header+0x1fe/0x210n oom_kill_process+0xd1/0x100n out_of_memory+0x125/0x570n mem_cgroup_out_of_memory+0xb5/0xd0n try_charge+0x720/0x770n mem_cgroup_try_charge+0x86/0x180n mem_cgroup_try_charge_delay+0x1c/0x40n do_anonymous_page+0xb5/0x390n handle_mm_fault+0xc4/0x1f0nnThis is because thousands of processes are in the OOM cgroup it takes anlong time to traverse all of them. As a result this lead to soft lockupnin the OOM process.nnTo fix this issue call 'cond_resched' in the 'mem_cgroup_scan_tasks'nfunction per 1000 iterations. For global OOM calln'touch_softlockup_watchdog' per 1000 iterations to avoid this issue.,CVE-2024-57977,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnpps: Fix a use-after-freennOn a board running ntpd and gpsd I'm seeing a consistent use-after-freenin sys_exit() from gpsd when rebooting:nn pps pps1: removedn ------------[ cut here ]------------n kobject: '(null)' (00000000db4bec24): is not initialized yet kobject_put() is being called.n WARNING: CPU: 2 PID: 440 at lib/kobject.c:734 kobject_put+0x120/0x150n CPU: 2 UID: 299 PID: 440 Comm: gpsd Not tainted 6.11.0-rc6-00308-gb31c44928842 #1n Hardware name: Raspberry Pi 4 Model B Rev 1.1 (DT)n pstate: 60000005 (nZCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)n pc : kobject_put+0x120/0x150n lr : kobject_put+0x120/0x150n sp : ffffffc0803d3ae0n x29: ffffffc0803d3ae0 x28: ffffff8042dc9738 x27: 0000000000000001n x26: 0000000000000000 x25: ffffff8042dc9040 x24: ffffff8042dc9440n x23: ffffff80402a4620 x22: ffffff8042ef4bd0 x21: ffffff80405cb600n x20: 000000000008001b x19: ffffff8040b3b6e0 x18: 0000000000000000n x17: 0000000000000000 x16: 0000000000000000 x15: 696e6920746f6e20n x14: 7369203a29343263 x13: 205d303434542020 x12: 0000000000000000n x11: 0000000000000000 x10: 0000000000000000 x9 : 0000000000000000n x8 : 0000000000000000 x7 : 0000000000000000 x6 : 0000000000000000n x5 : 0000000000000000 x4 : 0000000000000000 x3 : 0000000000000000n x2 : 0000000000000000 x1 : 0000000000000000 x0 : 0000000000000000n Call trace:n kobject_put+0x120/0x150n cdev_put+0x20/0x3cn __fput+0x2c4/0x2d8n ____fput+0x1c/0x38n task_work_run+0x70/0xfcn do_exit+0x2a0/0x924n do_group_exit+0x34/0x90n get_signal+0x7fc/0x8c0n do_signal+0x128/0x13b4n do_notify_resume+0xdc/0x160n el0_svc+0xd4/0xf8n el0t_64_sync_handler+0x140/0x14cn el0t_64_sync+0x190/0x194n ---[ end trace 0000000000000000 ]---nn...followed by more symptoms of corruption with similar stacks:nn refcount_t: underflow; use-after-free.n kernel BUG at lib/list_debug.c:62!n Kernel panic - not syncing: Oops - BUG: Fatal exceptionnnThis happens because pps_device_destruct() frees the pps_device with thenembedded cdev immediately after calling cdev_del() but as the commentnabove cdev_del() notes fops for previously opened cdevs are stillncallable even after cdev_del() returns. I think this bug has alwaysnbeen there: I can't explain why it suddenly started happening every timenI reboot this particular board.nnIn commit d953e0e837e6 (pps: Fix a use-after free bug whennunregistering a source.) George Spelvin suggested removing thenembedded cdev. That seems like the simplest way to fix this so I'venimplemented his suggestion using __register_chrdev() with pps_idrnbecoming the source of truth for which minor corresponds to whichndevice.nnBut now that pps_idr defines userspace visibility instead of cdev_add()nwe need to be sure the pps->dev refcount can't reach zero whilenuserspace can still find it again. So the idr_remove() call moves tonpps_unregister_cdev() and pps_idr now holds a reference to pps->dev.nn pps_core: source serial1 got cdev (251:1)n <...>n pps pps1: removedn pps_core: unregistering pps1n pps_core: deallocating pps1,CVE-2024-57979,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnmedia: uvcvideo: Fix double free in error pathnnIf the uvc_status_init() function fails to allocate the int_urb it willnfree the dev->status pointer but doesn't reset the pointer to NULL. Thisnresults in the kfree() call in uvc_status_cleanup() trying tondouble-free the memory. Fix it by resetting the dev->status pointer tonNULL after freeing it.nnReviewed by: Ricardo Ribalda <ribalda@chromium.org>,CVE-2024-57980,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnusb: xhci: Fix NULL pointer dereference on certain command abortsnnIf a command is queued to the final usable TRB of a ring segment thenenqueue pointer is advanced to the subsequent link TRB and no further.nIf the command is later aborted when the abort completion is handlednthe dequeue pointer is advanced to the first TRB of the next segment.nnIf no further commands are queued xhci_handle_stopped_cmd_ring() seesnthe ring pointers unequal and assumes that there is a pending commandnso it calls xhci_mod_cmd_timer() which crashes if cur_cmd was NULL.nnDon't attempt timer setup if cur_cmd is NULL. The subsequent doorbellnring likely is unnecessary too but it's harmless. Leave it alone.nnThis is probably Bug 219532 but no confirmation has been received.nnThe issue has been independently reproduced and confirmed fixed usingna USB MCU programmed to NAK the Status stage of SET_ADDRESS forever.nEverything continued working normally after several prevented crashes.,CVE-2024-57981,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnxfrm: state: fix out-of-bounds read during lookupnnlookup and resize can run in parallel.nnThe xfrm_state_hash_generation seqlock ensures a retry but the hashnfunctions can observe a hmask value that is too large for the new hlistnarray.nnrehash does:n rcu_assign_pointer(net->xfrm.state_bydst ndst) [..]n net->xfrm.state_hmask = nhashmask;nnWhile state lookup does:n h = xfrm_dst_hash(net daddr saddr tmpl->reqid encap_family);n hlist_for_each_entry_rcu(x net->xfrm.state_bydst + h bydst) {nnThis is only safe in case the update to state_bydst is larger thannnet->xfrm.xfrm_state_hmask (or if the lookup function getsnserialized via state spinlock again).nnFix this by prefetching state_hmask and the associated pointers.nThe xfrm_state_hash_generation seqlock retry will ensure that the pointernand the hmask will be consistent.nnThe existing helpers like xfrm_dst_hash() are now unsafe for RCU sidenadd lockdep assertions to document that they are only safe for insertnside.nnxfrm_state_lookup_byaddr() uses the spinlock rather than RCU.nAFAICS this is an oversight from back when state lookup was converted tonRCU this lock should be replaced with RCU in a future patch.,CVE-2024-57982,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nni3c: dw: Fix use-after-free in dw_i3c_master driver due to race conditionnnIn dw_i3c_common_probe &master->hj_work is bound withndw_i3c_hj_work. And dw_i3c_master_irq_handler can callndw_i3c_master_irq_handle_ibis function to start the work.nnIf we remove the module which will call dw_i3c_common_remove tonmake cleanup it will free master->base through i3c_master_unregisternwhile the work mentioned above will be used. The sequence of operationsnthat may lead to a UAF bug is as follows:nnCPU0 CPU1nn | dw_i3c_hj_workndw_i3c_common_remove |ni3c_master_unregister(&master->base) |ndevice_unregister(&master->dev) |ndevice_release |n//free master->base |n | i3c_master_do_daa(&master->base)n | //use master->basennFix it by ensuring that the work is canceled before proceeding withnthe cleanup in dw_i3c_common_remove.,CVE-2024-57984,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnHID: core: Fix assumption that Resolution Multipliers must be in Logical CollectionsnnA report in 2019 by the syzbot fuzzer was found to be connected to twonerrors in the HID core associated with Resolution Multipliers. One ofnthe errors was fixed by commit ea427a222d8b (HID: core: Fix deadloopnin hid_apply_multiplier.) but the other has not been fixed.nnThis error arises because hid_apply_multipler() assumes that everynResolution Multiplier control is contained in a Logical Collectionni.e. there's no way the routine can ever set multiplier_collection tonNULL. This is in spite of the fact that the function starts with anbig comment saying:nnt output.log scan_tyk_dockerimages.sh vulnerabilities.csv The Resolution Multiplier control must be contained in the sament output.log scan_tyk_dockerimages.sh vulnerabilities.csv Logical Collection as the control(s) to which it is to be applied.nt ...nt output.log scan_tyk_dockerimages.sh vulnerabilities.csv If no Logical Collection isnt output.log scan_tyk_dockerimages.sh vulnerabilities.csv defined the Resolution Multiplier is associated with allnt output.log scan_tyk_dockerimages.sh vulnerabilities.csv controls in the report.nt output.log scan_tyk_dockerimages.sh vulnerabilities.csv HID Usage Table v1.12 Section 4.3.1 p30nt *nt output.log scan_tyk_dockerimages.sh vulnerabilities.csv Thus search from the current collection upwards until we find ant output.log scan_tyk_dockerimages.sh vulnerabilities.csv logical collection...nnThe comment and the code overlook the possibility that none of thencollections found may be a Logical Collection.nnThe fix is to set the multiplier_collection pointer to NULL if thencollection found isn't a Logical Collection.,CVE-2024-57986,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet_sched: sch_sfq: don't allow 1 packet limitnnThe current implementation does not work correctly with a limit ofn1. iproute2 actually checks for this and this patch adds the check innkernel as well.nnThis fixes the following syzkaller reported crash:nnUBSAN: array-index-out-of-bounds in net/sched/sch_sfq.c:210:6nindex 65535 is out of range for type 'struct sfq_head[128]'nCPU: 0 PID: 2569 Comm: syz-executor101 Not tainted 5.10.0-smp-DEV #1nHardware name: Google Google Compute Engine/Google Compute Engine BIOS Google 09/13/2024nCall Trace:n __dump_stack lib/dump_stack.c:79 [inline]n dump_stack+0x125/0x19f lib/dump_stack.c:120n ubsan_epilogue lib/ubsan.c:148 [inline]n __ubsan_handle_out_of_bounds+0xed/0x120 lib/ubsan.c:347n sfq_link net/sched/sch_sfq.c:210 [inline]n sfq_dec+0x528/0x600 net/sched/sch_sfq.c:238n sfq_dequeue+0x39b/0x9d0 net/sched/sch_sfq.c:500n sfq_reset+0x13/0x50 net/sched/sch_sfq.c:525n qdisc_reset+0xfe/0x510 net/sched/sch_generic.c:1026n tbf_reset+0x3d/0x100 net/sched/sch_tbf.c:319n qdisc_reset+0xfe/0x510 net/sched/sch_generic.c:1026n dev_reset_queue+0x8c/0x140 net/sched/sch_generic.c:1296n netdev_for_each_tx_queue include/linux/netdevice.h:2350 [inline]n dev_deactivate_many+0x6dc/0xc20 net/sched/sch_generic.c:1362n __dev_close_many+0x214/0x350 net/core/dev.c:1468n dev_close_many+0x207/0x510 net/core/dev.c:1506n unregister_netdevice_many+0x40f/0x16b0 net/core/dev.c:10738n unregister_netdevice_queue+0x2be/0x310 net/core/dev.c:10695n unregister_netdevice include/linux/netdevice.h:2893 [inline]n __tun_detach+0x6b6/0x1600 drivers/net/tun.c:689n tun_detach drivers/net/tun.c:705 [inline]n tun_chr_close+0x104/0x1b0 drivers/net/tun.c:3640n __fput+0x203/0x840 fs/file_table.c:280n task_work_run+0x129/0x1b0 kernel/task_work.c:185n exit_task_work include/linux/task_work.h:33 [inline]n do_exit+0x5ce/0x2200 kernel/exit.c:931n do_group_exit+0x144/0x310 kernel/exit.c:1046n __do_sys_exit_group kernel/exit.c:1057 [inline]n __se_sys_exit_group kernel/exit.c:1055 [inline]n __x64_sys_exit_group+0x3b/0x40 kernel/exit.c:1055n do_syscall_64+0x6c/0xd0n entry_SYSCALL_64_after_hwframe+0x61/0xcbnRIP: 0033:0x7fe5e7b52479nCode: Unable to access opcode bytes at RIP 0x7fe5e7b5244f.nRSP: 002b:00007ffd3c800398 EFLAGS: 00000246 ORIG_RAX: 00000000000000e7nRAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007fe5e7b52479nRDX: 000000000000003c RSI: 00000000000000e7 RDI: 0000000000000000nRBP: 00007fe5e7bcd2d0 R08: ffffffffffffffb8 R09: 0000000000000014nR10: 0000000000000000 R11: 0000000000000246 R12: 00007fe5e7bcd2d0nR13: 0000000000000000 R14: 00007fe5e7bcdd20 R15: 00007fe5e7b24270nnThe crash can be also be reproduced with the following (with a tcnrecompiled to allow for sfq limits of 1):nntc qdisc add dev dummy0 handle 1: root tbf rate 1Kbit burst 100b lat 1sn../iproute2-6.9.0/tc/tc qdisc add dev dummy0 handle 2: parent 1:10 sfq limit 1nifconfig dummy0 upnping -I dummy0 -f -c2 -W0.1 8.8.8.8nsleep 1nnScenario that triggers the crash:nn* the first packet is sent and queued in TBF and SFQ; qdisc qlen is 1nn* TBF dequeues: it peeks from SFQ which moves the packet to then gso_skb list and keeps qdisc qlen set to 1. TBF is out of tokens son it schedules itself for later.nn* the second packet is sent and TBF tries to queues it to SFQ. qdiscn qlen is now 2 and because the SFQ limit is 1 the packet is droppedn by SFQ. At this point qlen is 1 and all of the SFQ slots are emptyn however q->tail is not NULL.nnAt this point assuming no more packets are queued when sch_dequeuenruns again it will decrement the qlen for the current empty slotncausing an underflow and the subsequent out of bounds access.,CVE-2024-57996,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnocfs2: handle a symlink read error correctlynnPatch series Convert ocfs2 to use folios.nnMark did a conversion of ocfs2 to use folios and sent it to me as angiant patch for review ;-)nnSo I've redone it as individual patches and credited Mark for the patchesnwhere his code is substantially the same. It's not a bad way to do it;nhis patch had some bugs and my patches had some bugs. Hopefully all ournbugs were different from each other. And hopefully Mark likes all thenchanges I made to his code!nnnThis patch (of 23):nnIf we can't read the buffer be sure to unlock the page before returning.,CVE-2024-58001,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnmedia: uvcvideo: Remove dangling pointersnnWhen an async control is written we copy a pointer to the file handlenthat started the operation. That pointer will be used when the device isndone. Which could be anytime in the future.nnIf the user closes that file descriptor its structure will be freednand there will be one dangling pointer per pending async control thatnthe driver will try to use.nnClean all the dangling pointers during release().nnTo avoid adding a performance penalty in the most common case (no asyncnoperation) a counter has been introduced with some logic to make surenthat it is properly handled.,CVE-2024-58002,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nntpm: Change to kvalloc() in eventlog/acpi.cnnThe following failure was reported on HPE ProLiant D320:nn[ 10.693310][ T1] tpm_tis STM0925:00: 2.0 TPM (device-id 0x3 rev-id 0)n[ 10.848132][ T1] ------------[ cut here ]------------n[ 10.853559][ T1] WARNING: CPU: 59 PID: 1 at mm/page_alloc.c:4727 __alloc_pages_noprof+0x2ca/0x330n[ 10.862827][ T1] Modules linked in:n[ 10.866671][ T1] CPU: 59 UID: 0 PID: 1 Comm: swapper/0 Not tainted 6.12.0-lp155.2.g52785e2-default #1 openSUSE Tumbleweed (unreleased) 588cd98293a7c9eba9013378d807364c088c9375n[ 10.882741][ T1] Hardware name: HPE ProLiant DL320 Gen12/ProLiant DL320 Gen12 BIOS 1.20 10/28/2024n[ 10.892170][ T1] RIP: 0010:__alloc_pages_noprof+0x2ca/0x330n[ 10.898103][ T1] Code: 24 08 e9 4a fe ff ff e8 34 36 fa ff e9 88 fe ff ff 83 fe 0a 0f 86 b3 fd ff ff 80 3d 01 e7 ce 01 00 75 09 c6 05 f8 e6 ce 01 01 <0f> 0b 45 31 ff e9 e5 fe ff ff f7 c2 00 00 08 00 75 42 89 d9 80 e1n[ 10.917750][ T1] RSP: 0000:ffffb7cf40077980 EFLAGS: 00010246n[ 10.923777][ T1] RAX: 0000000000000000 RBX: 0000000000040cc0 RCX: 0000000000000000n[ 10.931727][ T1] RDX: 0000000000000000 RSI: 000000000000000c RDI: 0000000000040cc0nnThe above transcript shows that ACPI pointed a 16 MiB buffer for the lognevents because RSI maps to the 'order' parameter of __alloc_pages_noprof().nAddress the bug by moving from devm_kmalloc() to devm_add_action() andnkvmalloc() and devm_add_action().,CVE-2024-58005,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnsoc: qcom: socinfo: Avoid out of bounds read of serial numbernnOn MSM8916 devices the serial number exposed in sysfs is constant and doesnnot change across individual devices. It's always:nn db410c:/sys/devices/soc0$ cat serial_numbern 2644893864nnThe firmware used on MSM8916 exposes SOCINFO_VERSION(0 8) which does notnhave support for the serial_num field in the socinfo struct. There is annexisting check to avoid exposing the serial number in that case but it'snnot correct: When checking the item_size returned by SMEM we need to makensure the *end* of the serial_num is within bounds instead of comparingnwith the *start* offset. The serial_number currently exposed on MSM8916ndevices is just an out of bounds read of whatever comes after the socinfonstruct in SMEM.nnFix this by changing offsetof() to offsetofend() so that the size of thenfield is also taken into account.,CVE-2024-58007,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnBluetooth: L2CAP: handle NULL sock pointer in l2cap_sock_allocnnA NULL sock pointer is passed into l2cap_sock_alloc() when it is callednfrom l2cap_sock_new_connection_cb() and the error handling paths shouldnalso be aware of it.nnSeemingly a more elegant solution would be to swap bt_sock_alloc() andnl2cap_chan_create() calls since they are not interdependent to that momentnbut then l2cap_chan_create() adds the soon to be deallocated and stillndummy-initialized channel to the global list accessible by many L2CAPnpaths. The channel would be removed from the list in short period of timenbut be a bit more straight-forward here and just check for NULL instead ofnchanging the order of function calls.nnFound by Linux Verification Center (linuxtesting.org) with SVACE staticnanalysis tool.,CVE-2024-58009,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbinfmt_flat: Fix integer overflow bug on 32 bit systemsnnMost of these sizes and counts are capped at 256MB so the math doesn'tnresult in an integer overflow. The relocs count needs to be checkednas well. Otherwise on 32bit systems the calculation of full_datancould be wrong.nntfull_data = data_len + relocs output.log scan_tyk_dockerimages.sh vulnerabilities.csv sizeof(unsigned long);,CVE-2024-58010,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnASoC: SOF: Intel: hda-dai: Ensure DAI widget is valid during paramsnnEach cpu DAI should associate with a widget. However the topology mightnnot create the right number of DAI widgets for aggregated amps. And itnwill cause NULL pointer deference.nCheck that the DAI widget associated with the CPU DAI is valid to preventnNULL pointer deference due to missing DAI widgets in topologies withnaggregated amps.,CVE-2024-58012,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnBluetooth: MGMT: Fix slab-use-after-free Read in mgmt_remove_adv_monitor_syncnnThis fixes the following crash:nn==================================================================nBUG: KASAN: slab-use-after-free in mgmt_remove_adv_monitor_sync+0x3a/0xd0 net/bluetooth/mgmt.c:5543nRead of size 8 at addr ffff88814128f898 by task kworker/u9:4/5961nnCPU: 1 UID: 0 PID: 5961 Comm: kworker/u9:4 Not tainted 6.12.0-syzkaller-10684-gf1cd565ce577 #0nHardware name: Google Google Compute Engine/Google Compute Engine BIOS Google 09/13/2024nWorkqueue: hci0 hci_cmd_sync_worknCall Trace:n <TASK>n __dump_stack lib/dump_stack.c:94 [inline]n dump_stack_lvl+0x241/0x360 lib/dump_stack.c:120n print_address_description mm/kasan/report.c:378 [inline]n print_report+0x169/0x550 mm/kasan/report.c:489n kasan_report+0x143/0x180 mm/kasan/report.c:602n mgmt_remove_adv_monitor_sync+0x3a/0xd0 net/bluetooth/mgmt.c:5543n hci_cmd_sync_work+0x22b/0x400 net/bluetooth/hci_sync.c:332n process_one_work kernel/workqueue.c:3229 [inline]n process_scheduled_works+0xa63/0x1850 kernel/workqueue.c:3310n worker_thread+0x870/0xd30 kernel/workqueue.c:3391n kthread+0x2f0/0x390 kernel/kthread.c:389n ret_from_fork+0x4b/0x80 arch/x86/kernel/process.c:147n ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244n </TASK>nnAllocated by task 16026:n kasan_save_stack mm/kasan/common.c:47 [inline]n kasan_save_track+0x3f/0x80 mm/kasan/common.c:68n poison_kmalloc_redzone mm/kasan/common.c:377 [inline]n __kasan_kmalloc+0x98/0xb0 mm/kasan/common.c:394n kasan_kmalloc include/linux/kasan.h:260 [inline]n __kmalloc_cache_noprof+0x243/0x390 mm/slub.c:4314n kmalloc_noprof include/linux/slab.h:901 [inline]n kzalloc_noprof include/linux/slab.h:1037 [inline]n mgmt_pending_new+0x65/0x250 net/bluetooth/mgmt_util.c:269n mgmt_pending_add+0x36/0x120 net/bluetooth/mgmt_util.c:296n remove_adv_monitor+0x102/0x1b0 net/bluetooth/mgmt.c:5568n hci_mgmt_cmd+0xc47/0x11d0 net/bluetooth/hci_sock.c:1712n hci_sock_sendmsg+0x7b8/0x11c0 net/bluetooth/hci_sock.c:1832n sock_sendmsg_nosec net/socket.c:711 [inline]n __sock_sendmsg+0x221/0x270 net/socket.c:726n sock_write_iter+0x2d7/0x3f0 net/socket.c:1147n new_sync_write fs/read_write.c:586 [inline]n vfs_write+0xaeb/0xd30 fs/read_write.c:679n ksys_write+0x18f/0x2b0 fs/read_write.c:731n do_syscall_x64 arch/x86/entry/common.c:52 [inline]n do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83n entry_SYSCALL_64_after_hwframe+0x77/0x7fnnFreed by task 16022:n kasan_save_stack mm/kasan/common.c:47 [inline]n kasan_save_track+0x3f/0x80 mm/kasan/common.c:68n kasan_save_free_info+0x40/0x50 mm/kasan/generic.c:582n poison_slab_object mm/kasan/common.c:247 [inline]n __kasan_slab_free+0x59/0x70 mm/kasan/common.c:264n kasan_slab_free include/linux/kasan.h:233 [inline]n slab_free_hook mm/slub.c:2338 [inline]n slab_free mm/slub.c:4598 [inline]n kfree+0x196/0x420 mm/slub.c:4746n mgmt_pending_foreach+0xd1/0x130 net/bluetooth/mgmt_util.c:259n __mgmt_power_off+0x183/0x430 net/bluetooth/mgmt.c:9550n hci_dev_close_sync+0x6c4/0x11c0 net/bluetooth/hci_sync.c:5208n hci_dev_do_close net/bluetooth/hci_core.c:483 [inline]n hci_dev_close+0x112/0x210 net/bluetooth/hci_core.c:508n sock_do_ioctl+0x158/0x460 net/socket.c:1209n sock_ioctl+0x626/0x8e0 net/socket.c:1328n vfs_ioctl fs/ioctl.c:51 [inline]n __do_sys_ioctl fs/ioctl.c:906 [inline]n __se_sys_ioctl+0xf5/0x170 fs/ioctl.c:892n do_syscall_x64 arch/x86/entry/common.c:52 [inline]n do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83n entry_SYSCALL_64_after_hwframe+0x77/0x7f,CVE-2024-58013,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnwifi: brcmsmac: add gain range check to wlc_phy_iqcal_gainparams_nphy()nnIn 'wlc_phy_iqcal_gainparams_nphy()' add gain range check to WARN()ninstead of possible out-of-bounds 'tbl_iqcal_gainparams_nphy' access.nCompile tested only.nnFound by Linux Verification Center (linuxtesting.org) with SVACE.,CVE-2024-58014,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnsafesetid: check size of policy writesnnsyzbot attempts to write a buffer with a large size to a sysfs entrynwith writes handled by handle_policy_update() triggering a warningnin kmalloc.nnCheck the size specified for write buffers before allocating.nn[PM: subject tweak],CVE-2024-58016,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnprintk: Fix signed integer overflow when defining LOG_BUF_LEN_MAXnnShifting 1 << 31 on a 32-bit int causes signed integer overflow whichnleads to undefined behavior. To prevent this cast 1 to u32 beforenperforming the shift ensuring well-defined behavior.nnThis change explicitly avoids any potential overflow by ensuring thatnthe shift occurs on an unsigned 32-bit integer.,CVE-2024-58017,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnHID: multitouch: Add NULL check in mt_input_configurednndevm_kasprintf() can return a NULL pointer on failurebut thisnreturned value in mt_input_configured() is not checked.nAdd NULL check in mt_input_configured() to handle kernel NULLnpointer dereference error.,CVE-2024-58020,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnmemory: tegra20-emc: fix an OF node reference bug in tegra_emc_find_node_by_ram_code()nnAs of_find_node_by_name() release the reference of the argument devicennode tegra_emc_find_node_by_ram_code() releases some device nodes whilenstill in use resulting in possible UAFs. According to the bindings andnthe in-tree DTS files the emc-tables node is always device's childnnode with the property nvidiause-ram-code and the lpddr2 node is anchild of the emc-tables node. Thus utilize thenfor_each_child_of_node() macro and of_get_child_by_name() instead ofnof_find_node_by_name() to simplify the code.nnThis bug was found by an experimental verification tool that I amndeveloping.nn[krzysztof: applied v1 adjust the commit msg to incorporate v2 parts],CVE-2024-58034,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnipmi: ipmb: Add check devm_kasprintf() returned valuenndevm_kasprintf() can return a NULL pointer on failure but thisnreturned value is not checked.,CVE-2024-58051,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amdgpu: Fix potential NULL pointer dereference in atomctrl_get_smc_sclk_range_tablennThe function atomctrl_get_smc_sclk_range_table() does not check the returnnvalue of smu_atom_get_data_table(). If smu_atom_get_data_table() fails tonretrieve SMU_Info table it returns NULL which is later dereferenced.nnFound by Linux Verification Center (linuxtesting.org) with SVACE.nnIn practice this should never happen as this code only gets callednon polaris chips and the vbios data table will always be present onnthose chips.,CVE-2024-58052,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnrxrpc: Fix handling of received connection abortnnFix the handling of a connection abort that we've received. Though thenabort is at the connection level it needs propagating to the calls on thatnconnection. Whilst the propagation bit is performed the calls aren't thennwoken up to go and process their termination and as no further input isnforthcoming they just hang.nnAlso add some tracing for the logging of connection aborts.,CVE-2024-58053,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnusb: gadget: f_tcm: Don't free command immediatelynnDon't prematurely free the command. Wait for the status completion ofnthe sense status. It can be freed then. Otherwise we will double-freenthe command.,CVE-2024-58055,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnubifs: skip dumping tnc tree when zroot is nullnnClearing slab cache will free all znode in memory and makenc->zroot.znode = NULL then dumping tnc tree will accessnc->zroot.znode which cause null pointer dereference.,CVE-2024-58058,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnwifi: rtlwifi: fix memory leaks and invalid access at probe error pathnnDeinitialize at reverse order when probe fails.nnWhen init_sw_vars fails rtl_deinit_core should not be called speciallynnow that it destroys the rtl_wq workqueue.nnAnd call rtl_pci_deinit and deinit_sw_vars otherwise memory will benleaked.nnRemove pci_set_drvdata call as it will already be cleaned up by the corendriver code and could lead to memory leaks too. cf. commit 8d450935ae7fn(wireless: rtlwifi: remove unnecessary pci_set_drvdata()) andncommit 3d86b93064c7 (rtlwifi: Fix PCI probe error path orphaned memory).,CVE-2024-58063,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnrtc: pcf85063: fix potential OOB write in PCF85063 NVMEM readnnThe nvmem interface supports variable buffer sizes while the regmapninterface operates with fixed-size storage. If an nvmem client uses anbuffer size less than 4 bytes regmap_read will write out of boundsnas it expects the buffer to point at an unsigned int.nnFix this by using an intermediary unsigned int to hold the value.,CVE-2024-58069,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnteam: prevent adding a device which is already a team device lowernnPrevent adding a device which is already a team device lowerne.g. adding veth0 if vlan1 was already added and veth0 is a lower ofnvlan1.nnThis is not useful in practice and can lead to recursive locking:nn$ ip link add veth0 type veth peer name veth1n$ ip link set veth0 upn$ ip link set veth1 upn$ ip link add link veth0 name veth0.1 type vlan protocol 802.1Q id 1n$ ip link add team0 type teamn$ ip link set veth0.1 downn$ ip link set veth0.1 master team0nteam0: Port device veth0.1 addedn$ ip link set veth0 downn$ ip link set veth0 master team0nn============================================nWARNING: possible recursive locking detectedn6.13.0-rc2-virtme-00441-ga14a429069bb #46 Not taintedn--------------------------------------------nip/7684 is trying to acquire lock:nffff888016848e00 (team->team_lock_key){+.+.}-{4:4} at: team_device_event (drivers/net/team/team_core.c:2928 drivers/net/team/team_core.c:2951 drivers/net/team/team_core.c:2973)nnbut task is already holding lock:nffff888016848e00 (team->team_lock_key){+.+.}-{4:4} at: team_add_slave (drivers/net/team/team_core.c:1147 drivers/net/team/team_core.c:1977)nnother info that might help us debug this:nPossible unsafe locking scenario:nnCPU0n----nlock(team->team_lock_key);nlock(team->team_lock_key);nn*** DEADLOCK ***nnMay be due to missing lock nesting notationnn2 locks held by ip/7684:nnstack backtrace:nCPU: 3 UID: 0 PID: 7684 Comm: ip Not tainted 6.13.0-rc2-virtme-00441-ga14a429069bb #46nHardware name: QEMU Standard PC (i440FX + PIIX 1996) BIOS 1.16.3-debian-1.16.3-2 04/01/2014nCall Trace:n<TASK>ndump_stack_lvl (lib/dump_stack.c:122)nprint_deadlock_bug.cold (kernel/locking/lockdep.c:3040)n__lock_acquire (kernel/locking/lockdep.c:3893 kernel/locking/lockdep.c:5226)n? netlink_broadcast_filtered (net/netlink/af_netlink.c:1548)nlock_acquire.part.0 (kernel/locking/lockdep.c:467 kernel/locking/lockdep.c:5851)n? team_device_event (drivers/net/team/team_core.c:2928 drivers/net/team/team_core.c:2951 drivers/net/team/team_core.c:2973)n? trace_lock_acquire (./include/trace/events/lock.h:24 (discriminator 2))n? team_device_event (drivers/net/team/team_core.c:2928 drivers/net/team/team_core.c:2951 drivers/net/team/team_core.c:2973)n? lock_acquire (kernel/locking/lockdep.c:5822)n? team_device_event (drivers/net/team/team_core.c:2928 drivers/net/team/team_core.c:2951 drivers/net/team/team_core.c:2973)n__mutex_lock (kernel/locking/mutex.c:587 kernel/locking/mutex.c:735)n? team_device_event (drivers/net/team/team_core.c:2928 drivers/net/team/team_core.c:2951 drivers/net/team/team_core.c:2973)n? team_device_event (drivers/net/team/team_core.c:2928 drivers/net/team/team_core.c:2951 drivers/net/team/team_core.c:2973)n? fib_sync_up (net/ipv4/fib_semantics.c:2167)n? team_device_event (drivers/net/team/team_core.c:2928 drivers/net/team/team_core.c:2951 drivers/net/team/team_core.c:2973)nteam_device_event (drivers/net/team/team_core.c:2928 drivers/net/team/team_core.c:2951 drivers/net/team/team_core.c:2973)nnotifier_call_chain (kernel/notifier.c:85)ncall_netdevice_notifiers_info (net/core/dev.c:1996)n__dev_notify_flags (net/core/dev.c:8993)n? __dev_change_flags (net/core/dev.c:8975)ndev_change_flags (net/core/dev.c:9027)nvlan_device_event (net/8021q/vlan.c:85 net/8021q/vlan.c:470)n? br_device_event (net/bridge/br.c:143)nnotifier_call_chain (kernel/notifier.c:85)ncall_netdevice_notifiers_info (net/core/dev.c:1996)ndev_open (net/core/dev.c:1519 net/core/dev.c:1505)nteam_add_slave (drivers/net/team/team_core.c:1219 drivers/net/team/team_core.c:1977)n? __pfx_team_add_slave (drivers/net/team/team_core.c:1972)ndo_set_master (net/core/rtnetlink.c:2917)ndo_setlink.isra.0 (net/core/rtnetlink.c:3117),CVE-2024-58071,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnwifi: rtlwifi: remove unused check_buddy_privnnCommit 2461c7d60f9f (rtlwifi: Update header file) introduced a globalnlist of private data structures.nnLater on commit 26634c4b1868 (rtlwifi Modify existing bits to matchnvendor version 2013.02.07) started adding the private data to that list atnprobe time and added a hook check_buddy_priv to find the private data fromna similar device.nnHowever that function was never used.nnBesides though there is a lock for that list it is never used. And whennthe probe fails the private data is never removed from the list. Thisnwould cause a second probe to access freed memory.nnRemove the unused hook structures and members which will prevent thenpotential race condition on the list and its corruption during a secondnprobe when probe fails.,CVE-2024-58072,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnASoC: soc-pcm: don't use soc_pcm_ret() on .prepare callbacknncommit 1f5664351410 (ASoC: lower no backend DAIs enabled for ... Portnlog severity) ignores -EINVAL error message on common soc_pcm_ret().nIt is used from many functions ignoring -EINVAL is over-kill.nnThe reason why -EINVAL was ignored was it really should only be usednupon invalid parameters coming from userspace and in that case we don'tnwant to log an error since we do not want to give userspace a way to dona denial-of-service attack on the syslog / diskspace.nnSo don't use soc_pcm_ret() on .prepare callback is better idea.,CVE-2024-58077,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnKVM: Explicitly verify target vCPU is online in kvm_get_vcpu()nnExplicitly verify the target vCPU is fully online _prior_ to clamping thenindex in kvm_get_vcpu(). If the index is bad the nospec clamping willngenerate '0' i.e. KVM will return vCPU0 instead of NULL.nnIn practice the bug is unlikely to cause problems as it will only comeninto play if userspace or the guest is buggy or misbehaving e.g. KVM maynsend interrupts to vCPU0 instead of dropping them on the floor.nnHowever returning vCPU0 when it shouldn't exist per online_vcpus isnproblematic now that KVM uses an xarray for the vCPUs array as KVM needsnto insert into the xarray before publishing the vCPU to userspace (seencommit c5b077549136 (KVM: Convert the kvm->vcpus array to a xarray))ni.e. before vCPU creation is guaranteed to succeed.nnAs a result incorrectly providing access to vCPU0 will trigger anuse-after-free if vCPU0 is dereferenced and kvm_vm_ioctl_create_vcpu()nbails out of vCPU creation due to an error and frees vCPU0. Commitnafb2acb2e3a3 (KVM: Fix vcpu_array[0] races) papered over that issue butnin doing so introduced an unsolvable teardown conundrum. Preventingnaccesses to vCPU0 before it's fully online will allow reverting commitnafb2acb2e3a3 without re-introducing the vcpu_array[0] UAF race.,CVE-2024-58083,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nntomoyo: don't emit warning in tomoyo_write_control()nnsyzbot is reporting too large allocation warning at tomoyo_write_control()nfor one can write a very very long line without new line character. To fixnthis warning I use __GFP_NOWARN rather than checking for KMALLOC_MAX_SIZEnfor practically a valid line should be always shorter than 32KB where thentoo small to fail memory-allocation rule applies.nnOne might try to write a valid line that is longer than 32KB but suchnrequest will likely fail with -ENOMEM. Therefore I feel that separatelynreturning -EINVAL when a line is longer than KMALLOC_MAX_SIZE is redundant.nThere is no need to distinguish over-32KB and over-KMALLOC_MAX_SIZE.,CVE-2024-58085,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbtrfs: fix double accounting race when btrfs_run_delalloc_range() failednn[BUG]nWhen running btrfs with block size (4K) smaller than page size (64Knaarch64) there is a very high chance to crash the kernel atngeneric/750 with the following messages:n(before the call traces there are 3 extra debug messages added)nn BTRFS warning (device dm-3): read-write for sector size 4096 with page size 65536 is experimentaln BTRFS info (device dm-3): checking UUID treen hrtimer: interrupt took 5451385 nsn BTRFS error (device dm-3): cow_file_range failed root=4957 inode=257 start=1605632 len=69632: -28n BTRFS error (device dm-3): run_delalloc_nocow failed root=4957 inode=257 start=1605632 len=69632: -28n BTRFS error (device dm-3): failed to run delalloc range root=4957 ino=257 folio=1572864 submit_bitmap=8-15 start=1605632 len=69632: -28n ------------[ cut here ]------------n WARNING: CPU: 2 PID: 3020984 at ordered-data.c:360 can_finish_ordered_extent+0x370/0x3b8 [btrfs]n CPU: 2 UID: 0 PID: 3020984 Comm: kworker/u24:1 Tainted: G OE 6.13.0-rc1-custom+ #89n Tainted: [O]=OOT_MODULE [E]=UNSIGNED_MODULEn Hardware name: QEMU KVM Virtual Machine BIOS unknown 2/2/2022n Workqueue: events_unbound btrfs_async_reclaim_data_space [btrfs]n pc : can_finish_ordered_extent+0x370/0x3b8 [btrfs]n lr : can_finish_ordered_extent+0x1ec/0x3b8 [btrfs]n Call trace:n can_finish_ordered_extent+0x370/0x3b8 [btrfs] (P)n can_finish_ordered_extent+0x1ec/0x3b8 [btrfs] (L)n btrfs_mark_ordered_io_finished+0x130/0x2b8 [btrfs]n extent_writepage+0x10c/0x3b8 [btrfs]n extent_write_cache_pages+0x21c/0x4e8 [btrfs]n btrfs_writepages+0x94/0x160 [btrfs]n do_writepages+0x74/0x190n filemap_fdatawrite_wbc+0x74/0xa0n start_delalloc_inodes+0x17c/0x3b0 [btrfs]n btrfs_start_delalloc_roots+0x17c/0x288 [btrfs]n shrink_delalloc+0x11c/0x280 [btrfs]n flush_space+0x288/0x328 [btrfs]n btrfs_async_reclaim_data_space+0x180/0x228 [btrfs]n process_one_work+0x228/0x680n worker_thread+0x1bc/0x360n kthread+0x100/0x118n ret_from_fork+0x10/0x20n ---[ end trace 0000000000000000 ]---n BTRFS critical (device dm-3): bad ordered extent accounting root=4957 ino=257 OE offset=1605632 OE len=16384 to_dec=16384 left=0n BTRFS critical (device dm-3): bad ordered extent accounting root=4957 ino=257 OE offset=1622016 OE len=12288 to_dec=12288 left=0n Unable to handle kernel NULL pointer dereference at virtual address 0000000000000008n BTRFS critical (device dm-3): bad ordered extent accounting root=4957 ino=257 OE offset=1634304 OE len=8192 to_dec=4096 left=0n CPU: 1 UID: 0 PID: 3286940 Comm: kworker/u24:3 Tainted: G W OE 6.13.0-rc1-custom+ #89n Hardware name: QEMU KVM Virtual Machine BIOS unknown 2/2/2022n Workqueue: btrfs_work_helper [btrfs] (btrfs-endio-write)n pstate: 404000c5 (nZcv daIF +PAN -UAO -TCO -DIT -SSBS BTYPE=--)n pc : process_one_work+0x110/0x680n lr : worker_thread+0x1bc/0x360n Call trace:n process_one_work+0x110/0x680 (P)n worker_thread+0x1bc/0x360 (L)n worker_thread+0x1bc/0x360n kthread+0x100/0x118n ret_from_fork+0x10/0x20n Code: f84086a1 f9000fe1 53041c21 b9003361 (f9400661)n ---[ end trace 0000000000000000 ]---n Kernel panic - not syncing: Oops: Fatal exceptionn SMP: stopping secondary CPUsn SMP: failed to stop secondary CPUs 2-3n Dumping ftrace buffer:n (ftrace buffer empty)n Kernel Offset: 0x275bb9540000 from 0xffff800080000000n PHYS_OFFSET: 0xffff8fbba0000000n CPU features: 0x10000000070008012508201720bnn[CAUSE]nThe above warning is triggered immediately after the delalloc rangenfailure this happens in the following sequence:nn- Range [1568K 1636K) is dirtynn 1536K 1568K 1600K 1636K 1664Kn | |/////////|////////| |nn Where 1536K 1600K and 1664K are page boundaries (64K page size)nn- Enter extent_writepage() for page 1536Knn- Enter run_delalloc_nocow() with locken---truncated---,CVE-2024-58089,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnsched/core: Prevent rescheduling when interrupts are disablednnDavid reported a warning observed while loop testing kexec jump:nn Interrupts enabled after irqrouter_resume+0x0/0x50n WARNING: CPU: 0 PID: 560 at drivers/base/syscore.c:103 syscore_resume+0x18a/0x220n kernel_kexec+0xf6/0x180n __do_sys_reboot+0x206/0x250n do_syscall_64+0x95/0x180nnThe corresponding interrupt flag trace:nn hardirqs last enabled at (15573): [<ffffffffa8281b8e>] __up_console_sem+0x7e/0x90n hardirqs last disabled at (15580): [<ffffffffa8281b73>] __up_console_sem+0x63/0x90nnThat means __up_console_sem() was invoked with interrupts enabled. Furtherninstrumentation revealed that in the interrupt disabled section of kexecnjump one of the syscore_suspend() callbacks woke up a task which set thenNEED_RESCHED flag. A later callback in the resume path invokedncond_resched() which in turn led to the invocation of the scheduler:nn __cond_resched+0x21/0x60n down_timeout+0x18/0x60n acpi_os_wait_semaphore+0x4c/0x80n acpi_ut_acquire_mutex+0x3d/0x100n acpi_ns_get_node+0x27/0x60n acpi_ns_evaluate+0x1cb/0x2d0n acpi_rs_set_srs_method_data+0x156/0x190n acpi_pci_link_set+0x11c/0x290n irqrouter_resume+0x54/0x60n syscore_resume+0x6a/0x200n kernel_kexec+0x145/0x1c0n __do_sys_reboot+0xeb/0x240n do_syscall_64+0x95/0x180nnThis is a long standing problem which probably got more visible withnthe recent printk changes. Something does a task wakeup and thenscheduler sets the NEED_RESCHED flag. cond_resched() sees it set andninvokes schedule() from a completely bogus context. The schedulernenables interrupts after context switching which causes the abovenwarning at the end.nnQuite some of the code paths in syscore_suspend()/resume() can result inntriggering a wakeup with the exactly same consequences. They might notnhave done so yet but as they share a lot of code with normal operationsnit's just a question of time.nnThe problem only affects the PREEMPT_NONE and PREEMPT_VOLUNTARY schedulingnmodels. Full preemption is not affected as cond_resched() is disabled andnthe preemption check preemptible() takes the interrupt disabled flag intonaccount.nnCure the problem by adding a corresponding check into cond_resched().,CVE-2024-58090,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnPCI/ASPM: Fix link state exit during switch upstream function removalnnBefore 456d8aa37d0f (PCI/ASPM: Disable ASPM on MFD function removal tonavoid use-after-free) we would free the ASPM link only after the lastnfunction on the bus pertaining to the given link was removed.nnThat was too late. If function 0 is removed before sibling functionnlink->downstream would point to free'd memory after.nnAfter above change we freed the ASPM parent link state upon any functionnremoval on the bus pertaining to a given link.nnThat is too early. If the link is to a PCIe switch with MFD on the upstreamnport then removing functions other than 0 first would free a link whichnstill remains parent_link to the remaining downstream ports.nnThe resulting GPFs are especially frequent during hot-unplug becausenpciehp removes devices on the link bus in reverse order.nnOn that switch function 0 is the virtual P2P bridge to the internal bus.nFree exactly when function 0 is removed -- before the parent link isnobsolete but after all subordinate links are gone.nn[kwilczynski: commit log],CVE-2024-58093,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnjfs: add check read-only before truncation in jfs_truncate_nolock()nnAdded a check for read-only mode in the `jfs_truncate_nolock`nfunction to avoid errors related to writing to a read-onlynfilesystem.nnCall stack:nnblock_write_begin() {n jfs_write_failed() {n jfs_truncate() {n jfs_truncate_nolock() {n txEnd() {n ...n log = JFS_SBI(tblk->sb)->log;n // (log == NULL)nnIf the `isReadOnly(ip)` condition is triggered inn`jfs_truncate_nolock` the function execution will stop and nonfurther data modification will occur. Instead the `xtTruncate`nfunction will be called with the COMMIT_WMAP flag preventingnmodifications in read-only mode.,CVE-2024-58094,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnjfs: add check read-only before txBeginAnon() callnnAdded a read-only check before calling `txBeginAnon` in `extAlloc`nand `extRecord`. This prevents modification attempts on a read-onlynmounted filesystem avoiding potential errors or crashes.nnCall trace:n txBeginAnon+0xac/0x154n extAlloc+0xe8/0xdec fs/jfs/jfs_extent.c:78n jfs_get_block+0x340/0xb98 fs/jfs/inode.c:248n __block_write_begin_int+0x580/0x166c fs/buffer.c:2128n __block_write_begin fs/buffer.c:2177 [inline]n block_write_begin+0x98/0x11c fs/buffer.c:2236n jfs_write_begin+0x44/0x88 fs/jfs/inode.c:299,CVE-2024-58095,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnwifi: ath11k: add srng->lock for ath11k_hal_srng_* in monitor modennath11k_hal_srng_* should be used with srng->lock to protect srng data.nnFor ath11k_dp_rx_mon_dest_process() and ath11k_dp_full_mon_process_rx()nthey use ath11k_hal_srng_* for many times but never call srng->lock.nnSo when running (full) monitor mode warning will occur:nRIP: 0010:ath11k_hal_srng_dst_peek+0x18/0x30 [ath11k]nCall Trace:n ? ath11k_hal_srng_dst_peek+0x18/0x30 [ath11k]n ath11k_dp_rx_process_mon_status+0xc45/0x1190 [ath11k]n ? idr_alloc_u32+0x97/0xd0n ath11k_dp_rx_process_mon_rings+0x32a/0x550 [ath11k]n ath11k_dp_service_srng+0x289/0x5a0 [ath11k]n ath11k_pcic_ext_grp_napi_poll+0x30/0xd0 [ath11k]n __napi_poll+0x30/0x1f0n net_rx_action+0x198/0x320n __do_softirq+0xdd/0x319nnSo add srng->lock for them to avoid such warnings.nnInorder to fetch the srng->lock should change srng's definition fromn'void' to 'struct hal_srng'. And initialize them elsewhere to preventnone line of code from being too long. This is consistent with other ringnprocess functions such as ath11k_dp_process_rx().nnTested-on: WCN6855 hw2.0 PCI WLAN.HSP.1.1-03125-QCAHSPSWPL_V1_V2_SILICONZ_LITE-3.6510.30nTested-on: QCN9074 hw1.0 PCI WLAN.HK.2.7.0.1-01744-QCAHKSWPL_SILICONZ-1,CVE-2024-58096,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnwifi: ath11k: fix RCU stall while reaping monitor destination ringnnWhile processing the monitor destination ring MSDUs are reaped from thenlink descriptor based on the corresponding buf_id.nnHowever sometimes the driver cannot obtain a valid buffer correspondingnto the buf_id received from the hardware. This causes an infinite loopnin the destination processing resulting in a kernel crash.nnkernel log:nath11k_pci 0000:58:00.0: data msdu_pop: invalid buf_id 309nath11k_pci 0000:58:00.0: data dp_rx_monitor_link_desc_return failednath11k_pci 0000:58:00.0: data msdu_pop: invalid buf_id 309nath11k_pci 0000:58:00.0: data dp_rx_monitor_link_desc_return failednnFix this by skipping the problematic buf_id and reaping the next entrynreplacing the break with the next MSDU processing.nnTested-on: WCN6855 hw2.0 PCI WLAN.HSP.1.1-03125-QCAHSPSWPL_V1_V2_SILICONZ_LITE-3.6510.30nTested-on: QCN9074 hw1.0 PCI WLAN.HK.2.7.0.1-01744-QCAHKSWPL_SILICONZ-1,CVE-2024-58097,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbpf: track changes_pkt_data property for global functionsnnWhen processing calls to certain helpers verifier invalidates allnpacket pointers in a current state. For example consider thenfollowing program:nn __attribute__((__noinline__))n long skb_pull_data(struct __sk_buff *sk __u32 len)n {n return bpf_skb_pull_data(sk len);n }nn SEC(tc)n int test_invalidate_checks(struct __sk_buff *sk)n {n int *p = (void *)(long)sk->data;n if ((void *)(p + 1) > (void *)(long)sk->data_end) return TCX_DROP;n skb_pull_data(sk 0);n *p = 42;n return TCX_PASS;n }nnAfter a call to bpf_skb_pull_data() the pointer 'p' can't be usednsafely. See function filter.c:bpf_helper_changes_pkt_data() for a listnof such helpers.nnAt the moment verifier invalidates packet pointers when processingnhelper function calls and does not traverse global sub-programs whennprocessing calls to global sub-programs. This means that calls tonhelpers done from global sub-programs do not invalidate pointers innthe caller state. E.g. the program above is unsafe but is notnrejected by verifier.nnThis commit fixes the omission by computing fieldnbpf_subprog_info->changes_pkt_data for each sub-program before mainnverification pass.nchanges_pkt_data should be set if:n- subprogram calls helper for which bpf_helper_changes_pkt_datan returns true;n- subprogram calls a global functionn for which bpf_subprog_info->changes_pkt_data should be set.nnThe verifier.c:check_cfg() pass is modified to compute thisninformation. The commit relies on depth first instruction traversalndone by check_cfg() and absence of recursive function calls:n- check_cfg() would eventually visit every call to subprogram S in an state when S is fully explored;n- when S is fully explored:n - every direct helper call within S is exploredn (and thus changes_pkt_data is set if needed);n - every call to subprogram S1 called by S was visited with S1 fullyn explored (and thus S inherits changes_pkt_data from S1).nnThe downside of such approach is that dead code elimination is notntaken into account: if a helper call inside global function is deadnbecause of current configuration verifier would conservatively assumenthat the call occurs for the purpose of the changes_pkt_datancomputation.,CVE-2024-58098,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbpf: check changes_pkt_data property for extension programsnnWhen processing calls to global sub-programs verifier decides whethernto invalidate all packet pointers in current state depending on thenchanges_pkt_data property of the global sub-program.nnBecause of this an extension program replacing a global sub-programnmust be compatible with changes_pkt_data property of the sub-programnbeing replaced.nnThis commit:n- adds changes_pkt_data flag to struct bpf_prog_aux:n - this flag is set in check_cfg() for main sub-program;n - in jit_subprogs() for other sub-programs;n- modifies bpf_check_attach_btf_id() to check changes_pkt_data flag;n- moves call to check_attach_btf_id() after the call to check_cfg()n because it needs changes_pkt_data flag to be set:nn bpf_check:n ... ...n - check_attach_btf_id resolve_pseudo_ldimm64n resolve_pseudo_ldimm64 --> bpf_prog_is_offloadedn bpf_prog_is_offloaded check_cfgn check_cfg + check_attach_btf_idn ... ...nnThe following fields are set by check_attach_btf_id():n- env->opsn- prog->aux->attach_btf_tracen- prog->aux->attach_func_namen- prog->aux->attach_func_proton- prog->aux->dst_trampolinen- prog->aux->modn- prog->aux->saved_dst_attach_typen- prog->aux->saved_dst_prog_typen- prog->expected_attach_typennNeither of these fields are used by resolve_pseudo_ldimm64() ornbpf_prog_offload_verifier_prep() (for netronome and netdevsimndrivers) so the reordering is safe.,CVE-2024-58100,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbpf: consider that tail calls invalidate packet pointersnnTail-called programs could execute any of the helpers that invalidatenpacket pointers. Hence conservatively assume that each tail callninvalidates packet pointers.nnMaking the change in bpf_helper_changes_pkt_data() automatically makesnuse of check_cfg() logic that computes 'changes_pkt_data' effect fornglobal sub-programs such that the following program could benrejected:nn int tail_call(struct __sk_buff *sk)n {n tbpf_tail_call_static(sk &jmp_table 0);n treturn 0;n }nn SEC(tc)n int not_safe(struct __sk_buff *sk)n {n tint *p = (void *)(long)sk->data;n t... make p valid ...n ttail_call(sk);n t*p = 42; /bin /boot /config /dev /etc /home /lib /media /mnt /opt /proc /root /run /sbin /shared /srv /sys /tmp /usr /utils /var this is unsafe */n t...n }nnThe tc_bpf2bpf.c:subprog_tc() needs change: mark it as a function thatncan invalidate packet pointers. Otherwise it can't be freplaced withntailcall_freplace.c:entry_freplace() that does a tail call.,CVE-2024-58237,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,BlueZ HID over GATT Profile Improper Access Control Remote Code Execution Vulnerability. This vulnerability allows network-adjacent attackers to execute arbitrary code on affected installations of BlueZ. Authentication is not required to exploit this vulnerability.nnThe specific flaw exists within the implementation of the HID over GATT Profile. The issue results from the lack of authorization prior to allowing access to functionality. An attacker can leverage this vulnerability to execute code in the context of the current user. Was ZDI-CAN-25177.,CVE-2024-8805,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet: reenable NETIF_F_IPV6_CSUM offload for BIG TCP packetsnnThe blamed commit disabled hardware offoad of IPv6 packets withnextension headers on devices that advertise NETIF_F_IPV6_CSUMnbased on the definition of that feature in skbuff.h:nn output.log scan_tyk_dockerimages.sh vulnerabilities.csv output.log scan_tyk_dockerimages.sh vulnerabilities.csv - %NETIF_F_IPV6_CSUMn output.log scan_tyk_dockerimages.sh vulnerabilities.csv - Driver (device) is only able to checksum plainn output.log scan_tyk_dockerimages.sh vulnerabilities.csv TCP or UDP packets over IPv6. These are specificallyn output.log scan_tyk_dockerimages.sh vulnerabilities.csv unencapsulated packets of the form IPv6|TCP orn output.log scan_tyk_dockerimages.sh vulnerabilities.csv IPv6|UDP where the Next Header field in the IPv6n output.log scan_tyk_dockerimages.sh vulnerabilities.csv header is either TCP or UDP. IPv6 extension headersn output.log scan_tyk_dockerimages.sh vulnerabilities.csv are not supported with this feature. This featuren output.log scan_tyk_dockerimages.sh vulnerabilities.csv cannot be set in features for a device withn output.log scan_tyk_dockerimages.sh vulnerabilities.csv NETIF_F_HW_CSUM also set. This feature is beingn output.log scan_tyk_dockerimages.sh vulnerabilities.csv DEPRECATED (see below).nnThe change causes skb_warn_bad_offload to fire for BIG TCPnpackets.nn[ 496.310233] WARNING: CPU: 13 PID: 23472 at net/core/dev.c:3129 skb_warn_bad_offload+0xc4/0xe0nn[ 496.310297] ? skb_warn_bad_offload+0xc4/0xe0n[ 496.310300] skb_checksum_help+0x129/0x1f0n[ 496.310303] skb_csum_hwoffload_help+0x150/0x1b0n[ 496.310306] validate_xmit_skb+0x159/0x270n[ 496.310309] validate_xmit_skb_list+0x41/0x70n[ 496.310312] sch_direct_xmit+0x5c/0x250n[ 496.310317] __qdisc_run+0x388/0x620nnBIG TCP introduced an IPV6_TLV_JUMBO IPv6 extension header toncommunicate packet length as this is an IPv6 jumbogram. But thenfeature is only enabled on devices that support BIG TCP TSO. Thenheader is only present for PF_PACKET taps like tcpdump and notntransmitted by physical devices.nnFor this specific case of extension headers that are notntransmitted return to the situation before the blamed commitnand support hardware offload.nnipv6_has_hopopt_jumbo() tests not only whether this header is presentnbut also that it is the only extension header before a terminal (L4)nheader.,CVE-2025-21629,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nncgroup/cpuset: remove kernfs active breaknnA warning was found:nnWARNING: CPU: 10 PID: 3486953 at fs/kernfs/file.c:828nCPU: 10 PID: 3486953 Comm: rmdir Kdump: loaded Tainted: GnRIP: 0010:kernfs_should_drain_open_files+0x1a1/0x1b0nRSP: 0018:ffff8881107ef9e0 EFLAGS: 00010202nRAX: 0000000080000002 RBX: ffff888154738c00 RCX: dffffc0000000000nRDX: 0000000000000007 RSI: 0000000000000004 RDI: ffff888154738c04nRBP: ffff888154738c04 R08: ffffffffaf27fa15 R09: ffffed102a8e7180nR10: ffff888154738c07 R11: 0000000000000000 R12: ffff888154738c08nR13: ffff888750f8c000 R14: ffff888750f8c0e8 R15: ffff888154738ca0nFS: 00007f84cd0be740(0000) GS:ffff8887ddc00000(0000) knlGS:0000000000000000nCS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033nCR2: 0000555f9fbe00c8 CR3: 0000000153eec001 CR4: 0000000000370ee0nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400nCall Trace:n kernfs_drain+0x15e/0x2f0n __kernfs_remove+0x165/0x300n kernfs_remove_by_name_ns+0x7b/0xc0n cgroup_rm_file+0x154/0x1c0n cgroup_addrm_files+0x1c2/0x1f0n css_clear_dir+0x77/0x110n kill_css+0x4c/0x1b0n cgroup_destroy_locked+0x194/0x380n cgroup_rmdir+0x2a/0x140nnIt can be explained by:nrmdir ttttecho 1 > cpuset.cpusnttttkernfs_fop_write_iter // active=0ncgroup_rm_filenkernfs_remove_by_name_nstkernfs_get_active // active=1n__kernfs_removettttt // active=0x80000002nkernfs_draintttcpuset_write_resmasknwait_eventn//waiting (active == 0x80000001)nttttkernfs_break_active_protectionntttt// active = 0x80000001n// continuenttttkernfs_unbreak_active_protectionntttt// active = 0x80000002n...nkernfs_should_drain_open_filesn// warning occursnttttkernfs_put_activennThis warning is caused by 'kernfs_break_active_protection' when it isnwriting to cpuset.cpus and the cgroup is removed concurrently.nnThe commit 3a5a6d0c2b03 (cpuset: don't nest cgroup_mutex insidenget_online_cpus()) made cpuset_hotplug_workfn asynchronous This changeninvolves calling flush_work() which can create a multiple processesncircular locking dependency that involve cgroup_mutex potentially leadingnto a deadlock. To avoid deadlock. the commit 76bb5ab8f6e3 (cpuset: breaknkernfs active protection in cpuset_write_resmask()) addedn'kernfs_break_active_protection' in the cpuset_write_resmask. This couldnlead to this warning.nnAfter the commit 2125c0034c5d (cgroup/cpuset: Make cpuset hotplugnprocessing synchronous) the cpuset_write_resmask no longer needs tonwait the hotplug to finish which means that concurrent hotplug and cpusetnoperations are no longer possible. Therefore the deadlock doesn't existnanymore and it does not have to 'break active protection' now. To fix thisnwarning just remove kernfs_break_active_protection operation in then'cpuset_write_resmask'.,CVE-2025-21634,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnrds: sysctl: rds_tcp_{rcvsnd}buf: avoid using current->nsproxynnAs mentioned in a previous commit of this series using the 'net'nstructure via 'current' is not recommended for different reasons:nn- Inconsistency: getting info from the reader's/writer's netns vs onlyn from the opener's netns.nn- current->nsproxy can be NULL in some cases resulting in an 'Oops'n (null-ptr-deref) e.g. when the current task is exiting as spotted byn syzbot [1] using acct(2).nnThe per-netns structure can be obtained from the table->data usingncontainer_of() then the 'net' one can be retrieved from the listennsocket (if available).,CVE-2025-21635,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnsched: sch_cake: add bounds checks to host bulk flow fairness countsnnEven though we fixed a logic error in the commit cited below syzbotnstill managed to trigger an underflow of the per-host bulk flowncounters leading to an out of bounds memory access.nnTo avoid any such logic errors causing out of bounds memory accessesnthis commit factors out all accesses to the per-host bulk flow countersnto a series of helpers that perform bounds-checking before anynincrements and decrements. This also has the benefit of improvingnreadability by moving the conditional checks for the flow mode intonthese helpers instead of having them spread out throughout thencode (which was the cause of the original logic error).nnAs part of this change the flow quantum calculation is consolidatedninto a helper function which means that the dithering applied to thenost load scaling is now applied both in the DRR rotation and when ansparse flow's quantum is first initiated. The only user-visible effectnof this is that the maximum packet size that can be sent while a flownstays sparse will now vary with +/- one byte in some cases. This shouldnnot make a noticeable difference in practice and thus it's not worthncomplicating the code to preserve the old behaviour.,CVE-2025-21647,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet: hns3: don't auto enable misc vectornnCurrently there is a time window between misc irq enablednand service task inited. If an interrupte is reported atnthis time it will cause warning like below:nn[ 16.324639] Call trace:n[ 16.324641] __queue_delayed_work+0xb8/0xe0n[ 16.324643] mod_delayed_work_on+0x78/0xd0n[ 16.324655] hclge_errhand_task_schedule+0x58/0x90 [hclge]n[ 16.324662] hclge_misc_irq_handle+0x168/0x240 [hclge]n[ 16.324666] __handle_irq_event_percpu+0x64/0x1e0n[ 16.324667] handle_irq_event+0x80/0x170n[ 16.324670] handle_fasteoi_edge_irq+0x110/0x2bcn[ 16.324671] __handle_domain_irq+0x84/0xfcn[ 16.324673] gic_handle_irq+0x88/0x2c0n[ 16.324674] el1_irq+0xb8/0x140n[ 16.324677] arch_cpu_idle+0x18/0x40n[ 16.324679] default_idle_call+0x5c/0x1bcn[ 16.324682] cpuidle_idle_call+0x18c/0x1c4n[ 16.324684] do_idle+0x174/0x17cn[ 16.324685] cpu_startup_entry+0x30/0x6cn[ 16.324687] secondary_start_kernel+0x1a4/0x280n[ 16.324688] ---[ end trace 6aa0bff672a964aa ]---nnSo don't auto enable misc vector when request irq..,CVE-2025-21651,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnhwmon: (drivetemp) Fix driver producing garbage data when SCSI errors occurnnscsi_execute_cmd() function can return both negative (linux codes) andnpositive (scsi_cmnd result field) error codes.nnCurrently the driver just passes error codes of scsi_execute_cmd() tonhwmon core which is incorrect because hwmon only checks for negativenerror codes. This leads to hwmon reporting uninitialized data tonuserspace in case of SCSI errors (for example if the disk drive wasndisconnected).nnThis patch checks scsi_execute_cmd() output and returns -EIO if it'snerror code is positive.nn[groeck: Avoid inline variable declaration for portability],CVE-2025-21656,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nneth: bnxt: always recalculate features after XDP clearing fix null-derefnnRecalculate features when XDP is detached.nnBefore:n # ip li set dev eth0 xdp obj xdp_dummy.bpf.o sec xdpn # ip li set dev eth0 xdp offn # ethtool -k eth0 | grep gron rx-gro-hw: off [requested on]nnAfter:n # ip li set dev eth0 xdp obj xdp_dummy.bpf.o sec xdpn # ip li set dev eth0 xdp offn # ethtool -k eth0 | grep gron rx-gro-hw: onnnThe fact that HW-GRO doesn't get re-enabled automatically is justna minor annoyance. The real issue is that the features will randomlyncome back during another reconfiguration which just happens to invokennetdev_update_features(). The driver doesn't handle reconfiguringntwo things at a time very robustly.nnStarting with commit 98ba1d931f61 (bnxt_en: Fix RSS logic inn__bnxt_reserve_rings()) we only reconfigure the RSS hash tablenif the effective number of Rx rings has changed. If HW-GRO isnenabled effective number of rings is 2x what user sees.nSo if we are in the bad state with HW-GRO re-enablement pendingnafter XDP off and we lower the rings by / 2 - the HW-GRO ringsndoing 2x and the ethtool -L doing / 2 may cancel each other outnand the:nn if (old_rx_rings != bp->hw_resc.resv_rx_rings &&nncondition in __bnxt_reserve_rings() will be false.nThe RSS map won't get updated and we'll crash with:nn BUG: kernel NULL pointer dereference address: 0000000000000168n RIP: 0010:__bnxt_hwrm_vnic_set_rss+0x13a/0x1a0n bnxt_hwrm_vnic_rss_cfg_p5+0x47/0x180n __bnxt_setup_vnic_p5+0x58/0x110n bnxt_init_nic+0xb72/0xf50n __bnxt_open_nic+0x40d/0xab0n bnxt_open_nic+0x2b/0x60n ethtool_set_channels+0x18c/0x1d0nnAs we try to access a freed ring.nnThe issue is present since XDP support was added really butnprior to commit 98ba1d931f61 (bnxt_en: Fix RSS logic inn__bnxt_reserve_rings()) it wasn't causing major issues.,CVE-2025-21682,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnscsi: storvsc: Ratelimit warning logs to prevent VM denial of servicennIf there's a persistent error in the hypervisor the SCSI warning fornfailed I/O can flood the kernel log and max out CPU utilizationnpreventing troubleshooting from the VM side. Ratelimit the warning sonit doesn't DoS the VM.,CVE-2025-21690,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnmm: clear uffd-wp PTE/PMD state on mremap()nnWhen mremap()ing a memory region previously registered with userfaultfd asnwrite-protected but without UFFD_FEATURE_EVENT_REMAP an inconsistency innflag clearing leads to a mismatch between the vma flags (which havenuffd-wp cleared) and the pte/pmd flags (which do not have uffd-wpncleared). This mismatch causes a subsequent mprotect(PROT_WRITE) tontrigger a warning in page_table_check_pte_flags() due to setting the ptento writable while uffd-wp is still set.nnFix this by always explicitly clearing the uffd-wp pte/pmd flags on anynsuch mremap() so that the values are consistent with the existing clearingnof VM_UFFD_WP. Be careful to clear the logical flag regardless of itsnphysical form; a PTE bit a swap PTE bit or a PTE marker. Cover PTEnhuge PMD and hugetlb paths.,CVE-2025-21696,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet: sched: Disallow replacing of child qdisc from one parent to anothernnLion Ackermann was able to create a UAF which can be abused for privilegenescalation with the following scriptnnStep 1. create root qdiscntc qdisc add dev lo root handle 1:0 drrnnstep2. a class for packet aggregation do demonstrate uafntc class add dev lo classid 1:1 drrnnstep3. a class for nestingntc class add dev lo classid 1:2 drrnnstep4. a class to graft qdisc tontc class add dev lo classid 1:3 drrnnstep5.ntc qdisc add dev lo parent 1:1 handle 2:0 plug limit 1024nnstep6.ntc qdisc add dev lo parent 1:2 handle 3:0 drrnnstep7.ntc class add dev lo classid 3:1 drrnnstep 8.ntc qdisc add dev lo parent 3:1 handle 4:0 pfifonnstep 9. Display the class/qdisc layoutnntc class ls dev lon class drr 1:1 root leaf 2: quantum 64Kbn class drr 1:2 root leaf 3: quantum 64Kbn class drr 3:1 root leaf 4: quantum 64Kbnntc qdisc lsn qdisc drr 1: dev lo root refcnt 2n qdisc plug 2: dev lo parent 1:1n qdisc pfifo 4: dev lo parent 3:1 limit 1000pn qdisc drr 3: dev lo parent 1:2nnstep10. trigger the bug <=== prevented by this patchntc qdisc replace dev lo parent 1:3 handle 4:0nnstep 11. Redisplay again the qdiscs/classesnntc class ls dev lon class drr 1:1 root leaf 2: quantum 64Kbn class drr 1:2 root leaf 3: quantum 64Kbn class drr 1:3 root leaf 4: quantum 64Kbn class drr 3:1 root leaf 4: quantum 64Kbnntc qdisc lsn qdisc drr 1: dev lo root refcnt 2n qdisc plug 2: dev lo parent 1:1n qdisc pfifo 4: dev lo parent 3:1 refcnt 2 limit 1000pn qdisc drr 3: dev lo parent 1:2nnObserve that a) parent for 4:0 does not change despite the replace request.nThere can only be one parent. b) refcount has gone up by two for 4:0 andnc) both class 1:3 and 3:1 are pointing to it.nnStep 12. send one packet to plugnecho  | socat -u STDIN UDP4-DATAGRAM:127.0.0.1:8888priority=$((0x10001))nstep13. send one packet to the grafted fifonecho  | socat -u STDIN UDP4-DATAGRAM:127.0.0.1:8888priority=$((0x10003))nnstep14. lets trigger the uafntc class delete dev lo classid 1:3ntc class delete dev lo classid 1:1nnThe semantics of replace is for a del/add _on the same node_ and notna delete from one node(3:1) and add to another node (1:3) as in step10.nWhile we could fix with a more complex approach there could benconsequences to expectations so the patch takes the preventive approach ofndisallow such config.nnJoint work with Lion Ackermann <nnamrec@gmail.com>,CVE-2025-21700,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet: avoid race between device unregistration and ethnl opsnnThe following trace can be seen if a device is being unregistered whilenits number of channels are being modified.nn DEBUG_LOCKS_WARN_ON(lock->magic != lock)n WARNING: CPU: 3 PID: 3754 at kernel/locking/mutex.c:564 __mutex_lock+0xc8a/0x1120n CPU: 3 UID: 0 PID: 3754 Comm: ethtool Not tainted 6.13.0-rc6+ #771n RIP: 0010:__mutex_lock+0xc8a/0x1120n Call Trace:n <TASK>n ethtool_check_max_channel+0x1ea/0x880n ethnl_set_channels+0x3c3/0xb10n ethnl_default_set_doit+0x306/0x650n genl_family_rcv_msg_doit+0x1e3/0x2c0n genl_rcv_msg+0x432/0x6f0n netlink_rcv_skb+0x13d/0x3b0n genl_rcv+0x28/0x40n netlink_unicast+0x42e/0x720n netlink_sendmsg+0x765/0xc20n __sys_sendto+0x3ac/0x420n __x64_sys_sendto+0xe0/0x1c0n do_syscall_64+0x95/0x180n entry_SYSCALL_64_after_hwframe+0x76/0x7ennThis is because unregister_netdevice_many_notify might run before thenrtnl lock section of ethnl operations eg. set_channels in the abovenexample. In this example the rss lock would be destroyed by the devicenunregistration path before being used again but in general runningnethnl operations while dismantle has started is not a good idea.nnFix this by denying any operation on devices being unregistered. A checknwas already there in ethnl_ops_begin but not wide enough.nnNote that the same issue cannot be seen on the ioctl versionn(__dev_ethtool) because the device reference is retrieved from withinnthe rtnl lock section there. Once dismantle started the net device isnunlisted and no reference will be found.,CVE-2025-21701,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnpfifo_tail_enqueue: Drop new packet when sch->limit == 0nnExpected behaviour:nIn case we reach scheduler's limit pfifo_tail_enqueue() will drop anpacket in scheduler's queue and decrease scheduler's qlen by one.nThen pfifo_tail_enqueue() enqueue new packet and increasenscheduler's qlen by one. Finally pfifo_tail_enqueue() returnn`NET_XMIT_CN` status code.nnWeird behaviour:nIn case we set `sch->limit == 0` and trigger pfifo_tail_enqueue() on anscheduler that has no packet the 'drop a packet' step will do nothing.nThis means the scheduler's qlen still has value equal 0.nThen we continue to enqueue new packet and increase scheduler's qlen bynone. In summary we can leverage pfifo_tail_enqueue() to increase qlen bynone and return `NET_XMIT_CN` status code.nnThe problem is:nLet's say we have two qdiscs: Qdisc_A and Qdisc_B.n - Qdisc_A's type must have '->graft()' function to create parent/child relationship.n Let's say Qdisc_A's type is `hfsc`. Enqueue packet to this qdisc will trigger `hfsc_enqueue`.n - Qdisc_B's type is pfifo_head_drop. Enqueue packet to this qdisc will trigger `pfifo_tail_enqueue`.n - Qdisc_B is configured to have `sch->limit == 0`.n - Qdisc_A is configured to route the enqueued's packet to Qdisc_B.nnEnqueue packet through Qdisc_A will lead to:n - hfsc_enqueue(Qdisc_A) -> pfifo_tail_enqueue(Qdisc_B)n - Qdisc_B->q.qlen += 1n - pfifo_tail_enqueue() return `NET_XMIT_CN`n - hfsc_enqueue() check for `NET_XMIT_SUCCESS` and see `NET_XMIT_CN` => hfsc_enqueue() don't increase qlen of Qdisc_A.nnThe whole process lead to a situation where Qdisc_A->q.qlen == 0 and Qdisc_B->q.qlen == 1.nReplace 'hfsc' with other type (for example: 'drr') still lead to the same problem.nThis violate the design where parent's qlen should equal to the sum of its childrens'qlen.nnBug impact: This issue can be used for user->kernel privilege escalation when it is reachable.,CVE-2025-21702,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnetem: Update sch->q.qlen before qdisc_tree_reduce_backlog()nnqdisc_tree_reduce_backlog() notifies parent qdisc only if childnqdisc becomes empty therefore we need to reduce the backlog of thenchild qdisc before calling it. Otherwise it would miss the opportunitynto call cops->qlen_notify() in the case of DRR it resulted in UAFnsince DRR uses ->qlen_notify() to maintain its active list.,CVE-2025-21703,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnusb: cdc-acm: Check control transfer buffer size before accessnnIf the first fragment is shorter than struct usb_cdc_notification we can'tncalculate an expected_size. Log an error and discard the notificationninstead of reading lengths from memory outside the received data which cannlead to memory corruption when the expected_size decreases betweennfragments causing `expected_size - acm->nb_index` to wrap.nnThis issue has been present since the beginning of git history; howevernit only leads to memory corruption since commit ea2583529cd1n(cdc-acm: reassemble fragmented notifications).nnA mitigating factor is that acm_ctrl_irq() can only execute after userspacenhas opened /dev/ttyACM*; but if ModemManager is running ModemManager willndo that automatically depending on the USB device's vendor/product IDs andnits other interfaces.,CVE-2025-21704,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet: usb: rtl8150: enable basic endpoint checkingnnSyzkaller reports [1] encountering a common issue of utilizing a wrongnusb endpoint type during URB submitting stage. This in turn triggersna warning shown below.nnFor now enable simple endpoint checking (specifically bulk andninterrupt eps testing control one is not essential) to mitigatenthe issue with a view to do other related cosmetic changes laternif they are necessary.nn[1] Syzkaller report:nusb 1-1: BOGUS urb xfer pipe 3 != type 1nWARNING: CPU: 1 PID: 2586 at drivers/usb/core/urb.c:503 usb_submit_urb+0xe4b/0x1730 driv>nModules linked in:nCPU: 1 UID: 0 PID: 2586 Comm: dhcpcd Not tainted 6.11.0-rc4-syzkaller-00069-gfc88bb11617>nHardware name: Google Google Compute Engine/Google Compute Engine BIOS Google 08/06/2024nRIP: 0010:usb_submit_urb+0xe4b/0x1730 drivers/usb/core/urb.c:503nCode: 84 3c 02 00 00 e8 05 e4 fc fc 4c 89 ef e8 fd 25 d7 fe 45 89 e0 89 e9 4c 89 f2 48 8>nRSP: 0018:ffffc9000441f740 EFLAGS: 00010282nRAX: 0000000000000000 RBX: ffff888112487a00 RCX: ffffffff811a99a9nRDX: ffff88810df6ba80 RSI: ffffffff811a99b6 RDI: 0000000000000001nRBP: 0000000000000003 R08: 0000000000000001 R09: 0000000000000000nR10: 0000000000000000 R11: 0000000000000001 R12: 0000000000000001nR13: ffff8881023bf0a8 R14: ffff888112452a20 R15: ffff888112487a7cnFS: 00007fc04eea5740(0000) GS:ffff8881f6300000(0000) knlGS:0000000000000000nCS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033nCR2: 00007f0a1de9f870 CR3: 000000010dbd0000 CR4: 00000000003506f0nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400nCall Trace:n <TASK>n rtl8150_open+0x300/0xe30 drivers/net/usb/rtl8150.c:733n __dev_open+0x2d4/0x4e0 net/core/dev.c:1474n __dev_change_flags+0x561/0x720 net/core/dev.c:8838n dev_change_flags+0x8f/0x160 net/core/dev.c:8910n devinet_ioctl+0x127a/0x1f10 net/ipv4/devinet.c:1177n inet_ioctl+0x3aa/0x3f0 net/ipv4/af_inet.c:1003n sock_do_ioctl+0x116/0x280 net/socket.c:1222n sock_ioctl+0x22e/0x6c0 net/socket.c:1341n vfs_ioctl fs/ioctl.c:51 [inline]n __do_sys_ioctl fs/ioctl.c:907 [inline]n __se_sys_ioctl fs/ioctl.c:893 [inline]n __x64_sys_ioctl+0x193/0x220 fs/ioctl.c:893n do_syscall_x64 arch/x86/entry/common.c:52 [inline]n do_syscall_64+0xcd/0x250 arch/x86/entry/common.c:83n entry_SYSCALL_64_after_hwframe+0x77/0x7fnRIP: 0033:0x7fc04ef73d49n...nnThis change has not been tested on real hardware.,CVE-2025-21708,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet/rose: prevent integer overflows in rose_setsockopt()nnIn case of possible unpredictably large arguments passed tonrose_setsockopt() and multiplied by extra values on top of thatninteger overflows may occur.nnDo the safest minimum and fix these issues by checking thencontents of 'opt' and returning -EINVAL if they are too large. Alsonswitch to unsigned int and remove useless check for negative 'opt'nin ROSE_IDLE case.,CVE-2025-21711,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnmd/md-bitmap: Synchronize bitmap_get_stats() with bitmap lifetimennAfter commit ec6bb299c7c3 (md/md-bitmap: add 'sync_size' into structnmd_bitmap_stats) following panic is reported:nnOops: general protection fault probably for non-canonical addressnRIP: 0010:bitmap_get_stats+0x2b/0xa0nCall Trace:n <TASK>n md_seq_show+0x2d2/0x5b0n seq_read_iter+0x2b9/0x470n seq_read+0x12f/0x180n proc_reg_read+0x57/0xb0n vfs_read+0xf6/0x380n ksys_read+0x6c/0xf0n do_syscall_64+0x82/0x170n entry_SYSCALL_64_after_hwframe+0x76/0x7ennRoot cause is that bitmap_get_stats() can be called at anytime if mddevnis still there even if bitmap is destroyed or not fully initialized.nDeferenceing bitmap in this case can crash the kernel. Meanwhile thenabove commit start to deferencing bitmap->storage make the problemneasier to trigger.nnFix the problem by protecting bitmap_get_stats() with bitmap_info.mutex.,CVE-2025-21712,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnRDMA/mlx5: Fix implicit ODP use after freennPrevent double queueing of implicit ODP mr destroy work by usingn__xa_cmpxchg() to make sure this is the only time we are destroying thisnspecific mr.nnWithout this change we could try to invalidate this mr twice which innturn could result in queuing a MR work destroy twice and eventually thensecond work could execute after the MR was freed due to the first workncausing a user after free and trace below.nn refcount_t: underflow; use-after-free.n WARNING: CPU: 2 PID: 12178 at lib/refcount.c:28 refcount_warn_saturate+0x12b/0x130n Modules linked in: bonding ib_ipoib vfio_pci ip_gre geneve nf_tables ip6_gre gre ip6_tunnel tunnel6 ipip tunnel4 ib_umad rdma_ucm mlx5_vfio_pci vfio_pci_core vfio_iommu_type1 mlx5_ib vfio ib_uverbs mlx5_core iptable_raw openvswitch nsh rpcrdma ib_iser libiscsi scsi_transport_iscsi rdma_cm iw_cm ib_cm ib_core xt_conntrack xt_MASQUERADE nf_conntrack_netlink nfnetlink xt_addrtype iptable_nat nf_nat br_netfilter rpcsec_gss_krb5 auth_rpcgss oid_registry overlay zram zsmalloc fuse [last unloaded: ib_uverbs]n CPU: 2 PID: 12178 Comm: kworker/u20:5 Not tainted 6.5.0-rc1_net_next_mlx5_58c644e #1n Hardware name: QEMU Standard PC (Q35 + ICH9 2009) BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014n Workqueue: events_unbound free_implicit_child_mr_work [mlx5_ib]n RIP: 0010:refcount_warn_saturate+0x12b/0x130n Code: 48 c7 c7 38 95 2a 82 c6 05 bc c6 fe 00 01 e8 0c 66 aa ff 0f 0b 5b c3 48 c7 c7 e0 94 2a 82 c6 05 a7 c6 fe 00 01 e8 f5 65 aa ff <0f> 0b 5b c3 90 8b 07 3d 00 00 00 c0 74 12 83 f8 01 74 13 8d 50 ffn RSP: 0018:ffff8881008e3e40 EFLAGS: 00010286n RAX: 0000000000000000 RBX: 0000000000000000 RCX: 0000000000000027n RDX: ffff88852c91b5c8 RSI: 0000000000000001 RDI: ffff88852c91b5c0n RBP: ffff8881dacd4e00 R08: 00000000ffffffff R09: 0000000000000019n R10: 000000000000072e R11: 0000000063666572 R12: ffff88812bfd9e00n R13: ffff8881c792d200 R14: ffff88810011c005 R15: ffff8881002099c0n FS: 0000000000000000(0000) GS:ffff88852c900000(0000) knlGS:0000000000000000n CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033n CR2: 00007f5694b5e000 CR3: 00000001153f6003 CR4: 0000000000370ea0n DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000n DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400n Call Trace:n <TASK>n ? refcount_warn_saturate+0x12b/0x130n free_implicit_child_mr_work+0x180/0x1b0 [mlx5_ib]n process_one_work+0x1cc/0x3c0n worker_thread+0x218/0x3c0n kthread+0xc6/0xf0n ret_from_fork+0x1f/0x30n </TASK>,CVE-2025-21714,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet: davicom: fix UAF in dm9000_drv_removenndm is netdev private data and it cannot benused after free_netdev() call. Using dm after free_netdev()ncan cause UAF bug. Fix it by moving free_netdev() at the end of thenfunction.nnThis is similar to the issue fixed in commitnad297cd2db89 (net: qcom/emac: fix UAF in emac_remove).nnThis bug is detected by our static analysis tool.,CVE-2025-21715,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet: rose: fix timer races against user threadsnnRose timers only acquire the socket spinlock withoutnchecking if the socket is owned by one user thread.nnAdd a check and rearm the timers if needed.nnBUG: KASAN: slab-use-after-free in rose_timer_expiry+0x31d/0x360 net/rose/rose_timer.c:174nRead of size 2 at addr ffff88802f09b82a by task swapper/0/0nnCPU: 0 UID: 0 PID: 0 Comm: swapper/0 Not tainted 6.13.0-rc5-syzkaller-00172-gd1bf27c4e176 #0nHardware name: Google Google Compute Engine/Google Compute Engine BIOS Google 09/13/2024nCall Trace:n <IRQ>n __dump_stack lib/dump_stack.c:94 [inline]n dump_stack_lvl+0x241/0x360 lib/dump_stack.c:120n print_address_description mm/kasan/report.c:378 [inline]n print_report+0x169/0x550 mm/kasan/report.c:489n kasan_report+0x143/0x180 mm/kasan/report.c:602n rose_timer_expiry+0x31d/0x360 net/rose/rose_timer.c:174n call_timer_fn+0x187/0x650 kernel/time/timer.c:1793n expire_timers kernel/time/timer.c:1844 [inline]n __run_timers kernel/time/timer.c:2418 [inline]n __run_timer_base+0x66a/0x8e0 kernel/time/timer.c:2430n run_timer_base kernel/time/timer.c:2439 [inline]n run_timer_softirq+0xb7/0x170 kernel/time/timer.c:2449n handle_softirqs+0x2d4/0x9b0 kernel/softirq.c:561n __do_softirq kernel/softirq.c:595 [inline]n invoke_softirq kernel/softirq.c:435 [inline]n __irq_exit_rcu+0xf7/0x220 kernel/softirq.c:662n irq_exit_rcu+0x9/0x30 kernel/softirq.c:678n instr_sysvec_apic_timer_interrupt arch/x86/kernel/apic/apic.c:1049 [inline]n sysvec_apic_timer_interrupt+0xa6/0xc0 arch/x86/kernel/apic/apic.c:1049n </IRQ>,CVE-2025-21718,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnipmr: do not call mr_mfc_uses_dev() for unres entriesnnsyzbot found that calling mr_mfc_uses_dev() for unres entriesnwould crash [1] because c->mfc_un.res.minvif / c->mfc_un.res.maxvifnalias to struct sk_buff_head unresolved which contain two pointers.nnThis code never worked lets remove it.nn[1]nUnable to handle kernel paging request at virtual address ffff5fff2d536613nKASAN: maybe wild-memory-access in range [0xfffefff96a9b3098-0xfffefff96a9b309f]nModules linked in:nCPU: 1 UID: 0 PID: 7321 Comm: syz.0.16 Not tainted 6.13.0-rc7-syzkaller-g1950a0af2d55 #0nHardware name: Google Google Compute Engine/Google Compute Engine BIOS Google 09/13/2024npstate: 80400005 (Nzcv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)n pc : mr_mfc_uses_dev net/ipv4/ipmr_base.c:290 [inline]n pc : mr_table_dump+0x5a4/0x8b0 net/ipv4/ipmr_base.c:334n lr : mr_mfc_uses_dev net/ipv4/ipmr_base.c:289 [inline]n lr : mr_table_dump+0x694/0x8b0 net/ipv4/ipmr_base.c:334nCall trace:n mr_mfc_uses_dev net/ipv4/ipmr_base.c:290 [inline] (P)n mr_table_dump+0x5a4/0x8b0 net/ipv4/ipmr_base.c:334 (P)n mr_rtm_dumproute+0x254/0x454 net/ipv4/ipmr_base.c:382n ipmr_rtm_dumproute+0x248/0x4b4 net/ipv4/ipmr.c:2648n rtnl_dump_all+0x2e4/0x4e8 net/core/rtnetlink.c:4327n rtnl_dumpit+0x98/0x1d0 net/core/rtnetlink.c:6791n netlink_dump+0x4f0/0xbc0 net/netlink/af_netlink.c:2317n netlink_recvmsg+0x56c/0xe64 net/netlink/af_netlink.c:1973n sock_recvmsg_nosec net/socket.c:1033 [inline]n sock_recvmsg net/socket.c:1055 [inline]n sock_read_iter+0x2d8/0x40c net/socket.c:1125n new_sync_read fs/read_write.c:484 [inline]n vfs_read+0x740/0x970 fs/read_write.c:565n ksys_read+0x15c/0x26c fs/read_write.c:708,CVE-2025-21719,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnilfs2: handle errors that nilfs_prepare_chunk() may returnnnPatch series nilfs2: fix issues with rename operations.nnThis series fixes BUG_ON check failures reported by syzbot around renamenoperations and a minor behavioral issue where the mtime of a childndirectory changes when it is renamed instead of moved.nnnThis patch (of 2):nnThe directory manipulation routines nilfs_set_link() andnnilfs_delete_entry() rewrite the directory entry in the folio/pagenpreviously read by nilfs_find_entry() so error handling is omitted on thenassumption that nilfs_prepare_chunk() which prepares the buffer fornrewriting will always succeed for these. And if an error is returned itntriggers the legacy BUG_ON() checks in each routine.nnThis assumption is wrong as proven by syzbot: the buffer layer called bynnilfs_prepare_chunk() may call nilfs_get_block() if necessary which maynfail due to metadata corruption or other reasons. This has been there allnalong but improved sanity checks and error handling may have made it morenreproducible in fuzzing tests.nnFix this issue by adding missing error paths in nilfs_set_link()nnilfs_delete_entry() and their caller nilfs_rename().,CVE-2025-21721,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnilfs2: do not force clear folio if buffer is referencednnPatch series nilfs2: protect busy buffer heads from being force-cleared.nnThis series fixes the buffer head state inconsistency issues reported bynsyzbot that occurs when the filesystem is corrupted and falls back tonread-only and the associated buffer head use-after-free issue.nnnThis patch (of 2):nnSyzbot has reported that after nilfs2 detects filesystem corruption andnfalls back to read-only inconsistencies in the buffer state may occur.nnOne of the inconsistencies is that when nilfs2 calls mark_buffer_dirty()nto set a data or metadata buffer as dirty but it detects that the buffernis not in the uptodate state:nn WARNING: CPU: 0 PID: 6049 at fs/buffer.c:1177 mark_buffer_dirty+0x2e5/0x520n fs/buffer.c:1177n ...n Call Trace:n <TASK>n nilfs_palloc_commit_alloc_entry+0x4b/0x160 fs/nilfs2/alloc.c:598n nilfs_ifile_create_inode+0x1dd/0x3a0 fs/nilfs2/ifile.c:73n nilfs_new_inode+0x254/0x830 fs/nilfs2/inode.c:344n nilfs_mkdir+0x10d/0x340 fs/nilfs2/namei.c:218n vfs_mkdir+0x2f9/0x4f0 fs/namei.c:4257n do_mkdirat+0x264/0x3a0 fs/namei.c:4280n __do_sys_mkdirat fs/namei.c:4295 [inline]n __se_sys_mkdirat fs/namei.c:4293 [inline]n __x64_sys_mkdirat+0x87/0xa0 fs/namei.c:4293n do_syscall_x64 arch/x86/entry/common.c:52 [inline]n do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83n entry_SYSCALL_64_after_hwframe+0x77/0x7fnnThe other is when nilfs_btree_propagate() which propagates the dirtynstate to the ancestor nodes of a b-tree that point to a dirty bufferndetects that the origin buffer is not dirty even though it should be:nn WARNING: CPU: 0 PID: 5245 at fs/nilfs2/btree.c:2089n nilfs_btree_propagate+0xc79/0xdf0 fs/nilfs2/btree.c:2089n ...n Call Trace:n <TASK>n nilfs_bmap_propagate+0x75/0x120 fs/nilfs2/bmap.c:345n nilfs_collect_file_data+0x4d/0xd0 fs/nilfs2/segment.c:587n nilfs_segctor_apply_buffers+0x184/0x340 fs/nilfs2/segment.c:1006n nilfs_segctor_scan_file+0x28c/0xa50 fs/nilfs2/segment.c:1045n nilfs_segctor_collect_blocks fs/nilfs2/segment.c:1216 [inline]n nilfs_segctor_collect fs/nilfs2/segment.c:1540 [inline]n nilfs_segctor_do_construct+0x1c28/0x6b90 fs/nilfs2/segment.c:2115n nilfs_segctor_construct+0x181/0x6b0 fs/nilfs2/segment.c:2479n nilfs_segctor_thread_construct fs/nilfs2/segment.c:2587 [inline]n nilfs_segctor_thread+0x69e/0xe80 fs/nilfs2/segment.c:2701n kthread+0x2f0/0x390 kernel/kthread.c:389n ret_from_fork+0x4b/0x80 arch/x86/kernel/process.c:147n ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244n </TASK>nnBoth of these issues are caused by the callbacks that handle thenpage/folio write requests forcibly clear various states including thenworking state of the buffers they hold at unexpected times when theyndetect read-only fallback.nnFix these issues by checking if the buffer is referenced before clearingnthe page/folio state and skipping the clear if it is.,CVE-2025-21722,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnpadata: avoid UAF for reorder_worknnAlthough the previous patch can avoid ps and ps UAF for _do_serial itncan not avoid potential UAF issue for reorder_work. This issue cannhappen just as below:nncrypto_requesttttcrypto_requestttcrypto_del_algnpadata_do_serialn ...n padata_reordern // processes all remainingn // requests then breaksn while (1) {n if (!padata)n break;n ...n }nnttttpadata_do_serialntttt // new request addedntttt list_addn // sees the new requestn queue_work(reorder_work)ntttt padata_reorderntttt queue_work_on(squeue->work)n...nntttt<kworker context>nttttpadata_serial_workerntttt// completes new requestntttt// no more outstandingntttt// requestsnntttttttcrypto_del_algnttttttt // free pdnn<kworker context>ninvoke_padata_reordern // UAF of pdnnTo avoid UAF for 'reorder_work' get 'pd' ref before put 'reorder_work'ninto the 'serial_wq' and put 'pd' ref until the 'serial_wq' finish.,CVE-2025-21726,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnpadata: fix UAF in padata_reordernnA bug was found when run ltp test:nnBUG: KASAN: slab-use-after-free in padata_find_next+0x29/0x1a0nRead of size 4 at addr ffff88bbfe003524 by task kworker/u113:2/3039206nnCPU: 0 PID: 3039206 Comm: kworker/u113:2 Kdump: loaded Not tainted 6.6.0+nWorkqueue: pdecrypt_parallel padata_parallel_workernCall Trace:n<TASK>ndump_stack_lvl+0x32/0x50nprint_address_description.constprop.0+0x6b/0x3d0nprint_report+0xdd/0x2c0nkasan_report+0xa5/0xd0npadata_find_next+0x29/0x1a0npadata_reorder+0x131/0x220npadata_parallel_worker+0x3d/0xc0nprocess_one_work+0x2ec/0x5a0nnIf 'mdelay(10)' is added before calling 'padata_find_next' in then'padata_reorder' function this issue could be reproduced easily withnltp test (pcrypt_aead01).nnThis can be explained as bellow:nnpcrypt_aead_encryptn...npadata_do_parallelnrefcount_inc(&pd->refcnt); // add refcntn...npadata_do_serialnpadata_reorder // pdnwhile (1) {npadata_find_next(pd true); // using pdnqueue_work_onn...npadata_serial_workerttttcrypto_del_algnpadata_put_pd_cnt // sub refcntnttttttpadata_free_shellnttttttpadata_put_pd(ps->pd);ntttttt// pd is freedn// loop again but pd is freedn// call padata_find_next UAFn}nnIn the padata_reorder function when it loops in 'while' if the alg isndeleted the refcnt may be decreased to 0 before enteringn'padata_find_next' which leads to UAF.nnAs mentioned in [1] do_serial is supposed to be called with BHs disablednand always happen under RCU protection to address this issue addnsynchronize_rcu() in 'padata_free_shell' wait for all _do_serial callsnto finish.nn[1] https://lore.kernel.org/all/20221028160401.cccypv4euxikusiq@parnassus.localdomain/n[2] https://lore.kernel.org/linux-kernel/jfjz5d7zwbytztackem7ibzalm5lnxldi2eofeiczqmqs2m7o6@fq426cwnjtkm/,CVE-2025-21727,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbpf: Send signals asynchronously if !preemptiblennBPF programs can execute in all kinds of contexts and when a programnrunning in a non-preemptible context uses the bpf_send_signal() kfuncnit will cause issues because this kfunc can sleep.nChange `irqs_disabled()` to `!preemptible()`.,CVE-2025-21728,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnbd: don't allow reconnect after disconnectnnFollowing process can cause nbd_config UAF:nn1) grab nbd_config temporarily;nn2) nbd_genl_disconnect() flush all recv_work() and release theninitial reference:nn nbd_genl_disconnectn nbd_disconnect_and_putn nbd_disconnectn flush_workqueue(nbd->recv_workq)n if (test_and_clear_bit(NBD_RT_HAS_CONFIG_REF ...))n nbd_config_putn -> due to step 1) reference is still not zeronn3) nbd_genl_reconfigure() queue recv_work() again;nn nbd_genl_reconfiguren config = nbd_get_config_unlocked(nbd)n if (!config)n -> succeedn if (!test_bit(NBD_RT_BOUND ...))n -> succeedn nbd_reconnect_socketn queue_work(nbd->recv_workq &args->work)nn4) step 1) release the reference;nn5) Finially recv_work() will trigger UAF:nn recv_workn nbd_config_put(nbd)n -> nbd_config is freedn atomic_dec(&config->recv_threads)n -> UAFnnFix the problem by clearing NBD_RT_BOUND in nbd_genl_disconnect() sonthat nbd_genl_reconfigure() will fail.,CVE-2025-21731,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnmisc: fastrpc: Fix copy buffer page sizennFor non-registered buffer fastrpc driver copies the buffer andnpass it to the remote subsystem. There is a problem with currentnimplementation of page size calculation which is not consideringnthe offset in the calculation. This might lead to passing ofnimproper and out-of-bounds page size which could result innmemory issue. Calculate page start and page end using the offsetnadjusted address instead of absolute address.,CVE-2025-21734,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnNFC: nci: Add bounds checking in nci_hci_create_pipe()nnThe pipe variable is a u8 which comes from the network. If it's morenthan 127 then it results in memory corruption in the callernnci_hci_connect_gate().,CVE-2025-21735,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnilfs2: fix possible int overflows in nilfs_fiemap()nnSince nilfs_bmap_lookup_contig() in nilfs_fiemap() calculates its resultnby being prepared to go through potentially maxblocks == INT_MAX blocksnthe value in n may experience an overflow caused by left shift of blkbits.nnWhile it is extremely unlikely to occur play it safe and cast right handnexpression to wider type to mitigate the issue.nnFound by Linux Verification Center (linuxtesting.org) with static analysisntool SVACE.,CVE-2025-21736,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnata: libata-sff: Ensure that we cannot write outside the allocated buffernnreveliofuzzing reported that a SCSI_IOCTL_SEND_COMMAND ioctl with out_lennset to 0xd42 SCSI command set to ATA_16 PASS-THROUGH ATA command set tonATA_NOP and protocol set to ATA_PROT_PIO can cause ata_pio_sector() tonwrite outside the allocated buffer overwriting random memory.nnWhile a ATA device is supposed to abort a ATA_NOP command there does seemnto be a bug either in libata-sff or QEMU where either this status is notnset or the status is cleared before read by ata_sff_hsm_move().nAnyway that is most likely a separate bug.nnLooking at __atapi_pio_bytes() it already has a safety check to ensurenthat __atapi_pio_bytes() cannot write outside the allocated buffer.nnAdd a similar check to ata_pio_sector() such that also ata_pio_sector()ncannot write outside the allocated buffer.,CVE-2025-21738,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnwifi: brcmfmac: fix NULL pointer dereference in brcmf_txfinalize()nnOn removal of the device or unloading of the kernel module a potential NULLnpointer dereference occurs.nnThe following sequence deletes the interface:nn brcmf_detach()n brcmf_remove_interface()n brcmf_del_if()nnInside the brcmf_del_if() function the drvr->if2bss[ifidx] is updated tonBRCMF_BSSIDX_INVALID (-1) if the bsscfgidx matches.nnAfter brcmf_remove_interface() call the brcmf_proto_detach() function isncalled providing the following sequence:nn brcmf_detach()n brcmf_proto_detach()n brcmf_proto_msgbuf_detach()n brcmf_flowring_detach()n brcmf_msgbuf_delete_flowring()n brcmf_msgbuf_remove_flowring()n brcmf_flowring_delete()n brcmf_get_ifp()n brcmf_txfinalize()nnSince brcmf_get_ip() can and actually will return NULL in this case thencall to brcmf_txfinalize() will result in a NULL pointer dereference insidenbrcmf_txfinalize() when trying to update ifp->ndev->stats.tx_errors.nnThis will only happen if a flowring still has an skb.nnAlthough the NULL pointer dereference has only been seen when trying tonupdate the tx statistic all other uses of the ifp pointer have beennguarded as well with an early return if ifp is NULL.,CVE-2025-21744,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnblk-cgroup: Fix class @block_class's subsystem refcount leakagennblkcg_fill_root_iostats() iterates over @block_class's devices bynclass_dev_iter_(init|next)() but does not end iterating withnclass_dev_iter_exit() so causes the class's subsystem refcount leakage.nnFix by ending the iterating with class_dev_iter_exit().,CVE-2025-21745,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet: rose: lock the socket in rose_bind()nnsyzbot reported a soft lockup in rose_loopback_timer()nwith a repro calling bind() from multiple threads.nnrose_bind() must lock the socket to avoid this issue.,CVE-2025-21749,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnwifi: brcmfmac: Check the return value of of_property_read_string_index()nnSomewhen between 6.10 and 6.11 the driver started to crash on mynMacBookPro143. The property doesn't exist and 'tmp' remainsnuninitialized so we pass a random pointer to devm_kstrdup().nnThe crash I am getting looks like this:nnBUG: unable to handle page fault for address: 00007f033c669379nPF: supervisor read access in kernel modenPF: error_code(0x0001) - permissions violationnPGD 8000000101341067 P4D 8000000101341067 PUD 101340067 PMD 1013bb067 PTE 800000010aee9025nOops: Oops: 0001 [#1] SMP PTInCPU: 4 UID: 0 PID: 827 Comm: (udev-worker) Not tainted 6.11.8-gentoo #1nHardware name: Apple Inc. MacBookPro143/Mac-551B86E5744E2388 BIOS 529.140.2.0.0 06/23/2024nRIP: 0010:strlen+0x4/0x30nCode: f7 75 ec 31 c0 c3 cc cc cc cc 48 89 f8 c3 cc cc cc cc 0f 1f 40 00 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 f3 0f 1e fa <80> 3f 00 74 14 48 89 f8 48 83 c0 01 80 38 00 75 f7 48 29 f8 c3 ccnRSP: 0018:ffffb4aac0683ad8 EFLAGS: 00010202nRAX: 00000000ffffffea RBX: 00007f033c669379 RCX: 0000000000000001nRDX: 0000000000000cc0 RSI: 00007f033c669379 RDI: 00007f033c669379nRBP: 00000000ffffffea R08: 0000000000000000 R09: 00000000c0ba916anR10: ffffffffffffffff R11: ffffffffb61ea260 R12: ffff91f7815b50c8nR13: 0000000000000cc0 R14: ffff91fafefffe30 R15: ffffb4aac0683b30nFS: 00007f033ccbe8c0(0000) GS:ffff91faeed00000(0000) knlGS:0000000000000000nCS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033nCR2: 00007f033c669379 CR3: 0000000107b1e004 CR4: 00000000003706f0nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400nCall Trace:n <TASK>n ? __die+0x23/0x70n ? page_fault_oops+0x149/0x4c0n ? raw_spin_rq_lock_nested+0xe/0x20n ? sched_balance_newidle+0x22b/0x3c0n ? update_load_avg+0x78/0x770n ? exc_page_fault+0x6f/0x150n ? asm_exc_page_fault+0x26/0x30n ? __pfx_pci_conf1_write+0x10/0x10n ? strlen+0x4/0x30n devm_kstrdup+0x25/0x70n brcmf_of_probe+0x273/0x350 [brcmfmac],CVE-2025-21750,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet/mlx5: HWS change error flow on matcher disconnectnnCurrently when firmware failure occurs during matcher disconnect flownthe error flow of the function reconnects the matcher back and returnsnan error which continues running the calling function and eventuallynfrees the matcher that is being disconnected.nThis leads to a case where we have a freed matcher on the matchers listnwhich in turn leads to use-after-free and eventual crash.nnThis patch fixes that by not trying to reconnect the matcher back whennsome FW command fails during disconnect.nnNote that we're dealing here with FW error. We can't overcome thisnproblem. This might lead to bad steering state (e.g. wrong connectionnbetween matchers) and will also lead to resource leakage as it isnthe case with any other error handling during resource destruction.nnHowever the goal here is to allow the driver to continue and not crashnthe machine with use-after-free error.,CVE-2025-21751,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbtrfs: fix use-after-free when attempting to join an aborted transactionnnWhen we are trying to join the current transaction and if it's abortednwe read its 'aborted' field after unlocking fs_info->trans_lock andnwithout holding any extra reference count on it. This means that anconcurrent task that is aborting the transaction may free the transactionnbefore we read its 'aborted' field leading to a use-after-free.nnFix this by reading the 'aborted' field while holding fs_info->trans_locknsince any freeing task must first acquire that lock and setnfs_info->running_transaction to NULL before freeing the transaction.nnThis was reported by syzbot and Dmitry with the following stack tracesnfrom KASAN:nn ==================================================================n BUG: KASAN: slab-use-after-free in join_transaction+0xd9b/0xda0 fs/btrfs/transaction.c:278n Read of size 4 at addr ffff888011839024 by task kworker/u4:9/1128nn CPU: 0 UID: 0 PID: 1128 Comm: kworker/u4:9 Not tainted 6.13.0-rc7-syzkaller-00019-gc45323b7560e #0n Hardware name: QEMU Standard PC (Q35 + ICH9 2009) BIOS 1.16.3-debian-1.16.3-2~bpo12+1 04/01/2014n Workqueue: events_unbound btrfs_async_reclaim_data_spacen Call Trace:n <TASK>n __dump_stack lib/dump_stack.c:94 [inline]n dump_stack_lvl+0x241/0x360 lib/dump_stack.c:120n print_address_description mm/kasan/report.c:378 [inline]n print_report+0x169/0x550 mm/kasan/report.c:489n kasan_report+0x143/0x180 mm/kasan/report.c:602n join_transaction+0xd9b/0xda0 fs/btrfs/transaction.c:278n start_transaction+0xaf8/0x1670 fs/btrfs/transaction.c:697n flush_space+0x448/0xcf0 fs/btrfs/space-info.c:803n btrfs_async_reclaim_data_space+0x159/0x510 fs/btrfs/space-info.c:1321n process_one_work kernel/workqueue.c:3236 [inline]n process_scheduled_works+0xa66/0x1840 kernel/workqueue.c:3317n worker_thread+0x870/0xd30 kernel/workqueue.c:3398n kthread+0x2f0/0x390 kernel/kthread.c:389n ret_from_fork+0x4b/0x80 arch/x86/kernel/process.c:147n ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244n </TASK>nn Allocated by task 5315:n kasan_save_stack mm/kasan/common.c:47 [inline]n kasan_save_track+0x3f/0x80 mm/kasan/common.c:68n poison_kmalloc_redzone mm/kasan/common.c:377 [inline]n __kasan_kmalloc+0x98/0xb0 mm/kasan/common.c:394n kasan_kmalloc include/linux/kasan.h:260 [inline]n __kmalloc_cache_noprof+0x243/0x390 mm/slub.c:4329n kmalloc_noprof include/linux/slab.h:901 [inline]n join_transaction+0x144/0xda0 fs/btrfs/transaction.c:308n start_transaction+0xaf8/0x1670 fs/btrfs/transaction.c:697n btrfs_create_common+0x1b2/0x2e0 fs/btrfs/inode.c:6572n lookup_open fs/namei.c:3649 [inline]n open_last_lookups fs/namei.c:3748 [inline]n path_openat+0x1c03/0x3590 fs/namei.c:3984n do_filp_open+0x27f/0x4e0 fs/namei.c:4014n do_sys_openat2+0x13e/0x1d0 fs/open.c:1402n do_sys_open fs/open.c:1417 [inline]n __do_sys_creat fs/open.c:1495 [inline]n __se_sys_creat fs/open.c:1489 [inline]n __x64_sys_creat+0x123/0x170 fs/open.c:1489n do_syscall_x64 arch/x86/entry/common.c:52 [inline]n do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83n entry_SYSCALL_64_after_hwframe+0x77/0x7fnn Freed by task 5336:n kasan_save_stack mm/kasan/common.c:47 [inline]n kasan_save_track+0x3f/0x80 mm/kasan/common.c:68n kasan_save_free_info+0x40/0x50 mm/kasan/generic.c:582n poison_slab_object mm/kasan/common.c:247 [inline]n __kasan_slab_free+0x59/0x70 mm/kasan/common.c:264n kasan_slab_free include/linux/kasan.h:233 [inline]n slab_free_hook mm/slub.c:2353 [inline]n slab_free mm/slub.c:4613 [inline]n kfree+0x196/0x430 mm/slub.c:4761n cleanup_transaction fs/btrfs/transaction.c:2063 [inline]n btrfs_commit_transaction+0x2c97/0x3720 fs/btrfs/transaction.c:2598n insert_balance_item+0x1284/0x20b0 fs/btrfs/volumes.c:3757n btrfs_balance+0x992/n---truncated---,CVE-2025-21753,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnvsock: Keep the binding until socket destructionnnPreserve sockets bindings; this includes both resulting from an explicitnbind() and those implicitly bound through autobind during connect().nnPrevents socket unbinding during a transport reassignment which fixes anuse-after-free:nn 1. vsock_create() (refcnt=1) calls vsock_insert_unbound() (refcnt=2)n 2. transport->release() calls vsock_remove_bound() without checking ifn sk was bound and moved to bound list (refcnt=1)n 3. vsock_bind() assumes sk is in unbound list and beforen __vsock_insert_bound(vsock_bound_sockets()) callsn __vsock_remove_bound() which does:n list_del_init(&vsk->bound_table); // nopn sock_put(&vsk->sk); // refcnt=0nnBUG: KASAN: slab-use-after-free in __vsock_bind+0x62e/0x730nRead of size 4 at addr ffff88816b46a74c by task a.out/2057n dump_stack_lvl+0x68/0x90n print_report+0x174/0x4f6n kasan_report+0xb9/0x190n __vsock_bind+0x62e/0x730n vsock_bind+0x97/0xe0n __sys_bind+0x154/0x1f0n __x64_sys_bind+0x6e/0xb0n do_syscall_64+0x93/0x1b0n entry_SYSCALL_64_after_hwframe+0x76/0x7ennAllocated by task 2057:n kasan_save_stack+0x1e/0x40n kasan_save_track+0x10/0x30n __kasan_slab_alloc+0x85/0x90n kmem_cache_alloc_noprof+0x131/0x450n sk_prot_alloc+0x5b/0x220n sk_alloc+0x2c/0x870n __vsock_create.constprop.0+0x2e/0xb60n vsock_create+0xe4/0x420n __sock_create+0x241/0x650n __sys_socket+0xf2/0x1a0n __x64_sys_socket+0x6e/0xb0n do_syscall_64+0x93/0x1b0n entry_SYSCALL_64_after_hwframe+0x76/0x7ennFreed by task 2057:n kasan_save_stack+0x1e/0x40n kasan_save_track+0x10/0x30n kasan_save_free_info+0x37/0x60n __kasan_slab_free+0x4b/0x70n kmem_cache_free+0x1a1/0x590n __sk_destruct+0x388/0x5a0n __vsock_bind+0x5e1/0x730n vsock_bind+0x97/0xe0n __sys_bind+0x154/0x1f0n __x64_sys_bind+0x6e/0xb0n do_syscall_64+0x93/0x1b0n entry_SYSCALL_64_after_hwframe+0x76/0x7ennrefcount_t: addition on 0; use-after-free.nWARNING: CPU: 7 PID: 2057 at lib/refcount.c:25 refcount_warn_saturate+0xce/0x150nRIP: 0010:refcount_warn_saturate+0xce/0x150n __vsock_bind+0x66d/0x730n vsock_bind+0x97/0xe0n __sys_bind+0x154/0x1f0n __x64_sys_bind+0x6e/0xb0n do_syscall_64+0x93/0x1b0n entry_SYSCALL_64_after_hwframe+0x76/0x7ennrefcount_t: underflow; use-after-free.nWARNING: CPU: 7 PID: 2057 at lib/refcount.c:28 refcount_warn_saturate+0xee/0x150nRIP: 0010:refcount_warn_saturate+0xee/0x150n vsock_remove_bound+0x187/0x1e0n __vsock_release+0x383/0x4a0n vsock_release+0x90/0x120n __sock_release+0xa3/0x250n sock_close+0x14/0x20n __fput+0x359/0xa80n task_work_run+0x107/0x1d0n do_exit+0x847/0x2560n do_group_exit+0xb8/0x250n __x64_sys_exit_group+0x3a/0x50n x64_sys_call+0xfec/0x14f0n do_syscall_64+0x93/0x1b0n entry_SYSCALL_64_after_hwframe+0x76/0x7e,CVE-2025-21756,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnipv6: mcast: add RCU protection to mld_newpack()nnmld_newpack() can be called without RTNL or RCU being held.nnNote that we no longer can use sock_alloc_send_skb() becausenipv6.igmp_sk uses GFP_KERNEL allocations which can sleep.nnInstead use alloc_skb() and charge the net->ipv6.igmp_sknsocket under RCU protection.,CVE-2025-21758,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnipv6: mcast: extend RCU protection in igmp6_send()nnigmp6_send() can be called without RTNL or RCU being held.nnExtend RCU protection so that we can safely fetch the net pointernand avoid a potential UAF.nnNote that we no longer can use sock_alloc_send_skb() becausenipv6.igmp_sk uses GFP_KERNEL allocations which can sleep.nnInstead use alloc_skb() and charge the net->ipv6.igmp_sknsocket under RCU protection.,CVE-2025-21759,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnndisc: extend RCU protection in ndisc_send_skb()nnndisc_send_skb() can be called without RTNL or RCU held.nnAcquire rcu_read_lock() earlier so that we can use dev_net_rcu()nand avoid a potential UAF.,CVE-2025-21760,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnopenvswitch: use RCU protection in ovs_vport_cmd_fill_info()nnovs_vport_cmd_fill_info() can be called without RTNL or RCU.nnUse RCU protection and dev_net_rcu() to avoid potential UAF.,CVE-2025-21761,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnarp: use RCU protection in arp_xmit()nnarp_xmit() can be called without RTNL or RCU protection.nnUse RCU protection to avoid potential UAF.,CVE-2025-21762,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnneighbour: use RCU protection in __neigh_notify()nn__neigh_notify() can be called without RTNL or RCU protection.nnUse RCU protection to avoid potential UAF.,CVE-2025-21763,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnndisc: use RCU protection in ndisc_alloc_skb()nnndisc_alloc_skb() can be called without RTNL or RCU being held.nnAdd RCU protection to avoid possible UAF.,CVE-2025-21764,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnipv6: use RCU protection in ip6_default_advmss()nnip6_default_advmss() needs rcu protection to makensure the net structure it reads does not disappear.,CVE-2025-21765,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnipv4: use RCU protection in __ip_rt_update_pmtu()nn__ip_rt_update_pmtu() must use RCU protection to makensure the net structure it reads does not disappear.,CVE-2025-21766,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnclocksource: Use migrate_disable() to avoid calling get_random_u32() in atomic contextnnThe following bug report happened with a PREEMPT_RT kernel:nn BUG: sleeping function called from invalid context at kernel/locking/spinlock_rt.c:48n in_atomic(): 1 irqs_disabled(): 0 non_block: 0 pid: 2012 name: kwatchdogn preempt_count: 1 expected: 0n RCU nest depth: 0 expected: 0n get_random_u32+0x4f/0x110n clocksource_verify_choose_cpus+0xab/0x1a0n clocksource_verify_percpu.part.0+0x6b/0x330n clocksource_watchdog_kthread+0x193/0x1a0nnIt is due to the fact that clocksource_verify_choose_cpus() is invoked withnpreemption disabled. This function invokes get_random_u32() to obtainnrandom numbers for choosing CPUs. The batched_entropy_32 local lock and/ornthe base_crng.lock spinlock in driver/char/random.c will be acquired duringnthe call. In PREEMPT_RT kernel they are both sleeping locks and so cannotnbe acquired in atomic context.nnFix this problem by using migrate_disable() to allow smp_processor_id() tonbe reliably used without introducing atomic context. preempt_disable() isnthen called after clocksource_verify_choose_cpus() but before thenclocksource measurement is being run to avoid introducing unexpectednlatency.,CVE-2025-21767,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet: ipv6: fix dst ref loops in rpl seg6 and ioam6 lwtunnelsnnSome lwtunnels have a dst cache for post-transformation dst.nIf the packet destination did not change we may end up recordingna reference to the lwtunnel in its own cache and the lwtunnelnstate will never be freed.nnDiscovered by the ioam6.sh test kmemleak was recently fixednto catch per-cpu memory leaks. I'm not sure if rpl and seg6ncan actually hit this but in principle I don't see why not.,CVE-2025-21768,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnpartitions: mac: fix handling of bogus partition tablennFix several issues in partition probing:nn - The bailout for a bad partoffset must use put_dev_sector() since then preceding read_part_sector() succeeded.n - If the partition table claims a silly sector size like 0xfff bytesn (which results in partition table entries straddling sector boundaries)n bail out instead of accessing out-of-bounds memory.n - We must not assume that the partition table contains proper NULn termination - use strnlen() and strncmp() instead of strlen() andn strcmp().,CVE-2025-21772,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnUSB: hub: Ignore non-compliant devices with too many configs or interfacesnnRobert Morris created a test program which can causenusb_hub_to_struct_hub() to dereference a NULL or inappropriatenpointer:nnOops: general protection fault probably for non-canonical addressn0xcccccccccccccccc: 0000 [#1] SMP DEBUG_PAGEALLOC PTInCPU: 7 UID: 0 PID: 117 Comm: kworker/7:1 Not tainted 6.13.0-rc3-00017-gf44d154d6e3d #14nHardware name: FreeBSD BHYVE/BHYVE BIOS 14.0 10/17/2021nWorkqueue: usb_hub_wq hub_eventnRIP: 0010:usb_hub_adjust_deviceremovable+0x78/0x110n...nCall Trace:n <TASK>n ? die_addr+0x31/0x80n ? exc_general_protection+0x1b4/0x3c0n ? asm_exc_general_protection+0x26/0x30n ? usb_hub_adjust_deviceremovable+0x78/0x110n hub_probe+0x7c7/0xab0n usb_probe_interface+0x14b/0x350n really_probe+0xd0/0x2d0n ? __pfx___device_attach_driver+0x10/0x10n __driver_probe_device+0x6e/0x110n driver_probe_device+0x1a/0x90n __device_attach_driver+0x7e/0xc0n bus_for_each_drv+0x7f/0xd0n __device_attach+0xaa/0x1a0n bus_probe_device+0x8b/0xa0n device_add+0x62e/0x810n usb_set_configuration+0x65d/0x990n usb_generic_driver_probe+0x4b/0x70n usb_probe_device+0x36/0xd0nnThe cause of this error is that the device has two interfaces and thenhub driver binds to interface 1 instead of interface 0 which is wherenusb_hub_to_struct_hub() looks.nnWe can prevent the problem from occurring by refusing to accept hubndevices that violate the USB spec by having more than onenconfiguration or interface.,CVE-2025-21776,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnKVM: x86: Reject Hyper-V's SEND_IPI hypercalls if local APIC isn't in-kernelnnAdvertise support for Hyper-V's SEND_IPI and SEND_IPI_EX hypercalls if andnonly if the local API is emulated/virtualized by KVM and explicitly rejectnsaid hypercalls if the local APIC is emulated in userspace i.e. don't relynon userspace to opt-in to KVM_CAP_HYPERV_ENFORCE_CPUID.nnRejecting SEND_IPI and SEND_IPI_EX fixes a NULL-pointer dereference ifnHyper-V enlightenments are exposed to the guest without an in-kernel localnAPIC:nn dump_stack+0xbe/0xfdn __kasan_report.cold+0x34/0x84n kasan_report+0x3a/0x50n __apic_accept_irq+0x3a/0x5c0n kvm_hv_send_ipi.isra.0+0x34e/0x820n kvm_hv_hypercall+0x8d9/0x9d0n kvm_emulate_hypercall+0x506/0x7e0n __vmx_handle_exit+0x283/0xb60n vmx_handle_exit+0x1d/0xd0n vcpu_enter_guest+0x16b0/0x24c0n vcpu_run+0xc0/0x550n kvm_arch_vcpu_ioctl_run+0x170/0x6d0n kvm_vcpu_ioctl+0x413/0xb20n __se_sys_ioctl+0x111/0x160n do_syscal1_64+0x30/0x40n entry_SYSCALL_64_after_hwframe+0x67/0xd1nnNote checking the sending vCPU is sufficient as the per-VM irqchip_modencan't be modified after vCPUs are created i.e. if one vCPU has annin-kernel local APIC then all vCPUs have an in-kernel local APIC.,CVE-2025-21779,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amdgpu: avoid buffer overflow attach in smu_sys_set_pp_table()nnIt malicious user provides a small pptable through sysfs and thenna bigger pptable it may cause buffer overflow attack in functionnsmu_sys_set_pp_table().,CVE-2025-21780,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbatman-adv: fix panic during interface removalnnReference counting is used to ensure thatnbatadv_hardif_neigh_node and batadv_hard_ifacenare not freed before/duringnbatadv_v_elp_throughput_metric_update work isnfinished.nnBut there isn't a guarantee that the hard if willnremain associated with a soft interface up untilnthe work is finished.nnThis fixes a crash triggered by reboot that looksnlike this:nnCall trace:n batadv_v_mesh_free+0xd0/0x4dc [batman_adv]n batadv_v_elp_throughput_metric_update+0x1c/0xa4n process_one_work+0x178/0x398n worker_thread+0x2e8/0x4d0n kthread+0xd8/0xdcn ret_from_fork+0x10/0x20nn(the batadv_v_mesh_free call is misleadingnand does not actually happen)nnI was able to make the issue happen more reliablynby changing hardif_neigh->bat_v.metric_work worknto be delayed work. This allowed me to track downnand confirm the fix.nn[sven@narfation.org: prevent entering batadv_v_elp_get_throughput withoutn soft_iface],CVE-2025-21781,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnorangefs: fix a oob in orangefs_debug_writennI got a syzbot report: slab-out-of-bounds Read innorangefs_debug_write... several people suggested fixesnI tested Al Viro's suggestion and made this patch.,CVE-2025-21782,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnarm64: cacheinfo: Avoid out-of-bounds write to cacheinfo arraynnThe loop that detects/populates cache information already has a boundsncheck on the array size but does not account for cache levels withnseparate data/instructions cache. Fix this by incrementing the indexnfor any populated leaf (instead of any populated level).,CVE-2025-21785,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnteam: better TEAM_OPTION_TYPE_STRING validationnnsyzbot reported following splat [1]nnMake sure user-provided data contains one nul byte.nn[1]n BUG: KMSAN: uninit-value in string_nocheck lib/vsprintf.c:633 [inline]n BUG: KMSAN: uninit-value in string+0x3ec/0x5f0 lib/vsprintf.c:714n string_nocheck lib/vsprintf.c:633 [inline]n string+0x3ec/0x5f0 lib/vsprintf.c:714n vsnprintf+0xa5d/0x1960 lib/vsprintf.c:2843n __request_module+0x252/0x9f0 kernel/module/kmod.c:149n team_mode_get drivers/net/team/team_core.c:480 [inline]n team_change_mode drivers/net/team/team_core.c:607 [inline]n team_mode_option_set+0x437/0x970 drivers/net/team/team_core.c:1401n team_option_set drivers/net/team/team_core.c:375 [inline]n team_nl_options_set_doit+0x1339/0x1f90 drivers/net/team/team_core.c:2662n genl_family_rcv_msg_doit net/netlink/genetlink.c:1115 [inline]n genl_family_rcv_msg net/netlink/genetlink.c:1195 [inline]n genl_rcv_msg+0x1214/0x12c0 net/netlink/genetlink.c:1210n netlink_rcv_skb+0x375/0x650 net/netlink/af_netlink.c:2543n genl_rcv+0x40/0x60 net/netlink/genetlink.c:1219n netlink_unicast_kernel net/netlink/af_netlink.c:1322 [inline]n netlink_unicast+0xf52/0x1260 net/netlink/af_netlink.c:1348n netlink_sendmsg+0x10da/0x11e0 net/netlink/af_netlink.c:1892n sock_sendmsg_nosec net/socket.c:718 [inline]n __sock_sendmsg+0x30f/0x380 net/socket.c:733n ____sys_sendmsg+0x877/0xb60 net/socket.c:2573n ___sys_sendmsg+0x28d/0x3c0 net/socket.c:2627n __sys_sendmsg net/socket.c:2659 [inline]n __do_sys_sendmsg net/socket.c:2664 [inline]n __se_sys_sendmsg net/socket.c:2662 [inline]n __x64_sys_sendmsg+0x212/0x3c0 net/socket.c:2662n x64_sys_call+0x2ed6/0x3c30 arch/x86/include/generated/asm/syscalls_64.h:47n do_syscall_x64 arch/x86/entry/common.c:52 [inline]n do_syscall_64+0xcd/0x1e0 arch/x86/entry/common.c:83n entry_SYSCALL_64_after_hwframe+0x77/0x7f,CVE-2025-21787,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnvrf: use RCU protection in l3mdev_l3_out()nnl3mdev_l3_out() can be called without RCU being held:nnraw_sendmsg()n ip_push_pending_frames()n ip_send_skb()n ip_local_out()n __ip_local_out()n l3mdev_ip_out()nnAdd rcu_read_lock() / rcu_read_unlock() pair to avoidna potential UAF.,CVE-2025-21791,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnax25: Fix refcount leak caused by setting SO_BINDTODEVICE sockoptnnIf an AX25 device is bound to a socket by setting the SO_BINDTODEVICEnsocket option a refcount leak will occur in ax25_release().nnCommit 9fd75b66b8f6 (ax25: Fix refcount leaks caused by ax25_cb_del())nadded decrement of device refcounts in ax25_release(). In order for thatnto work correctly the refcounts must already be incremented when thendevice is bound to the socket. An AX25 device can be bound to a socketnby either calling ax25_bind() or setting SO_BINDTODEVICE socket option.nIn both cases the refcounts should be incremented but in fact it is donenonly in ax25_bind().nnThis bug leads to the following issue reported by Syzkaller:nn================================================================nrefcount_t: decrement hit 0; leaking memory.nWARNING: CPU: 1 PID: 5932 at lib/refcount.c:31 refcount_warn_saturate+0x1ed/0x210 lib/refcount.c:31nModules linked in:nCPU: 1 UID: 0 PID: 5932 Comm: syz-executor424 Not tainted 6.13.0-rc4-syzkaller-00110-g4099a71718b0 #0nHardware name: QEMU Standard PC (Q35 + ICH9 2009) BIOS 1.16.3-debian-1.16.3-2~bpo12+1 04/01/2014nRIP: 0010:refcount_warn_saturate+0x1ed/0x210 lib/refcount.c:31nCall Trace:n <TASK>n __refcount_dec include/linux/refcount.h:336 [inline]n refcount_dec include/linux/refcount.h:351 [inline]n ref_tracker_free+0x710/0x820 lib/ref_tracker.c:236n netdev_tracker_free include/linux/netdevice.h:4156 [inline]n netdev_put include/linux/netdevice.h:4173 [inline]n netdev_put include/linux/netdevice.h:4169 [inline]n ax25_release+0x33f/0xa10 net/ax25/af_ax25.c:1069n __sock_release+0xb0/0x270 net/socket.c:640n sock_close+0x1c/0x30 net/socket.c:1408n ...n do_syscall_x64 arch/x86/entry/common.c:52 [inline]n do_syscall_64+0xcd/0x250 arch/x86/entry/common.c:83n entry_SYSCALL_64_after_hwframe+0x77/0x7fn ...n </TASK>n================================================================nnFix the implementation of ax25_setsockopt() by adding increment ofnrefcounts for the new device bound and decrement of refcounts fornthe old unbound device.,CVE-2025-21792,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnNFSD: fix hang in nfsd4_shutdown_callbacknnIf nfs4_client is in courtesy state then there is no point to sendnthe callback. This causes nfsd4_shutdown_callback to hang sincencl_cb_inflight is not 0. This hang lasts about 15 minutes until TCPnnotifies NFSD that the connection was dropped.nnThis patch modifies nfsd4_run_cb_work to skip the RPC call ifnnfs4_client is in courtesy state.,CVE-2025-21795,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnfsd: clear acl_access/acl_default after releasing themnnIf getting acl_default fails acl_access and acl_default will be releasednsimultaneously. However acl_access will still retain a pointer pointingnto the released posix_acl which will trigger a WARNING innnfs3svc_release_getacl like this:nn------------[ cut here ]------------nrefcount_t: underflow; use-after-free.nWARNING: CPU: 26 PID: 3199 at lib/refcount.c:28nrefcount_warn_saturate+0xb5/0x170nModules linked in:nCPU: 26 UID: 0 PID: 3199 Comm: nfsd Not taintedn6.12.0-rc6-00079-g04ae226af01f-dirty #8nHardware name: QEMU Standard PC (i440FX + PIIX 1996) BIOSn1.16.1-2.fc37 04/01/2014nRIP: 0010:refcount_warn_saturate+0xb5/0x170nCode: cc cc 0f b6 1d b3 20 a5 03 80 fb 01 0f 87 65 48 d8 00 83 e3 01 75ne4 48 c7 c7 c0 3b 9b 85 c6 05 97 20 a5 03 01 e8 fb 3e 30 ff <0f> 0b ebncd 0f b6 1d 8a3nRSP: 0018:ffffc90008637cd8 EFLAGS: 00010282nRAX: 0000000000000000 RBX: 0000000000000000 RCX: ffffffff83904fdenRDX: dffffc0000000000 RSI: 0000000000000008 RDI: ffff88871ed36380nRBP: ffff888158beeb40 R08: 0000000000000001 R09: fffff520010c6f56nR10: ffffc90008637ab7 R11: 0000000000000001 R12: 0000000000000001nR13: ffff888140e77400 R14: ffff888140e77408 R15: ffffffff858b42c0nFS: 0000000000000000(0000) GS:ffff88871ed00000(0000)nknlGS:0000000000000000nCS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033nCR2: 0000562384d32158 CR3: 000000055cc6a000 CR4: 00000000000006f0nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400nCall Trace:n <TASK>n ? refcount_warn_saturate+0xb5/0x170n ? __warn+0xa5/0x140n ? refcount_warn_saturate+0xb5/0x170n ? report_bug+0x1b1/0x1e0n ? handle_bug+0x53/0xa0n ? exc_invalid_op+0x17/0x40n ? asm_exc_invalid_op+0x1a/0x20n ? tick_nohz_tick_stopped+0x1e/0x40n ? refcount_warn_saturate+0xb5/0x170n ? refcount_warn_saturate+0xb5/0x170n nfs3svc_release_getacl+0xc9/0xe0n svc_process_common+0x5db/0xb60n ? __pfx_svc_process_common+0x10/0x10n ? __rcu_read_unlock+0x69/0xa0n ? __pfx_nfsd_dispatch+0x10/0x10n ? svc_xprt_received+0xa1/0x120n ? xdr_init_decode+0x11d/0x190n svc_process+0x2a7/0x330n svc_handle_xprt+0x69d/0x940n svc_recv+0x180/0x2d0n nfsd+0x168/0x200n ? __pfx_nfsd+0x10/0x10n kthread+0x1a2/0x1e0n ? kthread+0xf4/0x1e0n ? __pfx_kthread+0x10/0x10n ret_from_fork+0x34/0x60n ? __pfx_kthread+0x10/0x10n ret_from_fork_asm+0x1a/0x30n </TASK>nKernel panic - not syncing: kernel: panic_on_warn set ...nnClear acl_access/acl_default after posix_acl_release is called to preventnUAF from being triggered.,CVE-2025-21796,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet: ethernet: ti: am65-cpsw: fix freeing IRQ in am65_cpsw_nuss_remove_tx_chns()nnWhen getting the IRQ we use k3_udma_glue_tx_get_irq() which returnsnnegative error value on error. So not NULL check is not sufficientnto deteremine if IRQ is valid. Check that IRQ is greater then zeronto ensure it is valid.nnThere is no issue at probe time but at runtime user can invoken.set_channels which results in the following call chain.nam65_cpsw_set_channels()n am65_cpsw_nuss_update_tx_rx_chns()n am65_cpsw_nuss_remove_tx_chns()n am65_cpsw_nuss_init_tx_chns()nnAt this point if am65_cpsw_nuss_init_tx_chns() fails due tonk3_udma_glue_tx_get_irq() then tx_chn->irq will be set to annegative value.nnThen at subsequent .set_channels with higher channel count wenwill attempt to free an invalid IRQ in am65_cpsw_nuss_remove_tx_chns()nleading to a kernel warning.nnThe issue is present in the original commit that introduced this drivernalthough there am65_cpsw_nuss_update_tx_rx_chns() existed asnam65_cpsw_nuss_update_tx_chns().,CVE-2025-21799,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet: ravb: Fix missing rtnl lock in suspend/resume pathnnFix the suspend/resume path by ensuring the rtnl lock is held wherenrequired. Calls to ravb_open ravb_close and wol operations must benperformed under the rtnl lock to prevent conflicts with ongoing ndonoperations.nnWithout this fix the following warning is triggered:n[ 39.032969] =============================n[ 39.032983] WARNING: suspicious RCU usagen[ 39.033019] -----------------------------n[ 39.033033] drivers/net/phy/phy_device.c:2004 suspiciousnrcu_dereference_protected() usage!n...n[ 39.033597] stack backtrace:n[ 39.033613] CPU: 0 UID: 0 PID: 174 Comm: python3 Not taintedn6.13.0-rc7-next-20250116-arm64-renesas-00002-g35245dfdc62c #7n[ 39.033623] Hardware name: Renesas SMARC EVK version 2 based onnr9a08g045s33 (DT)n[ 39.033628] Call trace:n[ 39.033633] show_stack+0x14/0x1c (C)n[ 39.033652] dump_stack_lvl+0xb4/0xc4n[ 39.033664] dump_stack+0x14/0x1cn[ 39.033671] lockdep_rcu_suspicious+0x16c/0x22cn[ 39.033682] phy_detach+0x160/0x190n[ 39.033694] phy_disconnect+0x40/0x54n[ 39.033703] ravb_close+0x6c/0x1ccn[ 39.033714] ravb_suspend+0x48/0x120n[ 39.033721] dpm_run_callback+0x4c/0x14cn[ 39.033731] device_suspend+0x11c/0x4dcn[ 39.033740] dpm_suspend+0xdc/0x214n[ 39.033748] dpm_suspend_start+0x48/0x60n[ 39.033758] suspend_devices_and_enter+0x124/0x574n[ 39.033769] pm_suspend+0x1ac/0x274n[ 39.033778] state_store+0x88/0x124n[ 39.033788] kobj_attr_store+0x14/0x24n[ 39.033798] sysfs_kf_write+0x48/0x6cn[ 39.033808] kernfs_fop_write_iter+0x118/0x1a8n[ 39.033817] vfs_write+0x27c/0x378n[ 39.033825] ksys_write+0x64/0xf4n[ 39.033833] __arm64_sys_write+0x18/0x20n[ 39.033841] invoke_syscall+0x44/0x104n[ 39.033852] el0_svc_common.constprop.0+0xb4/0xd4n[ 39.033862] do_el0_svc+0x18/0x20n[ 39.033870] el0_svc+0x3c/0xf0n[ 39.033880] el0t_64_sync_handler+0xc0/0xc4n[ 39.033888] el0t_64_sync+0x154/0x158n[ 39.041274] ravb 11c30000.ethernet eth0: Link is Down,CVE-2025-21801,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet: hns3: fix oops when unload drivers parallelingnnWhen unload hclge driver it tries to disable sriov first for eachnae_dev node from hnae3_ae_dev_list. If user unloads hns3 driver atnthe time because it removes all the ae_dev nodes and it may causenoops.nnBut we can't simply use hnae3_common_lock for this. Because in thenprocess flow of pci_disable_sriov() it will trigger the remove flownof VF which will also take hnae3_common_lock.nnTo fixes it introduce a new mutex to protect the unload process.,CVE-2025-21802,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnPCI: rcar-ep: Fix incorrect variable used when calling devm_request_mem_region()nnThe rcar_pcie_parse_outbound_ranges() uses the devm_request_mem_region()nmacro to request a needed resource. A string variable that lives on thenstack is then used to store a dynamically computed resource name whichnis then passed on as one of the macro arguments. This can lead tonundefined behavior.nnDepending on the current contents of the memory the manifestations ofnerrors may vary. One possible output may be as follows:nn $ cat /proc/iomemn 30000000-37ffffff :n 38000000-3fffffff :nnSometimes garbage may appear after the colon.nnIn very rare cases if no NULL-terminator is found in memory the systemnmight crash because the string iterator will overrun which can lead tonaccess of unmapped memory above the stack.nnThus fix this by replacing outbound_name with the name of the previouslynrequested resource. With the changes applied the output will be asnfollows:nn $ cat /proc/iomemn 30000000-37ffffff : memory2n 38000000-3fffffff : memory3nn[kwilczynski: commit log],CVE-2025-21804,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet: let net.core.dev_weight always be non-zeronnThe following problem was encountered during stability test:nn(NULL net_device): NAPI poll function process_backlog+0x0/0x530 ntreturned 1 exceeding its budget of 0.n------------[ cut here ]------------nlist_add double add: new=ffff88905f746f48 prev=ffff88905f746f48 ntnext=ffff88905f746e40.nWARNING: CPU: 18 PID: 5462 at lib/list_debug.c:35 nt__list_add_valid_or_report+0xf3/0x130nCPU: 18 UID: 0 PID: 5462 Comm: ping Kdump: loaded Not tainted 6.13.0-rc7+nRIP: 0010:__list_add_valid_or_report+0xf3/0x130nCall Trace:n? __warn+0xcd/0x250n? __list_add_valid_or_report+0xf3/0x130nenqueue_to_backlog+0x923/0x1070nnetif_rx_internal+0x92/0x2b0n__netif_rx+0x15/0x170nloopback_xmit+0x2ef/0x450ndev_hard_start_xmit+0x103/0x490n__dev_queue_xmit+0xeac/0x1950nip_finish_output2+0x6cc/0x1620nip_output+0x161/0x270nip_push_pending_frames+0x155/0x1a0nraw_sendmsg+0xe13/0x1550n__sys_sendto+0x3bf/0x4e0n__x64_sys_sendto+0xdc/0x1b0ndo_syscall_64+0x5b/0x170nentry_SYSCALL_64_after_hwframe+0x76/0x7ennThe reproduction command is as follows:n sysctl -w net.core.dev_weight=0n ping 127.0.0.1nnThis is because when the napi's weight is set to 0 process_backlog() maynreturn 0 and clear the NAPI_STATE_SCHED bit of napi->state causing thisnnapi to be re-polled in net_rx_action() until __do_softirq() times out.nSince the NAPI_STATE_SCHED bit has been cleared napi_schedule_rps() cannbe retriggered in enqueue_to_backlog() causing this issue.nnMaking the napi's weight always non-zero solves this problem.nnTriggering this issue requires system-wide admin (setting isnnot namespaced).,CVE-2025-21806,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnilfs2: protect access to buffers with no active referencesnnnilfs_lookup_dirty_data_buffers() which iterates through the buffersnattached to dirty data folios/pages accesses the attached buffers withoutnlocking the folios/pages.nnFor data cache nilfs_clear_folio_dirty() may be called asynchronouslynwhen the file system degenerates to read only sonnilfs_lookup_dirty_data_buffers() still has the potential to cause usenafter free issues when buffers lose the protection of their dirty statenmidway due to this asynchronous clearing and are unintentionally freed byntry_to_free_buffers().nnEliminate this race issue by adjusting the lock section in this function.,CVE-2025-21811,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnax25: rcu protect dev->ax25_ptrnnsyzbot found a lockdep issue [1].nnWe should remove ax25 RTNL dependency in ax25_setsockopt()nnThis should also fix a variety of possible UAF in ax25.nn[1]nnWARNING: possible circular locking dependency detectedn6.13.0-rc3-syzkaller-00762-g9268abe611b0 #0 Not taintedn------------------------------------------------------nsyz.5.1818/12806 is trying to acquire lock:n ffffffff8fcb3988 (rtnl_mutex){+.+.}-{4:4} at: ax25_setsockopt+0xa55/0xe90 net/ax25/af_ax25.c:680nnbut task is already holding lock:n ffff8880617ac258 (sk_lock-AF_AX25){+.+.}-{0:0} at: lock_sock include/net/sock.h:1618 [inline]n ffff8880617ac258 (sk_lock-AF_AX25){+.+.}-{0:0} at: ax25_setsockopt+0x209/0xe90 net/ax25/af_ax25.c:574nnwhich lock already depends on the new lock.nnthe existing dependency chain (in reverse order) is:nn-> #1 (sk_lock-AF_AX25){+.+.}-{0:0}:n lock_acquire+0x1ed/0x550 kernel/locking/lockdep.c:5849n lock_sock_nested+0x48/0x100 net/core/sock.c:3642n lock_sock include/net/sock.h:1618 [inline]n ax25_kill_by_device net/ax25/af_ax25.c:101 [inline]n ax25_device_event+0x24d/0x580 net/ax25/af_ax25.c:146n notifier_call_chain+0x1a5/0x3f0 kernel/notifier.c:85n __dev_notify_flags+0x207/0x400n dev_change_flags+0xf0/0x1a0 net/core/dev.c:9026n dev_ifsioc+0x7c8/0xe70 net/core/dev_ioctl.c:563n dev_ioctl+0x719/0x1340 net/core/dev_ioctl.c:820n sock_do_ioctl+0x240/0x460 net/socket.c:1234n sock_ioctl+0x626/0x8e0 net/socket.c:1339n vfs_ioctl fs/ioctl.c:51 [inline]n __do_sys_ioctl fs/ioctl.c:906 [inline]n __se_sys_ioctl+0xf5/0x170 fs/ioctl.c:892n do_syscall_x64 arch/x86/entry/common.c:52 [inline]n do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83n entry_SYSCALL_64_after_hwframe+0x77/0x7fnn-> #0 (rtnl_mutex){+.+.}-{4:4}:n check_prev_add kernel/locking/lockdep.c:3161 [inline]n check_prevs_add kernel/locking/lockdep.c:3280 [inline]n validate_chain+0x18ef/0x5920 kernel/locking/lockdep.c:3904n __lock_acquire+0x1397/0x2100 kernel/locking/lockdep.c:5226n lock_acquire+0x1ed/0x550 kernel/locking/lockdep.c:5849n __mutex_lock_common kernel/locking/mutex.c:585 [inline]n __mutex_lock+0x1ac/0xee0 kernel/locking/mutex.c:735n ax25_setsockopt+0xa55/0xe90 net/ax25/af_ax25.c:680n do_sock_setsockopt+0x3af/0x720 net/socket.c:2324n __sys_setsockopt net/socket.c:2349 [inline]n __do_sys_setsockopt net/socket.c:2355 [inline]n __se_sys_setsockopt net/socket.c:2352 [inline]n __x64_sys_setsockopt+0x1ee/0x280 net/socket.c:2352n do_syscall_x64 arch/x86/entry/common.c:52 [inline]n do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83n entry_SYSCALL_64_after_hwframe+0x77/0x7fnnother info that might help us debug this:nn Possible unsafe locking scenario:nn CPU0 CPU1n ---- ----n lock(sk_lock-AF_AX25);n lock(rtnl_mutex);n lock(sk_lock-AF_AX25);n lock(rtnl_mutex);nn output.log scan_tyk_dockerimages.sh vulnerabilities.csv DEADLOCK ***nn1 lock held by syz.5.1818/12806:n #0: ffff8880617ac258 (sk_lock-AF_AX25){+.+.}-{0:0} at: lock_sock include/net/sock.h:1618 [inline]n #0: ffff8880617ac258 (sk_lock-AF_AX25){+.+.}-{0:0} at: ax25_setsockopt+0x209/0xe90 net/ax25/af_ax25.c:574nnstack backtrace:nCPU: 1 UID: 0 PID: 12806 Comm: syz.5.1818 Not tainted 6.13.0-rc3-syzkaller-00762-g9268abe611b0 #0nHardware name: Google Google Compute Engine/Google Compute Engine BIOS Google 09/13/2024nCall Trace:n <TASK>n __dump_stack lib/dump_stack.c:94 [inline]n dump_stack_lvl+0x241/0x360 lib/dump_stack.c:120n print_circular_bug+0x13a/0x1b0 kernel/locking/lockdep.c:2074n check_noncircular+0x36a/0x4a0 kernel/locking/lockdep.c:2206n check_prev_add kernel/locking/lockdep.c:3161 [inline]n check_prevs_add kernel/lockinn---truncated---,CVE-2025-21812,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnptp: Ensure info->enable callback is always setnnThe ioctl and sysfs handlers unconditionally call the ->enable callback.nNot all drivers implement that callback leading to NULL dereferences.nExample of affected drivers: ptp_s390.c ptp_vclock.c and ptp_mock.c.nnInstead use a dummy callback if no better was specified by the driver.,CVE-2025-21814,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnhrtimers: Force migrate away hrtimers queued after CPUHP_AP_HRTIMERS_DYINGnnhrtimers are migrated away from the dying CPU to any online target atnthe CPUHP_AP_HRTIMERS_DYING stage in order not to delay bandwidth timersnhandling tasks involved in the CPU hotplug forward progress.nnHowever wakeups can still be performed by the outgoing CPU afternCPUHP_AP_HRTIMERS_DYING. Those can result again in bandwidth timers beingnarmed. Depending on several considerations (crystal ball power managementnbased election earliest timer already enqueued timer migration enabled ornnot) the target may eventually be the current CPU even if offline. If thatnhappens the timer is eventually ignored.nnThe most notable example is RCU which had to deal with each and every ofnthose wake-ups by deferring them to an online CPU along with relatednworkarounds:nn_ e787644caf76 (rcu: Defer RCU kthreads wakeup when CPU is dying)n_ 9139f93209d1 (rcu/nocb: Fix RT throttling hrtimer armed from offline CPU)n_ f7345ccc62a4 (rcu/nocb: Fix rcuog wake-up from offline softirq)nnThe problem isn't confined to RCU though as the stop machine kthreadn(which runs CPUHP_AP_HRTIMERS_DYING) reports its completion at the endnof its work through cpu_stop_signal_done() and performs a wake up thatneventually arms the deadline server timer:nn WARNING: CPU: 94 PID: 588 at kernel/time/hrtimer.c:1086 hrtimer_start_range_ns+0x289/0x2d0n CPU: 94 UID: 0 PID: 588 Comm: migration/94 Not taintedn Stopper: multi_cpu_stop+0x0/0x120 <- stop_machine_cpuslocked+0x66/0xc0n RIP: 0010:hrtimer_start_range_ns+0x289/0x2d0n Call Trace:n <TASK>n start_dl_timern enqueue_dl_entityn dl_server_startn enqueue_task_fairn enqueue_taskn ttwu_do_activaten try_to_wake_upn completen cpu_stopper_threadnnInstead of providing yet another bandaid to work around the situation fixnit in the hrtimers infrastructure instead: always migrate away a timer tonan online target whenever it is enqueued from an offline CPU.nnThis will also allow to revert all the above RCU disgraceful hacks.,CVE-2025-21816,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnblock: mark GFP_NOIO around sysfs ->store()nnsysfs ->store is called with queue freezed meantime we have severaln->store() callbacks(update_nr_requests wbt scheduler) to allocatenmemory with GFP_KERNEL which may run into direct reclaim code pathnthen potential deadlock can be caused.nnFix the issue by marking NOIO around sysfs ->store(),CVE-2025-21817,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nntty: xilinx_uartps: split sysrq handlingnnlockdep detects the following circular locking dependency:nnCPU 0 CPU 1n========================== ============================ncdns_uart_isr() printk()n uart_port_lock(port) console_lock()nttt cdns_uart_console_write()n if (!port->sysrq)n uart_port_lock(port)n uart_handle_break()n port->sysrq = ...n uart_handle_sysrq_char()n printk()n console_lock()nnThe fixed commit attempts to avoid this situation by only taking thenport lock in cdns_uart_console_write if port->sysrq unset. However ifn(as shown above) cdns_uart_console_write runs before port->sysrq is setnthen it will try to take the port lock anyway. This may result in andeadlock.nnFix this by splitting sysrq handling into two parts. We use the preparenhelper under the port lock and defer handling until we release the lock.,CVE-2025-21820,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnfbdev: omap: use threaded IRQ for LCD DMAnnWhen using touchscreen and framebuffer Nokia 770 crashes easily with:nn BUG: scheduling while atomic: irq/144-ads7846/82/0x00010000n Modules linked in: usb_f_ecm g_ether usb_f_rndis u_ether libcomposite configfs omap_udc ohci_omap ohci_hcdn CPU: 0 UID: 0 PID: 82 Comm: irq/144-ads7846 Not tainted 6.12.7-770 #2n Hardware name: Nokia 770n Call trace:n unwind_backtrace from show_stack+0x10/0x14n show_stack from dump_stack_lvl+0x54/0x5cn dump_stack_lvl from __schedule_bug+0x50/0x70n __schedule_bug from __schedule+0x4d4/0x5bcn __schedule from schedule+0x34/0xa0n schedule from schedule_preempt_disabled+0xc/0x10n schedule_preempt_disabled from __mutex_lock.constprop.0+0x218/0x3b4n __mutex_lock.constprop.0 from clk_prepare_lock+0x38/0xe4n clk_prepare_lock from clk_set_rate+0x18/0x154n clk_set_rate from sossi_read_data+0x4c/0x168n sossi_read_data from hwa742_read_reg+0x5c/0x8cn hwa742_read_reg from send_frame_handler+0xfc/0x300n send_frame_handler from process_pending_requests+0x74/0xd0n process_pending_requests from lcd_dma_irq_handler+0x50/0x74n lcd_dma_irq_handler from __handle_irq_event_percpu+0x44/0x130n __handle_irq_event_percpu from handle_irq_event+0x28/0x68n handle_irq_event from handle_level_irq+0x9c/0x170n handle_level_irq from generic_handle_domain_irq+0x2c/0x3cn generic_handle_domain_irq from omap1_handle_irq+0x40/0x8cn omap1_handle_irq from generic_handle_arch_irq+0x28/0x3cn generic_handle_arch_irq from call_with_stack+0x1c/0x24n call_with_stack from __irq_svc+0x94/0xa8n Exception stack(0xc5255da0 to 0xc5255de8)n 5da0: 00000001 c22fc620 00000000 00000000 c08384a8 c106fc00 00000000 c240c248n 5dc0: c113a600 c3f6ec30 00000001 00000000 c22fc620 c5255df0 c22fc620 c0279a94n 5de0: 60000013 ffffffffn __irq_svc from clk_prepare_lock+0x4c/0xe4n clk_prepare_lock from clk_get_rate+0x10/0x74n clk_get_rate from uwire_setup_transfer+0x40/0x180n uwire_setup_transfer from spi_bitbang_transfer_one+0x2c/0x9cn spi_bitbang_transfer_one from spi_transfer_one_message+0x2d0/0x664n spi_transfer_one_message from __spi_pump_transfer_message+0x29c/0x498n __spi_pump_transfer_message from __spi_sync+0x1f8/0x2e8n __spi_sync from spi_sync+0x24/0x40n spi_sync from ads7846_halfd_read_state+0x5c/0x1c0n ads7846_halfd_read_state from ads7846_irq+0x58/0x348n ads7846_irq from irq_thread_fn+0x1c/0x78n irq_thread_fn from irq_thread+0x120/0x228n irq_thread from kthread+0xc8/0xe8n kthread from ret_from_fork+0x14/0x28nnAs a quick fix switch to a threaded IRQ which provides a stable system.,CVE-2025-21821,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbatman-adv: Drop unmanaged ELP metric workernnThe ELP worker needs to calculate new metric values for all neighborsnreachable over an interface. Some of the used metric sources requirenlocks which might need to sleep. This sleep is incompatible with the RCUnlist iterator used for the recorded neighbors. The initial approach to worknaround of this problem was to queue another work item per neighbor and thennrun this in a new context.nnEven when this solved the RCU vs might_sleep() conflict it has a majornproblems: Nothing was stopping the work item in case it is not needednanymore - for example because one of the related interfaces was removed ornthe batman-adv module was unloaded - resulting in potential invalid memorynaccesses.nnDirectly canceling the metric worker also has various problems:nn* cancel_work_sync for a to-be-deactivated interface is called withn rtnl_lock held. But the code in the ELP metric worker also tries to usen rtnl_lock() - which will never return in this case. This also means thatn cancel_work_sync would never return because it is waiting for the workern to finish.n* iterating over the neighbor list for the to-be-deactivated interface isn currently done using the RCU specific methods. Which means that it isn possible to miss items when iterating over it without the associatedn spinlock - a behaviour which is acceptable for a periodic metric checkn but not for a cleanup routine (which must stop all still runningn workers)nnThe better approch is to get rid of the per interface neighbor metricnworker and handle everything in the interface worker. The original problemsnare solved by:nn* creating a list of neighbors which require new metric information insiden the RCU protected context gathering the metric according to the new listn outside the RCU protected contextn* only use rcu_trylock inside metric gathering code to avoid a deadlockn when the cancel_delayed_work_sync is called in the interface removal coden (which is called with the rtnl_lock held),CVE-2025-21823,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnetfilter: nf_tables: reject mismatching sum of field_len with set key lengthnnThe field length description provides the length of each separated keynfield in the concatenation each field gets rounded up to 32-bits toncalculate the pipapo rule width from pipapo_init(). The set key lengthnprovides the total size of the key aligned to 32-bits.nnRegister-based arithmetics still allows for combining mismatching setnkey length and field length description eg. set key length 10 and fieldndescription [ 5 4 ] leading to pipapo width of 12.,CVE-2025-21826,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnPCI: Avoid putting some root ports into D3 on TUXEDO Sirius Gen1nncommit 9d26d3a8f1b0 (PCI: Put PCIe ports into D3 during suspend) sets thenpolicy that all PCIe ports are allowed to use D3. When the system isnsuspended if the port is not power manageable by the platform and won't benused for wakeup via a PME this sets up the policy for these ports to goninto D3hot.nnThis policy generally makes sense from an OSPM perspective but it leads tonproblems with wakeup from suspend on the TUXEDO Sirius 16 Gen 1 with anspecific old BIOS. This manifests as a system hang.nnOn the affected Device + BIOS combination add a quirk for the root port ofnthe problematic controller to ensure that these root ports are not put intonD3hot at suspend.nnThis patch is based onnn https://lore.kernel.org/linux-pci/20230708214457.1229-2-mario.limonciello@amd.comnnbut with the added condition both in the documentation and in the code tonapply only to the TUXEDO Sirius 16 Gen 1 with a specific old BIOS and onlynthe affected root ports.,CVE-2025-21831,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnusb: gadget: f_midi: fix MIDI Streaming descriptor lengthsnnWhile the MIDI jacks are configured correctly and the MIDIStreamingnendpoint descriptors are filled with the correct informationnbNumEmbMIDIJack and bLength are set incorrectly in these descriptors.nnThis does not matter when the numbers of in and out ports are equal butnwhen they differ the host will receive broken descriptors withnuninitialized stack memory leaking into the descriptor for whichevernvalue is smaller.nnThe precise meaning of in and out in the port counts is not clearlyndefined and can be confusing. But elsewhere the driver consistentlynuses this to match the USB meaning of IN and OUT viewed from the hostnso that in ports send data to the host and out ports receive datanfrom it.,CVE-2025-21835,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnusb: gadget: core: flush gadget workqueue after device removalnndevice_del() can lead to new work being scheduled in gadget->worknworkqueue. This is observed for example with the dwc3 driver with thenfollowing call stack:n device_del()n gadget_unbind_driver()n usb_gadget_disconnect_locked()n dwc3_gadget_pullup()nt dwc3_gadget_soft_disconnect()nt usb_gadget_set_state()nt schedule_work(&gadget->work)nnMove flush_work() after device_del() to ensure the workqueue is cleanednup.,CVE-2025-21838,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnKVM: x86: Load DR6 with guest value only before entering .vcpu_run() loopnnMove the conditional loading of hardware DR6 with the guest's DR6 valuenout of the core .vcpu_run() loop to fix a bug where KVM can load hardwarenwith a stale vcpu->arch.dr6.nnWhen the guest accesses a DR and host userspace isn't debugging the guestnKVM disables DR interception and loads the guest's values into hardware onnVM-Enter and saves them on VM-Exit. This allows the guest to access DRsnat will e.g. so that a sequence of DR accesses to configure a breakpointnonly generates one VM-Exit.nnFor DR0-DR3 the logic/behavior is identical between VMX and SVM and alsonidentical between KVM_DEBUGREG_BP_ENABLED (userspace debugging the guest)nand KVM_DEBUGREG_WONT_EXIT (guest using DRs) and so KVM handles loadingnDR0-DR3 in common code _outside_ of the core kvm_x86_ops.vcpu_run() loop.nnBut for DR6 the guest's value doesn't need to be loaded into hardware fornKVM_DEBUGREG_BP_ENABLED and SVM provides a dedicated VMCB field whereasnVMX requires software to manually load the guest value and so loading thenguest's value into DR6 is handled by {svmvmx}_vcpu_run() i.e. is donen_inside_ the core run loop.nnUnfortunately saving the guest values on VM-Exit is initiated by commonnx86 again outside of the core run loop. If the guest modifies DR6 (innhardware when DR interception is disabled) and then the next VM-Exit isna fastpath VM-Exit KVM will reload hardware DR6 with vcpu->arch.dr6 andnclobber the guest's actual value.nnThe bug shows up primarily with nested VMX because KVM handles the VMXnpreemption timer in the fastpath and the window between hardware DR6nbeing modified (in guest context) and DR6 being read by guest software isnorders of magnitude larger in a nested setup. E.g. in non-nested thenVMX preemption timer would need to fire precisely between #DB injectionnand the #DB handler's read of DR6 whereas with a KVM-on-KVM setup thenwindow where hardware DR6 is dirty extends all the way from L1 writingnDR6 to VMRESUME (in L1).nn L1's view:n ==========n <L1 disables DR interception>n CPU 0/KVM-7289 [023] d.... 2925.640961: kvm_entry: vcpu 0n A: L1 Writes DR6n CPU 0/KVM-7289 [023] d.... 2925.640963: <hack>: Set DRs DR6 = 0xffff0ff1nn B: CPU 0/KVM-7289 [023] d.... 2925.640967: kvm_exit: vcpu 0 reason EXTERNAL_INTERRUPT intr_info 0x800000ecnn D: L1 reads DR6 arch.dr6 = 0n CPU 0/KVM-7289 [023] d.... 2925.640969: <hack>: Sync DRs DR6 = 0xffff0ff0nn CPU 0/KVM-7289 [023] d.... 2925.640976: kvm_entry: vcpu 0n L2 reads DR6 L1 disables DR interceptionn CPU 0/KVM-7289 [023] d.... 2925.640980: kvm_exit: vcpu 0 reason DR_ACCESS info1 0x0000000000000216n CPU 0/KVM-7289 [023] d.... 2925.640983: kvm_entry: vcpu 0nn CPU 0/KVM-7289 [023] d.... 2925.640983: <hack>: Set DRs DR6 = 0xffff0ff0nn L2 detects failuren CPU 0/KVM-7289 [023] d.... 2925.640987: kvm_exit: vcpu 0 reason HLTn L1 reads DR6 (confirms failure)n CPU 0/KVM-7289 [023] d.... 2925.640990: <hack>: Sync DRs DR6 = 0xffff0ff0nn L0's view:n ==========n L2 reads DR6 arch.dr6 = 0n CPU 23/KVM-5046 [001] d.... 3410.005610: kvm_exit: vcpu 23 reason DR_ACCESS info1 0x0000000000000216n CPU 23/KVM-5046 [001] ..... 3410.005610: kvm_nested_vmexit: vcpu 23 reason DR_ACCESS info1 0x0000000000000216nn L2 => L1 nested VM-Exitn CPU 23/KVM-5046 [001] ..... 3410.005610: kvm_nested_vmexit_inject: reason: DR_ACCESS ext_inf1: 0x0000000000000216nn CPU 23/KVM-5046 [001] d.... 3410.005610: kvm_entry: vcpu 23n CPU 23/KVM-5046 [001] d.... 3410.005611: kvm_exit: vcpu 23 reason VMREADn CPU 23/KVM-5046 [001] d.... 3410.005611: kvm_entry: vcpu 23n CPU 23/KVM-5046 [001] d.... 3410.n---truncated---,CVE-2025-21839,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnsmb: client: Add check for next_buffer in receive_encrypted_standard()nnAdd check for the return value of cifs_buf_get() and cifs_small_buf_get()nin receive_encrypted_standard() to prevent null pointer dereference.,CVE-2025-21844,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnacct: perform last write from workqueuennIn [1] it was reported that the acct(2) system call can be used tontrigger NULL deref in cases where it is set to write to a file thatntriggers an internal lookup. This can e.g. happen when pointing acc(2)nto /sys/power/resume. At the point the where the write to this filenhappens the calling task has already exited and called exit_fs(). Anlookup will thus trigger a NULL-deref when accessing current->fs.nnReorganize the code so that the the final write happens from thenworkqueue but with the caller's credentials. This preserves then(strange) permission model and has almost no regression risk.nnThis api should stop to exist though.,CVE-2025-21846,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnfp: bpf: Add check for nfp_app_ctrl_msg_alloc()nnAdd check for the return value of nfp_app_ctrl_msg_alloc() innnfp_bpf_cmsg_alloc() to prevent null pointer dereference.,CVE-2025-21848,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbpf: avoid holding freeze_mutex during mmap operationnnWe use map->freeze_mutex to prevent races between map_freeze() andnmemory mapping BPF map contents with writable permissions. The way wennaively do this means we'll hold freeze_mutex for entire duration of allnthe mm and VMA manipulations which is completely unnecessary. This cannpotentially also lead to deadlocks as reported by syzbot in [0].nnSo instead hold freeze_mutex only during writeability checks bumpn(proactively) write active count for the map unlock the mutex andnproceed with mmap logic. And only if something went wrong during mmapnlogic then undo that write active counter increment.nn [0] https://lore.kernel.org/bpf/678dcbc9.050a0220.303755.0066.GAE@google.com/,CVE-2025-21853,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnibmvnic: Don't reference skb after sending to VIOSnnPreviously after successfully flushing the xmit buffer to VIOSnthe tx_bytes stat was incremented by the length of the skb.nnIt is invalid to access the skb memory after sending the buffer tonthe VIOS because at any point after sending the VIOS can triggernan interrupt to free this memory. A race between reading skb->lennand freeing the skb is possible (especially during LPM) and willnresult in use-after-free:n ==================================================================n BUG: KASAN: slab-use-after-free in ibmvnic_xmit+0x75c/0x1808 [ibmvnic]n Read of size 4 at addr c00000024eb48a70 by task hxecom/14495n <...>n Call Trace:n [c000000118f66cf0] [c0000000018cba6c] dump_stack_lvl+0x84/0xe8 (unreliable)n [c000000118f66d20] [c0000000006f0080] print_report+0x1a8/0x7f0n [c000000118f66df0] [c0000000006f08f0] kasan_report+0x128/0x1f8n [c000000118f66f00] [c0000000006f2868] __asan_load4+0xac/0xe0n [c000000118f66f20] [c0080000046eac84] ibmvnic_xmit+0x75c/0x1808 [ibmvnic]n [c000000118f67340] [c0000000014be168] dev_hard_start_xmit+0x150/0x358n <...>n Freed by task 0:n kasan_save_stack+0x34/0x68n kasan_save_track+0x2c/0x50n kasan_save_free_info+0x64/0x108n __kasan_mempool_poison_object+0x148/0x2d4n napi_skb_cache_put+0x5c/0x194n net_tx_action+0x154/0x5b8n handle_softirqs+0x20c/0x60cn do_softirq_own_stack+0x6c/0x88n <...>n The buggy address belongs to the object at c00000024eb48a00 whichn belongs to the cache skbuff_head_cache of size 224n==================================================================,CVE-2025-21855,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nngeneve: Fix use-after-free in geneve_find_dev().nnsyzkaller reported a use-after-free in geneve_find_dev() [0]nwithout repro.nngeneve_configure() links struct geneve_dev.next tonnet_generic(net geneve_net_id)->geneve_list.nnThe net here could differ from dev_net(dev) if IFLA_NET_NS_PIDnIFLA_NET_NS_FD or IFLA_TARGET_NETNSID is set.nnWhen dev_net(dev) is dismantled geneve_exit_batch_rtnl() finallyncalls unregister_netdevice_queue() for each dev in the netnsnand later the dev is freed.nnHowever its geneve_dev.next is still linked to the backend UDPnsocket netns.nnThen use-after-free will occur when another geneve dev is creatednin the netns.nnLet's call geneve_dellink() instead in geneve_destroy_tunnels().nn[0]:nBUG: KASAN: slab-use-after-free in geneve_find_dev drivers/net/geneve.c:1295 [inline]nBUG: KASAN: slab-use-after-free in geneve_configure+0x234/0x858 drivers/net/geneve.c:1343nRead of size 2 at addr ffff000054d6ee24 by task syz.1.4029/13441nnCPU: 1 UID: 0 PID: 13441 Comm: syz.1.4029 Not tainted 6.13.0-g0ad9617c78ac #24 dc35ca22c79fb82e8e7bc5c9c9adafea898b1e3dnHardware name: linuxdummy-virt (DT)nCall trace:n show_stack+0x38/0x50 arch/arm64/kernel/stacktrace.c:466 (C)n __dump_stack lib/dump_stack.c:94 [inline]n dump_stack_lvl+0xbc/0x108 lib/dump_stack.c:120n print_address_description mm/kasan/report.c:378 [inline]n print_report+0x16c/0x6f0 mm/kasan/report.c:489n kasan_report+0xc0/0x120 mm/kasan/report.c:602n __asan_report_load2_noabort+0x20/0x30 mm/kasan/report_generic.c:379n geneve_find_dev drivers/net/geneve.c:1295 [inline]n geneve_configure+0x234/0x858 drivers/net/geneve.c:1343n geneve_newlink+0xb8/0x128 drivers/net/geneve.c:1634n rtnl_newlink_create+0x23c/0x868 net/core/rtnetlink.c:3795n __rtnl_newlink net/core/rtnetlink.c:3906 [inline]n rtnl_newlink+0x1054/0x1630 net/core/rtnetlink.c:4021n rtnetlink_rcv_msg+0x61c/0x918 net/core/rtnetlink.c:6911n netlink_rcv_skb+0x1dc/0x398 net/netlink/af_netlink.c:2543n rtnetlink_rcv+0x34/0x50 net/core/rtnetlink.c:6938n netlink_unicast_kernel net/netlink/af_netlink.c:1322 [inline]n netlink_unicast+0x618/0x838 net/netlink/af_netlink.c:1348n netlink_sendmsg+0x5fc/0x8b0 net/netlink/af_netlink.c:1892n sock_sendmsg_nosec net/socket.c:713 [inline]n __sock_sendmsg net/socket.c:728 [inline]n ____sys_sendmsg+0x410/0x6f8 net/socket.c:2568n ___sys_sendmsg+0x178/0x1d8 net/socket.c:2622n __sys_sendmsg net/socket.c:2654 [inline]n __do_sys_sendmsg net/socket.c:2659 [inline]n __se_sys_sendmsg net/socket.c:2657 [inline]n __arm64_sys_sendmsg+0x12c/0x1c8 net/socket.c:2657n __invoke_syscall arch/arm64/kernel/syscall.c:35 [inline]n invoke_syscall+0x90/0x278 arch/arm64/kernel/syscall.c:49n el0_svc_common+0x13c/0x250 arch/arm64/kernel/syscall.c:132n do_el0_svc+0x54/0x70 arch/arm64/kernel/syscall.c:151n el0_svc+0x4c/0xa8 arch/arm64/kernel/entry-common.c:744n el0t_64_sync_handler+0x78/0x108 arch/arm64/kernel/entry-common.c:762n el0t_64_sync+0x198/0x1a0 arch/arm64/kernel/entry.S:600nnAllocated by task 13247:n kasan_save_stack mm/kasan/common.c:47 [inline]n kasan_save_track+0x30/0x68 mm/kasan/common.c:68n kasan_save_alloc_info+0x44/0x58 mm/kasan/generic.c:568n poison_kmalloc_redzone mm/kasan/common.c:377 [inline]n __kasan_kmalloc+0x84/0xa0 mm/kasan/common.c:394n kasan_kmalloc include/linux/kasan.h:260 [inline]n __do_kmalloc_node mm/slub.c:4298 [inline]n __kmalloc_node_noprof+0x2a0/0x560 mm/slub.c:4304n __kvmalloc_node_noprof+0x9c/0x230 mm/util.c:645n alloc_netdev_mqs+0xb8/0x11a0 net/core/dev.c:11470n rtnl_create_link+0x2b8/0xb50 net/core/rtnetlink.c:3604n rtnl_newlink_create+0x19c/0x868 net/core/rtnetlink.c:3780n __rtnl_newlink net/core/rtnetlink.c:3906 [inline]n rtnl_newlink+0x1054/0x1630 net/core/rtnetlink.c:4021n rtnetlink_rcv_msg+0x61c/0x918 net/core/rtnetlink.c:6911n netlink_rcv_skb+0x1dc/0x398 net/netlink/af_netlink.c:2543n rtnetlink_rcv+0x34/0x50 net/core/rtnetlink.c:6938n netlink_unicast_kernel net/netlink/af_nn---truncated---,CVE-2025-21858,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnUSB: gadget: f_midi: f_midi_complete to call queue_worknnWhen using USB MIDI a lock is attempted to be acquired twice through anre-entrant call to f_midi_transmit causing a deadlock.nnFix it by using queue_work() to schedule the inner f_midi_transmit() viana high priority work queue from the completion handler.,CVE-2025-21859,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnmm/migrate_device: don't add folio to be freed to LRU in migrate_device_finalize()nnIf migration succeeded we callednfolio_migrate_flags()->mem_cgroup_migrate() to migrate the memcg from thenold to the new folio. This will set memcg_data of the old folio to 0.nnSimilarly if migration failed memcg_data of the dst folio is left unset.nnIf we call folio_putback_lru() on such folios (memcg_data == 0) we willnadd the folio to be freed to the LRU making memcg code unhappy. Runningnthe hmm selftests:nn # ./hmm-testsn ...n # RUN hmm.hmm_device_private.migrate ...n [ 102.078007][T14893] page: refcount:1 mapcount:0 mapping:0000000000000000 index:0x7ff27d200 pfn:0x13cc00n [ 102.079974][T14893] anon flags: 0x17ff00000020018(uptodate|dirty|swapbacked|node=0|zone=2|lastcpupid=0x7ff)n [ 102.082037][T14893] raw: 017ff00000020018 dead000000000100 dead000000000122 ffff8881353896c9n [ 102.083687][T14893] raw: 00000007ff27d200 0000000000000000 00000001ffffffff 0000000000000000n [ 102.085331][T14893] page dumped because: VM_WARN_ON_ONCE_FOLIO(!memcg && !mem_cgroup_disabled())n [ 102.087230][T14893] ------------[ cut here ]------------n [ 102.088279][T14893] WARNING: CPU: 0 PID: 14893 at ./include/linux/memcontrol.h:726 folio_lruvec_lock_irqsave+0x10e/0x170n [ 102.090478][T14893] Modules linked in:n [ 102.091244][T14893] CPU: 0 UID: 0 PID: 14893 Comm: hmm-tests Not tainted 6.13.0-09623-g6c216bc522fd #151n [ 102.093089][T14893] Hardware name: QEMU Standard PC (Q35 + ICH9 2009) BIOS 1.16.3-2.fc40 04/01/2014n [ 102.094848][T14893] RIP: 0010:folio_lruvec_lock_irqsave+0x10e/0x170n [ 102.096104][T14893] Code: ...n [ 102.099908][T14893] RSP: 0018:ffffc900236c37b0 EFLAGS: 00010293n [ 102.101152][T14893] RAX: 0000000000000000 RBX: ffffea0004f30000 RCX: ffffffff8183f426n [ 102.102684][T14893] RDX: ffff8881063cb880 RSI: ffffffff81b8117f RDI: ffff8881063cb880n [ 102.104227][T14893] RBP: 0000000000000000 R08: 0000000000000005 R09: 0000000000000000n [ 102.105757][T14893] R10: 0000000000000001 R11: 0000000000000002 R12: ffffc900236c37d8n [ 102.107296][T14893] R13: ffff888277a2bcb0 R14: 000000000000001f R15: 0000000000000000n [ 102.108830][T14893] FS: 00007ff27dbdd740(0000) GS:ffff888277a00000(0000) knlGS:0000000000000000n [ 102.110643][T14893] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033n [ 102.111924][T14893] CR2: 00007ff27d400000 CR3: 000000010866e000 CR4: 0000000000750ef0n [ 102.113478][T14893] PKRU: 55555554n [ 102.114172][T14893] Call Trace:n [ 102.114805][T14893] <TASK>n [ 102.115397][T14893] ? folio_lruvec_lock_irqsave+0x10e/0x170n [ 102.116547][T14893] ? __warn.cold+0x110/0x210n [ 102.117461][T14893] ? folio_lruvec_lock_irqsave+0x10e/0x170n [ 102.118667][T14893] ? report_bug+0x1b9/0x320n [ 102.119571][T14893] ? handle_bug+0x54/0x90n [ 102.120494][T14893] ? exc_invalid_op+0x17/0x50n [ 102.121433][T14893] ? asm_exc_invalid_op+0x1a/0x20n [ 102.122435][T14893] ? __wake_up_klogd.part.0+0x76/0xd0n [ 102.123506][T14893] ? dump_page+0x4f/0x60n [ 102.124352][T14893] ? folio_lruvec_lock_irqsave+0x10e/0x170n [ 102.125500][T14893] folio_batch_move_lru+0xd4/0x200n [ 102.126577][T14893] ? __pfx_lru_add+0x10/0x10n [ 102.127505][T14893] __folio_batch_add_and_move+0x391/0x720n [ 102.128633][T14893] ? __pfx_lru_add+0x10/0x10n [ 102.129550][T14893] folio_putback_lru+0x16/0x80n [ 102.130564][T14893] migrate_device_finalize+0x9b/0x530n [ 102.131640][T14893] dmirror_migrate_to_device.constprop.0+0x7c5/0xad0n [ 102.133047][T14893] dmirror_fops_unlocked_ioctl+0x89b/0xc80nnLikely nothing else goes wrong: putting the last folio reference willnremove the folio from the LRU again. So besides memcg complaining addingnthe folio to be freed to the LRU is just an unnecessary step.nnThe new flow resembles what we have in migrate_folio_move(): add the dstnto the lru remn---truncated---,CVE-2025-21861,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrop_monitor: fix incorrect initialization ordernnSyzkaller reports the following bug:nnBUG: spinlock bad magic on CPU#1 syz-executor.0/7995n lock: 0xffff88805303f3e0 .magic: 00000000 .owner: <none>/-1 .owner_cpu: 0nCPU: 1 PID: 7995 Comm: syz-executor.0 Tainted: G E 5.10.209+ #1nHardware name: VMware Inc. VMware Virtual Platform/440BX Desktop Reference Platform BIOS 6.00 11/12/2020nCall Trace:n __dump_stack lib/dump_stack.c:77 [inline]n dump_stack+0x119/0x179 lib/dump_stack.c:118n debug_spin_lock_before kernel/locking/spinlock_debug.c:83 [inline]n do_raw_spin_lock+0x1f6/0x270 kernel/locking/spinlock_debug.c:112n __raw_spin_lock_irqsave include/linux/spinlock_api_smp.h:117 [inline]n _raw_spin_lock_irqsave+0x50/0x70 kernel/locking/spinlock.c:159n reset_per_cpu_data+0xe6/0x240 [drop_monitor]n net_dm_cmd_trace+0x43d/0x17a0 [drop_monitor]n genl_family_rcv_msg_doit+0x22f/0x330 net/netlink/genetlink.c:739n genl_family_rcv_msg net/netlink/genetlink.c:783 [inline]n genl_rcv_msg+0x341/0x5a0 net/netlink/genetlink.c:800n netlink_rcv_skb+0x14d/0x440 net/netlink/af_netlink.c:2497n genl_rcv+0x29/0x40 net/netlink/genetlink.c:811n netlink_unicast_kernel net/netlink/af_netlink.c:1322 [inline]n netlink_unicast+0x54b/0x800 net/netlink/af_netlink.c:1348n netlink_sendmsg+0x914/0xe00 net/netlink/af_netlink.c:1916n sock_sendmsg_nosec net/socket.c:651 [inline]n __sock_sendmsg+0x157/0x190 net/socket.c:663n ____sys_sendmsg+0x712/0x870 net/socket.c:2378n ___sys_sendmsg+0xf8/0x170 net/socket.c:2432n __sys_sendmsg+0xea/0x1b0 net/socket.c:2461n do_syscall_64+0x30/0x40 arch/x86/entry/common.c:46n entry_SYSCALL_64_after_hwframe+0x62/0xc7nRIP: 0033:0x7f3f9815aee9nCode: ff ff c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 b0 ff ff ff f7 d8 64 89 01 48nRSP: 002b:00007f3f972bf0c8 EFLAGS: 00000246 ORIG_RAX: 000000000000002enRAX: ffffffffffffffda RBX: 00007f3f9826d050 RCX: 00007f3f9815aee9nRDX: 0000000020000000 RSI: 0000000020001300 RDI: 0000000000000007nRBP: 00007f3f981b63bd R08: 0000000000000000 R09: 0000000000000000nR10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000nR13: 000000000000006e R14: 00007f3f9826d050 R15: 00007ffe01ee6768nnIf drop_monitor is built as a kernel module syzkaller may have timento send a netlink NET_DM_CMD_START message during the module loading.nThis will call the net_dm_monitor_start() function that usesna spinlock that has not yet been initialized.nnTo fix this let's place resource initialization above the registrationnof a generic netlink family.nnFound by InfoTeCS on behalf of Linux Verification Centern(linuxtesting.org) with Syzkaller.,CVE-2025-21862,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnio_uring: prevent opcode speculationnnsqe->opcode is used for different tables make sure we santitise itnagainst speculations.,CVE-2025-21863,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nngtp: Suppress list corruption splat in gtp_net_exit_batch_rtnl().nnBrad Spengler reported the list_del() corruption splat inngtp_net_exit_batch_rtnl(). [0]nnCommit eb28fd76c0a0 (gtp: Destroy device along with udp socket's netnsndismantle.) added the for_each_netdev() loop in gtp_net_exit_batch_rtnl()nto destroy devices in each netns as done in geneve and ip tunnels.nnHowever this could trigger ->dellink() twice for the same device duringn->exit_batch_rtnl().nnSay we have two netns A & B and gtp device B that resides in netns B butnwhose UDP socket is in netns A.nn 1. cleanup_net() processes netns A and then B.nn 2. gtp_net_exit_batch_rtnl() finds the device B while iteratingn netns A's gn->gtp_dev_list and calls ->dellink().nn [ device B is not yet unlinked from netns Bn as unregister_netdevice_many() has not been called. ]nn 3. gtp_net_exit_batch_rtnl() finds the device B while iteratingn netns B's for_each_netdev() and calls ->dellink().nngtp_dellink() cleans up the device's hash table unlinks the dev fromngn->gtp_dev_list and calls unregister_netdevice_queue().nnBasically calling gtp_dellink() multiple times is fine unlessnCONFIG_DEBUG_LIST is enabled.nnLet's remove for_each_netdev() in gtp_net_exit_batch_rtnl() andndelegate the destruction to default_device_exit_batch() as donenin bareudp.nn[0]:nlist_del corruption ffff8880aaa62c00->next (autoslab_size_M_dev_P_net_core_dev_11127_8_1328_8_S_4096_A_64_n_139+0xc00/0x1000 [slab object]) is LIST_POISON1 (ffffffffffffff02) (prev is 0xffffffffffffff04)nkernel BUG at lib/list_debug.c:58!nOops: invalid opcode: 0000 [#1] PREEMPT SMP KASANnCPU: 1 UID: 0 PID: 1804 Comm: kworker/u8:7 Tainted: G T 6.12.13-grsec-full-20250211091339 #1nTainted: [T]=RANDSTRUCTnHardware name: QEMU Standard PC (i440FX + PIIX 1996) BIOS 1.15.0-1 04/01/2014nWorkqueue: netns cleanup_netnRIP: 0010:[<ffffffff84947381>] __list_del_entry_valid_or_report+0x141/0x200 lib/list_debug.c:58nCode: c2 76 91 31 c0 e8 9f b1 f7 fc 0f 0b 4d 89 f0 48 c7 c1 02 ff ff ff 48 89 ea 48 89 ee 48 c7 c7 e0 c2 76 91 31 c0 e8 7f b1 f7 fc <0f> 0b 4d 89 e8 48 c7 c1 04 ff ff ff 48 89 ea 48 89 ee 48 c7 c7 60nRSP: 0018:fffffe8040b4fbd0 EFLAGS: 00010283nRAX: 00000000000000cc RBX: dffffc0000000000 RCX: ffffffff818c4054nRDX: ffffffff84947381 RSI: ffffffff818d1512 RDI: 0000000000000000nRBP: ffff8880aaa62c00 R08: 0000000000000001 R09: fffffbd008169f32nR10: fffffe8040b4f997 R11: 0000000000000001 R12: a1988d84f24943e4nR13: ffffffffffffff02 R14: ffffffffffffff04 R15: ffff8880aaa62c08nRBX: kasan shadow of 0x0nRCX: __wake_up_klogd.part.0+0x74/0xe0 kernel/printk/printk.c:4554nRDX: __list_del_entry_valid_or_report+0x141/0x200 lib/list_debug.c:58nRSI: vprintk+0x72/0x100 kernel/printk/printk_safe.c:71nRBP: autoslab_size_M_dev_P_net_core_dev_11127_8_1328_8_S_4096_A_64_n_139+0xc00/0x1000 [slab object]nRSP: process kstack fffffe8040b4fbd0+0x7bd0/0x8000 [kworker/u8:7+netns 1804 ]nR09: kasan shadow of process kstack fffffe8040b4f990+0x7990/0x8000 [kworker/u8:7+netns 1804 ]nR10: process kstack fffffe8040b4f997+0x7997/0x8000 [kworker/u8:7+netns 1804 ]nR15: autoslab_size_M_dev_P_net_core_dev_11127_8_1328_8_S_4096_A_64_n_139+0xc08/0x1000 [slab object]nFS: 0000000000000000(0000) GS:ffff888116000000(0000) knlGS:0000000000000000nCS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033nCR2: 0000748f5372c000 CR3: 0000000015408000 CR4: 00000000003406f0 shadow CR4: 00000000003406f0nStack:n 0000000000000000 ffffffff8a0c35e7 ffffffff8a0c3603 ffff8880aaa62c00n ffff8880aaa62c00 0000000000000004 ffff88811145311c 0000000000000005n 0000000000000001 ffff8880aaa62000 fffffe8040b4fd40 ffffffff8a0c360dnCall Trace:n <TASK>n [<ffffffff8a0c360d>] __list_del_entry_valid include/linux/list.h:131 [inline] fffffe8040b4fc28n [<ffffffff8a0c360d>] __list_del_entry include/linux/list.h:248 [inline] fffffe8040b4fc28n [<ffffffff8a0c360d>] list_del include/linux/list.h:262 [inln---truncated---,CVE-2025-21865,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnpowerpc/code-patching: Fix KASAN hit by not flagging text patching area as VM_ALLOCnnErhard reported the following KASAN hit while booting his PowerMac G4nwith a KASAN-enabled kernel 6.13-rc6:nn BUG: KASAN: vmalloc-out-of-bounds in copy_to_kernel_nofault+0xd8/0x1c8n Write of size 8 at addr f1000000 by task chronyd/1293nn CPU: 0 UID: 123 PID: 1293 Comm: chronyd Tainted: G W 6.13.0-rc6-PMacG4 #2n Tainted: [W]=WARNn Hardware name: PowerMac36 7455 0x80010303 PowerMacn Call Trace:n [c2437590] [c1631a84] dump_stack_lvl+0x70/0x8c (unreliable)n [c24375b0] [c0504998] print_report+0xdc/0x504n [c2437610] [c050475c] kasan_report+0xf8/0x108n [c2437690] [c0505a3c] kasan_check_range+0x24/0x18cn [c24376a0] [c03fb5e4] copy_to_kernel_nofault+0xd8/0x1c8n [c24376c0] [c004c014] patch_instructions+0x15c/0x16cn [c2437710] [c00731a8] bpf_arch_text_copy+0x60/0x7cn [c2437730] [c0281168] bpf_jit_binary_pack_finalize+0x50/0xacn [c2437750] [c0073cf4] bpf_int_jit_compile+0xb30/0xdecn [c2437880] [c0280394] bpf_prog_select_runtime+0x15c/0x478n [c24378d0] [c1263428] bpf_prepare_filter+0xbf8/0xc14n [c2437990] [c12677ec] bpf_prog_create_from_user+0x258/0x2b4n [c24379d0] [c027111c] do_seccomp+0x3dc/0x1890n [c2437ac0] [c001d8e0] system_call_exception+0x2dc/0x420n [c2437f30] [c00281ac] ret_from_syscall+0x0/0x2cn --- interrupt: c00 at 0x5a1274n NIP: 005a1274 LR: 006a3b3c CTR: 005296c8n REGS: c2437f40 TRAP: 0c00 Tainted: G W (6.13.0-rc6-PMacG4)n MSR: 0200f932 <VECEEPRFPMEIRDRRI> CR: 24004422 XER: 00000000nn GPR00: 00000166 af8f3fa0 a7ee3540 00000001 00000000 013b6500 005a5858 0200f932n GPR08: 00000000 00001fe9 013d5fc8 005296c8 2822244c 00b2fcd8 00000000 af8f4b57n GPR16: 00000000 00000001 00000000 00000000 00000000 00000001 00000000 00000002n GPR24: 00afdbb0 00000000 00000000 00000000 006e0004 013ce060 006e7c1c 00000001n NIP [005a1274] 0x5a1274n LR [006a3b3c] 0x6a3b3cn --- interrupt: c00nn The buggy address belongs to the virtual mapping atn [f1000000 f1002000) created by:n text_area_cpu_up+0x20/0x190nn The buggy address belongs to the physical page:n page: refcount:1 mapcount:0 mapping:00000000 index:0x0 pfn:0x76e30n flags: 0x80000000(zone=2)n raw: 80000000 00000000 00000122 00000000 00000000 00000000 ffffffff 00000001n raw: 00000000n page dumped because: kasan: bad access detectednn Memory state around the buggy address:n f0ffff00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00n f0ffff80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00n >f1000000: f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8n ^n f1000080: f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8n f1000100: f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8n ==================================================================nnf8 corresponds to KASAN_VMALLOC_INVALID which means the area is notninitialised hence not supposed to be used yet.nnPowerpc text patching infrastructure allocates a virtual memory areanusing get_vm_area() and flags it as VM_ALLOC. But that flag is meantnto be used for vmalloc() and vmalloc() allocated memory is notnsupposed to be used before a call to __vmalloc_node_range() which isnnever called for that area.nnThat went undetected until commit e4137f08816b (mm kasan kmsan:ninstrument copy_from/to_kernel_nofault)nnThe area allocated by text_area_cpu_up() is not vmalloc memory it isnmapped directly on demand when needed by map_kernel_page(). There isnno VM flag corresponding to such usage so just pass no flag. That waynthe area will be unpoisonned and usable immediately.,CVE-2025-21866,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nntee: optee: Fix supplicant wait loopnnOP-TEE supplicant is a user-space daemon and it's possible for itnbe hung or crashed or killed in the middle of processing an OP-TEEnRPC call. It becomes more complicated when there is incorrect shutdownnordering of the supplicant process vs the OP-TEE client application whichncan eventually lead to system hang-up waiting for the closure of thenclient application.nnAllow the client process waiting in kernel for supplicant response tonbe killed rather than indefinitely waiting in an unkillable state. Alsona normal uninterruptible wait should not have resulted in the hung-tasknwatchdog getting triggered but the endless loop would.nnThis fixes issues observed during system reboot/shutdown when supplicantngot hung for some reason or gets crashed/killed which lead to clientngetting hung in an unkillable state. It in turn lead to system being innhung up state requiring hard power off/on to recover.,CVE-2025-21871,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnefi: Don't map the entire mokvar table to determine its sizennCurrently when validating the mokvar table we (re)map the entire tablenon each iteration of the loop adding space as we discover new entries.nIf the table grows over a certain size this fails due to limitations ofnearly_memmap() and we get a failure and traceback:nn ------------[ cut here ]------------n WARNING: CPU: 0 PID: 0 at mm/early_ioremap.c:139 __early_ioremap+0xef/0x220n ...n Call Trace:n <TASK>n ? __early_ioremap+0xef/0x220n ? __warn.cold+0x93/0xfan ? __early_ioremap+0xef/0x220n ? report_bug+0xff/0x140n ? early_fixup_exception+0x5d/0xb0n ? early_idt_handler_common+0x2f/0x3an ? __early_ioremap+0xef/0x220n ? efi_mokvar_table_init+0xce/0x1d0n ? setup_arch+0x864/0xc10n ? start_kernel+0x6b/0xa10n ? x86_64_start_reservations+0x24/0x30n ? x86_64_start_kernel+0xed/0xf0n ? common_startup_64+0x13e/0x141n </TASK>n ---[ end trace 0000000000000000 ]---n mokvar: Failed to map EFI MOKvar config table pa=0x7c4c3000 size=265187.nnMapping the entire structure isn't actually necessary as we don't evernneed more than one entry header mapped at once.nnChanges efi_mokvar_table_init() to only map each entry header not thenentire table when determining the table size. Since we're not mappingnany data past the variable name it also changes the code to enforcenthat each variable name is NUL terminated rather than attempting tonverify it in place.,CVE-2025-21872,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnmptcp: always handle address removal under msk socket locknnSyzkaller reported a lockdep splat in the PM control path:nn WARNING: CPU: 0 PID: 6693 at ./include/net/sock.h:1711 sock_owned_by_me include/net/sock.h:1711 [inline]n WARNING: CPU: 0 PID: 6693 at ./include/net/sock.h:1711 msk_owned_by_me net/mptcp/protocol.h:363 [inline]n WARNING: CPU: 0 PID: 6693 at ./include/net/sock.h:1711 mptcp_pm_nl_addr_send_ack+0x57c/0x610 net/mptcp/pm_netlink.c:788n Modules linked in:n CPU: 0 UID: 0 PID: 6693 Comm: syz.0.205 Not tainted 6.14.0-rc2-syzkaller-00303-gad1b832bf1cf #0n Hardware name: Google Compute Engine/Google Compute Engine BIOS Google 12/27/2024n RIP: 0010:sock_owned_by_me include/net/sock.h:1711 [inline]n RIP: 0010:msk_owned_by_me net/mptcp/protocol.h:363 [inline]n RIP: 0010:mptcp_pm_nl_addr_send_ack+0x57c/0x610 net/mptcp/pm_netlink.c:788n Code: 5b 41 5c 41 5d 41 5e 41 5f 5d c3 cc cc cc cc e8 ca 7b d3 f5 eb b9 e8 c3 7b d3 f5 90 0f 0b 90 e9 dd fb ff ff e8 b5 7b d3 f5 90 <0f> 0b 90 e9 3e fb ff ff 44 89 f1 80 e1 07 38 c1 0f 8c eb fb ff ffn RSP: 0000:ffffc900034f6f60 EFLAGS: 00010283n RAX: ffffffff8bee3c2b RBX: 0000000000000001 RCX: 0000000000080000n RDX: ffffc90004d42000 RSI: 000000000000a407 RDI: 000000000000a408n RBP: ffffc900034f7030 R08: ffffffff8bee37f6 R09: 0100000000000000n R10: dffffc0000000000 R11: ffffed100bcc62e4 R12: ffff88805e6316e0n R13: ffff88805e630c00 R14: dffffc0000000000 R15: ffff88805e630c00n FS: 00007f7e9a7e96c0(0000) GS:ffff8880b8600000(0000) knlGS:0000000000000000n CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033n CR2: 0000001b2fd18ff8 CR3: 0000000032c24000 CR4: 00000000003526f0n DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000n DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400n Call Trace:n <TASK>n mptcp_pm_remove_addr+0x103/0x1d0 net/mptcp/pm.c:59n mptcp_pm_remove_anno_addr+0x1f4/0x2f0 net/mptcp/pm_netlink.c:1486n mptcp_nl_remove_subflow_and_signal_addr net/mptcp/pm_netlink.c:1518 [inline]n mptcp_pm_nl_del_addr_doit+0x118d/0x1af0 net/mptcp/pm_netlink.c:1629n genl_family_rcv_msg_doit net/netlink/genetlink.c:1115 [inline]n genl_family_rcv_msg net/netlink/genetlink.c:1195 [inline]n genl_rcv_msg+0xb1f/0xec0 net/netlink/genetlink.c:1210n netlink_rcv_skb+0x206/0x480 net/netlink/af_netlink.c:2543n genl_rcv+0x28/0x40 net/netlink/genetlink.c:1219n netlink_unicast_kernel net/netlink/af_netlink.c:1322 [inline]n netlink_unicast+0x7f6/0x990 net/netlink/af_netlink.c:1348n netlink_sendmsg+0x8de/0xcb0 net/netlink/af_netlink.c:1892n sock_sendmsg_nosec net/socket.c:718 [inline]n __sock_sendmsg+0x221/0x270 net/socket.c:733n ____sys_sendmsg+0x53a/0x860 net/socket.c:2573n ___sys_sendmsg net/socket.c:2627 [inline]n __sys_sendmsg+0x269/0x350 net/socket.c:2659n do_syscall_x64 arch/x86/entry/common.c:52 [inline]n do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83n entry_SYSCALL_64_after_hwframe+0x77/0x7fn RIP: 0033:0x7f7e9998cde9n Code: ff ff c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 a8 ff ff ff f7 d8 64 89 01 48n RSP: 002b:00007f7e9a7e9038 EFLAGS: 00000246 ORIG_RAX: 000000000000002en RAX: ffffffffffffffda RBX: 00007f7e99ba5fa0 RCX: 00007f7e9998cde9n RDX: 000000002000c094 RSI: 0000400000000000 RDI: 0000000000000007n RBP: 00007f7e99a0e2a0 R08: 0000000000000000 R09: 0000000000000000n R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000n R13: 0000000000000000 R14: 00007f7e99ba5fa0 R15: 00007fff49231088nnIndeed the PM can try to send a RM_ADDR over a msk without acquiringnfirst the msk socket lock.nnThe bugged code-path comes from an early optimization: when therenare no subflows the PM should (usually) not send RM_ADDRnnotifications.nnThe above statement is incorrect as without locks another processncould concurn---truncated---,CVE-2025-21875,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnusbnet: gl620a: fix endpoint checking in genelink_bind()nnSyzbot reports [1] a warning in usb_submit_urb() triggered byninconsistencies between expected and actually present endpointsnin gl620a driver. Since genelink_bind() does not properlynverify whether specified eps are in fact provided by the devicenin this case an artificially manufactured one one may get anmismatch.nnFix the issue by resorting to a usbnet utility functionnusbnet_get_endpoints() usually reserved for this very problem.nCheck for endpoints and return early before proceeding further ifnany are missing.nn[1] Syzbot report:nusb 5-1: Manufacturer: syznusb 5-1: SerialNumber: syznusb 5-1: config 0 descriptor??ngl620a 5-1:0.23 usb0: register 'gl620a' at usb-dummy_hcd.0-1 ...n------------[ cut here ]------------nusb 5-1: BOGUS urb xfer pipe 3 != type 1nWARNING: CPU: 2 PID: 1841 at drivers/usb/core/urb.c:503 usb_submit_urb+0xe4b/0x1730 drivers/usb/core/urb.c:503nModules linked in:nCPU: 2 UID: 0 PID: 1841 Comm: kworker/2:2 Not tainted 6.12.0-syzkaller-07834-g06afb0f36106 #0nHardware name: QEMU Standard PC (Q35 + ICH9 2009) BIOS 1.16.3-debian-1.16.3-2~bpo12+1 04/01/2014nWorkqueue: mld mld_ifc_worknRIP: 0010:usb_submit_urb+0xe4b/0x1730 drivers/usb/core/urb.c:503n...nCall Trace:n <TASK>n usbnet_start_xmit+0x6be/0x2780 drivers/net/usb/usbnet.c:1467n __netdev_start_xmit include/linux/netdevice.h:5002 [inline]n netdev_start_xmit include/linux/netdevice.h:5011 [inline]n xmit_one net/core/dev.c:3590 [inline]n dev_hard_start_xmit+0x9a/0x7b0 net/core/dev.c:3606n sch_direct_xmit+0x1ae/0xc30 net/sched/sch_generic.c:343n __dev_xmit_skb net/core/dev.c:3827 [inline]n __dev_queue_xmit+0x13d4/0x43e0 net/core/dev.c:4400n dev_queue_xmit include/linux/netdevice.h:3168 [inline]n neigh_resolve_output net/core/neighbour.c:1514 [inline]n neigh_resolve_output+0x5bc/0x950 net/core/neighbour.c:1494n neigh_output include/net/neighbour.h:539 [inline]n ip6_finish_output2+0xb1b/0x2070 net/ipv6/ip6_output.c:141n __ip6_finish_output net/ipv6/ip6_output.c:215 [inline]n ip6_finish_output+0x3f9/0x1360 net/ipv6/ip6_output.c:226n NF_HOOK_COND include/linux/netfilter.h:303 [inline]n ip6_output+0x1f8/0x540 net/ipv6/ip6_output.c:247n dst_output include/net/dst.h:450 [inline]n NF_HOOK include/linux/netfilter.h:314 [inline]n NF_HOOK include/linux/netfilter.h:308 [inline]n mld_sendpack+0x9f0/0x11d0 net/ipv6/mcast.c:1819n mld_send_cr net/ipv6/mcast.c:2120 [inline]n mld_ifc_work+0x740/0xca0 net/ipv6/mcast.c:2651n process_one_work+0x9c5/0x1ba0 kernel/workqueue.c:3229n process_scheduled_works kernel/workqueue.c:3310 [inline]n worker_thread+0x6c8/0xf00 kernel/workqueue.c:3391n kthread+0x2c1/0x3a0 kernel/kthread.c:389n ret_from_fork+0x45/0x80 arch/x86/kernel/process.c:147n ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244n </TASK>,CVE-2025-21877,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nni2c: npcm: disable interrupt enable bit before devm_request_irqnnThe customer reports that there is a soft lockup issue related tonthe i2c driver. After checking the i2c module was doing a tx transfernand the bmc machine reboots in the middle of the i2c transaction the i2cnmodule keeps the status without being reset.nnDue to such an i2c module status the i2c irq handler keeps gettingntriggered since the i2c irq handler is registered in the kernel bootingnprocess after the bmc machine is doing a warm rebooting.nThe continuous triggering is stopped by the soft lockup watchdog timer.nnDisable the interrupt enable bit in the i2c module before callingndevm_request_irq to fix this issue since the i2c relative status bitnis read-only.nnHere is the soft lockup log.n[ 28.176395] watchdog: BUG: soft lockup - CPU#0 stuck for 26s! [swapper/0:1]n[ 28.183351] Modules linked in:n[ 28.186407] CPU: 0 PID: 1 Comm: swapper/0 Not tainted 5.15.120-yocto-s-dirty-bbebc78 #1n[ 28.201174] pstate: 40000005 (nZcv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)n[ 28.208128] pc : __do_softirq+0xb0/0x368n[ 28.212055] lr : __do_softirq+0x70/0x368n[ 28.215972] sp : ffffff8035ebca00n[ 28.219278] x29: ffffff8035ebca00 x28: 0000000000000002 x27: ffffff80071a3780n[ 28.226412] x26: ffffffc008bdc000 x25: ffffffc008bcc640 x24: ffffffc008be50c0n[ 28.233546] x23: ffffffc00800200c x22: 0000000000000000 x21: 000000000000001bn[ 28.240679] x20: 0000000000000000 x19: ffffff80001c3200 x18: ffffffffffffffffn[ 28.247812] x17: ffffffc02d2e0000 x16: ffffff8035eb8b40 x15: 00001e8480000000n[ 28.254945] x14: 02c3647e37dbfcb6 x13: 02c364f2ab14200c x12: 0000000002c364f2n[ 28.262078] x11: 00000000fa83b2da x10: 000000000000b67e x9 : ffffffc008010250n[ 28.269211] x8 : 000000009d983d00 x7 : 7fffffffffffffff x6 : 0000036d74732434n[ 28.276344] x5 : 00ffffffffffffff x4 : 0000000000000015 x3 : 0000000000000198n[ 28.283476] x2 : ffffffc02d2e0000 x1 : 00000000000000e0 x0 : ffffffc008bdcb40n[ 28.290611] Call trace:n[ 28.293052] __do_softirq+0xb0/0x368n[ 28.296625] __irq_exit_rcu+0xe0/0x100n[ 28.300374] irq_exit+0x14/0x20n[ 28.303513] handle_domain_irq+0x68/0x90n[ 28.307440] gic_handle_irq+0x78/0xb0n[ 28.311098] call_on_irq_stack+0x20/0x38n[ 28.315019] do_interrupt_handler+0x54/0x5cn[ 28.319199] el1_interrupt+0x2c/0x4cn[ 28.322777] el1h_64_irq_handler+0x14/0x20n[ 28.326872] el1h_64_irq+0x74/0x78n[ 28.330269] __setup_irq+0x454/0x780n[ 28.333841] request_threaded_irq+0xd0/0x1b4n[ 28.338107] devm_request_threaded_irq+0x84/0x100n[ 28.342809] npcm_i2c_probe_bus+0x188/0x3d0n[ 28.346990] platform_probe+0x6c/0xc4n[ 28.350653] really_probe+0xcc/0x45cn[ 28.354227] __driver_probe_device+0x8c/0x160n[ 28.358578] driver_probe_device+0x44/0xe0n[ 28.362670] __driver_attach+0x124/0x1d0n[ 28.366589] bus_for_each_dev+0x7c/0xe0n[ 28.370426] driver_attach+0x28/0x30n[ 28.373997] bus_add_driver+0x124/0x240n[ 28.377830] driver_register+0x7c/0x124n[ 28.381662] __platform_driver_register+0x2c/0x34n[ 28.386362] npcm_i2c_init+0x3c/0x5cn[ 28.389937] do_one_initcall+0x74/0x230n[ 28.393768] kernel_init_freeable+0x24c/0x2b4n[ 28.398126] kernel_init+0x28/0x130n[ 28.401614] ret_from_fork+0x10/0x20n[ 28.405189] Kernel panic - not syncing: softlockup: hung tasksn[ 28.411011] SMP: stopping secondary CPUsn[ 28.414933] Kernel Offset: disabledn[ 28.418412] CPU features: 0x0000000000000802n[ 28.427644] Rebooting in 20 seconds..,CVE-2025-21878,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnuprobes: Reject the shared zeropage in uprobe_write_opcode()nnWe triggered the following crash in syzkaller tests:nn BUG: Bad page state in process syz.7.38 pfn:1eff3n page: refcount:0 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x1eff3n flags: 0x3fffff00004004(referenced|reserved|node=0|zone=1|lastcpupid=0x1fffff)n raw: 003fffff00004004 ffffe6c6c07bfcc8 ffffe6c6c07bfcc8 0000000000000000n raw: 0000000000000000 0000000000000000 00000000fffffffe 0000000000000000n page dumped because: PAGE_FLAGS_CHECK_AT_FREE flag(s) setn Hardware name: QEMU Standard PC (i440FX + PIIX 1996) BIOS 1.13.0-1ubuntu1.1 04/01/2014n Call Trace:n <TASK>n dump_stack_lvl+0x32/0x50n bad_page+0x69/0xf0n free_unref_page_prepare+0x401/0x500n free_unref_page+0x6d/0x1b0n uprobe_write_opcode+0x460/0x8e0n install_breakpoint.part.0+0x51/0x80n register_for_each_vma+0x1d9/0x2b0n __uprobe_register+0x245/0x300n bpf_uprobe_multi_link_attach+0x29b/0x4f0n link_create+0x1e2/0x280n __sys_bpf+0x75f/0xac0n __x64_sys_bpf+0x1a/0x30n do_syscall_64+0x56/0x100n entry_SYSCALL_64_after_hwframe+0x78/0xe2nn BUG: Bad rss-counter state mm:00000000452453e0 type:MM_FILEPAGES val:-1nnThe following syzkaller test case can be used to reproduce:nn r2 = creat(&(0x7f0000000000)='./file0x00' 0x8)n write$nbd(r2 &(0x7f0000000580)=ANY=[] 0x10)n r4 = openat(0xffffffffffffff9c &(0x7f0000000040)='./file0x00' 0x42 0x0)n mmap$IORING_OFF_SQ_RING(&(0x7f0000ffd000/0x3000)=nil 0x3000 0x0 0x12 r4 0x0)n r5 = userfaultfd(0x80801)n ioctl$UFFDIO_API(r5 0xc018aa3f &(0x7f0000000040)={0xaa 0x20})n r6 = userfaultfd(0x80801)n ioctl$UFFDIO_API(r6 0xc018aa3f &(0x7f0000000140))n ioctl$UFFDIO_REGISTER(r6 0xc020aa00 &(0x7f0000000100)={{&(0x7f0000ffc000/0x4000)=nil 0x4000} 0x2})n ioctl$UFFDIO_ZEROPAGE(r5 0xc020aa04 &(0x7f0000000000)={{&(0x7f0000ffd000/0x1000)=nil 0x1000}})n r7 = bpf$PROG_LOAD(0x5 &(0x7f0000000140)={0x2 0x3 &(0x7f0000000200)=ANY=[@ANYBLOB=1800000000120000000000000000000095] &(0x7f0000000000)='GPLx00' 0x7 0x0 0x0 0x0 0x0 'x00' 0x0 @fallback=0x30 0xffffffffffffffff 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x10 0x0 @void @value} 0x94)n bpf$BPF_LINK_CREATE_XDP(0x1c &(0x7f0000000040)={r7 0x0 0x30 0x1e @val=@uprobe_multi={&(0x7f0000000080)='./file0x00' &(0x7f0000000100)=[0x2] 0x0 0x0 0x1}} 0x40)nnThe cause is that zero pfn is set to the PTE without increasing the RSSncount in mfill_atomic_pte_zeropage() and the refcount of zero folio doesnnot increase accordingly. Then the operation on the same pfn is performednin uprobe_write_opcode()->__replace_page() to unconditional decrease thenRSS count and old_folio's refcount.nnTherefore two bugs are introduced:nn 1. The RSS count is incorrect when process exit the check_mm() reportn error Bad rss-count.nn 2. The reserved folio (zero folio) is freed when folio->refcount is zeron then free_pages_prepare->free_page_is_bad() report errorn Bad page state.nnThere is more the following warning could also theoretically be triggered:nn __replace_page()n -> ...n -> folio_remove_rmap_pte()n -> VM_WARN_ON_FOLIO(is_zero_folio(folio) folio)nnConsidering that uprobe hit on the zero folio is a very rare case justnreject zero old folio immediately after get_user_page_vma_remote().nn[ mingo: Cleaned up the changelog ],CVE-2025-21881,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnRDMA/bnxt_re: Fix the page details for the srq created by kernel consumersnnWhile using nvme target with use_srq on below kernel panic is noticed.nn[ 549.698111] bnxt_en 0000:41:00.0 enp65s0np0: FEC autoneg off encoding: Clause 91 RS(544514)n[ 566.393619] Oops: divide error: 0000 [#1] PREEMPT SMP NOPTIn..n[ 566.393799] <TASK>n[ 566.393807] ? __die_body+0x1a/0x60n[ 566.393823] ? die+0x38/0x60n[ 566.393835] ? do_trap+0xe4/0x110n[ 566.393847] ? bnxt_qplib_alloc_init_hwq+0x1d4/0x580 [bnxt_re]n[ 566.393867] ? bnxt_qplib_alloc_init_hwq+0x1d4/0x580 [bnxt_re]n[ 566.393881] ? do_error_trap+0x7c/0x120n[ 566.393890] ? bnxt_qplib_alloc_init_hwq+0x1d4/0x580 [bnxt_re]n[ 566.393911] ? exc_divide_error+0x34/0x50n[ 566.393923] ? bnxt_qplib_alloc_init_hwq+0x1d4/0x580 [bnxt_re]n[ 566.393939] ? asm_exc_divide_error+0x16/0x20n[ 566.393966] ? bnxt_qplib_alloc_init_hwq+0x1d4/0x580 [bnxt_re]n[ 566.393997] bnxt_qplib_create_srq+0xc9/0x340 [bnxt_re]n[ 566.394040] bnxt_re_create_srq+0x335/0x3b0 [bnxt_re]n[ 566.394057] ? srso_return_thunk+0x5/0x5fn[ 566.394068] ? __init_swait_queue_head+0x4a/0x60n[ 566.394090] ib_create_srq_user+0xa7/0x150 [ib_core]n[ 566.394147] nvmet_rdma_queue_connect+0x7d0/0xbe0 [nvmet_rdma]n[ 566.394174] ? lock_release+0x22c/0x3f0n[ 566.394187] ? srso_return_thunk+0x5/0x5fnnPage size and shift info is set only for the user space SRQs.nSet page size and page shift for kernel space SRQs also.,CVE-2025-21885,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnovl: fix UAF in ovl_dentry_update_reval by moving dput() in ovl_link_upnnThe issue was caused by dput(upper) being called beforenovl_dentry_update_reval() while upper->d_flags was stillnaccessed in ovl_dentry_remote().nnMove dput(upper) after its last use to prevent use-after-free.nnBUG: KASAN: slab-use-after-free in ovl_dentry_remote fs/overlayfs/util.c:162 [inline]nBUG: KASAN: slab-use-after-free in ovl_dentry_update_reval+0xd2/0xf0 fs/overlayfs/util.c:167nnCall Trace:n <TASK>n __dump_stack lib/dump_stack.c:88 [inline]n dump_stack_lvl+0x116/0x1f0 lib/dump_stack.c:114n print_address_description mm/kasan/report.c:377 [inline]n print_report+0xc3/0x620 mm/kasan/report.c:488n kasan_report+0xd9/0x110 mm/kasan/report.c:601n ovl_dentry_remote fs/overlayfs/util.c:162 [inline]n ovl_dentry_update_reval+0xd2/0xf0 fs/overlayfs/util.c:167n ovl_link_up fs/overlayfs/copy_up.c:610 [inline]n ovl_copy_up_one+0x2105/0x3490 fs/overlayfs/copy_up.c:1170n ovl_copy_up_flags+0x18d/0x200 fs/overlayfs/copy_up.c:1223n ovl_rename+0x39e/0x18c0 fs/overlayfs/dir.c:1136n vfs_rename+0xf84/0x20a0 fs/namei.c:4893n...n </TASK>,CVE-2025-21887,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnipvlan: ensure network headers are in skb linear partnnsyzbot found that ipvlan_process_v6_outbound() was assumingnthe IPv6 network header isis present in skb->head [1]nnAdd the needed pskb_network_may_pull() calls for bothnIPv4 and IPv6 handlers.nn[1]nBUG: KMSAN: uninit-value in __ipv6_addr_type+0xa2/0x490 net/ipv6/addrconf_core.c:47n __ipv6_addr_type+0xa2/0x490 net/ipv6/addrconf_core.c:47n ipv6_addr_type include/net/ipv6.h:555 [inline]n ip6_route_output_flags_noref net/ipv6/route.c:2616 [inline]n ip6_route_output_flags+0x51/0x720 net/ipv6/route.c:2651n ip6_route_output include/net/ip6_route.h:93 [inline]n ipvlan_route_v6_outbound+0x24e/0x520 drivers/net/ipvlan/ipvlan_core.c:476n ipvlan_process_v6_outbound drivers/net/ipvlan/ipvlan_core.c:491 [inline]n ipvlan_process_outbound drivers/net/ipvlan/ipvlan_core.c:541 [inline]n ipvlan_xmit_mode_l3 drivers/net/ipvlan/ipvlan_core.c:605 [inline]n ipvlan_queue_xmit+0xd72/0x1780 drivers/net/ipvlan/ipvlan_core.c:671n ipvlan_start_xmit+0x5b/0x210 drivers/net/ipvlan/ipvlan_main.c:223n __netdev_start_xmit include/linux/netdevice.h:5150 [inline]n netdev_start_xmit include/linux/netdevice.h:5159 [inline]n xmit_one net/core/dev.c:3735 [inline]n dev_hard_start_xmit+0x247/0xa20 net/core/dev.c:3751n sch_direct_xmit+0x399/0xd40 net/sched/sch_generic.c:343n qdisc_restart net/sched/sch_generic.c:408 [inline]n __qdisc_run+0x14da/0x35d0 net/sched/sch_generic.c:416n qdisc_run+0x141/0x4d0 include/net/pkt_sched.h:127n net_tx_action+0x78b/0x940 net/core/dev.c:5484n handle_softirqs+0x1a0/0x7c0 kernel/softirq.c:561n __do_softirq+0x14/0x1a kernel/softirq.c:595n do_softirq+0x9a/0x100 kernel/softirq.c:462n __local_bh_enable_ip+0x9f/0xb0 kernel/softirq.c:389n local_bh_enable include/linux/bottom_half.h:33 [inline]n rcu_read_unlock_bh include/linux/rcupdate.h:919 [inline]n __dev_queue_xmit+0x2758/0x57d0 net/core/dev.c:4611n dev_queue_xmit include/linux/netdevice.h:3311 [inline]n packet_xmit+0x9c/0x6c0 net/packet/af_packet.c:276n packet_snd net/packet/af_packet.c:3132 [inline]n packet_sendmsg+0x93e0/0xa7e0 net/packet/af_packet.c:3164n sock_sendmsg_nosec net/socket.c:718 [inline],CVE-2025-21891,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet: enetc: VFs do not support HWTSTAMP_TX_ONESTEP_SYNCnnActually ENETC VFs do not support HWTSTAMP_TX_ONESTEP_SYNC because onlynENETC PF can access PMa_SINGLE_STEP registers. And there will be a crashnif VFs are used to test one-step timestamp the crash log as follows.nn[ 129.110909] Unable to handle kernel paging request at virtual address 00000000000080c0n[ 129.287769] Call trace:n[ 129.290219] enetc_port_mac_wr+0x30/0xec (P)n[ 129.294504] enetc_start_xmit+0xda4/0xe74n[ 129.298525] enetc_xmit+0x70/0xecn[ 129.301848] dev_hard_start_xmit+0x98/0x118,CVE-2025-21894,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnftrace: Avoid potential division by zero in function_stat_show()nnCheck whether denominator expression x output.log scan_tyk_dockerimages.sh vulnerabilities.csv (x - 1) output.log scan_tyk_dockerimages.sh vulnerabilities.csv 1000 mod {2^32 2^64}nproduce zero and skip stddev computation in that case.nnFor now don't care about rec->counter output.log scan_tyk_dockerimages.sh vulnerabilities.csv rec->counter overflow becausenrec->time output.log scan_tyk_dockerimages.sh vulnerabilities.csv rec->time overflow will likely happen earlier.,CVE-2025-21898,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nntracing: Fix bad hist from corrupting named_triggers listnnThe following commands causes a crash:nn ~# cd /sys/kernel/tracing/events/rcu/rcu_callbackn ~# echo 'hist:name=bad:keys=common_pid:onmax(bogus).save(common_pid)' > triggern bash: echo: write error: Invalid argumentn ~# echo 'hist:name=bad:keys=common_pid' > triggernnBecause the following occurs:nnevent_trigger_write() {n trigger_process_regex() {n event_hist_trigger_parse() {nn data = event_trigger_alloc(..);nn event_trigger_register(.. data) {n cmd_ops->reg(.. data ..) [hist_register_trigger()] {n data->ops->init() [event_hist_trigger_init()] {n save_named_trigger(name data) {n list_add(&data->named_list &named_triggers);n }n }n }n }nn ret = create_actions(); (return -EINVAL)n if (ret)n goto out_unreg;n[..]n ret = hist_trigger_enable(data ...) {n list_add_tail_rcu(&data->list &file->triggers); <<<---- SKIPPED!!! (this is important!)n[..]n out_unreg:n event_hist_unregister(.. data) {n cmd_ops->unreg(.. data ..) [hist_unregister_trigger()] {n list_for_each_entry(iter &file->triggers list) {n if (!hist_trigger_match(data iter named_data false)) <- never matchesn continue;n [..]n test = iter;n }n if (test && test->ops->free) <<<-- test is NULLnn test->ops->free(test) [event_hist_trigger_free()] {n [..]n if (data->name)n del_named_trigger(data) {n list_del(&data->named_list); <<<<-- NEVER gets removed!n }n }n }n }nn [..]n kfree(data); <<<-- frees item but it is still on listnnThe next time a hist with name is registered it causes an u-a-f bug andnthe kernel can crash.nnMove the code around such that if event_trigger_register() succeeds thennext thing called is hist_trigger_enable() which adds it to the list.nnA bunch of actions is called if get_named_trigger_data() returns false.nBut that doesn't need to be called after event_trigger_register() so itncan be moved up allowing event_trigger_register() to be called justnbefore hist_trigger_enable() keeping them together and allowing thenfile->triggers to be properly populated.,CVE-2025-21899,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nncaif_virtio: fix wrong pointer check in cfv_probe()nndel_vqs() frees virtqueues therefore cfv->vq_tx pointer should be checkednfor NULL before calling it not cfv->vdev. Also the current implementationnis redundant because the pointer cfv->vdev is dereferenced before it isnchecked for NULL.nnFix this by checking cfv->vq_tx for NULL instead of cfv->vdev beforencalling del_vqs().,CVE-2025-21904,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnwifi: iwlwifi: limit printed string from FW filennThere's no guarantee here that the file is always with anNUL-termination so reading the string may read beyond thenend of the TLV. If that's the last TLV in the file it cannperhaps even read beyond the end of the file buffer.nnFix that by limiting the print format to the size of thenbuffer we have.,CVE-2025-21905,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnwifi: nl80211: reject cooked mode if it is set along with other flagsnnIt is possible to set both MONITOR_FLAG_COOK_FRAMES and MONITOR_FLAG_ACTIVEnflags simultaneously on the same monitor interface from the userspace. Thisncauses a sub-interface to be created with no IEEE80211_SDATA_IN_DRIVER bitnset because the monitor interface is in the cooked state and it takesnprecedence over all other states. When the interface is then being deletednthe kernel calls WARN_ONCE() from check_sdata_in_driver() because of missingnthat bit.nnFix this by rejecting MONITOR_FLAG_COOK_FRAMES if it is set along withnother flags.nnFound by Linux Verification Center (linuxtesting.org) with Syzkaller.,CVE-2025-21909,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnwifi: cfg80211: regulatory: improve invalid hints checkingnnSyzbot keeps reporting an issue [1] that occurs when erroneous symbolsnsent from userspace get through into user_alpha2[] vianregulatory_hint_user() call. Such invalid regulatory hints should benrejected.nnWhile a sanity check from commit 47caf685a685 (cfg80211: regulatory:nreject invalid hints) looks to be enough to deter these very casesnthere is a way to get around it due to 2 reasons.nn1) The way isalpha() works symbols other than latin lower andnupper letters may be used to determine a country/domain.nFor instance greek letters will also be considered upper/lowernletters and for such characters isalpha() will return true as well.nHowever ISO-3166-1 alpha2 codes should only hold latinncharacters.nn2) While processing a user regulatory request betweennreg_process_hint_user() and regulatory_hint_user() there happens tonbe a call to queue_regulatory_request() which modifies letters innrequest->alpha2[] with toupper(). This works fine for latin symbolsnless so for weird letter characters from the second part of _ctype[].nnSyzbot triggers a warning in is_user_regdom_saved() by first sendingnover an unexpected non-latin letter that gets malformed by toupper()ninto a character that ends up failing isalpha() check.nnPrevent this by enhancing is_an_alpha2() to ensure that incomingnsymbols are latin letters and nothing else.nn[1] Syzbot report:n------------[ cut here ]------------nUnexpected user alpha2: AnWARNING: CPU: 1 PID: 964 at net/wireless/reg.c:442 is_user_regdom_saved net/wireless/reg.c:440 [inline]nWARNING: CPU: 1 PID: 964 at net/wireless/reg.c:442 restore_alpha2 net/wireless/reg.c:3424 [inline]nWARNING: CPU: 1 PID: 964 at net/wireless/reg.c:442 restore_regulatory_settings+0x3c0/0x1e50 net/wireless/reg.c:3516nModules linked in:nCPU: 1 UID: 0 PID: 964 Comm: kworker/1:2 Not tainted 6.12.0-rc5-syzkaller-00044-gc1e939a21eb1 #0nHardware name: Google Google Compute Engine/Google Compute Engine BIOS Google 09/13/2024nWorkqueue: events_power_efficient crda_timeout_worknRIP: 0010:is_user_regdom_saved net/wireless/reg.c:440 [inline]nRIP: 0010:restore_alpha2 net/wireless/reg.c:3424 [inline]nRIP: 0010:restore_regulatory_settings+0x3c0/0x1e50 net/wireless/reg.c:3516n...nCall Trace:n <TASK>n crda_timeout_work+0x27/0x50 net/wireless/reg.c:542n process_one_work kernel/workqueue.c:3229 [inline]n process_scheduled_works+0xa65/0x1850 kernel/workqueue.c:3310n worker_thread+0x870/0xd30 kernel/workqueue.c:3391n kthread+0x2f2/0x390 kernel/kthread.c:389n ret_from_fork+0x4d/0x80 arch/x86/kernel/process.c:147n ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244n </TASK>,CVE-2025-21910,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nngpio: rcar: Use raw_spinlock to protect register accessnnUse raw_spinlock in order to fix spurious messages about invalid contextnwhen spinlock debugging is enabled. The lock is only used to serializenregister access.nn [ 4.239592] =============================n [ 4.239595] [ BUG: Invalid wait context ]n [ 4.239599] 6.13.0-rc7-arm64-renesas-05496-gd088502a519f #35 Not taintedn [ 4.239603] -----------------------------n [ 4.239606] kworker/u8:5/76 is trying to lock:n [ 4.239609] ffff0000091898a0 (&p->lock){....}-{3:3} at: gpio_rcar_config_interrupt_input_mode+0x34/0x164n [ 4.239641] other info that might help us debug this:n [ 4.239643] context-{5:5}n [ 4.239646] 5 locks held by kworker/u8:5/76:n [ 4.239651] #0: ffff0000080fb148 ((wq_completion)async){+.+.}-{0:0} at: process_one_work+0x190/0x62cn [ 4.250180] OF: /soc/sound@ec500000/ports/port@0/endpoint: Read of boolean property 'frame-master' with a value.n [ 4.254094] #1: ffff80008299bd80 ((work_completion)(&entry->work)){+.+.}-{0:0} at: process_one_work+0x1b8/0x62cn [ 4.254109] #2: ffff00000920c8f8n [ 4.258345] OF: /soc/sound@ec500000/ports/port@1/endpoint: Read of boolean property 'bitclock-master' with a value.n [ 4.264803] (&dev->mutex){....}-{4:4} at: __device_attach_async_helper+0x3c/0xdcn [ 4.264820] #3: ffff00000a50ca40 (request_class#2){+.+.}-{4:4} at: __setup_irq+0xa0/0x690n [ 4.264840] #4:n [ 4.268872] OF: /soc/sound@ec500000/ports/port@1/endpoint: Read of boolean property 'frame-master' with a value.n [ 4.273275] ffff00000a50c8c8 (lock_class){....}-{2:2} at: __setup_irq+0xc4/0x690n [ 4.296130] renesas_sdhi_internal_dmac ee100000.mmc: mmc1 base at 0x00000000ee100000 max clock rate 200 MHzn [ 4.304082] stack backtrace:n [ 4.304086] CPU: 1 UID: 0 PID: 76 Comm: kworker/u8:5 Not tainted 6.13.0-rc7-arm64-renesas-05496-gd088502a519f #35n [ 4.304092] Hardware name: Renesas Salvator-X 2nd version board based on r8a77965 (DT)n [ 4.304097] Workqueue: async async_run_entry_fnn [ 4.304106] Call trace:n [ 4.304110] show_stack+0x14/0x20 (C)n [ 4.304122] dump_stack_lvl+0x6c/0x90n [ 4.304131] dump_stack+0x14/0x1cn [ 4.304138] __lock_acquire+0xdfc/0x1584n [ 4.426274] lock_acquire+0x1c4/0x33cn [ 4.429942] _raw_spin_lock_irqsave+0x5c/0x80n [ 4.434307] gpio_rcar_config_interrupt_input_mode+0x34/0x164n [ 4.440061] gpio_rcar_irq_set_type+0xd4/0xd8n [ 4.444422] __irq_set_trigger+0x5c/0x178n [ 4.448435] __setup_irq+0x2e4/0x690n [ 4.452012] request_threaded_irq+0xc4/0x190n [ 4.456285] devm_request_threaded_irq+0x7c/0xf4n [ 4.459398] ata1: link resume succeeded after 1 retriesn [ 4.460902] mmc_gpiod_request_cd_irq+0x68/0xe0n [ 4.470660] mmc_start_host+0x50/0xacn [ 4.474327] mmc_add_host+0x80/0xe4n [ 4.477817] tmio_mmc_host_probe+0x2b0/0x440n [ 4.482094] renesas_sdhi_probe+0x488/0x6f4n [ 4.486281] renesas_sdhi_internal_dmac_probe+0x60/0x78n [ 4.491509] platform_probe+0x64/0xd8n [ 4.495178] really_probe+0xb8/0x2a8n [ 4.498756] __driver_probe_device+0x74/0x118n [ 4.503116] driver_probe_device+0x3c/0x154n [ 4.507303] __device_attach_driver+0xd4/0x160n [ 4.511750] bus_for_each_drv+0x84/0xe0n [ 4.515588] __device_attach_async_helper+0xb0/0xdcn [ 4.520470] async_run_entry_fn+0x30/0xd8n [ 4.524481] process_one_work+0x210/0x62cn [ 4.528494] worker_thread+0x1ac/0x340n [ 4.532245] kthread+0x10c/0x110n [ 4.535476] ret_from_fork+0x10/0x20,CVE-2025-21912,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnslimbus: messaging: Free transaction ID in delayed interrupt scenarionnIn case of interrupt delay for any reason slim_do_transfer()nreturns timeout error but the transaction ID (TID) is not freed.nThis results into invalid memory access insidenqcom_slim_ngd_rx_msgq_cb() due to invalid TID.nnFix the issue by freeing the TID in slim_do_transfer() beforenreturning timeout error to avoid invalid memory access.nnCall trace:n__memcpy_fromio+0x20/0x190nqcom_slim_ngd_rx_msgq_cb+0x130/0x290 [slim_qcom_ngd_ctrl]nvchan_complete+0x2a0/0x4a0ntasklet_action_common+0x274/0x700ntasklet_action+0x28/0x3cn_stext+0x188/0x620nrun_ksoftirqd+0x34/0x74nsmpboot_thread_fn+0x1d8/0x464nkthread+0x178/0x238nret_from_fork+0x10/0x20nCode: aa0003e8 91000429 f100044a 3940002b (3800150b)n---[ end trace 0fe00bec2b975c99 ]---nKernel panic - not syncing: Oops: Fatal exception in interrupt.,CVE-2025-21914,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnusb: atm: cxacru: fix a flaw in existing endpoint checksnnSyzbot once again identified a flaw in usb endpoint checking see [1].nThis time the issue stems from a commit authored by me (2eabb655a968n(usb: atm: cxacru: fix endpoint checking in cxacru_bind())).nnWhile using usb_find_common_endpoints() may usually be enough tondiscard devices with wrong endpoints in this case one needs morenthan just finding and identifying the sufficient number of endpointsnof correct types - one needs to check the endpoint's address as well.nnSince cxacru_bind() fills URBs with CXACRU_EP_CMD address in mindnswitch the endpoint verification approach to usb_check_XXX_endpoints()ninstead to fix incomplete ep testing.nn[1] Syzbot report:nusb 5-1: BOGUS urb xfer pipe 3 != type 1nWARNING: CPU: 0 PID: 1378 at drivers/usb/core/urb.c:504 usb_submit_urb+0xc4e/0x18c0 drivers/usb/core/urb.c:503n...nRIP: 0010:usb_submit_urb+0xc4e/0x18c0 drivers/usb/core/urb.c:503n...nCall Trace:n <TASK>n cxacru_cm+0x3c8/0xe50 drivers/usb/atm/cxacru.c:649n cxacru_card_status drivers/usb/atm/cxacru.c:760 [inline]n cxacru_bind+0xcf9/0x1150 drivers/usb/atm/cxacru.c:1223n usbatm_usb_probe+0x314/0x1d30 drivers/usb/atm/usbatm.c:1058n cxacru_usb_probe+0x184/0x220 drivers/usb/atm/cxacru.c:1377n usb_probe_interface+0x641/0xbb0 drivers/usb/core/driver.c:396n really_probe+0x2b9/0xad0 drivers/base/dd.c:658n __driver_probe_device+0x1a2/0x390 drivers/base/dd.c:800n driver_probe_device+0x50/0x430 drivers/base/dd.c:830n...,CVE-2025-21916,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnusb: renesas_usbhs: Flush the notify_hotplug_worknnWhen performing continuous unbind/bind operations on the USB driversnavailable on the Renesas RZ/G2L SoC a kernel crash with the messagenUnable to handle kernel NULL pointer dereference at virtual addressnmay occur. This issue points to the usbhsc_notify_hotplug() function.nnFlush the delayed work to avoid its execution when driver resources arenunavailable.,CVE-2025-21917,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnvlan: enforce underlying device typennCurrently VLAN devices can be created on top of non-ethernet devices.nnBesides the fact that it doesn't make much sense this also causes anbug which leaks the address of a kernel function to usermode.nnWhen creating a VLAN device we initialize GARP (garp_init_applicant)nand MRP (mrp_init_applicant) for the underlying device.nnAs part of the initialization process we add the multicast address ofneach applicant to the underlying device by calling dev_mc_add.nn__dev_mc_add uses dev->addr_len to determine the length of the newnmulticast address.nnThis causes an out-of-bounds read if dev->addr_len is greater than 6nsince the multicast addresses provided by GARP and MRP are only 6nbytes long.nnThis behaviour can be reproduced using the following commands:nnip tunnel add gretest mode ip6gre local ::1 remote ::2 dev lonip l set up dev gretestnip link add link gretest name vlantest type vlan id 100nnThen the following command will display the address of garp_pdu_rcv:nnip maddr show | grep 01:80:c2:00:00:21nnFix the bug by enforcing the type of the underlying device during VLANndevice initialization.,CVE-2025-21920,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnppp: Fix KMSAN uninit-value warning with bpfnnSyzbot caught an KMSAN: uninit-value warning [1] which is caused by thenppp driver not initializing a 2-byte header when using socket filter.nnThe following code can generate a PPP filter BPF program:n'''nstruct bpf_program fp;npcap_t *handle;nhandle = pcap_open_dead(DLT_PPP_PPPD 65535);npcap_compile(handle &fp ip and outbound 0 0);nbpf_dump(&fp 1);n'''nIts output is:n'''n(000) ldh [2]n(001) jeq #0x21 jt 2 jf 5n(002) ldb [0]n(003) jeq #0x1 jt 4 jf 5n(004) ret #65535n(005) ret #0n'''nWen can find similar code at the following link:nhttps://github.com/ppp-project/ppp/blob/master/pppd/options.c#L1680nThe maintainer of this code repository is also the original maintainernof the ppp driver.nnAs you can see the BPF program skips 2 bytes of data and then reads then'Protocol' field to determine if it's an IP packet. Then it read the firstnbyte of the first 2 bytes to determine the direction.nnThe issue is that only the first byte indicating direction is initializednin current ppp driver code while the second byte is not initialized.nnFor normal BPF programs generated by libpcap uninitialized data won't benused so it's not a problem. However for carefully crafted BPF programsnsuch as those generated by syzkaller [2] which start reading from offsetn0 the uninitialized data will be used and caught by KMSAN.nn[1] https://syzkaller.appspot.com/bug?extid=853242d9c9917165d791n[2] https://syzkaller.appspot.com/text?tag=ReproC&x=11994913980000,CVE-2025-21922,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnllc: do not use skb_get() before dev_queue_xmit()nnsyzbot is able to crash hosts [1] using llc and devicesnnot supporting IFF_TX_SKB_SHARING.nnIn this case e1000 driver calls eth_skb_pad() whilenthe skb is shared.nnSimply replace skb_get() by skb_clone() in net/llc/llc_s_ac.cnnNote that e1000 driver might have an issue with pktgennbecause it does not clear IFF_TX_SKB_SHARING this is annorthogonal change.nnWe need to audit other skb_get() uses in net/llc.nn[1]nnkernel BUG at net/core/skbuff.c:2178 !nOops: invalid opcode: 0000 [#1] PREEMPT SMP KASAN NOPTInCPU: 0 UID: 0 PID: 16371 Comm: syz.2.2764 Not tainted 6.14.0-rc4-syzkaller-00052-gac9c34d1e45a #0nHardware name: QEMU Standard PC (Q35 + ICH9 2009) BIOS 1.16.3-debian-1.16.3-2~bpo12+1 04/01/2014n RIP: 0010:pskb_expand_head+0x6ce/0x1240 net/core/skbuff.c:2178nCall Trace:n <TASK>n __skb_pad+0x18a/0x610 net/core/skbuff.c:2466n __skb_put_padto include/linux/skbuff.h:3843 [inline]n skb_put_padto include/linux/skbuff.h:3862 [inline]n eth_skb_pad include/linux/etherdevice.h:656 [inline]n e1000_xmit_frame+0x2d99/0x5800 drivers/net/ethernet/intel/e1000/e1000_main.c:3128n __netdev_start_xmit include/linux/netdevice.h:5151 [inline]n netdev_start_xmit include/linux/netdevice.h:5160 [inline]n xmit_one net/core/dev.c:3806 [inline]n dev_hard_start_xmit+0x9a/0x7b0 net/core/dev.c:3822n sch_direct_xmit+0x1ae/0xc30 net/sched/sch_generic.c:343n __dev_xmit_skb net/core/dev.c:4045 [inline]n __dev_queue_xmit+0x13d4/0x43e0 net/core/dev.c:4621n dev_queue_xmit include/linux/netdevice.h:3313 [inline]n llc_sap_action_send_test_c+0x268/0x320 net/llc/llc_s_ac.c:144n llc_exec_sap_trans_actions net/llc/llc_sap.c:153 [inline]n llc_sap_next_state net/llc/llc_sap.c:182 [inline]n llc_sap_state_process+0x239/0x510 net/llc/llc_sap.c:209n llc_ui_sendmsg+0xd0d/0x14e0 net/llc/af_llc.c:993n sock_sendmsg_nosec net/socket.c:718 [inline],CVE-2025-21925,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet: gso: fix ownership in __udp_gso_segmentnnIn __udp_gso_segment the skb destructor is removed before segmenting thenskb but the socket reference is kept as-is. This is an issue if thenoriginal skb is later orphaned as we can hit the following bug:nn kernel BUG at ./include/linux/skbuff.h:3312! (skb_orphan)n RIP: 0010:ip_rcv_core+0x8b2/0xca0n Call Trace:n ip_rcv+0xab/0x6e0n __netif_receive_skb_one_core+0x168/0x1b0n process_backlog+0x384/0x1100n __napi_poll.constprop.0+0xa1/0x370n net_rx_action+0x925/0xe50nnThe above can happen following a sequence of events when usingnOpenVSwitch when an OVS_ACTION_ATTR_USERSPACE action precedes annOVS_ACTION_ATTR_OUTPUT action:nn1. OVS_ACTION_ATTR_USERSPACE is handled (in do_execute_actions): the skbn goes through queue_gso_packets and then __udp_gso_segment where itsn destructor is removed.n2. The segments' data are copied and sent to userspace.n3. OVS_ACTION_ATTR_OUTPUT is handled (in do_execute_actions) and then same original skb is sent to its path.n4. If it later hits skb_orphan we hit the bug.nnFix this by also removing the reference to the socket inn__udp_gso_segment.,CVE-2025-21926,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnvme-tcp: fix potential memory corruption in nvme_tcp_recv_pdu()nnnvme_tcp_recv_pdu() doesn't check the validity of the header length.nWhen header digests are enabled a target might send a packet with anninvalid header length (e.g. 255) causing nvme_tcp_verify_hdgst()nto access memory outside the allocated area and cause memory corruptionsnby overwriting it with the calculated digest.nnFix this by rejecting packets with an unexpected header length.,CVE-2025-21927,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnHID: intel-ish-hid: Fix use-after-free issue in ishtp_hid_remove()nnThe system can experience a random crash a few minutes after the driver isnremoved. This issue occurs due to improper handling of memory freeing innthe ishtp_hid_remove() function.nnThe function currently frees the `driver_data` directly within the loopnthat destroys the HID devices which can lead to accessing freed memory.nSpecifically `hid_destroy_device()` uses `driver_data` when it callsn`hid_ishtp_set_feature()` to power off the sensor so freeingn`driver_data` beforehand can result in accessing invalid memory.nnThis patch resolves the issue by storing the `driver_data` in a temporarynvariable before calling `hid_destroy_device()` and then freeing then`driver_data` after the device is destroyed.,CVE-2025-21928,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnhwpoison memory_hotplug: lock folio before unmap hwpoisoned folionnCommit b15c87263a69 (hwpoison memory_hotplug: allow hwpoisoned pages tonbe offlined) add page poison checks in do_migrate_range in order to makenoffline hwpoisoned page possible by introducing isolate_lru_page andntry_to_unmap for hwpoisoned page. However folio lock must be held beforencalling try_to_unmap. Add it to fix this problem.nnWarning will be produced if folio is not locked during unmap:nn ------------[ cut here ]------------n kernel BUG at ./include/linux/swapops.h:400!n Internal error: Oops - BUG: 00000000f2000800 [#1] PREEMPT SMPn Modules linked in:n CPU: 4 UID: 0 PID: 411 Comm: bash Tainted: G W 6.13.0-rc1-00016-g3c434c7ee82a-dirty #41n Tainted: [W]=WARNn Hardware name: QEMU QEMU Virtual Machine BIOS 0.0.0 02/06/2015n pstate: 40400005 (nZcv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)n pc : try_to_unmap_one+0xb08/0xd3cn lr : try_to_unmap_one+0x3dc/0xd3cn Call trace:n try_to_unmap_one+0xb08/0xd3c (P)n try_to_unmap_one+0x3dc/0xd3c (L)n rmap_walk_anon+0xdc/0x1f8n rmap_walk+0x3c/0x58n try_to_unmap+0x88/0x90n unmap_poisoned_folio+0x30/0xa8n do_migrate_range+0x4a0/0x568n offline_pages+0x5a4/0x670n memory_block_action+0x17c/0x374n memory_subsys_offline+0x3c/0x78n device_offline+0xa4/0xd0n state_store+0x8c/0xf0n dev_attr_store+0x18/0x2cn sysfs_kf_write+0x44/0x54n kernfs_fop_write_iter+0x118/0x1a8n vfs_write+0x3a8/0x4bcn ksys_write+0x6c/0xf8n __arm64_sys_write+0x1c/0x28n invoke_syscall+0x44/0x100n el0_svc_common.constprop.0+0x40/0xe0n do_el0_svc+0x1c/0x28n el0_svc+0x30/0xd0n el0t_64_sync_handler+0xc8/0xccn el0t_64_sync+0x198/0x19cn Code: f9407be0 b5fff320 d4210000 17ffff97 (d4210000)n ---[ end trace 0000000000000000 ]---,CVE-2025-21931,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnrapidio: fix an API misues when rio_add_net() failsnnrio_add_net() calls device_register() and fails when device_register()nfails. Thus put_device() should be used rather than kfree(). Addnmport->net = NULL; to avoid a use after free issue.,CVE-2025-21934,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnrapidio: add check for rio_add_net() in rio_scan_alloc_net()nnThe return value of rio_add_net() should be checked. If it failsnput_device() should be called to free the memory and give up the referenceninitialized in rio_add_net().,CVE-2025-21935,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Fix null check for pipe_ctx->plane_state in resource_build_scaling_paramsnnNull pointer dereference issue could occur when pipe_ctx->plane_statenis null. The fix adds a check to ensure 'pipe_ctx->plane_state' is notnnull before accessing. This prevents a null pointer dereference.nnFound by code review.nn(cherry picked from commit 63e6a77ccf239337baa9b1e7787cde9fa0462092),CVE-2025-21941,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nngpio: aggregator: protect driver attr handlers against module unloadnnBoth new_device_store and delete_device_store touch module globalnresources (e.g. gpio_aggregator_lock). To prevent race conditions withnmodule unload a reference needs to be held.nnAdd try_module_get() in these handlers.nnFor new_device_store this eliminates what appears to be the most dangerousnscenario: if an id is allocated from gpio_aggregator_idr butnplatform_device_register has not yet been called or completed a concurrentnmodule unload could fail to unregister/delete the device leaving behind andangling platform device/GPIO forwarder. This can result in various issues.nThe following simple reproducer demonstrates these problems:nn #!/bin/bashn while :; don # note: whether 'gpiochip0 0' exists or not does not matter.n echo 'gpiochip0 0' > /sys/bus/platform/drivers/gpio-aggregator/new_devicen done &n while :; don modprobe gpio-aggregatorn modprobe -r gpio-aggregatorn done &n waitnn Starting with the following warning several kinds of warnings will appearn and the system may become unstable:nn ------------[ cut here ]------------n list_del corruption ffff888103e2e980->next is LIST_POISON1 (dead000000000100)n WARNING: CPU: 1 PID: 1327 at lib/list_debug.c:56 __list_del_entry_valid_or_report+0xa3/0x120n [...]n RIP: 0010:__list_del_entry_valid_or_report+0xa3/0x120n [...]n Call Trace:n <TASK>n ? __list_del_entry_valid_or_report+0xa3/0x120n ? __warn.cold+0x93/0xf2n ? __list_del_entry_valid_or_report+0xa3/0x120n ? report_bug+0xe6/0x170n ? __irq_work_queue_local+0x39/0xe0n ? handle_bug+0x58/0x90n ? exc_invalid_op+0x13/0x60n ? asm_exc_invalid_op+0x16/0x20n ? __list_del_entry_valid_or_report+0xa3/0x120n gpiod_remove_lookup_table+0x22/0x60n new_device_store+0x315/0x350 [gpio_aggregator]n kernfs_fop_write_iter+0x137/0x1f0n vfs_write+0x262/0x430n ksys_write+0x60/0xd0n do_syscall_64+0x6c/0x180n entry_SYSCALL_64_after_hwframe+0x76/0x7en [...]n </TASK>n ---[ end trace 0000000000000000 ]---,CVE-2025-21943,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnHID: appleir: Fix potential NULL dereference at raw event handlennSyzkaller reports a NULL pointer dereference issue in input_event().nnBUG: KASAN: null-ptr-deref in instrument_atomic_read include/linux/instrumented.h:68 [inline]nBUG: KASAN: null-ptr-deref in _test_bit include/asm-generic/bitops/instrumented-non-atomic.h:141 [inline]nBUG: KASAN: null-ptr-deref in is_event_supported drivers/input/input.c:67 [inline]nBUG: KASAN: null-ptr-deref in input_event+0x42/0xa0 drivers/input/input.c:395nRead of size 8 at addr 0000000000000028 by task syz-executor199/2949nnCPU: 0 UID: 0 PID: 2949 Comm: syz-executor199 Not tainted 6.13.0-rc4-syzkaller-00076-gf097a36ef88d #0nHardware name: Google Google Compute Engine/Google Compute Engine BIOS Google 09/13/2024nCall Trace:n <IRQ>n __dump_stack lib/dump_stack.c:94 [inline]n dump_stack_lvl+0x116/0x1f0 lib/dump_stack.c:120n kasan_report+0xd9/0x110 mm/kasan/report.c:602n check_region_inline mm/kasan/generic.c:183 [inline]n kasan_check_range+0xef/0x1a0 mm/kasan/generic.c:189n instrument_atomic_read include/linux/instrumented.h:68 [inline]n _test_bit include/asm-generic/bitops/instrumented-non-atomic.h:141 [inline]n is_event_supported drivers/input/input.c:67 [inline]n input_event+0x42/0xa0 drivers/input/input.c:395n input_report_key include/linux/input.h:439 [inline]n key_down drivers/hid/hid-appleir.c:159 [inline]n appleir_raw_event+0x3e5/0x5e0 drivers/hid/hid-appleir.c:232n __hid_input_report.constprop.0+0x312/0x440 drivers/hid/hid-core.c:2111n hid_ctrl+0x49f/0x550 drivers/hid/usbhid/hid-core.c:484n __usb_hcd_giveback_urb+0x389/0x6e0 drivers/usb/core/hcd.c:1650n usb_hcd_giveback_urb+0x396/0x450 drivers/usb/core/hcd.c:1734n dummy_timer+0x17f7/0x3960 drivers/usb/gadget/udc/dummy_hcd.c:1993n __run_hrtimer kernel/time/hrtimer.c:1739 [inline]n __hrtimer_run_queues+0x20a/0xae0 kernel/time/hrtimer.c:1803n hrtimer_run_softirq+0x17d/0x350 kernel/time/hrtimer.c:1820n handle_softirqs+0x206/0x8d0 kernel/softirq.c:561n __do_softirq kernel/softirq.c:595 [inline]n invoke_softirq kernel/softirq.c:435 [inline]n __irq_exit_rcu+0xfa/0x160 kernel/softirq.c:662n irq_exit_rcu+0x9/0x30 kernel/softirq.c:678n instr_sysvec_apic_timer_interrupt arch/x86/kernel/apic/apic.c:1049 [inline]n sysvec_apic_timer_interrupt+0x90/0xb0 arch/x86/kernel/apic/apic.c:1049n </IRQ>n <TASK>n asm_sysvec_apic_timer_interrupt+0x1a/0x20 arch/x86/include/asm/idtentry.h:702n __mod_timer+0x8f6/0xdc0 kernel/time/timer.c:1185n add_timer+0x62/0x90 kernel/time/timer.c:1295n schedule_timeout+0x11f/0x280 kernel/time/sleep_timeout.c:98n usbhid_wait_io+0x1c7/0x380 drivers/hid/usbhid/hid-core.c:645n usbhid_init_reports+0x19f/0x390 drivers/hid/usbhid/hid-core.c:784n hiddev_ioctl+0x1133/0x15b0 drivers/hid/usbhid/hiddev.c:794n vfs_ioctl fs/ioctl.c:51 [inline]n __do_sys_ioctl fs/ioctl.c:906 [inline]n __se_sys_ioctl fs/ioctl.c:892 [inline]n __x64_sys_ioctl+0x190/0x200 fs/ioctl.c:892n do_syscall_x64 arch/x86/entry/common.c:52 [inline]n do_syscall_64+0xcd/0x250 arch/x86/entry/common.c:83n entry_SYSCALL_64_after_hwframe+0x77/0x7fn </TASK>nnThis happens due to the malformed report items sent by the emulated devicenwhich results in a report that has no fields being added to the report list.nDue to this appleir_input_configured() is never called hidinput_connect()nfails which results in the HID_CLAIMED_INPUT flag is not being set. Howevernit does not make appleir_probe() fail and lets the event callback to bencalled without the associated input device.nnThus add a check for the HID_CLAIMED_INPUT flag and leave the event hooknearly if the driver didn't claim any input_dev for some reason. Moreovernsome other hid drivers accessing input_dev in their event callbacks do havensimilar checks too.nnFound by Linux Verification Center (linuxtesting.org) with Syzkaller.,CVE-2025-21948,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Assign normalized_pix_clk when color depth = 14nn[WHY & HOW]nA warning message WARNING: CPU: 4 PID: 459 at ... /dc_resource.c:3397ncalculate_phy_pix_clks+0xef/0x100 [amdgpu] occurs because thendisplay_color_depth == COLOR_DEPTH_141414 is not handled. This isnobserved in Radeon RX 6600 XT.nnIt is fixed by assigning pix_clk output.log scan_tyk_dockerimages.sh vulnerabilities.csv (14 output.log scan_tyk_dockerimages.sh vulnerabilities.csv 3) / 24 - same as the rests.nnAlso fixes the indentation in get_norm_pix_clk.nn(cherry picked from commit 274a87eb389f58eddcbc5659ab0b180b37e92775),CVE-2025-21956,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnscsi: qla1280: Fix kernel oops when debug level > 2nnA null dereference or oops exception will eventually occur when qla1280.cndriver is compiled with DEBUG_QLA1280 enabled and ql_debug_level > 2. Inthink its clear from the code that the intention here is sg_dma_len(s) notnlength of sg_next(s) when printing the debug info.,CVE-2025-21957,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnetfilter: nf_conncount: Fully initialize struct nf_conncount_tuple in insert_tree()nnSince commit b36e4523d4d5 (netfilter: nf_conncount: fix garbagencollection confirm race) `cpu` and `jiffies32` were introduced tonthe struct nf_conncount_tuple.nnThe commit made nf_conncount_add() initialize `conn->cpu` andn`conn->jiffies32` when allocating the struct.nIn contrast count_tree() was not changed to initialize them.nnBy commit 34848d5c896e (netfilter: nf_conncount: Split insert andntraversal) count_tree() was split and the relevant allocationncode now resides in insert_tree().nInitialize `conn->cpu` and `conn->jiffies32` in insert_tree().nnBUG: KMSAN: uninit-value in find_or_evict net/netfilter/nf_conncount.c:117 [inline]nBUG: KMSAN: uninit-value in __nf_conncount_add+0xd9c/0x2850 net/netfilter/nf_conncount.c:143n find_or_evict net/netfilter/nf_conncount.c:117 [inline]n __nf_conncount_add+0xd9c/0x2850 net/netfilter/nf_conncount.c:143n count_tree net/netfilter/nf_conncount.c:438 [inline]n nf_conncount_count+0x82f/0x1e80 net/netfilter/nf_conncount.c:521n connlimit_mt+0x7f6/0xbd0 net/netfilter/xt_connlimit.c:72n __nft_match_eval net/netfilter/nft_compat.c:403 [inline]n nft_match_eval+0x1a5/0x300 net/netfilter/nft_compat.c:433n expr_call_ops_eval net/netfilter/nf_tables_core.c:240 [inline]n nft_do_chain+0x426/0x2290 net/netfilter/nf_tables_core.c:288n nft_do_chain_ipv4+0x1a5/0x230 net/netfilter/nft_chain_filter.c:23n nf_hook_entry_hookfn include/linux/netfilter.h:154 [inline]n nf_hook_slow+0xf4/0x400 net/netfilter/core.c:626n nf_hook_slow_list+0x24d/0x860 net/netfilter/core.c:663n NF_HOOK_LIST include/linux/netfilter.h:350 [inline]n ip_sublist_rcv+0x17b7/0x17f0 net/ipv4/ip_input.c:633n ip_list_rcv+0x9ef/0xa40 net/ipv4/ip_input.c:669n __netif_receive_skb_list_ptype net/core/dev.c:5936 [inline]n __netif_receive_skb_list_core+0x15c5/0x1670 net/core/dev.c:5983n __netif_receive_skb_list net/core/dev.c:6035 [inline]n netif_receive_skb_list_internal+0x1085/0x1700 net/core/dev.c:6126n netif_receive_skb_list+0x5a/0x460 net/core/dev.c:6178n xdp_recv_frames net/bpf/test_run.c:280 [inline]n xdp_test_run_batch net/bpf/test_run.c:361 [inline]n bpf_test_run_xdp_live+0x2e86/0x3480 net/bpf/test_run.c:390n bpf_prog_test_run_xdp+0xf1d/0x1ae0 net/bpf/test_run.c:1316n bpf_prog_test_run+0x5e5/0xa30 kernel/bpf/syscall.c:4407n __sys_bpf+0x6aa/0xd90 kernel/bpf/syscall.c:5813n __do_sys_bpf kernel/bpf/syscall.c:5902 [inline]n __se_sys_bpf kernel/bpf/syscall.c:5900 [inline]n __ia32_sys_bpf+0xa0/0xe0 kernel/bpf/syscall.c:5900n ia32_sys_call+0x394d/0x4180 arch/x86/include/generated/asm/syscalls_32.h:358n do_syscall_32_irqs_on arch/x86/entry/common.c:165 [inline]n __do_fast_syscall_32+0xb0/0x110 arch/x86/entry/common.c:387n do_fast_syscall_32+0x38/0x80 arch/x86/entry/common.c:412n do_SYSENTER_32+0x1f/0x30 arch/x86/entry/common.c:450n entry_SYSENTER_compat_after_hwframe+0x84/0x8ennUninit was created at:n slab_post_alloc_hook mm/slub.c:4121 [inline]n slab_alloc_node mm/slub.c:4164 [inline]n kmem_cache_alloc_noprof+0x915/0xe10 mm/slub.c:4171n insert_tree net/netfilter/nf_conncount.c:372 [inline]n count_tree net/netfilter/nf_conncount.c:450 [inline]n nf_conncount_count+0x1415/0x1e80 net/netfilter/nf_conncount.c:521n connlimit_mt+0x7f6/0xbd0 net/netfilter/xt_connlimit.c:72n __nft_match_eval net/netfilter/nft_compat.c:403 [inline]n nft_match_eval+0x1a5/0x300 net/netfilter/nft_compat.c:433n expr_call_ops_eval net/netfilter/nf_tables_core.c:240 [inline]n nft_do_chain+0x426/0x2290 net/netfilter/nf_tables_core.c:288n nft_do_chain_ipv4+0x1a5/0x230 net/netfilter/nft_chain_filter.c:23n nf_hook_entry_hookfn include/linux/netfilter.h:154 [inline]n nf_hook_slow+0xf4/0x400 net/netfilter/core.c:626n nf_hook_slow_list+0x24d/0x860 net/netfilter/core.c:663n NF_HOOK_LIST include/linux/netfilter.h:350 [inline]n ip_sublist_rcv+0x17b7/0x17f0 net/ipv4/ip_input.c:633n ip_list_rcv+0x9ef/0xa40 net/ipn---truncated---,CVE-2025-21959,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Fix slab-use-after-free on hdcp_worknn[Why]nA slab-use-after-free is reported when HDCP is destroyed but thenproperty_validate_dwork queue is still running.nn[How]nCancel the delayed work when destroying workqueue.nn(cherry picked from commit 725a04ba5a95e89c89633d4322430cfbca7ce128),CVE-2025-21968,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnBluetooth: L2CAP: Fix slab-use-after-free Read in l2cap_send_cmdnnAfter the hci sync command releases l2cap_conn the hci receive data worknqueue references the released l2cap_conn when sending to the upper layer.nAdd hci dev lock to the hci receive data work queue to synchronize the two.nn[1]nBUG: KASAN: slab-use-after-free in l2cap_send_cmd+0x187/0x8d0 net/bluetooth/l2cap_core.c:954nRead of size 8 at addr ffff8880271a4000 by task kworker/u9:2/5837nnCPU: 0 UID: 0 PID: 5837 Comm: kworker/u9:2 Not tainted 6.13.0-rc5-syzkaller-00163-gab75170520d4 #0nHardware name: Google Google Compute Engine/Google Compute Engine BIOS Google 09/13/2024nWorkqueue: hci1 hci_rx_worknCall Trace:n <TASK>n __dump_stack lib/dump_stack.c:94 [inline]n dump_stack_lvl+0x241/0x360 lib/dump_stack.c:120n print_address_description mm/kasan/report.c:378 [inline]n print_report+0x169/0x550 mm/kasan/report.c:489n kasan_report+0x143/0x180 mm/kasan/report.c:602n l2cap_build_cmd net/bluetooth/l2cap_core.c:2964 [inline]n l2cap_send_cmd+0x187/0x8d0 net/bluetooth/l2cap_core.c:954n l2cap_sig_send_rej net/bluetooth/l2cap_core.c:5502 [inline]n l2cap_sig_channel net/bluetooth/l2cap_core.c:5538 [inline]n l2cap_recv_frame+0x221f/0x10db0 net/bluetooth/l2cap_core.c:6817n hci_acldata_packet net/bluetooth/hci_core.c:3797 [inline]n hci_rx_work+0x508/0xdb0 net/bluetooth/hci_core.c:4040n process_one_work kernel/workqueue.c:3229 [inline]n process_scheduled_works+0xa66/0x1840 kernel/workqueue.c:3310n worker_thread+0x870/0xd30 kernel/workqueue.c:3391n kthread+0x2f0/0x390 kernel/kthread.c:389n ret_from_fork+0x4b/0x80 arch/x86/kernel/process.c:147n ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244n </TASK>nnAllocated by task 5837:n kasan_save_stack mm/kasan/common.c:47 [inline]n kasan_save_track+0x3f/0x80 mm/kasan/common.c:68n poison_kmalloc_redzone mm/kasan/common.c:377 [inline]n __kasan_kmalloc+0x98/0xb0 mm/kasan/common.c:394n kasan_kmalloc include/linux/kasan.h:260 [inline]n __kmalloc_cache_noprof+0x243/0x390 mm/slub.c:4329n kmalloc_noprof include/linux/slab.h:901 [inline]n kzalloc_noprof include/linux/slab.h:1037 [inline]n l2cap_conn_add+0xa9/0x8e0 net/bluetooth/l2cap_core.c:6860n l2cap_connect_cfm+0x115/0x1090 net/bluetooth/l2cap_core.c:7239n hci_connect_cfm include/net/bluetooth/hci_core.h:2057 [inline]n hci_remote_features_evt+0x68e/0xac0 net/bluetooth/hci_event.c:3726n hci_event_func net/bluetooth/hci_event.c:7473 [inline]n hci_event_packet+0xac2/0x1540 net/bluetooth/hci_event.c:7525n hci_rx_work+0x3f3/0xdb0 net/bluetooth/hci_core.c:4035n process_one_work kernel/workqueue.c:3229 [inline]n process_scheduled_works+0xa66/0x1840 kernel/workqueue.c:3310n worker_thread+0x870/0xd30 kernel/workqueue.c:3391n kthread+0x2f0/0x390 kernel/kthread.c:389n ret_from_fork+0x4b/0x80 arch/x86/kernel/process.c:147n ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244nnFreed by task 54:n kasan_save_stack mm/kasan/common.c:47 [inline]n kasan_save_track+0x3f/0x80 mm/kasan/common.c:68n kasan_save_free_info+0x40/0x50 mm/kasan/generic.c:582n poison_slab_object mm/kasan/common.c:247 [inline]n __kasan_slab_free+0x59/0x70 mm/kasan/common.c:264n kasan_slab_free include/linux/kasan.h:233 [inline]n slab_free_hook mm/slub.c:2353 [inline]n slab_free mm/slub.c:4613 [inline]n kfree+0x196/0x430 mm/slub.c:4761n l2cap_connect_cfm+0xcc/0x1090 net/bluetooth/l2cap_core.c:7235n hci_connect_cfm include/net/bluetooth/hci_core.h:2057 [inline]n hci_conn_failed+0x287/0x400 net/bluetooth/hci_conn.c:1266n hci_abort_conn_sync+0x56c/0x11f0 net/bluetooth/hci_sync.c:5603n hci_cmd_sync_work+0x22b/0x400 net/bluetooth/hci_sync.c:332n process_one_work kernel/workqueue.c:3229 [inline]n process_scheduled_works+0xa66/0x1840 kernel/workqueue.c:3310n worker_thread+0x870/0xd30 kernel/workqueue.c:3391n kthread+0x2f0/0x390 kernel/kthread.c:389n ret_from_fork+0x4b/0x80 arch/x86/kernel/process.c:147n ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entrn---truncated---,CVE-2025-21969,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet_sched: Prevent creation of classes with TC_H_ROOTnnThe function qdisc_tree_reduce_backlog() uses TC_H_ROOT as a terminationncondition when traversing up the qdisc tree to update parent backlogncounters. However if a class is created with classid TC_H_ROOT thentraversal terminates prematurely at this class instead of reaching thenactual root qdisc causing parent statistics to be incorrectly maintained.nIn case of DRR this could lead to a crash as reported by Mingi Cho.nnPrevent the creation of any Qdisc class with classid TC_H_ROOTn(0xFFFFFFFF) across all qdisc types as suggested by Jamal.,CVE-2025-21971,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet/mlx5: handle errors in mlx5_chains_create_table()nnIn mlx5_chains_create_table() the return value ofmlx5_get_fdb_sub_ns()nand mlx5_get_flow_namespace() must be checked to prevent NULL pointerndereferences. If either function fails the function should log errornmessage with mlx5_core_warn() and return error pointer.,CVE-2025-21975,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnfbdev: hyperv_fb: Allow graceful removal of framebuffernnWhen a Hyper-V framebuffer device is unbind hyperv_fb driver tries tonrelease the framebuffer forcefully. If this framebuffer is in use itnproduce the following WARN and hence this framebuffer is never released.nn[ 44.111220] WARNING: CPU: 35 PID: 1882 at drivers/video/fbdev/core/fb_info.c:70 framebuffer_release+0x2c/0x40n< snip >n[ 44.111289] Call Trace:n[ 44.111290] <TASK>n[ 44.111291] ? show_regs+0x6c/0x80n[ 44.111295] ? __warn+0x8d/0x150n[ 44.111298] ? framebuffer_release+0x2c/0x40n[ 44.111300] ? report_bug+0x182/0x1b0n[ 44.111303] ? handle_bug+0x6e/0xb0n[ 44.111306] ? exc_invalid_op+0x18/0x80n[ 44.111308] ? asm_exc_invalid_op+0x1b/0x20n[ 44.111311] ? framebuffer_release+0x2c/0x40n[ 44.111313] ? hvfb_remove+0x86/0xa0 [hyperv_fb]n[ 44.111315] vmbus_remove+0x24/0x40 [hv_vmbus]n[ 44.111323] device_remove+0x40/0x80n[ 44.111325] device_release_driver_internal+0x20b/0x270n[ 44.111327] ? bus_find_device+0xb3/0xf0nnFix this by moving the release of framebuffer and assosiated memorynto fb_ops.fb_destroy function so that framebuffer framework handlesnit gracefully.nnWhile we fix this also replace manual registrations/unregistration ofnframebuffer with devm_register_framebuffer.,CVE-2025-21976,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnice: fix memory leak in aRFS after resetnnFix aRFS (accelerated Receive Flow Steering) structures memory leak bynadding a checker to verify if aRFS memory is already allocated whilenconfiguring VSI. aRFS objects are allocated in two cases:n- as part of VSI initialization (at probe) andn- as part of reset handlingnnHowever VSI reconfiguration executed during reset involves memorynallocation one more time without prior releasing already allocatednresources. This led to the memory leak with the following signature:nn[root@os-delivery ~]# cat /sys/kernel/debug/kmemleaknunreferenced object 0xff3c1ca7252e6000 (size 8192):n comm kworker/0:0 pid 8 jiffies 4296833052n hex dump (first 32 bytes):n 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................n 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................n backtrace (crc 0):n [<ffffffff991ec485>] __kmalloc_cache_noprof+0x275/0x340n [<ffffffffc0a6e06a>] ice_init_arfs+0x3a/0xe0 [ice]n [<ffffffffc09f1027>] ice_vsi_cfg_def+0x607/0x850 [ice]n [<ffffffffc09f244b>] ice_vsi_setup+0x5b/0x130 [ice]n [<ffffffffc09c2131>] ice_init+0x1c1/0x460 [ice]n [<ffffffffc09c64af>] ice_probe+0x2af/0x520 [ice]n [<ffffffff994fbcd3>] local_pci_probe+0x43/0xa0n [<ffffffff98f07103>] work_for_cpu_fn+0x13/0x20n [<ffffffff98f0b6d9>] process_one_work+0x179/0x390n [<ffffffff98f0c1e9>] worker_thread+0x239/0x340n [<ffffffff98f14abc>] kthread+0xcc/0x100n [<ffffffff98e45a6d>] ret_from_fork+0x2d/0x50n [<ffffffff98e083ba>] ret_from_fork_asm+0x1a/0x30n ...,CVE-2025-21981,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Fix out-of-bound accessesnn[WHAT & HOW]nhpo_stream_to_link_encoder_mapping has size MAX_HPO_DP2_ENCODERS(=4)nbut location can have size up to 6. As a result it is necessary toncheck location against MAX_HPO_DP2_ENCODERS.nnSimiliarly disp_cfg_stream_location can be used as an array index whichnshould be 0..5 so the ASSERT's conditions should be less without equal.,CVE-2025-21985,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnx86/microcode/AMD: Fix out-of-bounds on systems with CPU-less NUMA nodesnnCurrently load_microcode_amd() iterates over all NUMA nodes retrieves theirnCPU masks and unconditionally accesses per-CPU data for the first CPU of eachnmask.nnAccording to Documentation/admin-guide/mm/numaperf.rst:nn Some memory may share the same node as a CPU and others are provided asn memory only nodes.nnTherefore some node CPU masks may be empty and wouldn't have a first CPU.nnOn a machine with far memory (and therefore CPU-less NUMA nodes):n- cpumask_of_node(nid) is 0n- cpumask_first(0) is CONFIG_NR_CPUSn- cpu_data(CONFIG_NR_CPUS) accesses the cpu_info per-CPU array at ann index that is 1 out of boundsnnThis does not have any security implications since flashing microcode isna privileged operation but I believe this has reliability implications bynpotentially corrupting memory while flashing a microcode update.nnWhen booting with CONFIG_UBSAN_BOUNDS=y on an AMD machine that flashesna microcode update. I get the following splat:nn UBSAN: array-index-out-of-bounds in arch/x86/kernel/cpu/microcode/amd.c:X:Yn index 512 is out of range for type 'unsigned long[512]'n [...]n Call Trace:n dump_stackn __ubsan_handle_out_of_boundsn load_microcode_amdn request_microcode_amdn reload_storen kernfs_fop_write_itern vfs_writen ksys_writen do_syscall_64n entry_SYSCALL_64_after_hwframennChange the loop to go over only NUMA nodes which have CPUs before determiningnwhether the first CPU on the respective node needs microcode update.nn [ bp: Massage commit message fix typo. ],CVE-2025-21991,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnHID: ignore non-functional sensor in HP 5MP CamerannThe HP 5MP Camera (USB ID 0408:5473) reports a HID sensor interface thatnis not actually implemented. Attempting to access this non-functionalnsensor via iio_info causes system hangs as runtime PM tries to wake upnan unresponsive sensor.nn [453] hid-sensor-hub 0003:0408:5473.0003: Report latency attributes: ffffffff:ffffffffn [453] hid-sensor-hub 0003:0408:5473.0003: common attributes: 5:1 2:1 3:1 ffffffff:ffffffffnnAdd this device to the HID ignore list since the sensor interface isnnon-functional by design and should not be exposed to userspace.,CVE-2025-21992,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nniscsi_ibft: Fix UBSAN shift-out-of-bounds warning in ibft_attr_show_nic()nnWhen performing an iSCSI boot using IPv6 iscsistart still reads then/sys/firmware/ibft/ethernetX/subnet-mask entry. Since the IPv6 prefixnlength is 64 this causes the shift exponent to become negativentriggering a UBSAN warning. As the concept of a subnet mask does notnapply to IPv6 the value is set to ~0 to suppress the warning message.,CVE-2025-21993,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/radeon: fix uninitialized size issue in radeon_vce_cs_parse()nnOn the off chance that command stream passed from userspace vianioctl() call to radeon_vce_cs_parse() is weirdly crafted andnfirst command to execute is to encode (case 0x03000001) the functionnin question will attempt to call radeon_vce_cs_reloc() with sizenargument that has not been properly initialized. Specifically 'size'nwill point to 'tmp' variable before the latter had a chance to benassigned any value.nnPlay it safe and init 'tmp' with 0 thus ensuring thatnradeon_vce_cs_reloc() will catch an early error in cases like these.nnFound by Linux Verification Center (linuxtesting.org) with staticnanalysis tool SVACE.nn(cherry picked from commit 2d52de55f9ee7aaee0e09ac443f77855989c6b68),CVE-2025-21996,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnproc: fix UAF in proc_get_inode()nnFix race between rmmod and /proc/XXX's inode instantiation.nnThe bug is that pde->proc_ops don't belong to /proc it belongs to anmodule therefore dereferencing it after /proc entry has been registerednis a bug unless use_pde/unuse_pde() pair has been used.nnuse_pde/unuse_pde can be avoided (2 atomic ops!) because pde->proc_opsnnever changes so information necessary for inode instantiation can bensaved _before_ proc_register() in PDE itself and used later avoidingnpde->proc_ops->... dereference.nn rmmod lookupnsys_delete_modulen proc_lookup_denttt pde_get(de);nttt proc_get_inode(dir->i_sb de);n mod->exit()n proc_removen remove_proc_subtreen proc_entry_rundown(de);n free_module(mod);nn if (S_ISREG(inode->i_mode))nt if (de->proc_ops->proc_read_iter)n --> As module is already freed will trigger UAFnnBUG: unable to handle page fault for address: fffffbfff80a702bnPGD 817fc4067 P4D 817fc4067 PUD 817fc0067 PMD 102ef4067 PTE 0nOops: Oops: 0000 [#1] PREEMPT SMP KASAN PTInCPU: 26 UID: 0 PID: 2667 Comm: ls Tainted: GnHardware name: QEMU Standard PC (i440FX + PIIX 1996)nRIP: 0010:proc_get_inode+0x302/0x6e0nRSP: 0018:ffff88811c837998 EFLAGS: 00010a06nRAX: dffffc0000000000 RBX: ffffffffc0538140 RCX: 0000000000000007nRDX: 1ffffffff80a702b RSI: 0000000000000001 RDI: ffffffffc0538158nRBP: ffff8881299a6000 R08: 0000000067bbe1e5 R09: 1ffff11023906f20nR10: ffffffffb560ca07 R11: ffffffffb2b43a58 R12: ffff888105bb78f0nR13: ffff888100518048 R14: ffff8881299a6004 R15: 0000000000000001nFS: 00007f95b9686840(0000) GS:ffff8883af100000(0000) knlGS:0000000000000000nCS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033nCR2: fffffbfff80a702b CR3: 0000000117dd2000 CR4: 00000000000006f0nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400nCall Trace:n <TASK>n proc_lookup_de+0x11f/0x2e0n __lookup_slow+0x188/0x350n walk_component+0x2ab/0x4f0n path_lookupat+0x120/0x660n filename_lookup+0x1ce/0x560n vfs_statx+0xac/0x150n __do_sys_newstat+0x96/0x110n do_syscall_64+0x5f/0x170n entry_SYSCALL_64_after_hwframe+0x76/0x7enn[adobriyan@gmail.com: don't do 2 atomic ops on the common path],CVE-2025-21999,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet: atm: fix use after free in lec_send()nnThe ->send() operation frees skb so save the length before callingn->send() to avoid a use after free.,CVE-2025-22004,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnipv6: Fix memleak of nhc_pcpu_rth_output in fib_check_nh_v6_gw().nnfib_check_nh_v6_gw() expects that fib6_nh_init() cleans up everythingnwhen it fails.nnCommit 7dd73168e273 (ipv6: Always allocate pcpu memory in a fib6_nh)nmoved fib_nh_common_init() before alloc_percpu_gfp() within fib6_nh_init()nbut forgot to add cleanup for fib6_nh->nh_common.nhc_pcpu_rth_output inncase it fails to allocate fib6_nh->rt6i_pcpu resulting in memleak.nnLet's call fib_nh_common_release() and clear nhc_pcpu_rth_output in thenerror path.nnNote that we can remove the fib6_nh_release() call in nh_create_ipv6()nlater in net-next.git.,CVE-2025-22005,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnBluetooth: Fix error code in chan_alloc_skb_cb()nnThe chan_alloc_skb_cb() function is supposed to return error pointers onnerror. Returning NULL will lead to a NULL dereference.,CVE-2025-22007,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnregulator: check that dummy regulator has been probed before using itnnDue to asynchronous driver probing there is a chance that the dummynregulator hasn't already been probed when first accessing it.,CVE-2025-22008,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnRDMA/hns: Fix soft lockup during bt pages loopnnDriver runs a for-loop when allocating bt pages and mapping them withnbuffer pages. When a large buffer (e.g. MR over 100GB) is being allocatednit may require a considerable loop count. This will lead to soft lockup:nn watchdog: BUG: soft lockup - CPU#27 stuck for 22s!n ...n Call trace:n hem_list_alloc_mid_bt+0x124/0x394 [hns_roce_hw_v2]n hns_roce_hem_list_request+0xf8/0x160 [hns_roce_hw_v2]n hns_roce_mtr_create+0x2e4/0x360 [hns_roce_hw_v2]n alloc_mr_pbl+0xd4/0x17c [hns_roce_hw_v2]n hns_roce_reg_user_mr+0xf8/0x190 [hns_roce_hw_v2]n ib_uverbs_reg_mr+0x118/0x290nn watchdog: BUG: soft lockup - CPU#35 stuck for 23s!n ...n Call trace:n hns_roce_hem_list_find_mtt+0x7c/0xb0 [hns_roce_hw_v2]n mtr_map_bufs+0xc4/0x204 [hns_roce_hw_v2]n hns_roce_mtr_create+0x31c/0x3c4 [hns_roce_hw_v2]n alloc_mr_pbl+0xb0/0x160 [hns_roce_hw_v2]n hns_roce_reg_user_mr+0x108/0x1c0 [hns_roce_hw_v2]n ib_uverbs_reg_mr+0x120/0x2bcnnAdd a cond_resched() to fix soft lockup during these loops. In order notnto affect the allocation performance of normal-size buffer set the loopncount of a 100GB MR as the threshold to call cond_resched().,CVE-2025-22010,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnsoc: qcom: pdr: Fix the potential deadlocknnWhen some client process A call pdr_add_lookup() to add the look up fornthe service and does schedule locator work later a process B got a newnserver packet indicating locator is up and call pdr_locator_new_server()nwhich eventually sets pdr->locator_init_complete to true which process Ansees and takes list lock and queries domain list but it will timeout duento deadlock as the response will queued to the same qmi->wq and it isnordered workqueue and process B is not able to complete new servernrequest work due to deadlock on list lock.nnFix it by removing the unnecessary list iteration as the list iterationnis already being done inside locator work so avoid it here and justncall schedule_work() here.nn Process A Process Bnn process_scheduled_works()npdr_add_lookup() qmi_data_ready_work()n process_scheduled_works() pdr_locator_new_server()n pdr->locator_init_complete=true;n pdr_locator_work()n mutex_lock(&pdr->list_lock);nn pdr_locate_service() mutex_lock(&pdr->list_lock);nn pdr_get_domain_list()n pr_err(PDR: %s get domain listn txn wait failed: %dnn req->service_namen ret);nnTimeout error log due to deadlock:nnn PDR: tms/servreg get domain list txn wait failed: -110n PDR: service lookup for msm/adsp/sensor_pd:tms/servreg failed: -110nnnThanks to Bjorn and Johan for letting me know that this commit also fixesnan audio regression when using the in-kernel pd-mapper as that makes itneasier to hit this race. [1],CVE-2025-22014,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnatm: Fix NULL pointer dereferencennWhen MPOA_cache_impos_rcvd() receives the msg it can triggernNull Pointer Dereference Vulnerability if both entry andnholding_time are NULL. Because there is only for the situationnwhere entry is NULL and holding_time exists it can be passednwhen both entry and holding_time are NULL. If these are NULLnthe entry will be passd to eg_cache_put() as parameter andnit is referenced by entry->use code in it.nnkasan log:nn[ 3.316691] Oops: general protection fault probably for non-canonical address 0xdffffc0000000006:In[ 3.317568] KASAN: null-ptr-deref in range [0x0000000000000030-0x0000000000000037]n[ 3.318188] CPU: 3 UID: 0 PID: 79 Comm: ex Not tainted 6.14.0-rc2 #102n[ 3.318601] Hardware name: QEMU Standard PC (i440FX + PIIX 1996) BIOS 1.15.0-1 04/01/2014n[ 3.319298] RIP: 0010:eg_cache_remove_entry+0xa5/0x470n[ 3.319677] Code: c1 f7 6e fd 48 c7 c7 00 7e 38 b2 e8 95 64 54 fd 48 c7 c7 40 7e 38 b2 48 89 ee e80n[ 3.321220] RSP: 0018:ffff88800583f8a8 EFLAGS: 00010006n[ 3.321596] RAX: 0000000000000006 RBX: ffff888005989000 RCX: ffffffffaecc2d8en[ 3.322112] RDX: 0000000000000000 RSI: 0000000000000004 RDI: 0000000000000030n[ 3.322643] RBP: 0000000000000000 R08: 0000000000000000 R09: fffffbfff6558b88n[ 3.323181] R10: 0000000000000003 R11: 203a207972746e65 R12: 1ffff11000b07f15n[ 3.323707] R13: dffffc0000000000 R14: ffff888005989000 R15: ffff888005989068n[ 3.324185] FS: 000000001b6313c0(0000) GS:ffff88806d380000(0000) knlGS:0000000000000000n[ 3.325042] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033n[ 3.325545] CR2: 00000000004b4b40 CR3: 000000000248e000 CR4: 00000000000006f0n[ 3.326430] Call Trace:n[ 3.326725] <TASK>n[ 3.326927] ? die_addr+0x3c/0xa0n[ 3.327330] ? exc_general_protection+0x161/0x2a0n[ 3.327662] ? asm_exc_general_protection+0x26/0x30n[ 3.328214] ? vprintk_emit+0x15e/0x420n[ 3.328543] ? eg_cache_remove_entry+0xa5/0x470n[ 3.328910] ? eg_cache_remove_entry+0x9a/0x470n[ 3.329294] ? __pfx_eg_cache_remove_entry+0x10/0x10n[ 3.329664] ? console_unlock+0x107/0x1d0n[ 3.329946] ? __pfx_console_unlock+0x10/0x10n[ 3.330283] ? do_syscall_64+0xa6/0x1a0n[ 3.330584] ? entry_SYSCALL_64_after_hwframe+0x47/0x7fn[ 3.331090] ? __pfx_prb_read_valid+0x10/0x10n[ 3.331395] ? down_trylock+0x52/0x80n[ 3.331703] ? vprintk_emit+0x15e/0x420n[ 3.331986] ? __pfx_vprintk_emit+0x10/0x10n[ 3.332279] ? down_trylock+0x52/0x80n[ 3.332527] ? _printk+0xbf/0x100n[ 3.332762] ? __pfx__printk+0x10/0x10n[ 3.333007] ? _raw_write_lock_irq+0x81/0xe0n[ 3.333284] ? __pfx__raw_write_lock_irq+0x10/0x10n[ 3.333614] msg_from_mpoad+0x1185/0x2750n[ 3.333893] ? __build_skb_around+0x27b/0x3a0n[ 3.334183] ? __pfx_msg_from_mpoad+0x10/0x10n[ 3.334501] ? __alloc_skb+0x1c0/0x310n[ 3.334809] ? __pfx___alloc_skb+0x10/0x10n[ 3.335283] ? _raw_spin_lock+0xe0/0xe0n[ 3.335632] ? finish_wait+0x8d/0x1e0n[ 3.335975] vcc_sendmsg+0x684/0xba0n[ 3.336250] ? __pfx_vcc_sendmsg+0x10/0x10n[ 3.336587] ? __pfx_autoremove_wake_function+0x10/0x10n[ 3.337056] ? fdget+0x176/0x3e0n[ 3.337348] __sys_sendto+0x4a2/0x510n[ 3.337663] ? __pfx___sys_sendto+0x10/0x10n[ 3.337969] ? ioctl_has_perm.constprop.0.isra.0+0x284/0x400n[ 3.338364] ? sock_ioctl+0x1bb/0x5a0n[ 3.338653] ? __rseq_handle_notify_resume+0x825/0xd20n[ 3.339017] ? __pfx_sock_ioctl+0x10/0x10n[ 3.339316] ? __pfx___rseq_handle_notify_resume+0x10/0x10n[ 3.339727] ? selinux_file_ioctl+0xa4/0x260n[ 3.340166] __x64_sys_sendto+0xe0/0x1c0n[ 3.340526] ? syscall_exit_to_user_mode+0x123/0x140n[ 3.340898] do_syscall_64+0xa6/0x1a0n[ 3.341170] entry_SYSCALL_64_after_hwframe+0x77/0x7fn[ 3.341533] RIP: 0033:0x44a380n[ 3.341757] Code: 0f 1f 84 00 00 00 00 00 66 90 f3 0f 1e fa 41 89 ca 64 8b 04 25 18 00 00 00 85 c00n[ n---truncated---,CVE-2025-22018,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnmemstick: rtsx_usb_ms: Fix slab-use-after-free in rtsx_usb_ms_drv_removennThis fixes the following crash:nn==================================================================nBUG: KASAN: slab-use-after-free in rtsx_usb_ms_poll_card+0x159/0x200 [rtsx_usb_ms]nRead of size 8 at addr ffff888136335380 by task kworker/6:0/140241nnCPU: 6 UID: 0 PID: 140241 Comm: kworker/6:0 Kdump: loaded Tainted: G E 6.14.0-rc6+ #1nTainted: [E]=UNSIGNED_MODULEnHardware name: LENOVO 30FNA1V7CW/1057 BIOS S0EKT54A 07/01/2024nWorkqueue: events rtsx_usb_ms_poll_card [rtsx_usb_ms]nCall Trace:n <TASK>n dump_stack_lvl+0x51/0x70n print_address_description.constprop.0+0x27/0x320n ? rtsx_usb_ms_poll_card+0x159/0x200 [rtsx_usb_ms]n print_report+0x3e/0x70n kasan_report+0xab/0xe0n ? rtsx_usb_ms_poll_card+0x159/0x200 [rtsx_usb_ms]n rtsx_usb_ms_poll_card+0x159/0x200 [rtsx_usb_ms]n ? __pfx_rtsx_usb_ms_poll_card+0x10/0x10 [rtsx_usb_ms]n ? __pfx___schedule+0x10/0x10n ? kick_pool+0x3b/0x270n process_one_work+0x357/0x660n worker_thread+0x390/0x4c0n ? __pfx_worker_thread+0x10/0x10n kthread+0x190/0x1d0n ? __pfx_kthread+0x10/0x10n ret_from_fork+0x2d/0x50n ? __pfx_kthread+0x10/0x10n ret_from_fork_asm+0x1a/0x30n </TASK>nnAllocated by task 161446:n kasan_save_stack+0x20/0x40n kasan_save_track+0x10/0x30n __kasan_kmalloc+0x7b/0x90n __kmalloc_noprof+0x1a7/0x470n memstick_alloc_host+0x1f/0xe0 [memstick]n rtsx_usb_ms_drv_probe+0x47/0x320 [rtsx_usb_ms]n platform_probe+0x60/0xe0n call_driver_probe+0x35/0x120n really_probe+0x123/0x410n __driver_probe_device+0xc7/0x1e0n driver_probe_device+0x49/0xf0n __device_attach_driver+0xc6/0x160n bus_for_each_drv+0xe4/0x160n __device_attach+0x13a/0x2b0n bus_probe_device+0xbd/0xd0n device_add+0x4a5/0x760n platform_device_add+0x189/0x370n mfd_add_device+0x587/0x5e0n mfd_add_devices+0xb1/0x130n rtsx_usb_probe+0x28e/0x2e0 [rtsx_usb]n usb_probe_interface+0x15c/0x460n call_driver_probe+0x35/0x120n really_probe+0x123/0x410n __driver_probe_device+0xc7/0x1e0n driver_probe_device+0x49/0xf0n __device_attach_driver+0xc6/0x160n bus_for_each_drv+0xe4/0x160n __device_attach+0x13a/0x2b0n rebind_marked_interfaces.isra.0+0xcc/0x110n usb_reset_device+0x352/0x410n usbdev_do_ioctl+0xe5c/0x1860n usbdev_ioctl+0xa/0x20n __x64_sys_ioctl+0xc5/0xf0n do_syscall_64+0x59/0x170n entry_SYSCALL_64_after_hwframe+0x76/0x7ennFreed by task 161506:n kasan_save_stack+0x20/0x40n kasan_save_track+0x10/0x30n kasan_save_free_info+0x36/0x60n __kasan_slab_free+0x34/0x50n kfree+0x1fd/0x3b0n device_release+0x56/0xf0n kobject_cleanup+0x73/0x1c0n rtsx_usb_ms_drv_remove+0x13d/0x220 [rtsx_usb_ms]n platform_remove+0x2f/0x50n device_release_driver_internal+0x24b/0x2e0n bus_remove_device+0x124/0x1d0n device_del+0x239/0x530n platform_device_del.part.0+0x19/0xe0n platform_device_unregister+0x1c/0x40n mfd_remove_devices_fn+0x167/0x170n device_for_each_child_reverse+0xc9/0x130n mfd_remove_devices+0x6e/0xa0n rtsx_usb_disconnect+0x2e/0xd0 [rtsx_usb]n usb_unbind_interface+0xf3/0x3f0n device_release_driver_internal+0x24b/0x2e0n proc_disconnect_claim+0x13d/0x220n usbdev_do_ioctl+0xb5e/0x1860n usbdev_ioctl+0xa/0x20n __x64_sys_ioctl+0xc5/0xf0n do_syscall_64+0x59/0x170n entry_SYSCALL_64_after_hwframe+0x76/0x7ennLast potentially related work creation:n kasan_save_stack+0x20/0x40n kasan_record_aux_stack+0x85/0x90n insert_work+0x29/0x100n __queue_work+0x34a/0x540n call_timer_fn+0x2a/0x160n expire_timers+0x5f/0x1f0n __run_timer_base.part.0+0x1b6/0x1e0n run_timer_softirq+0x8b/0xe0n handle_softirqs+0xf9/0x360n __irq_exit_rcu+0x114/0x130n sysvec_apic_timer_interrupt+0x72/0x90n asm_sysvec_apic_timer_interrupt+0x16/0x20nnSecond to last potentially related work creation:n kasan_save_stack+0x20/0x40n kasan_record_aux_stack+0x85/0x90n insert_work+0x29/0x100n __queue_work+0x34a/0x540n call_timer_fn+0x2a/0x160n expire_timers+0x5f/0x1f0n __run_timer_base.part.0+0x1b6/0x1e0n run_timer_softirq+0x8b/0xe0n handle_softirqs+0xf9/0xn---truncated---,CVE-2025-22020,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnetfilter: socket: Lookup orig tuple for IPv6 SNATnnnf_sk_lookup_slow_v4 does the conntrack lookup for IPv4 packets tonrestore the original 5-tuple in case of SNAT to be able to find thenright socket (if any). Then socket_match() can correctly check whethernthe socket was transparent.nnHowever the IPv6 counterpart (nf_sk_lookup_slow_v6) lacks thisnconntrack lookup making xt_socket fail to match on the socket when thenpacket was SNATed. Add the same logic to nf_sk_lookup_slow_v6.nnIPv6 SNAT is used in Kubernetes clusters for pod-to-world packets asnpods' addresses are in the fd00::/8 ULA subnet and need to be replacednwith the node's external address. Cilium leverages Envoy to enforce L7npolicies and Envoy uses transparent sockets. Cilium inserts an iptablesnprerouting rule that matches on `-m socket --transparent` and redirectsnthe packets to localhost but it fails to match SNATed IPv6 packets duento that missing conntrack lookup.,CVE-2025-22021,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnusb: xhci: Apply the link chain quirk on NEC isoc endpointsnnTwo clearly different specimens of NEC uPD720200 (one with start/stopnbug one without) were seen to cause IOMMU faults after some MissednService Errors. Faulting address is immediately after a transfer ringnsegment and patched dynamic debug messages revealed that the MSE wasnreceived when waiting for a TD near the end of that segment:nn[ 1.041954] xhci_hcd: Miss service interval error for slot 1 ep 2 expected TD DMA ffa08fe0n[ 1.042120] xhci_hcd: AMD-Vi: Event logged [IO_PAGE_FAULT domain=0x0005 address=0xffa09000 flags=0x0000]n[ 1.042146] xhci_hcd: AMD-Vi: Event logged [IO_PAGE_FAULT domain=0x0005 address=0xffa09040 flags=0x0000]nnIt gets even funnier if the next page is a ring segment accessible tonthe HC. Below it reports MSE in segment at ff1e8000 plows through anzero-filled page at ff1e9000 and starts reporting events for TRBs innpage at ff1ea000 every microframe instead of jumping to seg ff1e6000.nn[ 7.041671] xhci_hcd: Miss service interval error for slot 1 ep 2 expected TD DMA ff1e8fe0n[ 7.041999] xhci_hcd: Miss service interval error for slot 1 ep 2 expected TD DMA ff1e8fe0n[ 7.042011] xhci_hcd: WARN: buffer overrun event for slot 1 ep 2 on endpointn[ 7.042028] xhci_hcd: All TDs skipped for slot 1 ep 2. Clear skip flag.n[ 7.042134] xhci_hcd: WARN: buffer overrun event for slot 1 ep 2 on endpointn[ 7.042138] xhci_hcd: ERROR Transfer event TRB DMA ptr not part of current TD ep_index 2 comp_code 31n[ 7.042144] xhci_hcd: Looking for event-dma 00000000ff1ea040 trb-start 00000000ff1e6820 trb-end 00000000ff1e6820n[ 7.042259] xhci_hcd: WARN: buffer overrun event for slot 1 ep 2 on endpointn[ 7.042262] xhci_hcd: ERROR Transfer event TRB DMA ptr not part of current TD ep_index 2 comp_code 31n[ 7.042266] xhci_hcd: Looking for event-dma 00000000ff1ea050 trb-start 00000000ff1e6820 trb-end 00000000ff1e6820nnAt some point completion events change from Isoch Buffer Overrun tonShort Packet and the HC finally finds cycle bit mismatch in ff1ec000.nn[ 7.098130] xhci_hcd: ERROR Transfer event TRB DMA ptr not part of current TD ep_index 2 comp_code 13n[ 7.098132] xhci_hcd: Looking for event-dma 00000000ff1ecc50 trb-start 00000000ff1e6820 trb-end 00000000ff1e6820n[ 7.098254] xhci_hcd: ERROR Transfer event TRB DMA ptr not part of current TD ep_index 2 comp_code 13n[ 7.098256] xhci_hcd: Looking for event-dma 00000000ff1ecc60 trb-start 00000000ff1e6820 trb-end 00000000ff1e6820n[ 7.098379] xhci_hcd: Overrun event on slot 1 ep 2nnIt's possible that data from the isochronous device were written tonrandom buffers of pending TDs on other endpoints (either IN or OUT)nother devices or even other HCs in the same IOMMU domain.nnLastly an error from a different USB device on another HC. Was itncaused by the above? I don't know but it may have been. The disknwas working without any other issues and generated PCIe traffic tonstarve the NEC of upstream BW and trigger those MSEs. The two HCsnshared one x1 slot by means of a commercial PCIe splitter board.nn[ 7.162604] usb 10-2: reset SuperSpeed USB device number 3 using xhci_hcdn[ 7.178990] sd 9:0:0:0: [sdb] tag#0 UNKNOWN(0x2003) Result: hostbyte=0x07 driverbyte=DRIVER_OK cmd_age=0sn[ 7.179001] sd 9:0:0:0: [sdb] tag#0 CDB: opcode=0x28 28 00 04 02 ae 00 00 02 00 00n[ 7.179004] I/O error dev sdb sector 67284480 op 0x0:(READ) flags 0x80700 phys_seg 5 prio class 0nnFortunately it appears that this ridiculous bug is avoided by settingnthe chain bit of Link TRBs on isochronous rings. Other ancient HCs arenknown which also expect the bit to be set and they ignore Link TRBs ifnit's not. Reportedly 0.95 spec guaranteed that the bit is set.nnThe bandwidth-starved NEC HC running a 32KB/uframe UVC endpoint reportsntens of MSEs per second and runs into the bug within seconds. ChainingnLink TRBs allows the same workload to run for many minutes many times.nnNo nen---truncated---,CVE-2025-22022,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnfsd: put dl_stid if fail to queue dl_recallnnBefore calling nfsd4_run_cb to queue dl_recall to the callback_wq wenincrement the reference count of dl_stid.nWe expect that after the corresponding work_struct is processed thenreference count of dl_stid will be decremented through the callbacknfunction nfsd4_cb_recall_release.nHowever if the call to nfsd4_run_cb fails the incremented referencencount of dl_stid will not be decremented correspondingly leading to thenfollowing nfs4_stid leak:nunreferenced object 0xffff88812067b578 (size 344):n comm nfsd pid 2761 jiffies 4295044002 (age 5541.241s)n hex dump (first 32 bytes):n 01 00 00 00 6b 6b 6b 6b b8 02 c0 e2 81 88 ff ff ....kkkk........n 00 6b 6b 6b 6b 6b 6b 6b 00 00 00 00 ad 4e ad de .kkkkkkk.....N..n backtrace:n kmem_cache_alloc+0x4b9/0x700n nfsd4_process_open1+0x34/0x300n nfsd4_open+0x2d1/0x9d0n nfsd4_proc_compound+0x7a2/0xe30n nfsd_dispatch+0x241/0x3e0n svc_process_common+0x5d3/0xcc0n svc_process+0x2a3/0x320n nfsd+0x180/0x2e0n kthread+0x199/0x1d0n ret_from_fork+0x30/0x50n ret_from_fork_asm+0x1b/0x30nunreferenced object 0xffff8881499f4d28 (size 368):n comm nfsd pid 2761 jiffies 4295044005 (age 5541.239s)n hex dump (first 32 bytes):n 01 00 00 00 00 00 00 00 30 4d 9f 49 81 88 ff ff ........0M.I....n 30 4d 9f 49 81 88 ff ff 20 00 00 00 01 00 00 00 0M.I.... .......n backtrace:n kmem_cache_alloc+0x4b9/0x700n nfs4_alloc_stid+0x29/0x210n alloc_init_deleg+0x92/0x2e0n nfs4_set_delegation+0x284/0xc00n nfs4_open_delegation+0x216/0x3f0n nfsd4_process_open2+0x2b3/0xee0n nfsd4_open+0x770/0x9d0n nfsd4_proc_compound+0x7a2/0xe30n nfsd_dispatch+0x241/0x3e0n svc_process_common+0x5d3/0xcc0n svc_process+0x2a3/0x320n nfsd+0x180/0x2e0n kthread+0x199/0x1d0n ret_from_fork+0x30/0x50n ret_from_fork_asm+0x1b/0x30nFix it by checking the result of nfsd4_run_cb and call nfs4_put_stid ifnfail to queue dl_recall.,CVE-2025-22025,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnfsd: don't ignore the return code of svc_proc_register()nnCurrently nfsd_proc_stat_init() ignores the return value ofnsvc_proc_register(). If the procfile creation fails then the kernelnwill WARN when it tries to remove the entry later.nnFix nfsd_proc_stat_init() to return the same type of pointer asnsvc_proc_register() and fix up nfsd_net_init() to check that and failnthe nfsd_net construction if it occurs.nnsvc_proc_register() can fail if the dentry can't be allocated or if annidentical dentry already exists. The second case is pretty unlikely innthe nfsd_net construction codepath so if this happens return -ENOMEM.,CVE-2025-22026,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnmedia: streamzap: fix race between device disconnection and urb callbacknnSyzkaller has reported a general protection fault at functionnir_raw_event_store_with_filter(). This crash is caused by a NULL pointerndereference of dev->raw pointer even though it is checked for NULL innthe same function which means there is a race condition. It occurs duento the incorrect order of actions in the streamzap_disconnect() function:nrc_unregister_device() is called before usb_kill_urb(). The dev->rawnpointer is freed and set to NULL in rc_unregister_device() and onlynafter that usb_kill_urb() waits for in-progress requests to finish.nnIf rc_unregister_device() is called while streamzap_callback() handler isnnot finished this can lead to accessing freed resources. Thusnrc_unregister_device() should be called after usb_kill_urb().nnFound by Linux Verification Center (linuxtesting.org) with Syzkaller.,CVE-2025-22027,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnmedia: vimc: skip .s_stream() for stopped entitiesnnSyzbot reported [1] a warning prompted by a check in call_s_stream()nthat checks whether .s_stream() operation is warranted for unstartednor stopped subdevs.nnAdd a simple fix in vimc_streamer_pipeline_terminate() ensuring thatnentities skip a call to .s_stream() unless they have been previouslynproperly started.nn[1] Syzbot report:n------------[ cut here ]------------nWARNING: CPU: 0 PID: 5933 at drivers/media/v4l2-core/v4l2-subdev.c:460 call_s_stream+0x2df/0x350 drivers/media/v4l2-core/v4l2-subdev.c:460nModules linked in:nCPU: 0 UID: 0 PID: 5933 Comm: syz-executor330 Not tainted 6.13.0-rc2-syzkaller-00362-g2d8308bf5b67 #0n...nCall Trace:n <TASK>n vimc_streamer_pipeline_terminate+0x218/0x320 drivers/media/test-drivers/vimc/vimc-streamer.c:62n vimc_streamer_pipeline_init drivers/media/test-drivers/vimc/vimc-streamer.c:101 [inline]n vimc_streamer_s_stream+0x650/0x9a0 drivers/media/test-drivers/vimc/vimc-streamer.c:203n vimc_capture_start_streaming+0xa1/0x130 drivers/media/test-drivers/vimc/vimc-capture.c:256n vb2_start_streaming+0x15f/0x5a0 drivers/media/common/videobuf2/videobuf2-core.c:1789n vb2_core_streamon+0x2a7/0x450 drivers/media/common/videobuf2/videobuf2-core.c:2348n vb2_streamon drivers/media/common/videobuf2/videobuf2-v4l2.c:875 [inline]n vb2_ioctl_streamon+0xf4/0x170 drivers/media/common/videobuf2/videobuf2-v4l2.c:1118n __video_do_ioctl+0xaf0/0xf00 drivers/media/v4l2-core/v4l2-ioctl.c:3122n video_usercopy+0x4d2/0x1620 drivers/media/v4l2-core/v4l2-ioctl.c:3463n v4l2_ioctl+0x1ba/0x250 drivers/media/v4l2-core/v4l2-dev.c:366n vfs_ioctl fs/ioctl.c:51 [inline]n __do_sys_ioctl fs/ioctl.c:906 [inline]n __se_sys_ioctl fs/ioctl.c:892 [inline]n __x64_sys_ioctl+0x190/0x200 fs/ioctl.c:892n do_syscall_x64 arch/x86/entry/common.c:52 [inline]n do_syscall_64+0xcd/0x250 arch/x86/entry/common.c:83n entry_SYSCALL_64_after_hwframe+0x77/0x7fnRIP: 0033:0x7f2b85c01b19n...,CVE-2025-22028,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nntracing: Fix use-after-free in print_graph_function_flags during tracer switchingnnKairui reported a UAF issue in print_graph_function_flags() duringnftrace stress testing [1]. This issue can be reproduced if puting an'mdelay(10)' after 'mutex_unlock(&trace_types_lock)' in s_start()nand executing the following script:nn $ echo function_graph > current_tracern $ cat trace > /dev/null &n $ sleep 5 # Ensure the 'cat' reaches the 'mdelay(10)' pointn $ echo timerlat > current_tracernnThe root cause lies in the two calls to print_graph_function_flagsnwithin print_trace_line during each s_show():nn output.log scan_tyk_dockerimages.sh vulnerabilities.csv One through 'iter->trace->print_line()';n output.log scan_tyk_dockerimages.sh vulnerabilities.csv Another through 'event->funcs->trace()' which is hidden inn print_trace_fmt() before print_trace_line returns.nnTracer switching only updates the former while the latter continuesnto use the print_line function of the old tracer which in the scriptnabove is print_graph_function_flags.nnMoreover when switching from the 'function_graph' tracer to then'timerlat' tracer s_start only calls graph_trace_close of then'function_graph' tracer to free 'iter->private' but does not setnit to NULL. This provides an opportunity for 'event->funcs->trace()'nto use an invalid 'iter->private'.nnTo fix this issue set 'iter->private' to NULL immediately afternfreeing it in graph_trace_close() ensuring that an invalid pointernis not passed to other tracers. Additionally clean up the unnecessaryn'iter->private = NULL' during each 'cat trace' when using wakeup andnirqsoff tracers.nn [1] https://lore.kernel.org/all/20231112150030.84609-1-ryncsn@gmail.com/,CVE-2025-22035,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnacpi: nfit: fix narrowing conversion in acpi_nfit_ctlnnSyzkaller has reported a warning in to_nfit_bus_uuid(): only secondarynbus families can be translated. This warning is emited if the argumentnis equal to NVDIMM_BUS_FAMILY_NFIT == 0. Function acpi_nfit_ctl() firstnverifies that a user-provided value call_pkg->nd_family of type u64 isnnot equal to 0. Then the value is converted to int and only after thatnis compared to NVDIMM_BUS_FAMILY_MAX. This can lead to passing an invalidnargument to acpi_nfit_ctl() if call_pkg->nd_family is non-zero whilenthe lower 32 bits are zero.nnFurthermore it is best to return EINVAL immediately upon seeing theninvalid user input. The WARNING is insufficient to prevent furthernundefined behavior based on other invalid user input.nnAll checks of the input value should be applied to the original variablencall_pkg->nd_family.nn[iweiny: update commit message],CVE-2025-22044,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnx86/mm: Fix flush_tlb_range() when used for zapping normal PMDsnnOn the following path flush_tlb_range() can be used for zapping normalnPMD entries (PMD entries that point to page tables) together with the PTEnentries in the pointed-to page table:nn collapse_pte_mapped_thpn pmdp_collapse_flushn flush_tlb_rangennThe arm64 version of flush_tlb_range() has a comment describing that it cannbe used for page table removal and does not use any last-levelninvalidation optimizations. Fix the X86 version by making it behave thensame way.nnCurrently X86 only uses this information for the following two purposesnwhich I think means the issue doesn't have much impact:nn - In native_flush_tlb_multi() for checking if lazy TLB CPUs need to ben IPI'd to avoid issues with speculative page table walks.n - In Hyper-V TLB paravirtualization again for lazy TLB stuff.nnThe patch x86/mm: only invalidate final translations with INVLPGB whichnis currently under review (seen<https://lore.kernel.org/all/20241230175550.4046587-13-riel@surriel.com/>)nwould probably be making the impact of this a lot worse.,CVE-2025-22045,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet: ibmveth: make veth_pool_store stop hangingnnv2:n- Created a single error handling unlock and exit in veth_pool_storen- Greatly expanded commit message with previous explanatory-only textnnSummary: Use rtnl_mutex to synchronize veth_pool_store with itselfnibmveth_close and ibmveth_open preventing multiple calls in a row tonnapi_disable.nnBackground: Two (or more) threads could call veth_pool_store throughnwriting to /sys/devices/vio/30000002/pool*/*. You can do this easilynwith a little shell script. This causes a hang.nnI configured LOCKDEP compiled ibmveth.c with DEBUG and built a newnkernel. I ran this test again and saw:nn Setting pool0/active to 0n Setting pool1/active to 1n [ 73.911067][ T4365] ibmveth 30000002 eth0: close startingn Setting pool1/active to 1n Setting pool1/active to 0n [ 73.911367][ T4366] ibmveth 30000002 eth0: close startingn [ 73.916056][ T4365] ibmveth 30000002 eth0: close completen [ 73.916064][ T4365] ibmveth 30000002 eth0: open startingn [ 110.808564][ T712] systemd-journald[712]: Sent WATCHDOG=1 notification.n [ 230.808495][ T712] systemd-journald[712]: Sent WATCHDOG=1 notification.n [ 243.683786][ T123] INFO: task stress.sh:4365 blocked for more than 122 seconds.n [ 243.683827][ T123] Not tainted 6.14.0-01103-g2df0c02dab82-dirty #8n [ 243.683833][ T123] echo 0 > /proc/sys/kernel/hung_task_timeout_secs disables this message.n [ 243.683838][ T123] task:stress.sh state:D stack:28096 pid:4365 tgid:4365 ppid:4364 task_flags:0x400040 flags:0x00042000n [ 243.683852][ T123] Call Trace:n [ 243.683857][ T123] [c00000000c38f690] [0000000000000001] 0x1 (unreliable)n [ 243.683868][ T123] [c00000000c38f840] [c00000000001f908] __switch_to+0x318/0x4e0n [ 243.683878][ T123] [c00000000c38f8a0] [c000000001549a70] __schedule+0x500/0x12a0n [ 243.683888][ T123] [c00000000c38f9a0] [c00000000154a878] schedule+0x68/0x210n [ 243.683896][ T123] [c00000000c38f9d0] [c00000000154ac80] schedule_preempt_disabled+0x30/0x50n [ 243.683904][ T123] [c00000000c38fa00] [c00000000154dbb0] __mutex_lock+0x730/0x10f0n [ 243.683913][ T123] [c00000000c38fb10] [c000000001154d40] napi_enable+0x30/0x60n [ 243.683921][ T123] [c00000000c38fb40] [c000000000f4ae94] ibmveth_open+0x68/0x5dcn [ 243.683928][ T123] [c00000000c38fbe0] [c000000000f4aa20] veth_pool_store+0x220/0x270n [ 243.683936][ T123] [c00000000c38fc70] [c000000000826278] sysfs_kf_write+0x68/0xb0n [ 243.683944][ T123] [c00000000c38fcb0] [c0000000008240b8] kernfs_fop_write_iter+0x198/0x2d0n [ 243.683951][ T123] [c00000000c38fd00] [c00000000071b9ac] vfs_write+0x34c/0x650n [ 243.683958][ T123] [c00000000c38fdc0] [c00000000071bea8] ksys_write+0x88/0x150n [ 243.683966][ T123] [c00000000c38fe10] [c0000000000317f4] system_call_exception+0x124/0x340n [ 243.683973][ T123] [c00000000c38fe50] [c00000000000d05c] system_call_vectored_common+0x15c/0x2ecn ...n [ 243.684087][ T123] Showing all locks held in the system:n [ 243.684095][ T123] 1 lock held by khungtaskd/123:n [ 243.684099][ T123] #0: c00000000278e370 (rcu_read_lock){....}-{1:2} at: debug_show_all_locks+0x50/0x248n [ 243.684114][ T123] 4 locks held by stress.sh/4365:n [ 243.684119][ T123] #0: c00000003a4cd3f8 (sb_writers#3){.+.+}-{0:0} at: ksys_write+0x88/0x150n [ 243.684132][ T123] #1: c000000041aea888 (&of->mutex#2){+.+.}-{3:3} at: kernfs_fop_write_iter+0x154/0x2d0n [ 243.684143][ T123] #2: c0000000366fb9a8 (kn->active#64){.+.+}-{0:0} at: kernfs_fop_write_iter+0x160/0x2d0n [ 243.684155][ T123] #3: c000000035ff4cb8 (&dev->lock){+.+.}-{3:3} at: napi_enable+0x30/0x60n [ 243.684166][ T123] 5 locks held by stress.sh/4366:n [ 243.684170][ T123] #0: c00000003a4cd3f8 (sb_writers#3){.+.+}-{0:0} at: ksys_write+0x88/0x150n [ 243.n---truncated---,CVE-2025-22053,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnarcnet: Add NULL check in com20020pci_probe()nndevm_kasprintf() returns NULL when memory allocation fails. Currentlyncom20020pci_probe() does not check for this case which results in anNULL pointer dereference.nnAdd NULL check after devm_kasprintf() to prevent this issue and ensurenno resources are left allocated.,CVE-2025-22054,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet: fix geneve_opt length integer overflownnstruct geneve_opt uses 5 bit length for each single option whichnmeans every vary size option should be smaller than 128 bytes.nnHowever all current related Netlink policies cannot promise thisnlength condition and the attacker can exploit a exact 128-byte sizenoption to *fake* a zero length option and confuse the parsing logicnfurther achieve heap out-of-bounds read.nnOne example crash log is like below:nn[ 3.905425] ==================================================================n[ 3.905925] BUG: KASAN: slab-out-of-bounds in nla_put+0xa9/0xe0n[ 3.906255] Read of size 124 at addr ffff888005f291cc by task poc/177n[ 3.906646]n[ 3.906775] CPU: 0 PID: 177 Comm: poc-oob-read Not tainted 6.1.132 #1n[ 3.907131] Hardware name: QEMU Standard PC (i440FX + PIIX 1996) BIOS rel-1.16.0-0-gd239552ce722-prebuilt.qemu.org 04/01/2014n[ 3.907784] Call Trace:n[ 3.907925] <TASK>n[ 3.908048] dump_stack_lvl+0x44/0x5cn[ 3.908258] print_report+0x184/0x4ben[ 3.909151] kasan_report+0xc5/0x100n[ 3.909539] kasan_check_range+0xf3/0x1a0n[ 3.909794] memcpy+0x1f/0x60n[ 3.909968] nla_put+0xa9/0xe0n[ 3.910147] tunnel_key_dump+0x945/0xba0n[ 3.911536] tcf_action_dump_1+0x1c1/0x340n[ 3.912436] tcf_action_dump+0x101/0x180n[ 3.912689] tcf_exts_dump+0x164/0x1e0n[ 3.912905] fw_dump+0x18b/0x2d0n[ 3.913483] tcf_fill_node+0x2ee/0x460n[ 3.914778] tfilter_notify+0xf4/0x180n[ 3.915208] tc_new_tfilter+0xd51/0x10d0n[ 3.918615] rtnetlink_rcv_msg+0x4a2/0x560n[ 3.919118] netlink_rcv_skb+0xcd/0x200n[ 3.919787] netlink_unicast+0x395/0x530n[ 3.921032] netlink_sendmsg+0x3d0/0x6d0n[ 3.921987] __sock_sendmsg+0x99/0xa0n[ 3.922220] __sys_sendto+0x1b7/0x240n[ 3.922682] __x64_sys_sendto+0x72/0x90n[ 3.922906] do_syscall_64+0x5e/0x90n[ 3.923814] entry_SYSCALL_64_after_hwframe+0x6e/0xd8n[ 3.924122] RIP: 0033:0x7e83eab84407n[ 3.924331] Code: 48 89 fa 4c 89 df e8 38 aa 00 00 8b 93 08 03 00 00 59 5e 48 83 f8 fc 74 1a 5b c3 0f 1f 84 00 00 00 00 00 48 8b 44 24 10 0f 05 <5b> c3 0f 1f 80 00 00 00 00 83 e2 39 83 fafn[ 3.925330] RSP: 002b:00007ffff505e370 EFLAGS: 00000202 ORIG_RAX: 000000000000002cn[ 3.925752] RAX: ffffffffffffffda RBX: 00007e83eaafa740 RCX: 00007e83eab84407n[ 3.926173] RDX: 00000000000001a8 RSI: 00007ffff505e3c0 RDI: 0000000000000003n[ 3.926587] RBP: 00007ffff505f460 R08: 00007e83eace1000 R09: 000000000000000cn[ 3.926977] R10: 0000000000000000 R11: 0000000000000202 R12: 00007ffff505f3c0n[ 3.927367] R13: 00007ffff505f5c8 R14: 00007e83ead1b000 R15: 00005d4fbbe6dcb8nnFix these issues by enforing correct length condition in relatednpolicies.,CVE-2025-22055,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnetfilter: nft_tunnel: fix geneve_opt type confusion additionnnWhen handling multiple NFTA_TUNNEL_KEY_OPTS_GENEVE attributes thenparsing logic should place every geneve_opt structure one by onencompactly. Hence when deciding the next geneve_opt position thenpointer addition should be in units of char *.nnHowever the current implementation erroneously does type conversionnbefore the addition which will lead to heap out-of-bounds write.nn[ 6.989857] ==================================================================n[ 6.990293] BUG: KASAN: slab-out-of-bounds in nft_tunnel_obj_init+0x977/0xa70n[ 6.990725] Write of size 124 at addr ffff888005f18974 by task poc/178n[ 6.991162]n[ 6.991259] CPU: 0 PID: 178 Comm: poc-oob-write Not tainted 6.1.132 #1n[ 6.991655] Hardware name: QEMU Standard PC (i440FX + PIIX 1996) BIOS rel-1.16.0-0-gd239552ce722-prebuilt.qemu.org 04/01/2014n[ 6.992281] Call Trace:n[ 6.992423] <TASK>n[ 6.992586] dump_stack_lvl+0x44/0x5cn[ 6.992801] print_report+0x184/0x4ben[ 6.993790] kasan_report+0xc5/0x100n[ 6.994252] kasan_check_range+0xf3/0x1a0n[ 6.994486] memcpy+0x38/0x60n[ 6.994692] nft_tunnel_obj_init+0x977/0xa70n[ 6.995677] nft_obj_init+0x10c/0x1b0n[ 6.995891] nf_tables_newobj+0x585/0x950n[ 6.996922] nfnetlink_rcv_batch+0xdf9/0x1020n[ 6.998997] nfnetlink_rcv+0x1df/0x220n[ 6.999537] netlink_unicast+0x395/0x530n[ 7.000771] netlink_sendmsg+0x3d0/0x6d0n[ 7.001462] __sock_sendmsg+0x99/0xa0n[ 7.001707] ____sys_sendmsg+0x409/0x450n[ 7.002391] ___sys_sendmsg+0xfd/0x170n[ 7.003145] __sys_sendmsg+0xea/0x170n[ 7.004359] do_syscall_64+0x5e/0x90n[ 7.005817] entry_SYSCALL_64_after_hwframe+0x6e/0xd8n[ 7.006127] RIP: 0033:0x7ec756d4e407n[ 7.006339] Code: 48 89 fa 4c 89 df e8 38 aa 00 00 8b 93 08 03 00 00 59 5e 48 83 f8 fc 74 1a 5b c3 0f 1f 84 00 00 00 00 00 48 8b 44 24 10 0f 05 <5b> c3 0f 1f 80 00 00 00 00 83 e2 39 83 fafn[ 7.007364] RSP: 002b:00007ffed5d46760 EFLAGS: 00000202 ORIG_RAX: 000000000000002en[ 7.007827] RAX: ffffffffffffffda RBX: 00007ec756cc4740 RCX: 00007ec756d4e407n[ 7.008223] RDX: 0000000000000000 RSI: 00007ffed5d467f0 RDI: 0000000000000003n[ 7.008620] RBP: 00007ffed5d468a0 R08: 0000000000000000 R09: 0000000000000000n[ 7.009039] R10: 0000000000000000 R11: 0000000000000202 R12: 0000000000000000n[ 7.009429] R13: 00007ffed5d478b0 R14: 00007ec756ee5000 R15: 00005cbd4e655cb8nnFix this bug with correct pointer addition and conversion in parsenand dump code.,CVE-2025-22056,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet: decrease cached dst counters in dst_releasennUpstream fix ac888d58869b (net: do not delay dst_entries_add() inndst_release()) moved decrementing the dst count from dst_destroy tondst_release to avoid accessing already freed data in case of netnsndismantle. However in case CONFIG_DST_CACHE is enabled and OvS+tunnelsnare used this fix is incomplete as the same issue will be seen forncached dsts:nn Unable to handle kernel paging request at virtual address ffff5aabf6b5c000n Call trace:n percpu_counter_add_batch+0x3c/0x160 (P)n dst_release+0xec/0x108n dst_cache_destroy+0x68/0xd8n dst_destroy+0x13c/0x168n dst_destroy_rcu+0x1c/0xb0n rcu_do_batch+0x18c/0x7d0n rcu_core+0x174/0x378n rcu_core_si+0x18/0x30nnFix this by invalidating the cache and thus decrementing cached dstncounters in dst_release too.,CVE-2025-22057,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnudp: Fix memory accounting leak.nnMatt Dowling reported a weird UDP memory usage issue.nnUnder normal operation the UDP memory usage reported in /proc/net/sockstatnremains close to zero. However it occasionally spiked to 524288 pagesnand never dropped. Moreover the value doubled when the application wasnterminated. Finally it caused intermittent packet drops.nnWe can reproduce the issue with the script below [0]:nn 1. /proc/net/sockstat reports 0 pagesnn # cat /proc/net/sockstat | grep UDP:n UDP: inuse 1 mem 0nn 2. Run the script till the report reaches 524288nn # python3 test.py & sleep 5n # cat /proc/net/sockstat | grep UDP:n UDP: inuse 3 mem 524288 <-- (INT_MAX + 1) >> PAGE_SHIFTnn 3. Kill the socket and confirm the number never dropsnn # pkill python3 && sleep 5n # cat /proc/net/sockstat | grep UDP:n UDP: inuse 1 mem 524288nn 4. (necessary since v6.0) Trigger proto_memory_pcpu_drain()nn # python3 test.py & sleep 1 && pkill python3nn 5. The number doublesnn # cat /proc/net/sockstat | grep UDP:n UDP: inuse 1 mem 1048577nnThe application set INT_MAX to SO_RCVBUF which triggered an integernoverflow in udp_rmem_release().nnWhen a socket is close()d udp_destruct_common() purges its receivenqueue and sums up skb->truesize in the queue. This total is calculatednand stored in a local unsigned integer variable.nnThe total size is then passed to udp_rmem_release() to adjust memorynaccounting. However because the function takes a signed integernargument the total size can wrap around causing an overflow.nnThen the released amount is calculated as follows:nn 1) Add size to sk->sk_forward_alloc.n 2) Round down sk->sk_forward_alloc to the nearest lower multiple ofn PAGE_SIZE and assign it to amount.n 3) Subtract amount from sk->sk_forward_alloc.n 4) Pass amount >> PAGE_SHIFT to __sk_mem_reduce_allocated().nnWhen the issue occurred the total in udp_destruct_common() was 2147484480n(INT_MAX + 833) which was cast to -2147482816 in udp_rmem_release().nnAt 1) sk->sk_forward_alloc is changed from 3264 to -2147479552 andn2) sets -2147479552 to amount. 3) reverts the wraparound so we don'tnsee a warning in inet_sock_destruct(). However udp_memory_allocatednends up doubling at 4).nnSince commit 3cd3399dd7a8 (net: implement per-cpu reserves fornmemory_allocated) memory usage no longer doubles immediately afterna socket is close()d because __sk_mem_reduce_allocated() caches thenamount in udp_memory_per_cpu_fw_alloc. However the next time a UDPnsocket receives a packet the subtraction takes effect causing UDPnmemory usage to double.nnThis issue makes further memory allocation fail once the socket'snsk->sk_rmem_alloc exceeds net.ipv4.udp_rmem_min resulting in packetndrops.nnTo prevent this issue let's use unsigned int for the calculation andncall sk_forward_alloc_add() only once for the small delta.nnNote that first_packet_length() also potentially has the same problem.nn[0]:nfrom socket import *nnSO_RCVBUFFORCE = 33nINT_MAX = (2 output.log scan_tyk_dockerimages.sh vulnerabilities.csv 31) - 1nns = socket(AF_INET SOCK_DGRAM)ns.bind(('' 0))ns.setsockopt(SOL_SOCKET SO_RCVBUFFORCE INT_MAX)nnc = socket(AF_INET SOCK_DGRAM)nc.connect(s.getsockname())nndata = b'a' output.log scan_tyk_dockerimages.sh vulnerabilities.csv 100nnwhile True:n c.send(data),CVE-2025-22058,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet: mvpp2: Prevent parser TCAM memory corruptionnnProtect the parser TCAM/SRAM memory and the cached (shadow) SRAMninformation from concurrent modifications.nnBoth the TCAM and SRAM tables are indirectly accessed by configuringnan index register that selects the row to read or write to. This meansnthat operations must be atomic in order to e.g. avoid spreadingnwrites across multiple rows. Since the shadow SRAM array is used tonfind free rows in the hardware table it must also be protected innorder to avoid TOCTOU errors where multiple cores allocate the samenrow.nnThis issue was detected in a situation where `mvpp2_set_rx_mode()` rannconcurrently on two CPUs. In this particular case thenMVPP2_PE_MAC_UC_PROMISCUOUS entry was corrupted causing thenclassifier unit to drop all incoming unicast - indicated by then`rx_classifier_drops` counter.,CVE-2025-22060,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnetlabel: Fix NULL pointer exception caused by CALIPSO on IPv4 socketsnnWhen calling netlbl_conn_setattr() addr->sa_family is usednto determine the function behavior. If sk is an IPv4 socketnbut the connect function is called with an IPv6 addressnthe function calipso_sock_setattr() is triggered.nInside this function the following code is executed:nnsk_fullsock(__sk) ? inet_sk(__sk)->pinet6 : NULL;nnSince sk is an IPv4 socket pinet6 is NULL leading to annull pointer dereference.nnThis patch fixes the issue by checking if inet6_sk(sk)nreturns a NULL pointer before accessing pinet6.,CVE-2025-22063,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnspufs: fix a leak in spufs_create_context()nnLeak fixes back in 2008 missed one case - if we are trying to set affinitynand spufs_mkdir() fails we need to drop the reference to neighbor.,CVE-2025-22071,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnspufs: fix gang directory lifetimesnnprior to [POWERPC] spufs: Fix gang destroy leaks we used to havena problem with gang lifetimes - creation of a gang returns openedngang directory which normally gets removed when that gets closednbut if somebody has created a context belonging to that gang andnkept it alive until the gang got closed removal failed and wenended up with a leak.nnUnfortunately it had been fixed the wrong way. Dentry of gangndirectory was no longer pinned and rmdir on close was gone.nOne problem was that failure of open kept calling simple_rmdir()nas cleanup which meant an unbalanced dput(). Another bug wasnin the success case - gang creation incremented link count onnroot directory but that was no longer undone when gang gotndestroyed.nnFix consists ofnt* reverting the commit in questionnt* adding a counter to gang protected by ->i_rwsemnof gang directory inode.nt* having it set to 1 at creation time droppednin both spufs_dir_close() and spufs_gang_close() and bumpednin spufs_create_context() provided that it's not 0.nt* using simple_recursive_removal() to take the gangndirectory out when counter reaches zero.,CVE-2025-22072,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnspufs: fix a leak on spufs_new_file() failurennIt's called from spufs_fill_dir() and caller of that will donspufs_rmdir() in case of failure. That does remove everythingnwe'd managed to create but... the problem dentry is stillnnegative. IOW it needs to be explicitly dropped.,CVE-2025-22073,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnrtnetlink: Allocate vfinfo size for VF GUIDs when supportednnCommit 30aad41721e0 (net/core: Add support for getting VF GUIDs)nadded support for getting VF port and node GUIDs in netlink ifinfonmessages but their size was not taken into consideration in thenfunction that allocates the netlink message causing the followingnwarning when a netlink message is filled with many VF port and nodenGUIDs:n # echo 64 > /sys/bus/pci/devices/0000:08:00.0/sriov_numvfsn # ip link show dev ib0n RTNETLINK answers: Message too longn Cannot send link get request: Message too longnnKernel warning:nn ------------[ cut here ]------------n WARNING: CPU: 2 PID: 1930 at net/core/rtnetlink.c:4151 rtnl_getlink+0x586/0x5a0n Modules linked in: xt_conntrack xt_MASQUERADE nfnetlink xt_addrtype iptable_nat nf_nat br_netfilter overlay mlx5_ib macsec mlx5_core tls rpcrdma rdma_ucm ib_uverbs ib_iser libiscsi scsi_transport_iscsi ib_umad rdma_cm iw_cm ib_ipoib fuse ib_cm ib_coren CPU: 2 UID: 0 PID: 1930 Comm: ip Not tainted 6.14.0-rc2+ #1n Hardware name: QEMU Standard PC (Q35 + ICH9 2009) BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014n RIP: 0010:rtnl_getlink+0x586/0x5a0n Code: cb 82 e8 3d af 0a 00 4d 85 ff 0f 84 08 ff ff ff 4c 89 ff 41 be ea ff ff ff e8 66 63 5b ff 49 c7 07 80 4f cb 82 e9 36 fc ff ff <0f> 0b e9 16 fe ff ff e8 de a0 56 00 66 66 2e 0f 1f 84 00 00 00 00n RSP: 0018:ffff888113557348 EFLAGS: 00010246n RAX: 00000000ffffffa6 RBX: ffff88817e87aa34 RCX: dffffc0000000000n RDX: 0000000000000003 RSI: 0000000000000000 RDI: ffff88817e87afb8n RBP: 0000000000000009 R08: ffffffff821f44aa R09: 0000000000000000n R10: ffff8881260f79a8 R11: ffff88817e87af00 R12: ffff88817e87aa00n R13: ffffffff8563d300 R14: 00000000ffffffa6 R15: 00000000ffffffffn FS: 00007f63a5dbf280(0000) GS:ffff88881ee00000(0000) knlGS:0000000000000000n CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033n CR2: 00007f63a5ba4493 CR3: 00000001700fe002 CR4: 0000000000772eb0n DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000n DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400n PKRU: 55555554n Call Trace:n <TASK>n ? __warn+0xa5/0x230n ? rtnl_getlink+0x586/0x5a0n ? report_bug+0x22d/0x240n ? handle_bug+0x53/0xa0n ? exc_invalid_op+0x14/0x50n ? asm_exc_invalid_op+0x16/0x20n ? skb_trim+0x6a/0x80n ? rtnl_getlink+0x586/0x5a0n ? __pfx_rtnl_getlink+0x10/0x10n ? rtnetlink_rcv_msg+0x1e5/0x860n ? __pfx___mutex_lock+0x10/0x10n ? rcu_is_watching+0x34/0x60n ? __pfx_lock_acquire+0x10/0x10n ? stack_trace_save+0x90/0xd0n ? filter_irq_stacks+0x1d/0x70n ? kasan_save_stack+0x30/0x40n ? kasan_save_stack+0x20/0x40n ? kasan_save_track+0x10/0x30n rtnetlink_rcv_msg+0x21c/0x860n ? entry_SYSCALL_64_after_hwframe+0x76/0x7en ? __pfx_rtnetlink_rcv_msg+0x10/0x10n ? arch_stack_walk+0x9e/0xf0n ? rcu_is_watching+0x34/0x60n ? lock_acquire+0xd5/0x410n ? rcu_is_watching+0x34/0x60n netlink_rcv_skb+0xe0/0x210n ? __pfx_rtnetlink_rcv_msg+0x10/0x10n ? __pfx_netlink_rcv_skb+0x10/0x10n ? rcu_is_watching+0x34/0x60n ? __pfx___netlink_lookup+0x10/0x10n ? lock_release+0x62/0x200n ? netlink_deliver_tap+0xfd/0x290n ? rcu_is_watching+0x34/0x60n ? lock_release+0x62/0x200n ? netlink_deliver_tap+0x95/0x290n netlink_unicast+0x31f/0x480n ? __pfx_netlink_unicast+0x10/0x10n ? rcu_is_watching+0x34/0x60n ? lock_acquire+0xd5/0x410n netlink_sendmsg+0x369/0x660n ? lock_release+0x62/0x200n ? __pfx_netlink_sendmsg+0x10/0x10n ? import_ubuf+0xb9/0xf0n ? __import_iovec+0x254/0x2b0n ? lock_release+0x62/0x200n ? __pfx_netlink_sendmsg+0x10/0x10n ____sys_sendmsg+0x559/0x5a0n ? __pfx_____sys_sendmsg+0x10/0x10n ? __pfx_copy_msghdr_from_user+0x10/0x10n ? rcu_is_watching+0x34/0x60n ? do_read_fault+0x213/0x4a0n ? rcu_is_watching+0x34/0x60n ___sys_sendmsg+0xe4/0x150n ? __pfx____sys_sendmsg+0x10/0x10n ? do_fault+0x2cc/0x6f0n ? handle_pte_fault+0x2e3/0x3d0n ? __pfx_handle_pte_fault+0x10/0x10n---truncated---,CVE-2025-22075,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnocfs2: validate l_tree_depth to avoid out-of-bounds accessnnThe l_tree_depth field is 16-bit (__le16) but the actual maximum depth isnlimited to OCFS2_MAX_PATH_DEPTH.nnAdd a check to prevent out-of-bounds access if l_tree_depth has an invalidnvalue which may occur when reading from a corrupted mounted disk [1].,CVE-2025-22079,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnvhost-scsi: Fix handling of multiple calls to vhost_scsi_set_endpointnnIf vhost_scsi_set_endpoint is called multiple times without anvhost_scsi_clear_endpoint between them we can hit multiple bugsnfound by Haoran Zhang:nn1. Use-after-free when no tpgs are found:nnThis fixes a use after free that occurs when vhost_scsi_set_endpoint isncalled more than once and calls after the first call do not find anyntpgs to add to the vs_tpg. When vhost_scsi_set_endpoint first findsntpgs to add to the vs_tpg array match=true so we will do:nnvhost_vq_set_backend(vq vs_tpg);n...nnkfree(vs->vs_tpg);nvs->vs_tpg = vs_tpg;nnIf vhost_scsi_set_endpoint is called again and no tpgs are foundnmatch=false so we skip the vhost_vq_set_backend call leaving thenpointer to the vs_tpg we then free via:nnkfree(vs->vs_tpg);nvs->vs_tpg = vs_tpg;nnIf a scsi request is then sent we do:nnvhost_scsi_handle_vq -> vhost_scsi_get_req -> vhost_vq_get_backendnnwhich sees the vs_tpg we just did a kfree on.nn2. Tpg dir removal hang:nnThis patch fixes an issue where we cannot remove a LIO/target layerntpg (and structs above it like the target) dir due to the refcountndropping to -1.nnThe problem is that if vhost_scsi_set_endpoint detects a tpg is alreadynin the vs->vs_tpg array or if the tpg has been removed sontarget_depend_item fails the undepend goto handler will dontarget_undepend_item on all tpgs in the vs_tpg array dropping theirnrefcount to 0. At this time vs_tpg contains both the tpgs we have addednin the current vhost_scsi_set_endpoint call as well as tpgs we added innprevious calls which are also in vs->vs_tpg.nnLater when vhost_scsi_clear_endpoint runs it will dontarget_undepend_item on all the tpgs in the vs->vs_tpg which will dropntheir refcount to -1. Userspace will then not be able to remove the tpgnand will hang when it tries to do rmdir on the tpg dir.nn3. Tpg leak:nnThis fixes a bug where we can leak tpgs and cause them to benun-removable because the target name is overwritten whennvhost_scsi_set_endpoint is called multiple times but with differentntarget names.nnThe bug occurs if a user has called VHOST_SCSI_SET_ENDPOINT and setupna vhost-scsi device to target/tpg mapping then callsnVHOST_SCSI_SET_ENDPOINT again with a new target name that has tpgs wenhaven't seen before (target1 has tpg1 but target2 has tpg2). When thisnhappens we don't teardown the old target tpg mapping and just overwritenthe target name and the vs->vs_tpg array. Later when we donvhost_scsi_clear_endpoint we are passed in either target1 or target2'snname and we will only match that target's tpgs when we loop over thenvs->vs_tpg. We will then return from the function without doingntarget_undepend_item on the tpgs.nnBecause of all these bugs it looks like being able to callnvhost_scsi_set_endpoint multiple times was never supported. The majornuser QEMU already has checks to prevent this use case. So to fix thenissues this patch prevents vhost_scsi_set_endpoint from being callednif it's already successfully added tpgs. To add remove or change thentpg config or target name you must do a vhost_scsi_clear_endpointnfirst.,CVE-2025-22083,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnRDMA/mlx5: Fix mlx5_poll_one() cur_qp update flownnWhen cur_qp isn't NULL in order to avoid fetching the QP fromnthe radix tree again we check if the next cqe QP is identical tonthe one we already have.nnThe bug however is that we are checking if the QP is identical bynchecking the QP number inside the CQE against the QP number inside thenmlx5_ib_qp but that's wrong since the QP number from the CQE is fromnFW so it should be matched against mlx5_core_qp which is our FW QPnnumber.nnOtherwise we could use the wrong QP when handling a CQE which couldncause the kernel trace below.nnThis issue is mainly noticeable over QPs 0 & 1 since for now they arenthe only QPs in our driver whereas the QP number inside mlx5_ib_qpndoesn't match the QP number inside mlx5_core_qp.nnBUG: kernel NULL pointer dereference address: 0000000000000012n #PF: supervisor read access in kernel moden #PF: error_code(0x0000) - not-present pagen PGD 0 P4D 0n Oops: Oops: 0000 [#1] SMPn CPU: 0 UID: 0 PID: 7927 Comm: kworker/u62:1 Not tainted 6.14.0-rc3+ #189n Hardware name: QEMU Standard PC (Q35 + ICH9 2009) BIOS rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org 04/01/2014n Workqueue: ib-comp-unb-wq ib_cq_poll_work [ib_core]n RIP: 0010:mlx5_ib_poll_cq+0x4c7/0xd90 [mlx5_ib]n Code: 03 00 00 8d 58 ff 21 cb 66 39 d3 74 39 48 c7 c7 3c 89 6e a0 0f b7 db e8 b7 d2 b3 e0 49 8b 86 60 03 00 00 48 c7 c7 4a 89 6e a0 <0f> b7 5c 98 02 e8 9f d2 b3 e0 41 0f b7 86 78 03 00 00 83 e8 01 21n RSP: 0018:ffff88810511bd60 EFLAGS: 00010046n RAX: 0000000000000010 RBX: 0000000000000000 RCX: 0000000000000000n RDX: 0000000000000000 RSI: ffff88885fa1b3c0 RDI: ffffffffa06e894an RBP: 00000000000000b0 R08: 0000000000000000 R09: ffff88810511bc10n R10: 0000000000000001 R11: 0000000000000001 R12: ffff88810d593000n R13: ffff88810e579108 R14: ffff888105146000 R15: 00000000000000b0n FS: 0000000000000000(0000) GS:ffff88885fa00000(0000) knlGS:0000000000000000n CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033n CR2: 0000000000000012 CR3: 00000001077e6001 CR4: 0000000000370eb0n Call Trace:n <TASK>n ? __die+0x20/0x60n ? page_fault_oops+0x150/0x3e0n ? exc_page_fault+0x74/0x130n ? asm_exc_page_fault+0x22/0x30n ? mlx5_ib_poll_cq+0x4c7/0xd90 [mlx5_ib]n __ib_process_cq+0x5a/0x150 [ib_core]n ib_cq_poll_work+0x31/0x90 [ib_core]n process_one_work+0x169/0x320n worker_thread+0x288/0x3a0n ? work_busy+0xb0/0xb0n kthread+0xd7/0x1f0n ? kthreads_online_cpu+0x130/0x130n ? kthreads_online_cpu+0x130/0x130n ret_from_fork+0x2d/0x50n ? kthreads_online_cpu+0x130/0x130n ret_from_fork_asm+0x11/0x20n </TASK>,CVE-2025-22086,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnx86/mm/pat: Fix VM_PAT handling when fork() fails in copy_page_range()nnIf track_pfn_copy() fails we already added the dst VMA to the maplentree. As fork() fails we'll cleanup the maple tree and stumble overnthe dst VMA for which we neither performed any reservation nor copiednany page tables.nnConsequently untrack_pfn() will see VM_PAT and try obtaining thenPAT information from the page table -- which fails because the pagentable was not copied.nnThe easiest fix would be to simply clear the VM_PAT flag of the dst VMAnif track_pfn_copy() fails. However the whole thing is about simplynclearing the VM_PAT flag is shaky as well: if we passed track_pfn_copy()nand performed a reservation but copying the page tables fails we'llnsimply clear the VM_PAT flag not properly undoing the reservation ...nwhich is also wrong.nnSo let's fix it properly: set the VM_PAT flag only if the reservationnsucceeded (leaving it clear initially) and undo the reservation ifnanything goes wrong while copying the page tables: clearing the VM_PATnflag after undoing the reservation.nnNote that any copied page table entries will get zapped when the VMA willnget removed later after copy_page_range() succeeded; as VM_PAT is not setnthen we won't try cleaning VM_PAT up once more and untrack_pfn() will benhappy. Note that leaving these page tables in place without a reservationnis not a problem as we are aborting fork(); this process will never run.nnA reproducer can trigger this usually at the first try:nn https://gitlab.com/davidhildenbrand/scratchspace/-/raw/main/reproducers/pat_fork.cnn WARNING: CPU: 26 PID: 11650 at arch/x86/mm/pat/memtype.c:983 get_pat_info+0xf6/0x110n Modules linked in: ...n CPU: 26 UID: 0 PID: 11650 Comm: repro3 Not tainted 6.12.0-rc5+ #92n Hardware name: QEMU Standard PC (Q35 + ICH9 2009) BIOS 1.16.3-2.fc40 04/01/2014n RIP: 0010:get_pat_info+0xf6/0x110n ...n Call Trace:n <TASK>n ...n untrack_pfn+0x52/0x110n unmap_single_vma+0xa6/0xe0n unmap_vmas+0x105/0x1f0n exit_mmap+0xf6/0x460n __mmput+0x4b/0x120n copy_process+0x1bf6/0x2aa0n kernel_clone+0xab/0x440n __do_sys_clone+0x66/0x90n do_syscall_64+0x95/0x180nnLikely this case was missed in:nn d155df53f310 (x86/mm/pat: clear VM_PAT if copy_p4d_range failed)nn... and instead of undoing the reservation we simply cleared the VM_PAT flag.nnKeep the documentation of these functions in include/linux/pgtable.hnone place is more than sufficient -- we should clean that up for the othernfunctions like track_pfn_remap/untrack_pfn separately.,CVE-2025-22090,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet: fix NULL pointer dereference in l3mdev_l3_rcvnnWhen delete l3s ipvlan:nn ip link del link eth0 ipvlan1 type ipvlan mode l3snnThis may cause a null pointer dereference:nn Call trace:n ip_rcv_finish+0x48/0xd0n ip_rcv+0x5c/0x100n __netif_receive_skb_one_core+0x64/0xb0n __netif_receive_skb+0x20/0x80n process_backlog+0xb4/0x204n napi_poll+0xe8/0x294n net_rx_action+0xd8/0x22cn __do_softirq+0x12c/0x354nnThis is because l3mdev_l3_rcv() visit dev->l3mdev_ops afternipvlan_l3s_unregister() assign the dev->l3mdev_ops to NULL. The processnlike this:nn (CPU1) | (CPU2)n l3mdev_l3_rcv() |n check dev->priv_flags: |n master = skb->dev; |n |n | ipvlan_l3s_unregister()n | set dev->priv_flagsn | dev->l3mdev_ops = NULL;n |n visit master->l3mdev_ops |nnTo avoid this by do not set dev->l3mdev_ops when unregister l3s ipvlan.,CVE-2025-22103,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnibmvnic: Use kernel helpers for hex dumpsnnPreviously when the driver was printing hex dumps the buffer was castnto an 8 byte long and printed using string formatters. If the buffernsize was not a multiple of 8 then a read buffer overflow was possible.nnTherefore create a new ibmvnic function that loops over a buffer andncalls hex_dump_to_buffer instead.nnThis patch address KASAN reports like the one below:n ibmvnic 30000003 env3: Login Buffer:n ibmvnic 30000003 env3: 01000000af000000n <...>n ibmvnic 30000003 env3: 2e6d62692e736261n ibmvnic 30000003 env3: 65050003006d6f63n ==================================================================n BUG: KASAN: slab-out-of-bounds in ibmvnic_login+0xacc/0xffc [ibmvnic]n Read of size 8 at addr c0000001331a9aa8 by task ip/17681n <...>n Allocated by task 17681:n <...>n ibmvnic_login+0x2f0/0xffc [ibmvnic]n ibmvnic_open+0x148/0x308 [ibmvnic]n __dev_open+0x1ac/0x304n <...>n The buggy address is located 168 bytes inside ofn allocated 175-byte region [c0000001331a9a00 c0000001331a9aaf)n <...>n =================================================================n ibmvnic 30000003 env3: 000000000033766e,CVE-2025-22104,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet: dsa: sja1105: fix kasan out-of-bounds warning in sja1105_table_delete_entry()nnThere are actually 2 problems:n- deleting the last element doesn't require the memmove of elementsn [i + 1 end) over it. Actually element i+1 is out of bounds.n- The memmove itself should move size - i - 1 elements because the lastn element is out of bounds.nnThe out-of-bounds element still remains out of bounds after beingnaccessed so the problem is only that we touch it not that it becomesnin active use. But I suppose it can lead to issues if the out-of-boundsnelement is part of an unmapped page.,CVE-2025-22107,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnax25: Remove broken autobindnnBinding AX25 socket by using the autobind feature leads to memory leaksnin ax25_connect() and also refcount leaks in ax25_release(). Memorynleak was detected with kmemleak:nn================================================================nunreferenced object 0xffff8880253cd680 (size 96):nbacktrace:n__kmalloc_node_track_caller_noprof (./include/linux/kmemleak.h:43)nkmemdup_noprof (mm/util.c:136)nax25_rt_autobind (net/ax25/ax25_route.c:428)nax25_connect (net/ax25/af_ax25.c:1282)n__sys_connect_file (net/socket.c:2045)n__sys_connect (net/socket.c:2064)n__x64_sys_connect (net/socket.c:2067)ndo_syscall_64 (arch/x86/entry/common.c:52 arch/x86/entry/common.c:83)nentry_SYSCALL_64_after_hwframe (arch/x86/entry/entry_64.S:130)n================================================================nnWhen socket is bound refcounts must be incremented the way it is donenin ax25_bind() and ax25_setsockopt() (SO_BINDTODEVICE). In case ofnautobind the refcounts are not incremented.nnThis bug leads to the following issue reported by Syzkaller:nn================================================================nax25_connect(): syz-executor318 uses autobind please contact jreuter@yaina.den------------[ cut here ]------------nrefcount_t: decrement hit 0; leaking memory.nWARNING: CPU: 0 PID: 5317 at lib/refcount.c:31 refcount_warn_saturate+0xfa/0x1d0 lib/refcount.c:31nModules linked in:nCPU: 0 UID: 0 PID: 5317 Comm: syz-executor318 Not tainted 6.14.0-rc4-syzkaller-00278-gece144f151ac #0nHardware name: QEMU Standard PC (Q35 + ICH9 2009) BIOS 1.16.3-debian-1.16.3-2~bpo12+1 04/01/2014nRIP: 0010:refcount_warn_saturate+0xfa/0x1d0 lib/refcount.c:31n...nCall Trace:n <TASK>n __refcount_dec include/linux/refcount.h:336 [inline]n refcount_dec include/linux/refcount.h:351 [inline]n ref_tracker_free+0x6af/0x7e0 lib/ref_tracker.c:236n netdev_tracker_free include/linux/netdevice.h:4302 [inline]n netdev_put include/linux/netdevice.h:4319 [inline]n ax25_release+0x368/0x960 net/ax25/af_ax25.c:1080n __sock_release net/socket.c:647 [inline]n sock_close+0xbc/0x240 net/socket.c:1398n __fput+0x3e9/0x9f0 fs/file_table.c:464n __do_sys_close fs/open.c:1580 [inline]n __se_sys_close fs/open.c:1565 [inline]n __x64_sys_close+0x7f/0x110 fs/open.c:1565n do_syscall_x64 arch/x86/entry/common.c:52 [inline]n do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83n entry_SYSCALL_64_after_hwframe+0x77/0x7fn ...n </TASK>n================================================================nnConsidering the issues above and the comments left in the code that say:ncheck if we can remove this feature. It is broken.; autobinding in thisnmay or may not work; - it is better to completely remove this feature thannto fix it because it is broken and leads to various kinds of memory bugs.nnNow calling connect() without first binding socket will result in annerror (-EINVAL). Userspace software that relies on the autobind featurenmight get broken. However this feature does not seem widely used withnthis specific driver as it was not reliable at any point of time and itnis already broken anyway. E.g. ax25-tools and ax25-apps packages fornpopular distributions do not use the autobind feature for AF_AX25.nnFound by Linux Verification Center (linuxtesting.org) with Syzkaller.,CVE-2025-22109,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnext4: fix out-of-bound read in ext4_xattr_inode_dec_ref_all()nnThere's issue as follows:nBUG: KASAN: use-after-free in ext4_xattr_inode_dec_ref_all+0x6ff/0x790nRead of size 4 at addr ffff88807b003000 by task syz-executor.0/15172nnCPU: 3 PID: 15172 Comm: syz-executor.0nCall Trace:n __dump_stack lib/dump_stack.c:82 [inline]n dump_stack+0xbe/0xfd lib/dump_stack.c:123n print_address_description.constprop.0+0x1e/0x280 mm/kasan/report.c:400n __kasan_report.cold+0x6c/0x84 mm/kasan/report.c:560n kasan_report+0x3a/0x50 mm/kasan/report.c:585n ext4_xattr_inode_dec_ref_all+0x6ff/0x790 fs/ext4/xattr.c:1137n ext4_xattr_delete_inode+0x4c7/0xda0 fs/ext4/xattr.c:2896n ext4_evict_inode+0xb3b/0x1670 fs/ext4/inode.c:323n evict+0x39f/0x880 fs/inode.c:622n iput_final fs/inode.c:1746 [inline]n iput fs/inode.c:1772 [inline]n iput+0x525/0x6c0 fs/inode.c:1758n ext4_orphan_cleanup fs/ext4/super.c:3298 [inline]n ext4_fill_super+0x8c57/0xba40 fs/ext4/super.c:5300n mount_bdev+0x355/0x410 fs/super.c:1446n legacy_get_tree+0xfe/0x220 fs/fs_context.c:611n vfs_get_tree+0x8d/0x2f0 fs/super.c:1576n do_new_mount fs/namespace.c:2983 [inline]n path_mount+0x119a/0x1ad0 fs/namespace.c:3316n do_mount+0xfc/0x110 fs/namespace.c:3329n __do_sys_mount fs/namespace.c:3540 [inline]n __se_sys_mount+0x219/0x2e0 fs/namespace.c:3514n do_syscall_64+0x33/0x40 arch/x86/entry/common.c:46n entry_SYSCALL_64_after_hwframe+0x67/0xd1nnMemory state around the buggy address:n ffff88807b002f00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00n ffff88807b002f80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00n>ffff88807b003000: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ffn ^n ffff88807b003080: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ffn ffff88807b003100: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ffnnAbove issue happens as ext4_xattr_delete_inode() isn't check xattrnis valid if xattr is in inode.nTo solve above issue call xattr_check_inode() check if xattr if validnin inode. In fact we can directly verify in ext4_iget_extra_inode()nso that there is no divergent verification.,CVE-2025-22121,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnmd/raid1raid10: don't ignore IO flagsnnIf blk-wbt is enabled by default it's found that raid write performancenis quite bad because all IO are throttled by wbt of underlying disksndue to flag REQ_IDLE is ignored. And turns out this behaviour exist sincenblk-wbt is introduced.nnOther than REQ_IDLE other flags should not be ignored as well fornexample REQ_META can be set for filesystems clearing it can cause prioritynreverse problems; And REQ_NOWAIT should not be cleared as well becausenio will wait instead of failing directly in underlying disks.nnFix those problems by keep IO flags from master bio.nnFises: f51d46d0e7cb (md: add support for REQ_NOWAIT),CVE-2025-22125,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnf2fs: fix potential deadloop in prepare_compress_overwrite()nnJan Prusakowski reported a kernel hang issue as below:nnWhen running xfstests on linux-next kernel (6.14.0-rc3 6.12) Inencountered a problem in generic/475 test where fsstress processngets blocked in __f2fs_write_data_pages() and the test hangs.nThe options I used are:nnMKFS_OPTIONS -- -O compression -O extra_attr -O project_quota -O quota /dev/vdcnMOUNT_OPTIONS -- -o acluser_xattr -o discardcompress_extension=* /dev/vdc /vdcnnINFO: task kworker/u8:0:11 blocked for more than 122 seconds.n Not tainted 6.14.0-rc3-xfstests-lockdep #1necho 0 > /proc/sys/kernel/hung_task_timeout_secs disables this message.ntask:kworker/u8:0 state:D stack:0 pid:11 tgid:11 ppid:2 task_flags:0x4208160 flags:0x00004000nWorkqueue: writeback wb_workfn (flush-253:0)nCall Trace:n <TASK>n __schedule+0x309/0x8e0n schedule+0x3a/0x100n schedule_preempt_disabled+0x15/0x30n __mutex_lock+0x59a/0xdb0n __f2fs_write_data_pages+0x3ac/0x400n do_writepages+0xe8/0x290n __writeback_single_inode+0x5c/0x360n writeback_sb_inodes+0x22f/0x570n wb_writeback+0xb0/0x410n wb_do_writeback+0x47/0x2f0n wb_workfn+0x5a/0x1c0n process_one_work+0x223/0x5b0n worker_thread+0x1d5/0x3c0n kthread+0xfd/0x230n ret_from_fork+0x31/0x50n ret_from_fork_asm+0x1a/0x30n </TASK>nnThe root cause is: once generic/475 starts toload error table to dmndevice f2fs_prepare_compress_overwrite() will loop reading compressedncluster pages due to IO error meanwhile it has held .writepages locknit can block all other writeback tasks.nnLet's fix this issue w/ below changes:n- add f2fs_handle_page_eio() in prepare_compress_overwrite() tondetect IO error.n- detect cp_error earler in f2fs_read_multi_pages().,CVE-2025-22127,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnf2fs: fix to avoid panic once fallocation fails for pinfilennsyzbot reports a f2fs bug as below:nn------------[ cut here ]------------nkernel BUG at fs/f2fs/segment.c:2746!nCPU: 0 UID: 0 PID: 5323 Comm: syz.0.0 Not tainted 6.13.0-rc2-syzkaller-00018-g7cb1b4663150 #0nRIP: 0010:get_new_segment fs/f2fs/segment.c:2746 [inline]nRIP: 0010:new_curseg+0x1f52/0x1f70 fs/f2fs/segment.c:2876nCall Trace:n <TASK>n __allocate_new_segment+0x1ce/0x940 fs/f2fs/segment.c:3210n f2fs_allocate_new_section fs/f2fs/segment.c:3224 [inline]n f2fs_allocate_pinning_section+0xfa/0x4e0 fs/f2fs/segment.c:3238n f2fs_expand_inode_data+0x696/0xca0 fs/f2fs/file.c:1830n f2fs_fallocate+0x537/0xa10 fs/f2fs/file.c:1940n vfs_fallocate+0x569/0x6e0 fs/open.c:327n do_vfs_ioctl+0x258c/0x2e40 fs/ioctl.c:885n __do_sys_ioctl fs/ioctl.c:904 [inline]n __se_sys_ioctl+0x80/0x170 fs/ioctl.c:892n do_syscall_x64 arch/x86/entry/common.c:52 [inline]n do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83n entry_SYSCALL_64_after_hwframe+0x77/0x7fnnConcurrent pinfile allocation may run out of free section result innpanic in get_new_segment() let's expand pin_sem lock coverage toninclude f2fs_gc() so that we can make sure to reclaim enough freenspace for following allocation.nnIn addition do below changes to enhance error path handling:n- call f2fs_bug_on() only in non-pinfile allocation path innget_new_segment().n- call reset_curseg_fields() to reset all fields of curseg innnew_curseg(),CVE-2025-23130,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndlm: prevent NPD when writing a positive value to event_donenndo_uevent returns the value written to event_done. In case it is anpositive value new_lockspace would undo all the work and lockspacenwould not be set. __dlm_new_lockspace however would treat thatnpositive value as a success due to commit 8511a2728ab8 (dlm: fix usencount with multiple joins).nnDown the line device_create_lockspace would pass that NULL lockspace tondlm_find_lockspace_local leading to a NULL pointer dereference.nnTreating such positive values as successes prevents the problem. Givennthis has been broken for so long this is unlikely to break userspacenexpectations.,CVE-2025-23131,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnf2fs: quota: fix to avoid warning in dquot_writeback_dquots()nnF2FS-fs (dm-59): checkpoint=enable has some unwritten data.nn------------[ cut here ]------------nWARNING: CPU: 6 PID: 8013 at fs/quota/dquot.c:691 dquot_writeback_dquots+0x2fc/0x308npc : dquot_writeback_dquots+0x2fc/0x308nlr : f2fs_quota_sync+0xcc/0x1c4nCall trace:ndquot_writeback_dquots+0x2fc/0x308nf2fs_quota_sync+0xcc/0x1c4nf2fs_write_checkpoint+0x3d4/0x9b0nf2fs_issue_checkpoint+0x1bc/0x2c0nf2fs_sync_fs+0x54/0x150nf2fs_do_sync_file+0x2f8/0x814n__f2fs_ioctl+0x1960/0x3244nf2fs_ioctl+0x54/0xe0n__arm64_sys_ioctl+0xa8/0xe4ninvoke_syscall+0x58/0x114nncheckpoint and f2fs_remount may race as below resulting triggering warningnin dquot_writeback_dquots().nnatomic write remountn - do_remountn - down_write(&sb->s_umount);n - f2fs_remountn- ioctln - f2fs_do_sync_filen - f2fs_sync_fsn - f2fs_write_checkpointn - block_operationsn - locked = down_read_trylock(&sbi->sb->s_umount)n : fail to lock due to the write lock was held by remountn - up_write(&sb->s_umount);n - f2fs_quota_syncn - dquot_writeback_dquotsn - WARN_ON_ONCE(!rwsem_is_locked(&sb->s_umount))n : trigger warning because s_umount lock was unlocked by remountnnIf checkpoint comes from mount/umount/remount/freeze/quotactl caller ofncheckpoint has already held s_umount lock calling dquot_writeback_dquots()nin the context should be safe.nnSo let's record task to sbi->umount_lock_holder so that checkpoint cannknow whether the lock has held in the context or not by checking currentnw/ it.nnIn addition in order to not misrepresent caller of checkpoint we shouldnnot allow to trigger async checkpoint for those callers: mount/umount/remount/nfreeze/quotactl.,CVE-2025-23132,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnthermal: int340x: Add NULL check for adevnnNot all devices have an ACPI companion fwnode so adev might be NULL.nThis is similar to the commit cd2fd6eab480n(platform/x86: int3472: Check for adev == NULL).nnAdd a check for adev not being set and return -ENODEV in that case tonavoid a possible NULL pointer deref in int3402_thermal_probe().nnNote under the same directory int3400_thermal_probe() has such ancheck.nn[ rjw: Subject edit added Fixes: ],CVE-2025-23136,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnwatch_queue: fix pipe accounting mismatchnnCurrently watch_queue_set_size() modifies the pipe buffers charged tonuser->pipe_bufs without updating the pipe->nr_accounted on the pipenitself due to the if (!pipe_has_watch_queue()) test innpipe_resize_ring(). This means that when the pipe is ultimately freednwe decrement user->pipe_bufs by something other than what than we hadncharged to it potentially leading to an underflow. This in turn canncause subsequent too_many_pipe_buffers_soft() tests to fail with -EPERM.nnTo remedy this explicitly account for the pipe usage innwatch_queue_set_size() to match the number set via account_pipe_buffers()nn(It's unclear why watch_queue_set_size() does not update nr_accounted;nit may be due to intentional overprovisioning in watch_queue_set_size()?),CVE-2025-23138,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnmisc: pci_endpoint_test: Avoid issue of interrupts remaining after request_irq errornnAfter devm_request_irq() fails with error in pci_endpoint_test_request_irq()nthe pci_endpoint_test_free_irq_vectors() is called assuming that all IRQsnhave been released.nnHowever some requested IRQs remain unreleased so there are stilln/proc/irq/* entries remaining and this results in WARN() with thenfollowing message:nn remove_proc_entry: removing non-empty directory 'irq/30' leaking at least 'pci-endpoint-test.0'n WARNING: CPU: 0 PID: 202 at fs/proc/generic.c:719 remove_proc_entry +0x190/0x19cnnTo solve this issue set the number of remaining IRQs to test->num_irqsnand release IRQs in advance by calling pci_endpoint_test_release_irq().nn[kwilczynski: commit log],CVE-2025-23140,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnKVM: x86: Acquire SRCU in KVM_GET_MP_STATE to protect guest memory accessesnnAcquire a lock on kvm->srcu when userspace is getting MP state to handle anrather extreme edge case where accepting APIC events i.e. processingnpending INIT or SIPI can trigger accesses to guest memory. If the vCPUnis in L2 with INIT *and* a TRIPLE_FAULT request pending then getting MPnstate will trigger a nested VM-Exit by way of ->check_nested_events() andnemuating the nested VM-Exit can access guest memory.nnThe splat was originally hit by syzkaller on a Google-internal kernel andnreproduced on an upstream kernel by hacking the triple_fault_event_testnselftest to stuff a pending INIT store an MSR on VM-Exit (to generate anmemory access on VMX) and do vcpu_mp_state_get() to trigger the scenario.nn =============================n WARNING: suspicious RCU usagen 6.14.0-rc3-b112d356288b-vmx/pi_lockdep_false_pos-lock #3 Not taintedn -----------------------------n include/linux/kvm_host.h:1058 suspicious rcu_dereference_check() usage!nn other info that might help us debug this:nn rcu_scheduler_active = 2 debug_locks = 1n 1 lock held by triple_fault_ev/1256:n #0: ffff88810df5a330 (&vcpu->mutex){+.+.}-{4:4} at: kvm_vcpu_ioctl+0x8b/0x9a0 [kvm]nn stack backtrace:n CPU: 11 UID: 1000 PID: 1256 Comm: triple_fault_ev Not tainted 6.14.0-rc3-b112d356288b-vmx #3n Hardware name: QEMU Standard PC (Q35 + ICH9 2009) BIOS 0.0.0 02/06/2015n Call Trace:n <TASK>n dump_stack_lvl+0x7f/0x90n lockdep_rcu_suspicious+0x144/0x190n kvm_vcpu_gfn_to_memslot+0x156/0x180 [kvm]n kvm_vcpu_read_guest+0x3e/0x90 [kvm]n read_and_check_msr_entry+0x2e/0x180 [kvm_intel]n __nested_vmx_vmexit+0x550/0xde0 [kvm_intel]n kvm_check_nested_events+0x1b/0x30 [kvm]n kvm_apic_accept_events+0x33/0x100 [kvm]n kvm_arch_vcpu_ioctl_get_mpstate+0x30/0x1d0 [kvm]n kvm_vcpu_ioctl+0x33e/0x9a0 [kvm]n __x64_sys_ioctl+0x8b/0xb0n do_syscall_64+0x6c/0x170n entry_SYSCALL_64_after_hwframe+0x4b/0x53n </TASK>,CVE-2025-23141,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnsctp: detect and prevent references to a freed transport in sendmsgnnsctp_sendmsg() re-uses associations and transports when possible byndoing a lookup based on the socket endpoint and the message destinationnaddress and then sctp_sendmsg_to_asoc() sets the selected transport innall the message chunks to be sent.nnThere's a possible race condition if another thread triggers the removalnof that selected transport for instance by explicitly unbinding annaddress with setsockopt(SCTP_SOCKOPT_BINDX_REM) after the chunks havenbeen set up and before the message is sent. This can happen if the sendnbuffer is full during the period when the sender thread temporarilynreleases the socket lock in sctp_wait_for_sndbuf().nnThis causes the access to the transport data innsctp_outq_select_transport() when the association outqueue is flushednto result in a use-after-free read.nnThis change avoids this scenario by having sctp_transport_free() signalnthe freeing of the transport tagging it as dead. In order to do thisnthe patch restores the dead bit in struct sctp_transport which wasnremoved inncommit 47faa1e4c50e (sctp: remove the dead field of sctp_transport).nnThen in the scenario where the sender thread has released the socketnlock in sctp_wait_for_sndbuf() the bit is checked again afternre-acquiring the socket lock to detect the deletion. This is done whilenholding a reference to the transport to prevent it from being freed innthe process.nnIf the transport was deleted while the socket lock was relinquishednsctp_sendmsg_to_asoc() will return -EAGAIN to let userspace retry thensend.nnThe bug was found by a private syzbot instance (see the error report [1]nand the C reproducer that triggers it [2]).,CVE-2025-23142,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet: Fix null-ptr-deref by sock_lock_init_class_and_name() and rmmod.nnWhen I ran the repro [0] and waited a few seconds I observed twonLOCKDEP splats: a warning immediately followed by a null-ptr-deref. [1]nnReproduction Steps:nn 1) Mount CIFSn 2) Add an iptables rule to drop incoming FIN packets for CIFSn 3) Unmount CIFSn 4) Unload the CIFS modulen 5) Remove the iptables rulennAt step 3) the CIFS module calls sock_release() for the underlyingnTCP socket and it returns quickly. However the socket remains innFIN_WAIT_1 because incoming FIN packets are dropped.nnAt this point the module's refcnt is 0 while the socket is stillnalive so the following rmmod command succeeds.nn # ss -tann State Recv-Q Send-Q Local Address:Port Peer Address:Portn FIN-WAIT-1 0 477 10.0.2.15:51062 10.0.0.137:445nn # lsmod | grep cifsn cifs 1159168 0nnThis highlights a discrepancy between the lifetime of the CIFS modulenand the underlying TCP socket. Even after CIFS calls sock_release()nand it returns the TCP socket does not die immediately in order tonclose the connection gracefully.nnWhile this is generally fine it causes an issue with LOCKDEP becausenCIFS assigns a different lock class to the TCP socket's sk->sk_locknusing sock_lock_init_class_and_name().nnOnce an incoming packet is processed for the socket or a timer firesnsk->sk_lock is acquired.nnThen LOCKDEP checks the lock context in check_wait_context() wherenhlock_class() is called to retrieve the lock class. However sincenthe module has already been unloaded hlock_class() logs a warningnand returns NULL triggering the null-ptr-deref.nnIf LOCKDEP is enabled we must ensure that a module callingnsock_lock_init_class_and_name() (CIFS NFS etc) cannot be unloadednwhile such a socket is still alive to prevent this issue.nnLet's hold the module reference in sock_lock_init_class_and_name()nand release it when the socket is freed in sk_prot_free().nnNote that sock_lock_init() clears sk->sk_owner for svc_create_socket()nthat calls sock_lock_init_class_and_name() for a listening socketnwhich clones a socket by sk_clone_lock() without GFP_ZERO.nn[0]:nCIFS_SERVER=10.0.0.137nCIFS_PATH=//${CIFS_SERVER}/Users/Administrator/Desktop/CIFS_TESTnDEV=enp0s3nCRED=/root/WindowsCredential.txtnnMNT=$(mktemp -d /tmp/XXXXXX)nmount -t cifs ${CIFS_PATH} ${MNT} -o vers=3.0credentials=${CRED}cache=noneecho_interval=1nniptables -A INPUT -s ${CIFS_SERVER} -j DROPnnfor i in $(seq 10);ndon umount ${MNT}n rmmod cifsn sleep 1ndonennrm -r ${MNT}nniptables -D INPUT -s ${CIFS_SERVER} -j DROPnn[1]:nDEBUG_LOCKS_WARN_ON(1)nWARNING: CPU: 10 PID: 0 at kernel/locking/lockdep.c:234 hlock_class (kernel/locking/lockdep.c:234 kernel/locking/lockdep.c:223)nModules linked in: cifs_arc4 nls_ucs2_utils cifs_md4 [last unloaded: cifs]nCPU: 10 UID: 0 PID: 0 Comm: swapper/10 Not tainted 6.14.0 #36nHardware name: QEMU Standard PC (i440FX + PIIX 1996) BIOS rel-1.16.0-0-gd239552ce722-prebuilt.qemu.org 04/01/2014nRIP: 0010:hlock_class (kernel/locking/lockdep.c:234 kernel/locking/lockdep.c:223)n...nCall Trace:n <IRQ>n __lock_acquire (kernel/locking/lockdep.c:4853 kernel/locking/lockdep.c:5178)n lock_acquire (kernel/locking/lockdep.c:469 kernel/locking/lockdep.c:5853 kernel/locking/lockdep.c:5816)n _raw_spin_lock_nested (kernel/locking/spinlock.c:379)n tcp_v4_rcv (./include/linux/skbuff.h:1678 ./include/net/tcp.h:2547 net/ipv4/tcp_ipv4.c:2350)n...nnBUG: kernel NULL pointer dereference address: 00000000000000c4n PF: supervisor read access in kernel moden PF: error_code(0x0000) - not-present pagenPGD 0nOops: Oops: 0000 [#1] PREEMPT SMP NOPTInCPU: 10 UID: 0 PID: 0 Comm: swapper/10 Tainted: G W 6.14.0 #36nTainted: [W]=WARNnHardware name: QEMU Standard PC (i440FX + PIIX 1996) BIOS rel-1.16.0-0-gd239552ce722-prebuilt.qemu.org 04/01/2014nRIP: 0010:__lock_acquire (kernel/n---truncated---,CVE-2025-23143,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbacklight: led_bl: Hold led_access lock when calling led_sysfs_disable()nnLockdep detects the following issue on led-backlight removal:n [ 142.315935] ------------[ cut here ]------------n [ 142.315954] WARNING: CPU: 2 PID: 292 at drivers/leds/led-core.c:455 led_sysfs_enable+0x54/0x80n ...n [ 142.500725] Call trace:n [ 142.503176] led_sysfs_enable+0x54/0x80 (P)n [ 142.507370] led_bl_remove+0x80/0xa8 [led_bl]n [ 142.511742] platform_remove+0x30/0x58n [ 142.515501] device_remove+0x54/0x90n ...nnIndeed led_sysfs_enable() has to be called with the led_accessnlock held.nnHold the lock when calling led_sysfs_disable().,CVE-2025-23144,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnmptcp: fix NULL pointer in can_accept_new_subflownnWhen testing valkey benchmark tool with MPTCP the kernel panics inn'mptcp_can_accept_new_subflow' because subflow_req->msk is NULL.nnCall trace:nn mptcp_can_accept_new_subflow (./net/mptcp/subflow.c:63 (discriminator 4)) (P)n subflow_syn_recv_sock (./net/mptcp/subflow.c:854)n tcp_check_req (./net/ipv4/tcp_minisocks.c:863)n tcp_v4_rcv (./net/ipv4/tcp_ipv4.c:2268)n ip_protocol_deliver_rcu (./net/ipv4/ip_input.c:207)n ip_local_deliver_finish (./net/ipv4/ip_input.c:234)n ip_local_deliver (./net/ipv4/ip_input.c:254)n ip_rcv_finish (./net/ipv4/ip_input.c:449)n ...nnAccording to the debug log the same req received two SYN-ACK in a verynshort time very likely because the client retransmits the syn ack duento multiple reasons.nnEven if the packets are transmitted with a relevant time interval theyncan be processed by the server on different CPUs concurrently). Then'subflow_req->msk' ownership is transferred to the subflow the firstnand there will be a risk of a null pointer dereference here.nnThis patch fixes this issue by moving the 'subflow_req->msk' under then`own_req == true` conditional.nnNote that the !msk check in subflow_hmac_valid() can be dropped becausenthe same check already exists under the own_req mpj branch where thencode has been moved to.,CVE-2025-23145,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnmfd: ene-kb3930: Fix a potential NULL pointer dereferencennThe off_gpios could be NULL. Add missing check in the kb3930_probe().nThis is similar to the issue fixed in commit b1ba8bcb2d1fn(backlight: hx8357: Fix potential NULL pointer dereference).nnThis was detected by our static analysis tool.,CVE-2025-23146,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nni3c: Add NULL pointer check in i3c_master_queue_ibi()nnThe I3C master driver may receive an IBI from a target device that has notnbeen probed yet. In such cases the master calls `i3c_master_queue_ibi()`nto queue an IBI work task leading to Unable to handle kernel read fromnunreadable memory and resulting in a kernel panic.nnTypical IBI handling flow:n1. The I3C master scans target devices and probes their respective drivers.n2. The target device driver calls `i3c_device_request_ibi()` to enable IBIn and assigns `dev->ibi = ibi`.n3. The I3C master receives an IBI from the target device and callsn `i3c_master_queue_ibi()` to queue the target device drivers IBIn handler task.nnHowever since target device events are asynchronous to the I3C probensequence step 3 may occur before step 2 causing `dev->ibi` to be `NULL`nleading to a kernel panic.nnAdd a NULL pointer check in `i3c_master_queue_ibi()` to prevent accessingnan uninitialized `dev->ibi` ensuring stability.,CVE-2025-23147,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnsoc: samsung: exynos-chipid: Add NULL pointer check in exynos_chipid_probe()nnsoc_dev_attr->revision could be NULL thusna pointer check is added to prevent potential NULL pointer dereference.nThis is similar to the fix in commit 3027e7b15b02n(ice: Fix some null pointer dereference issues in ice_ptp.c).nnThis issue is found by our static analysis tool.,CVE-2025-23148,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnext4: fix off-by-one error in do_splitnnSyzkaller detected a use-after-free issue in ext4_insert_dentry that wasncaused by out-of-bounds access due to incorrect splitting in do_split.nnBUG: KASAN: use-after-free in ext4_insert_dentry+0x36a/0x6d0 fs/ext4/namei.c:2109nWrite of size 251 at addr ffff888074572f14 by task syz-executor335/5847nnCPU: 0 UID: 0 PID: 5847 Comm: syz-executor335 Not tainted 6.12.0-rc6-syzkaller-00318-ga9cda7c0ffed #0nHardware name: Google Google Compute Engine/Google Compute Engine BIOS Google 10/30/2024nCall Trace:n <TASK>n __dump_stack lib/dump_stack.c:94 [inline]n dump_stack_lvl+0x241/0x360 lib/dump_stack.c:120n print_address_description mm/kasan/report.c:377 [inline]n print_report+0x169/0x550 mm/kasan/report.c:488n kasan_report+0x143/0x180 mm/kasan/report.c:601n kasan_check_range+0x282/0x290 mm/kasan/generic.c:189n __asan_memcpy+0x40/0x70 mm/kasan/shadow.c:106n ext4_insert_dentry+0x36a/0x6d0 fs/ext4/namei.c:2109n add_dirent_to_buf+0x3d9/0x750 fs/ext4/namei.c:2154n make_indexed_dir+0xf98/0x1600 fs/ext4/namei.c:2351n ext4_add_entry+0x222a/0x25d0 fs/ext4/namei.c:2455n ext4_add_nondir+0x8d/0x290 fs/ext4/namei.c:2796n ext4_symlink+0x920/0xb50 fs/ext4/namei.c:3431n vfs_symlink+0x137/0x2e0 fs/namei.c:4615n do_symlinkat+0x222/0x3a0 fs/namei.c:4641n __do_sys_symlink fs/namei.c:4662 [inline]n __se_sys_symlink fs/namei.c:4660 [inline]n __x64_sys_symlink+0x7a/0x90 fs/namei.c:4660n do_syscall_x64 arch/x86/entry/common.c:52 [inline]n do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83n entry_SYSCALL_64_after_hwframe+0x77/0x7fn </TASK>nnThe following loop is located right above 'if' statement.nnfor (i = count-1; i >= 0; i--) {nt/* is more than half of this entry in 2nd half of the block? */ntif (size + map[i].size/2 > blocksize/2)nttbreak;ntsize += map[i].size;ntmove++;n}nn'i' in this case could go down to -1 in which case sum of active entriesnwouldn't exceed half the block size but previous behaviour would also donsplit in half if sum would exceed at the very last block which in case ofnhaving too many long name files in a single block could lead tonout-of-bounds access and following use-after-free.nnFound by Linux Verification Center (linuxtesting.org) with Syzkaller.,CVE-2025-23150,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnmedia: venus: hfi_parser: refactor hfi packet parsing logicnnwords_count denotes the number of words in total payload while datanpoints to payload of various property within it. When words_countnreaches last word data can access memory beyond the total payload. Thisncan lead to OOB access. With this patch the utility api for handlingnindividual properties now returns the size of data consumed. Accordinglynremaining bytes are calculated before parsing the payload therebyneliminates the OOB access possibilities.,CVE-2025-23156,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnmedia: venus: hfi_parser: add check to avoid out of bound accessnnThere is a possibility that init_codecs is invoked multiple times duringnmanipulated payload from video firmware. In such case if codecs_countncan get incremented to value more than MAX_CODEC_NUM there can be OOBnaccess. Reset the count so that it always starts from beginning.,CVE-2025-23157,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnmedia: venus: hfi: add check to handle incorrect queue sizennqsize represents size of shared queued between driver and videonfirmware. Firmware can modify this value to an invalid large value. Innsuch situation empty_space will be bigger than the space actuallynavailable. Since new_wr_idx is not checked so the following code willnresult in an OOB write.n...nqsize = qhdr->q_sizennif (wr_idx >= rd_idx)n empty_space = qsize - (wr_idx - rd_idx)n....nif (new_wr_idx < qsize) {n memcpy(wr_ptr packet dwords << 2) --> OOB writennAdd check to ensure qsize is within the allocated size whilenreading and writing packets into the queue.,CVE-2025-23158,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnmedia: venus: hfi: add a check to handle OOB in sfr regionnnsfr->buf_size is in shared memory and can be modified by malicious user.nOOB write is possible when the size is made higher than actual sfr datanbuffer. Cap the size to allocated size for such cases.,CVE-2025-23159,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnPCI: vmd: Make vmd_dev::cfg_lock a raw_spinlock_t typennThe access to the PCI config space via pci_ops::read and pci_ops::write isna low-level hardware access. The functions can be accessed with disabledninterrupts even on PREEMPT_RT. The pci_lock is a raw_spinlock_t for thisnpurpose.nnA spinlock_t becomes a sleeping lock on PREEMPT_RT so it cannot benacquired with disabled interrupts. The vmd_dev::cfg_lock is accessed innthe same context as the pci_lock.nnMake vmd_dev::cfg_lock a raw_spinlock_t type so it can be used withninterrupts disabled.nnThis was reported as:nn BUG: sleeping function called from invalid context at kernel/locking/spinlock_rt.c:48n Call Trace:n rt_spin_lock+0x4e/0x130n vmd_pci_read+0x8d/0x100 [vmd]n pci_user_read_config_byte+0x6f/0xe0n pci_read_config+0xfe/0x290n sysfs_kf_bin_read+0x68/0x90nn[bigeasy: reword commit message]nTested-off-by: Luis Claudio R. Goncalves <lgoncalv@redhat.com>n[kwilczynski: commit log]n[bhelgaas: add back report info fromnhttps://lore.kernel.org/lkml/20241218115951.83062-1-ryotkkr98@gmail.com/],CVE-2025-23161,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet: vlan: don't propagate flags on opennnWith the device instance lock there is now a possibility of a deadlock:nn[ 1.211455] ============================================n[ 1.211571] WARNING: possible recursive locking detectedn[ 1.211687] 6.14.0-rc5-01215-g032756b4ca7a-dirty #5 Not taintedn[ 1.211823] --------------------------------------------n[ 1.211936] ip/184 is trying to acquire lock:n[ 1.212032] ffff8881024a4c30 (&dev->lock){+.+.}-{4:4} at: dev_set_allmulti+0x4e/0xb0n[ 1.212207]n[ 1.212207] but task is already holding lock:n[ 1.212332] ffff8881024a4c30 (&dev->lock){+.+.}-{4:4} at: dev_open+0x50/0xb0n[ 1.212487]n[ 1.212487] other info that might help us debug this:n[ 1.212626] Possible unsafe locking scenario:n[ 1.212626]n[ 1.212751] CPU0n[ 1.212815] ----n[ 1.212871] lock(&dev->lock);n[ 1.212944] lock(&dev->lock);n[ 1.213016]n[ 1.213016] output.log scan_tyk_dockerimages.sh vulnerabilities.csv DEADLOCK ***n[ 1.213016]n[ 1.213143] May be due to missing lock nesting notationn[ 1.213143]n[ 1.213294] 3 locks held by ip/184:n[ 1.213371] #0: ffffffff838b53e0 (rtnl_mutex){+.+.}-{4:4} at: rtnl_nets_lock+0x1b/0xa0n[ 1.213543] #1: ffffffff84e5fc70 (&net->rtnl_mutex){+.+.}-{4:4} at: rtnl_nets_lock+0x37/0xa0n[ 1.213727] #2: ffff8881024a4c30 (&dev->lock){+.+.}-{4:4} at: dev_open+0x50/0xb0n[ 1.213895]n[ 1.213895] stack backtrace:n[ 1.213991] CPU: 0 UID: 0 PID: 184 Comm: ip Not tainted 6.14.0-rc5-01215-g032756b4ca7a-dirty #5n[ 1.213993] Hardware name: QEMU Standard PC (i440FX + PIIX 1996) BIOS Arch Linux 1.16.3-1-1 04/01/2014n[ 1.213994] Call Trace:n[ 1.213995] <TASK>n[ 1.213996] dump_stack_lvl+0x8e/0xd0n[ 1.214000] print_deadlock_bug+0x28b/0x2a0n[ 1.214020] lock_acquire+0xea/0x2a0n[ 1.214027] __mutex_lock+0xbf/0xd40n[ 1.214038] dev_set_allmulti+0x4e/0xb0 # real_dev->flags & IFF_ALLMULTIn[ 1.214040] vlan_dev_open+0xa5/0x170 # ndo_open on vlandevn[ 1.214042] __dev_open+0x145/0x270n[ 1.214046] __dev_change_flags+0xb0/0x1e0n[ 1.214051] netif_change_flags+0x22/0x60 # IFF_UP vlandevn[ 1.214053] dev_change_flags+0x61/0xb0 # for each device in group from dev->vlan_infon[ 1.214055] vlan_device_event+0x766/0x7c0 # on netdevsim0n[ 1.214058] notifier_call_chain+0x78/0x120n[ 1.214062] netif_open+0x6d/0x90n[ 1.214064] dev_open+0x5b/0xb0 # locks netdevsim0n[ 1.214066] bond_enslave+0x64c/0x1230n[ 1.214075] do_set_master+0x175/0x1e0 # on netdevsim0n[ 1.214077] do_setlink+0x516/0x13b0n[ 1.214094] rtnl_newlink+0xaba/0xb80n[ 1.214132] rtnetlink_rcv_msg+0x440/0x490n[ 1.214144] netlink_rcv_skb+0xeb/0x120n[ 1.214150] netlink_unicast+0x1f9/0x320n[ 1.214153] netlink_sendmsg+0x346/0x3f0n[ 1.214157] __sock_sendmsg+0x86/0xb0n[ 1.214160] ____sys_sendmsg+0x1c8/0x220n[ 1.214164] ___sys_sendmsg+0x28f/0x2d0n[ 1.214179] __x64_sys_sendmsg+0xef/0x140n[ 1.214184] do_syscall_64+0xec/0x1d0n[ 1.214190] entry_SYSCALL_64_after_hwframe+0x77/0x7fn[ 1.214191] RIP: 0033:0x7f2d1b4a7e56nnDevice setup:nn netdevsim0 (down)n ^ ^n bond netdevsim1.100@netdevsim1 allmulticast=on (down)nnWhen we enslave the lower device (netdevsim0) which has a vlan wenpropagate vlan's allmuti/promisc flags during ndo_open. This causesn(re)locking on of the real_dev.nnPropagate allmulti/promisc on flags change not on the open. Therenis a slight semantics change that vlans that are down now propagatenthe flags but this seems unlikely to result in the real issues.nnReproducer:nn echo 0 1 > /sys/bus/netdevsim/new_devicenn dev_path=$(ls -d /sys/bus/netdevsim/devices/netdevsim0/net/*)n dev=$(echo $dev_path | rev | cut -d/ -f1 | rev)nn ip link set dev $dev name netdevsim0n ip link set dev netdevsim0 upnn ip link add link netdevsim0 name netdevsim0.100 type vlan id 100n ip link set dev netdevsim0.100 allmn---truncated---,CVE-2025-23163,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnext4: ignore xattrs past endnnOnce inside 'ext4_xattr_inode_dec_ref_all' we shouldnignore xattrs entries past the 'end' entry.nnThis fixes the following KASAN reported issue:nn==================================================================nBUG: KASAN: slab-use-after-free in ext4_xattr_inode_dec_ref_all+0xb8c/0xe90nRead of size 4 at addr ffff888012c120c4 by task repro/2065nnCPU: 1 UID: 0 PID: 2065 Comm: repro Not tainted 6.13.0-rc2+ #11nHardware name: QEMU Standard PC (Q35 + ICH9 2009) BIOS rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org 04/01/2014nCall Trace:n <TASK>n dump_stack_lvl+0x1fd/0x300n ? tcp_gro_dev_warn+0x260/0x260n ? _printk+0xc0/0x100n ? read_lock_is_recursive+0x10/0x10n ? irq_work_queue+0x72/0xf0n ? __virt_addr_valid+0x17b/0x4b0n print_address_description+0x78/0x390n print_report+0x107/0x1f0n ? __virt_addr_valid+0x17b/0x4b0n ? __virt_addr_valid+0x3ff/0x4b0n ? __phys_addr+0xb5/0x160n ? ext4_xattr_inode_dec_ref_all+0xb8c/0xe90n kasan_report+0xcc/0x100n ? ext4_xattr_inode_dec_ref_all+0xb8c/0xe90n ext4_xattr_inode_dec_ref_all+0xb8c/0xe90n ? ext4_xattr_delete_inode+0xd30/0xd30n ? __ext4_journal_ensure_credits+0x5f0/0x5f0n ? __ext4_journal_ensure_credits+0x2b/0x5f0n ? inode_update_timestamps+0x410/0x410n ext4_xattr_delete_inode+0xb64/0xd30n ? ext4_truncate+0xb70/0xdc0n ? ext4_expand_extra_isize_ea+0x1d20/0x1d20n ? __ext4_mark_inode_dirty+0x670/0x670n ? ext4_journal_check_start+0x16f/0x240n ? ext4_inode_is_fast_symlink+0x2f2/0x3a0n ext4_evict_inode+0xc8c/0xff0n ? ext4_inode_is_fast_symlink+0x3a0/0x3a0n ? do_raw_spin_unlock+0x53/0x8a0n ? ext4_inode_is_fast_symlink+0x3a0/0x3a0n evict+0x4ac/0x950n ? proc_nr_inodes+0x310/0x310n ? trace_ext4_drop_inode+0xa2/0x220n ? _raw_spin_unlock+0x1a/0x30n ? iput+0x4cb/0x7e0n do_unlinkat+0x495/0x7c0n ? try_break_deleg+0x120/0x120n ? 0xffffffff81000000n ? __check_object_size+0x15a/0x210n ? strncpy_from_user+0x13e/0x250n ? getname_flags+0x1dc/0x530n __x64_sys_unlinkat+0xc8/0xf0n do_syscall_64+0x65/0x110n entry_SYSCALL_64_after_hwframe+0x67/0x6fnRIP: 0033:0x434ffdnCode: 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 00 f3 0f 1e fa 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 8nRSP: 002b:00007ffc50fa7b28 EFLAGS: 00000246 ORIG_RAX: 0000000000000107nRAX: ffffffffffffffda RBX: 00007ffc50fa7e18 RCX: 0000000000434ffdnRDX: 0000000000000000 RSI: 0000000020000240 RDI: 0000000000000005nRBP: 00007ffc50fa7be0 R08: 0000000000000000 R09: 0000000000000000nR10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000001nR13: 00007ffc50fa7e08 R14: 00000000004bbf30 R15: 0000000000000001n </TASK>nnThe buggy address belongs to the object at ffff888012c12000n which belongs to the cache filp of size 360nThe buggy address is located 196 bytes inside ofn freed 360-byte region [ffff888012c12000 ffff888012c12168)nnThe buggy address belongs to the physical page:npage: refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x12c12nhead: order:1 mapcount:0 entire_mapcount:0 nr_pages_mapped:0 pincount:0nflags: 0x40(head|node=0|zone=0)npage_type: f5(slab)nraw: 0000000000000040 ffff888000ad7640 ffffea0000497a00 dead000000000004nraw: 0000000000000000 0000000000100010 00000001f5000000 0000000000000000nhead: 0000000000000040 ffff888000ad7640 ffffea0000497a00 dead000000000004nhead: 0000000000000000 0000000000100010 00000001f5000000 0000000000000000nhead: 0000000000000001 ffffea00004b0481 ffffffffffffffff 0000000000000000nhead: 0000000000000002 0000000000000000 00000000ffffffff 0000000000000000npage dumped because: kasan: bad access detectednnMemory state around the buggy address:n ffff888012c11f80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00n ffff888012c12000: fa fb fb fb fb fb fb fb fb fb fb fb fb fb fb fbn> ffff888012c12080: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fbn ^n ffff888012c12100: fb fb fb fb fb fb fb fb fb fb fb fb fb fc fc fcn ffff888012c12180: fc fc fc fc fc fc fc fc fcn---truncated---,CVE-2025-37738,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnf2fs: fix to avoid out-of-bounds access in f2fs_truncate_inode_blocks()nnsyzbot reports an UBSAN issue as below:nn------------[ cut here ]------------nUBSAN: array-index-out-of-bounds in fs/f2fs/node.h:381:10nindex 18446744073709550692 is out of range for type '__le32[5]' (aka 'unsigned int[5]')nCPU: 0 UID: 0 PID: 5318 Comm: syz.0.0 Not tainted 6.14.0-rc3-syzkaller-00060-g6537cfb395f3 #0nCall Trace:n <TASK>n __dump_stack lib/dump_stack.c:94 [inline]n dump_stack_lvl+0x241/0x360 lib/dump_stack.c:120n ubsan_epilogue lib/ubsan.c:231 [inline]n __ubsan_handle_out_of_bounds+0x121/0x150 lib/ubsan.c:429n get_nid fs/f2fs/node.h:381 [inline]n f2fs_truncate_inode_blocks+0xa5e/0xf60 fs/f2fs/node.c:1181n f2fs_do_truncate_blocks+0x782/0x1030 fs/f2fs/file.c:808n f2fs_truncate_blocks+0x10d/0x300 fs/f2fs/file.c:836n f2fs_truncate+0x417/0x720 fs/f2fs/file.c:886n f2fs_file_write_iter+0x1bdb/0x2550 fs/f2fs/file.c:5093n aio_write+0x56b/0x7c0 fs/aio.c:1633n io_submit_one+0x8a7/0x18a0 fs/aio.c:2052n __do_sys_io_submit fs/aio.c:2111 [inline]n __se_sys_io_submit+0x171/0x2e0 fs/aio.c:2081n do_syscall_x64 arch/x86/entry/common.c:52 [inline]n do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83n entry_SYSCALL_64_after_hwframe+0x77/0x7fnRIP: 0033:0x7f238798cde9nnindex 18446744073709550692 (decimal unsigned long long)n= 0xfffffffffffffc64 (hexadecimal unsigned long long)n= -924 (decimal long long)nnIn f2fs_truncate_inode_blocks() UBSAN detects that get_nid() tries tonaccess .i_nid[-924] it means both offset[0] and level should zero.nnThe possible case should be in f2fs_do_truncate_blocks() we try tontruncate inode size to zero however dn.ofs_in_node is zero andndn.node_page is not an inode page so it fails to truncate inode pagenand then pass zeroed free_from to f2fs_truncate_inode_blocks() resultnin this issue.nntif (dn.ofs_in_node || IS_INODE(dn.node_page)) {nttf2fs_truncate_data_blocks_range(&dn count);nttfree_from += count;nt}nnI guess the reason why dn.node_page is not an inode page could be: therenare multiple nat entries share the same node block address once the nodenblock address was reused f2fs_get_node_page() may load a non-inode block.nnLet's add a sanity check for such condition to avoid out-of-bounds accessnissue.,CVE-2025-37739,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnjfs: add sanity check for agwidth in dbMountnnThe width in dmapctl of the AG is zero it trigger a divide error whenncalculating the control page level in dbAllocAG.nnTo avoid this issue add a check for agwidth in dbAllocAG.,CVE-2025-37740,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnjfs: Prevent copying of nlink with value 0 from disk inodennsyzbot report a deadlock in diFree. [1]nnWhen calling ioctl$LOOP_SET_STATUS64 the offset value passed in is 4nwhich does not match the mounted loop device causing the mapping of thenmounted loop device to be invalidated.nnWhen creating the directory and creating the inode of iag in diReadSpecial()nread the page of fixed disk inode (AIT) in raw mode in read_metapage() thenmetapage data it returns is corrupted which causes the nlink value of 0 to benassigned to the iag inode when executing copy_from_dinode() which ultimatelyncauses a deadlock when entering diFree().nnTo avoid this first check the nlink value of dinode before setting iag inode.nn[1]nWARNING: possible recursive locking detectedn6.12.0-rc7-syzkaller-00212-g4a5df3796467 #0 Not taintedn--------------------------------------------nsyz-executor301/5309 is trying to acquire lock:nffff888044548920 (&(imap->im_aglock[index])){+.+.}-{3:3} at: diFree+0x37c/0x2fb0 fs/jfs/jfs_imap.c:889nnbut task is already holding lock:nffff888044548920 (&(imap->im_aglock[index])){+.+.}-{3:3} at: diAlloc+0x1b6/0x1630nnother info that might help us debug this:n Possible unsafe locking scenario:nn CPU0n ----n lock(&(imap->im_aglock[index]));n lock(&(imap->im_aglock[index]));nn output.log scan_tyk_dockerimages.sh vulnerabilities.csv DEADLOCK ***nn May be due to missing lock nesting notationnn5 locks held by syz-executor301/5309:n #0: ffff8880422a4420 (sb_writers#9){.+.+}-{0:0} at: mnt_want_write+0x3f/0x90 fs/namespace.c:515n #1: ffff88804755b390 (&type->i_mutex_dir_key#6/1){+.+.}-{3:3} at: inode_lock_nested include/linux/fs.h:850 [inline]n #1: ffff88804755b390 (&type->i_mutex_dir_key#6/1){+.+.}-{3:3} at: filename_create+0x260/0x540 fs/namei.c:4026n #2: ffff888044548920 (&(imap->im_aglock[index])){+.+.}-{3:3} at: diAlloc+0x1b6/0x1630n #3: ffff888044548890 (&imap->im_freelock){+.+.}-{3:3} at: diNewIAG fs/jfs/jfs_imap.c:2460 [inline]n #3: ffff888044548890 (&imap->im_freelock){+.+.}-{3:3} at: diAllocExt fs/jfs/jfs_imap.c:1905 [inline]n #3: ffff888044548890 (&imap->im_freelock){+.+.}-{3:3} at: diAllocAG+0x4b7/0x1e50 fs/jfs/jfs_imap.c:1669n #4: ffff88804755a618 (&jfs_ip->rdwrlock/1){++++}-{3:3} at: diNewIAG fs/jfs/jfs_imap.c:2477 [inline]n #4: ffff88804755a618 (&jfs_ip->rdwrlock/1){++++}-{3:3} at: diAllocExt fs/jfs/jfs_imap.c:1905 [inline]n #4: ffff88804755a618 (&jfs_ip->rdwrlock/1){++++}-{3:3} at: diAllocAG+0x869/0x1e50 fs/jfs/jfs_imap.c:1669nnstack backtrace:nCPU: 0 UID: 0 PID: 5309 Comm: syz-executor301 Not tainted 6.12.0-rc7-syzkaller-00212-g4a5df3796467 #0nHardware name: QEMU Standard PC (Q35 + ICH9 2009) BIOS 1.16.3-debian-1.16.3-2~bpo12+1 04/01/2014nCall Trace:n <TASK>n __dump_stack lib/dump_stack.c:94 [inline]n dump_stack_lvl+0x241/0x360 lib/dump_stack.c:120n print_deadlock_bug+0x483/0x620 kernel/locking/lockdep.c:3037n check_deadlock kernel/locking/lockdep.c:3089 [inline]n validate_chain+0x15e2/0x5920 kernel/locking/lockdep.c:3891n __lock_acquire+0x1384/0x2050 kernel/locking/lockdep.c:5202n lock_acquire+0x1ed/0x550 kernel/locking/lockdep.c:5825n __mutex_lock_common kernel/locking/mutex.c:608 [inline]n __mutex_lock+0x136/0xd70 kernel/locking/mutex.c:752n diFree+0x37c/0x2fb0 fs/jfs/jfs_imap.c:889n jfs_evict_inode+0x32d/0x440 fs/jfs/inode.c:156n evict+0x4e8/0x9b0 fs/inode.c:725n diFreeSpecial fs/jfs/jfs_imap.c:552 [inline]n duplicateIXtree+0x3c6/0x550 fs/jfs/jfs_imap.c:3022n diNewIAG fs/jfs/jfs_imap.c:2597 [inline]n diAllocExt fs/jfs/jfs_imap.c:1905 [inline]n diAllocAG+0x17dc/0x1e50 fs/jfs/jfs_imap.c:1669n diAlloc+0x1d2/0x1630 fs/jfs/jfs_imap.c:1590n ialloc+0x8f/0x900 fs/jfs/jfs_inode.c:56n jfs_mkdir+0x1c5/0xba0 fs/jfs/namei.c:225n vfs_mkdir+0x2f9/0x4f0 fs/namei.c:4257n do_mkdirat+0x264/0x3a0 fs/namei.c:4280n __do_sys_mkdirat fs/namei.c:4295 [inline]n __se_sys_mkdirat fs/namei.c:4293 [inline]n __x64_sys_mkdirat+0x87/0xa0 fs/namei.c:4293n do_syscall_x64 arch/x86/enn---truncated---,CVE-2025-37741,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnjfs: Fix uninit-value access of imap allocated in the diMount() functionnnsyzbot reports that hex_dump_to_buffer is using uninit-value:nn=====================================================nBUG: KMSAN: uninit-value in hex_dump_to_buffer+0x888/0x1100 lib/hexdump.c:171nhex_dump_to_buffer+0x888/0x1100 lib/hexdump.c:171nprint_hex_dump+0x13d/0x3e0 lib/hexdump.c:276ndiFree+0x5ba/0x4350 fs/jfs/jfs_imap.c:876njfs_evict_inode+0x510/0x550 fs/jfs/inode.c:156nevict+0x723/0xd10 fs/inode.c:796niput_final fs/inode.c:1946 [inline]niput+0x97b/0xdb0 fs/inode.c:1972ntxUpdateMap+0xf3e/0x1150 fs/jfs/jfs_txnmgr.c:2367ntxLazyCommit fs/jfs/jfs_txnmgr.c:2664 [inline]njfs_lazycommit+0x627/0x11d0 fs/jfs/jfs_txnmgr.c:2733nkthread+0x6b9/0xef0 kernel/kthread.c:464nret_from_fork+0x6d/0x90 arch/x86/kernel/process.c:148nret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244nnUninit was created at:nslab_post_alloc_hook mm/slub.c:4121 [inline]nslab_alloc_node mm/slub.c:4164 [inline]n__kmalloc_cache_noprof+0x8e3/0xdf0 mm/slub.c:4320nkmalloc_noprof include/linux/slab.h:901 [inline]ndiMount+0x61/0x7f0 fs/jfs/jfs_imap.c:105njfs_mount+0xa8e/0x11d0 fs/jfs/jfs_mount.c:176njfs_fill_super+0xa47/0x17c0 fs/jfs/super.c:523nget_tree_bdev_flags+0x6ec/0x910 fs/super.c:1636nget_tree_bdev+0x37/0x50 fs/super.c:1659njfs_get_tree+0x34/0x40 fs/jfs/super.c:635nvfs_get_tree+0xb1/0x5a0 fs/super.c:1814ndo_new_mount+0x71f/0x15e0 fs/namespace.c:3560npath_mount+0x742/0x1f10 fs/namespace.c:3887ndo_mount fs/namespace.c:3900 [inline]n__do_sys_mount fs/namespace.c:4111 [inline]n__se_sys_mount+0x71f/0x800 fs/namespace.c:4088n__x64_sys_mount+0xe4/0x150 fs/namespace.c:4088nx64_sys_call+0x39bf/0x3c30 arch/x86/include/generated/asm/syscalls_64.h:166ndo_syscall_x64 arch/x86/entry/common.c:52 [inline]ndo_syscall_64+0xcd/0x1e0 arch/x86/entry/common.c:83nentry_SYSCALL_64_after_hwframe+0x77/0x7fn=====================================================nnThe reason is that imap is not properly initialized after memorynallocation. It will cause the snprintf() function to write uninitializedndata into linebuf within hex_dump_to_buffer().nnFix this by using kzalloc instead of kmalloc to clear its content at thenbeginning in diMount().,CVE-2025-37742,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnPM: hibernate: Avoid deadlock in hibernate_compressor_param_set()nnsyzbot reported a deadlock in lock_system_sleep() (see below).nnThe write operation to /sys/module/hibernate/parameters/compressornconflicts with the registration of ieee80211 device resulting in a deadlocknwhen attempting to acquire system_transition_mutex under param_lock.nnTo avoid this deadlock change hibernate_compressor_param_set() to usenmutex_trylock() for attempting to acquire system_transition_mutex andnreturn -EBUSY when it fails.nnTask flags need not be saved or adjusted before callingnmutex_trylock(&system_transition_mutex) because the caller is not goingnto end up waiting for this mutex and if it runs concurrently with systemnsuspend in progress it will be frozen properly when it returns to usernspace.nnsyzbot report:nnsyz-executor895/5833 is trying to acquire lock:nffffffff8e0828c8 (system_transition_mutex){+.+.}-{4:4} at: lock_system_sleep+0x87/0xa0 kernel/power/main.c:56nnbut task is already holding lock:nffffffff8e07dc68 (param_lock){+.+.}-{4:4} at: kernel_param_lock kernel/params.c:607 [inline]nffffffff8e07dc68 (param_lock){+.+.}-{4:4} at: param_attr_store+0xe6/0x300 kernel/params.c:586nnwhich lock already depends on the new lock.nnthe existing dependency chain (in reverse order) is:nn-> #3 (param_lock){+.+.}-{4:4}:n __mutex_lock_common kernel/locking/mutex.c:585 [inline]n __mutex_lock+0x19b/0xb10 kernel/locking/mutex.c:730n ieee80211_rate_control_ops_get net/mac80211/rate.c:220 [inline]n rate_control_alloc net/mac80211/rate.c:266 [inline]n ieee80211_init_rate_ctrl_alg+0x18d/0x6b0 net/mac80211/rate.c:1015n ieee80211_register_hw+0x20cd/0x4060 net/mac80211/main.c:1531n mac80211_hwsim_new_radio+0x304e/0x54e0 drivers/net/wireless/virtual/mac80211_hwsim.c:5558n init_mac80211_hwsim+0x432/0x8c0 drivers/net/wireless/virtual/mac80211_hwsim.c:6910n do_one_initcall+0x128/0x700 init/main.c:1257n do_initcall_level init/main.c:1319 [inline]n do_initcalls init/main.c:1335 [inline]n do_basic_setup init/main.c:1354 [inline]n kernel_init_freeable+0x5c7/0x900 init/main.c:1568n kernel_init+0x1c/0x2b0 init/main.c:1457n ret_from_fork+0x45/0x80 arch/x86/kernel/process.c:148n ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244nn-> #2 (rtnl_mutex){+.+.}-{4:4}:n __mutex_lock_common kernel/locking/mutex.c:585 [inline]n __mutex_lock+0x19b/0xb10 kernel/locking/mutex.c:730n wg_pm_notification drivers/net/wireguard/device.c:80 [inline]n wg_pm_notification+0x49/0x180 drivers/net/wireguard/device.c:64n notifier_call_chain+0xb7/0x410 kernel/notifier.c:85n notifier_call_chain_robust kernel/notifier.c:120 [inline]n blocking_notifier_call_chain_robust kernel/notifier.c:345 [inline]n blocking_notifier_call_chain_robust+0xc9/0x170 kernel/notifier.c:333n pm_notifier_call_chain_robust+0x27/0x60 kernel/power/main.c:102n snapshot_open+0x189/0x2b0 kernel/power/user.c:77n misc_open+0x35a/0x420 drivers/char/misc.c:179n chrdev_open+0x237/0x6a0 fs/char_dev.c:414n do_dentry_open+0x735/0x1c40 fs/open.c:956n vfs_open+0x82/0x3f0 fs/open.c:1086n do_open fs/namei.c:3830 [inline]n path_openat+0x1e88/0x2d80 fs/namei.c:3989n do_filp_open+0x20c/0x470 fs/namei.c:4016n do_sys_openat2+0x17a/0x1e0 fs/open.c:1428n do_sys_open fs/open.c:1443 [inline]n __do_sys_openat fs/open.c:1459 [inline]n __se_sys_openat fs/open.c:1454 [inline]n __x64_sys_openat+0x175/0x210 fs/open.c:1454n do_syscall_x64 arch/x86/entry/common.c:52 [inline]n do_syscall_64+0xcd/0x250 arch/x86/entry/common.c:83n entry_SYSCALL_64_after_hwframe+0x77/0x7fnn-> #1 ((pm_chain_head).rwsem){++++}-{4:4}:n down_read+0x9a/0x330 kernel/locking/rwsem.c:1524n blocking_notifier_call_chain_robust kernen---truncated---,CVE-2025-37745,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet: ppp: Add bound checking for skb data on ppp_sync_txmungnnEnsure we have enough data in linear buffer from skb before accessingninitial bytes. This prevents potential out-of-bounds accessesnwhen processing short packets.nnWhen ppp_sync_txmung receives an incoming package with an emptynpayload:n(remote) gef p *(struct pppoe_hdr *) (skb->head + skb->network_header)n$18 = {nttype = 0x1ntver = 0x1ntcode = 0x0ntsid = 0x2n length = 0x0nttag = 0xffff8880371cdb96n}nnfrom the skb struct (trimmed)n tail = 0x16n end = 0x140n head = 0xffff88803346f400 4n data = 0xffff88803346f416 :377n truesize = 0x380n len = 0x0n data_len = 0x0n mac_len = 0xen hdr_len = 0x0nnit is not safe to access data[2].nn[pabeni@redhat.com: fixed subj typo],CVE-2025-37749,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet: tls: explicitly disallow disconnectnnsyzbot discovered that it can disconnect a TLS socket and thennrun into all sort of unexpected corner cases. I have a vaguenrecollection of Eric pointing this out to us a long time ago.nSupporting disconnect is really hard for one thing if offloadnis enabled we'd need to wait for all packets to be _acked_.nDisconnect is not commonly used disallow it.nnThe immediate problem syzbot run into is the warning in the strpnbut that's just the easiest bug to trigger:nn WARNING: CPU: 0 PID: 5834 at net/tls/tls_strp.c:486 tls_strp_msg_load+0x72e/0xa80 net/tls/tls_strp.c:486n RIP: 0010:tls_strp_msg_load+0x72e/0xa80 net/tls/tls_strp.c:486n Call Trace:n <TASK>n tls_rx_rec_wait+0x280/0xa60 net/tls/tls_sw.c:1363n tls_sw_recvmsg+0x85c/0x1c30 net/tls/tls_sw.c:2043n inet6_recvmsg+0x2c9/0x730 net/ipv6/af_inet6.c:678n sock_recvmsg_nosec net/socket.c:1023 [inline]n sock_recvmsg+0x109/0x280 net/socket.c:1045n __sys_recvfrom+0x202/0x380 net/socket.c:2237,CVE-2025-37756,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nntipc: fix memory leak in tipc_link_xmitnnIn case the backlog transmit queue for system-importance messages is overloadedntipc_link_xmit() returns -ENOBUFS but the skb list is not purged. This leads tonmemory leak and failure when a skb is allocated.nnThis commit fixes this issue by purging the skb list before tipc_link_xmit()nreturns.,CVE-2025-37757,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnata: pata_pxa: Fix potential NULL pointer dereference in pxa_ata_probe()nndevm_ioremap() returns NULL on error. Currently pxa_ata_probe() doesnnot check for this case which can result in a NULL pointer dereference.nnAdd NULL check after devm_ioremap() to prevent this issue.,CVE-2025-37758,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/nouveau: prime: fix ttm_bo_delayed_delete oopsnnFix an oops in ttm_bo_delayed_delete which results from dererencing andangling pointer:nnOops: general protection fault probably for non-canonical address 0x6b6b6b6b6b6b6b7b: 0000 [#1] PREEMPT SMPnCPU: 4 UID: 0 PID: 1082 Comm: kworker/u65:2 Not tainted 6.14.0-rc4-00267-g505460b44513-dirty #216nHardware name: LENOVO 82N6/LNVNB161216 BIOS GKCN65WW 01/16/2024nWorkqueue: ttm ttm_bo_delayed_delete [ttm]nRIP: 0010:dma_resv_iter_first_unlocked+0x55/0x290nCode: 31 f6 48 c7 c7 00 2b fa aa e8 97 bd 52 ff e8 a2 c1 53 00 5a 85 c0 74 48 e9 88 01 00 00 4c 89 63 20 4d 85 e4 0f 84 30 01 00 00 <41> 8b 44 24 10 c6 43 2c 01 48 89 df 89 43 28 e8 97 fd ff ff 4c 8bnRSP: 0018:ffffbf9383473d60 EFLAGS: 00010202nRAX: 0000000000000001 RBX: ffffbf9383473d88 RCX: 0000000000000000nRDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000000nRBP: ffffbf9383473d78 R08: 0000000000000000 R09: 0000000000000000nR10: 0000000000000000 R11: 0000000000000000 R12: 6b6b6b6b6b6b6b6bnR13: ffffa003bbf78580 R14: ffffa003a6728040 R15: 00000000000383ccnFS: 0000000000000000(0000) GS:ffffa00991c00000(0000) knlGS:0000000000000000nCS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033nCR2: 0000758348024dd0 CR3: 000000012c259000 CR4: 0000000000f50ef0nPKRU: 55555554nCall Trace:n <TASK>n ? __die_body.cold+0x19/0x26n ? die_addr+0x3d/0x70n ? exc_general_protection+0x159/0x460n ? asm_exc_general_protection+0x27/0x30n ? dma_resv_iter_first_unlocked+0x55/0x290n dma_resv_wait_timeout+0x56/0x100n ttm_bo_delayed_delete+0x69/0xb0 [ttm]n process_one_work+0x217/0x5c0n worker_thread+0x1c8/0x3d0n ? apply_wqattrs_cleanup.part.0+0xc0/0xc0n kthread+0x10b/0x240n ? kthreads_online_cpu+0x140/0x140n ret_from_fork+0x40/0x70n ? kthreads_online_cpu+0x140/0x140n ret_from_fork_asm+0x11/0x20n </TASK>nnThe cause of this is:nn- drm_prime_gem_destroy calls dma_buf_put(dma_buf) which releases then reference to the shared dma_buf. The reference count is 0 so then dma_buf is destroyed which in turn decrements the correspondingn amdgpu_bo reference count to 0 and the amdgpu_bo is destroyed -n calling drm_gem_object_release then dma_resv_fini (which destroys then reservation object) then finally freeing the amdgpu_bo.nn- nouveau_bo obj->bo.base.resv is now a dangling pointer to the memoryn formerly allocated to the amdgpu_bo.nn- nouveau_gem_object_del calls ttm_bo_put(&nvbo->bo) which callsn ttm_bo_release which schedules ttm_bo_delayed_delete.nn- ttm_bo_delayed_delete runs and dereferences the dangling resv pointern resulting in a general protection fault.nnFix this by moving the drm_prime_gem_destroy call fromnnouveau_gem_object_del to nouveau_bo_del_ttm. This ensures that it willnbe run after ttm_bo_delayed_delete.,CVE-2025-37765,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/pm: Prevent division by zeronnThe user can set any speed value.nIf speed is greater than UINT_MAX/8 division by zero is possible.nnFound by Linux Verification Center (linuxtesting.org) with SVACE.,CVE-2025-37766,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/pm: Prevent division by zeronnThe user can set any speed value.nIf speed is greater than UINT_MAX/8 division by zero is possible.nnFound by Linux Verification Center (linuxtesting.org) with SVACE.,CVE-2025-37768,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/pm: Prevent division by zeronnThe user can set any speed value.nIf speed is greater than UINT_MAX/8 division by zero is possible.nnFound by Linux Verification Center (linuxtesting.org) with SVACE.,CVE-2025-37770,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnvirtiofs: add filesystem context source name checknnIn certain scenarios for example during fuzz testing the sourcenname may be NULL which could lead to a kernel panic. Therefore annextra check for the source name should be added.,CVE-2025-37773,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnisofs: Prevent the use of too small fidnnsyzbot reported a slab-out-of-bounds Read in isofs_fh_to_parent. [1]nnThe handle_bytes value passed in by the reproducing program is equal to 12.nIn handle_to_path() only 12 bytes of memory are allocated for the structurenfile_handle->f_handle member which causes an out-of-bounds access whennaccessing the member parent_block of the structure isofs_fid in isofsnbecause accessing parent_block requires at least 16 bytes of f_handle.nHere fh_len is used to indirectly confirm that the value of handle_bytesnis greater than 3 before accessing parent_block.nn[1]nBUG: KASAN: slab-out-of-bounds in isofs_fh_to_parent+0x1b8/0x210 fs/isofs/export.c:183nRead of size 4 at addr ffff0000cc030d94 by task syz-executor215/6466nCPU: 1 UID: 0 PID: 6466 Comm: syz-executor215 Not tainted 6.14.0-rc7-syzkaller-ga2392f333575 #0nHardware name: Google Google Compute Engine/Google Compute Engine BIOS Google 02/12/2025nCall trace:n show_stack+0x2c/0x3c arch/arm64/kernel/stacktrace.c:466 (C)n __dump_stack lib/dump_stack.c:94 [inline]n dump_stack_lvl+0xe4/0x150 lib/dump_stack.c:120n print_address_description mm/kasan/report.c:408 [inline]n print_report+0x198/0x550 mm/kasan/report.c:521n kasan_report+0xd8/0x138 mm/kasan/report.c:634n __asan_report_load4_noabort+0x20/0x2c mm/kasan/report_generic.c:380n isofs_fh_to_parent+0x1b8/0x210 fs/isofs/export.c:183n exportfs_decode_fh_raw+0x2dc/0x608 fs/exportfs/expfs.c:523n do_handle_to_path+0xa0/0x198 fs/fhandle.c:257n handle_to_path fs/fhandle.c:385 [inline]n do_handle_open+0x8cc/0xb8c fs/fhandle.c:403n __do_sys_open_by_handle_at fs/fhandle.c:443 [inline]n __se_sys_open_by_handle_at fs/fhandle.c:434 [inline]n __arm64_sys_open_by_handle_at+0x80/0x94 fs/fhandle.c:434n __invoke_syscall arch/arm64/kernel/syscall.c:35 [inline]n invoke_syscall+0x98/0x2b8 arch/arm64/kernel/syscall.c:49n el0_svc_common+0x130/0x23c arch/arm64/kernel/syscall.c:132n do_el0_svc+0x48/0x58 arch/arm64/kernel/syscall.c:151n el0_svc+0x54/0x168 arch/arm64/kernel/entry-common.c:744n el0t_64_sync_handler+0x84/0x108 arch/arm64/kernel/entry-common.c:762n el0t_64_sync+0x198/0x19c arch/arm64/kernel/entry.S:600nnAllocated by task 6466:n kasan_save_stack mm/kasan/common.c:47 [inline]n kasan_save_track+0x40/0x78 mm/kasan/common.c:68n kasan_save_alloc_info+0x40/0x50 mm/kasan/generic.c:562n poison_kmalloc_redzone mm/kasan/common.c:377 [inline]n __kasan_kmalloc+0xac/0xc4 mm/kasan/common.c:394n kasan_kmalloc include/linux/kasan.h:260 [inline]n __do_kmalloc_node mm/slub.c:4294 [inline]n __kmalloc_noprof+0x32c/0x54c mm/slub.c:4306n kmalloc_noprof include/linux/slab.h:905 [inline]n handle_to_path fs/fhandle.c:357 [inline]n do_handle_open+0x5a4/0xb8c fs/fhandle.c:403n __do_sys_open_by_handle_at fs/fhandle.c:443 [inline]n __se_sys_open_by_handle_at fs/fhandle.c:434 [inline]n __arm64_sys_open_by_handle_at+0x80/0x94 fs/fhandle.c:434n __invoke_syscall arch/arm64/kernel/syscall.c:35 [inline]n invoke_syscall+0x98/0x2b8 arch/arm64/kernel/syscall.c:49n el0_svc_common+0x130/0x23c arch/arm64/kernel/syscall.c:132n do_el0_svc+0x48/0x58 arch/arm64/kernel/syscall.c:151n el0_svc+0x54/0x168 arch/arm64/kernel/entry-common.c:744n el0t_64_sync_handler+0x84/0x108 arch/arm64/kernel/entry-common.c:762n el0t_64_sync+0x198/0x19c arch/arm64/kernel/entry.S:600,CVE-2025-37780,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nni2c: cros-ec-tunnel: defer probe if parent EC is not presentnnWhen i2c-cros-ec-tunnel and the EC driver are built-in the EC parentndevice will not be found leading to NULL pointer dereference.nnThat can also be reproduced by unbinding the controller driver and thennloading i2c-cros-ec-tunnel module (or binding the device).nn[ 271.991245] BUG: kernel NULL pointer dereference address: 0000000000000058n[ 271.998215] #PF: supervisor read access in kernel moden[ 272.003351] #PF: error_code(0x0000) - not-present pagen[ 272.008485] PGD 0 P4D 0n[ 272.011022] Oops: Oops: 0000 [#1] SMP NOPTIn[ 272.015207] CPU: 0 UID: 0 PID: 3859 Comm: insmod Tainted: G S 6.15.0-rc1-00004-g44722359ed83 #30 PREEMPT(full) 3c7fb39a552e7d949de2ad921a7d6588d3a4fdc5n[ 272.030312] Tainted: [S]=CPU_OUT_OF_SPECn[ 272.034233] Hardware name: HP Berknip/Berknip BIOS Google_Berknip.13434.356.0 05/17/2021n[ 272.042400] RIP: 0010:ec_i2c_probe+0x2b/0x1c0 [i2c_cros_ec_tunnel]n[ 272.048577] Code: 1f 44 00 00 41 57 41 56 41 55 41 54 53 48 83 ec 10 65 48 8b 05 06 a0 6c e7 48 89 44 24 08 4c 8d 7f 10 48 8b 47 50 4c 8b 60 78 <49> 83 7c 24 58 00 0f 84 2f 01 00 00 48 89 fb be 30 06 00 00 4c 9n[ 272.067317] RSP: 0018:ffffa32082a03940 EFLAGS: 00010282n[ 272.072541] RAX: ffff969580b6a810 RBX: ffff969580b68c10 RCX: 0000000000000000n[ 272.079672] RDX: 0000000000000000 RSI: 0000000000000282 RDI: ffff969580b68c00n[ 272.086804] RBP: 00000000fffffdfb R08: 0000000000000000 R09: 0000000000000000n[ 272.093936] R10: 0000000000000000 R11: ffffffffc0600000 R12: 0000000000000000n[ 272.101067] R13: ffffffffa666fbb8 R14: ffffffffc05b5528 R15: ffff969580b68c10n[ 272.108198] FS: 00007b930906fc40(0000) GS:ffff969603149000(0000) knlGS:0000000000000000n[ 272.116282] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033n[ 272.122024] CR2: 0000000000000058 CR3: 000000012631c000 CR4: 00000000003506f0n[ 272.129155] Call Trace:n[ 272.131606] <TASK>n[ 272.133709] ? acpi_dev_pm_attach+0xdd/0x110n[ 272.137985] platform_probe+0x69/0xa0n[ 272.141652] really_probe+0x152/0x310n[ 272.145318] __driver_probe_device+0x77/0x110n[ 272.149678] driver_probe_device+0x1e/0x190n[ 272.153864] __driver_attach+0x10b/0x1e0n[ 272.157790] ? driver_attach+0x20/0x20n[ 272.161542] bus_for_each_dev+0x107/0x150n[ 272.165553] bus_add_driver+0x15d/0x270n[ 272.169392] driver_register+0x65/0x110n[ 272.173232] ? cleanup_module+0xa80/0xa80 [i2c_cros_ec_tunnel 3a00532f3f4af4a9eade753f86b0f8dd4e4e5698]n[ 272.182617] do_one_initcall+0x110/0x350n[ 272.186543] ? security_kernfs_init_security+0x49/0xd0n[ 272.191682] ? __kernfs_new_node+0x1b9/0x240n[ 272.195954] ? security_kernfs_init_security+0x49/0xd0n[ 272.201093] ? __kernfs_new_node+0x1b9/0x240n[ 272.205365] ? kernfs_link_sibling+0x105/0x130n[ 272.209810] ? kernfs_next_descendant_post+0x1c/0xa0n[ 272.214773] ? kernfs_activate+0x57/0x70n[ 272.218699] ? kernfs_add_one+0x118/0x160n[ 272.222710] ? __kernfs_create_file+0x71/0xa0n[ 272.227069] ? sysfs_add_bin_file_mode_ns+0xd6/0x110n[ 272.232033] ? internal_create_group+0x453/0x4a0n[ 272.236651] ? __vunmap_range_noflush+0x214/0x2d0n[ 272.241355] ? __free_frozen_pages+0x1dc/0x420n[ 272.245799] ? free_vmap_area_noflush+0x10a/0x1c0n[ 272.250505] ? load_module+0x1509/0x16f0n[ 272.254431] do_init_module+0x60/0x230n[ 272.258181] __se_sys_finit_module+0x27a/0x370n[ 272.262627] do_syscall_64+0x6a/0xf0n[ 272.266206] ? do_syscall_64+0x76/0xf0n[ 272.269956] ? irqentry_exit_to_user_mode+0x79/0x90n[ 272.274836] entry_SYSCALL_64_after_hwframe+0x55/0x5dn[ 272.279887] RIP: 0033:0x7b9309168d39n[ 272.283466] Code: 5b 41 5c 5d c3 66 2e 0f 1f 84 00 00 00 00 00 66 90 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 8b 0d af 40 0c 00 f7 d8 64 89 01 8n[ 272.302210] RSP: 002b:00007fff50f1a288 EFLAGS: 00000246 ORIG_RAX: 000n---truncated---,CVE-2025-37781,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnhfs/hfsplus: fix slab-out-of-bounds in hfs_bnode_read_keynnSyzbot reported an issue in hfs subsystem:nnBUG: KASAN: slab-out-of-bounds in memcpy_from_page include/linux/highmem.h:423 [inline]nBUG: KASAN: slab-out-of-bounds in hfs_bnode_read fs/hfs/bnode.c:35 [inline]nBUG: KASAN: slab-out-of-bounds in hfs_bnode_read_key+0x314/0x450 fs/hfs/bnode.c:70nWrite of size 94 at addr ffff8880123cd100 by task syz-executor237/5102nnCall Trace:n <TASK>n __dump_stack lib/dump_stack.c:94 [inline]n dump_stack_lvl+0x241/0x360 lib/dump_stack.c:120n print_address_description mm/kasan/report.c:377 [inline]n print_report+0x169/0x550 mm/kasan/report.c:488n kasan_report+0x143/0x180 mm/kasan/report.c:601n kasan_check_range+0x282/0x290 mm/kasan/generic.c:189n __asan_memcpy+0x40/0x70 mm/kasan/shadow.c:106n memcpy_from_page include/linux/highmem.h:423 [inline]n hfs_bnode_read fs/hfs/bnode.c:35 [inline]n hfs_bnode_read_key+0x314/0x450 fs/hfs/bnode.c:70n hfs_brec_insert+0x7f3/0xbd0 fs/hfs/brec.c:159n hfs_cat_create+0x41d/0xa50 fs/hfs/catalog.c:118n hfs_mkdir+0x6c/0xe0 fs/hfs/dir.c:232n vfs_mkdir+0x2f9/0x4f0 fs/namei.c:4257n do_mkdirat+0x264/0x3a0 fs/namei.c:4280n __do_sys_mkdir fs/namei.c:4300 [inline]n __se_sys_mkdir fs/namei.c:4298 [inline]n __x64_sys_mkdir+0x6c/0x80 fs/namei.c:4298n do_syscall_x64 arch/x86/entry/common.c:52 [inline]n do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83n entry_SYSCALL_64_after_hwframe+0x77/0x7fnRIP: 0033:0x7fbdd6057a99nnAdd a check for key length in hfs_bnode_read_key to preventnout-of-bounds memory access. If the key length is invalid thenkey buffer is cleared improving stability and reliability.,CVE-2025-37782,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnext4: fix OOB read when checking dotdot dirnnMounting a corrupted filesystem with directory which contains '.' dirnentry with rec_len == block size results in out-of-bounds read (laternon when the corrupted directory is removed).nnext4_empty_dir() assumes every ext4 directory contains at least '.'nand '..' as directory entries in the first data block. It first loadsnthe '.' dir entry performs sanity checks by calling ext4_check_dir_entry()nand then uses its rec_len member to compute the location of '..' dirnentry (in ext4_next_entry). It assumes the '..' dir entry fits into thensame data block.nnIf the rec_len of '.' is precisely one block (4KB) it slips through thensanity checks (it is considered the last directory entry in the datanblock) and leaves struct ext4_dir_entry_2 *de point exactly past thenmemory slot allocated to the data block. The following call tonext4_check_dir_entry() on new value of de then dereferences this pointernwhich results in out-of-bounds mem access.nnFix this by extending __ext4_check_dir_entry() to check for '.' dirnentries that reach the end of data block. Make sure to ignore the phonyndir entries for checksum (by checking name_len for non-zero).nnNote: This is reported by KASAN as use-after-free in case anothernstructure was recently freed from the slot past the bound but it isnreally an OOB read.nnThis issue was found by syzkaller tool.nnCall Trace:n[ 38.594108] BUG: KASAN: slab-use-after-free in __ext4_check_dir_entry+0x67e/0x710n[ 38.594649] Read of size 2 at addr ffff88802b41a004 by task syz-executor/5375n[ 38.595158]n[ 38.595288] CPU: 0 UID: 0 PID: 5375 Comm: syz-executor Not tainted 6.14.0-rc7 #1n[ 38.595298] Hardware name: QEMU Standard PC (i440FX + PIIX 1996) BIOS rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org 04/01/2014n[ 38.595304] Call Trace:n[ 38.595308] <TASK>n[ 38.595311] dump_stack_lvl+0xa7/0xd0n[ 38.595325] print_address_description.constprop.0+0x2c/0x3f0n[ 38.595339] ? __ext4_check_dir_entry+0x67e/0x710n[ 38.595349] print_report+0xaa/0x250n[ 38.595359] ? __ext4_check_dir_entry+0x67e/0x710n[ 38.595368] ? kasan_addr_to_slab+0x9/0x90n[ 38.595378] kasan_report+0xab/0xe0n[ 38.595389] ? __ext4_check_dir_entry+0x67e/0x710n[ 38.595400] __ext4_check_dir_entry+0x67e/0x710n[ 38.595410] ext4_empty_dir+0x465/0x990n[ 38.595421] ? __pfx_ext4_empty_dir+0x10/0x10n[ 38.595432] ext4_rmdir.part.0+0x29a/0xd10n[ 38.595441] ? __dquot_initialize+0x2a7/0xbf0n[ 38.595455] ? __pfx_ext4_rmdir.part.0+0x10/0x10n[ 38.595464] ? __pfx___dquot_initialize+0x10/0x10n[ 38.595478] ? down_write+0xdb/0x140n[ 38.595487] ? __pfx_down_write+0x10/0x10n[ 38.595497] ext4_rmdir+0xee/0x140n[ 38.595506] vfs_rmdir+0x209/0x670n[ 38.595517] ? lookup_one_qstr_excl+0x3b/0x190n[ 38.595529] do_rmdir+0x363/0x3c0n[ 38.595537] ? __pfx_do_rmdir+0x10/0x10n[ 38.595544] ? strncpy_from_user+0x1ff/0x2e0n[ 38.595561] __x64_sys_unlinkat+0xf0/0x130n[ 38.595570] do_syscall_64+0x5b/0x180n[ 38.595583] entry_SYSCALL_64_after_hwframe+0x76/0x7e,CVE-2025-37785,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet: dsa: free routing table on probe failurennIf complete = true in dsa_tree_setup() it means that we are the lastnswitch of the tree which is successfully probing and we should bensetting up all switches from our probe path.nnAfter complete becomes true dsa_tree_setup_cpu_ports() or anynsubsequent function may fail. If that happens the entire tree setup isnin limbo: the first N-1 switches have successfully finished probingn(doing nothing but having allocated persistent memory in the tree'sndst->ports and maybe dst->rtable) and switch N failed to probe endingnthe tree setup process before anything is tangible from the user's PoV.nnIf switch N fails to probe its memory (ports) will be freed and removednfrom dst->ports. However the dst->rtable elements pointing to its portsnas created by dsa_link_touch() will remain there and will lead tonuse-after-free if dereferenced.nnIf dsa_tree_setup_switches() returns -EPROBE_DEFER which is entirelynpossible because that is where ds->ops->setup() is we get a kasannreport like this:nn==================================================================nBUG: KASAN: slab-use-after-free in mv88e6xxx_setup_upstream_port+0x240/0x568nRead of size 8 at addr ffff000004f56020 by task kworker/u8:3/42nnCall trace:n __asan_report_load8_noabort+0x20/0x30n mv88e6xxx_setup_upstream_port+0x240/0x568n mv88e6xxx_setup+0xebc/0x1eb0n dsa_register_switch+0x1af4/0x2ae0n mv88e6xxx_register_switch+0x1b8/0x2a8n mv88e6xxx_probe+0xc4c/0xf60n mdio_probe+0x78/0xb8n really_probe+0x2b8/0x5a8n __driver_probe_device+0x164/0x298n driver_probe_device+0x78/0x258n __device_attach_driver+0x274/0x350nnAllocated by task 42:n __kasan_kmalloc+0x84/0xa0n __kmalloc_cache_noprof+0x298/0x490n dsa_switch_touch_ports+0x174/0x3d8n dsa_register_switch+0x800/0x2ae0n mv88e6xxx_register_switch+0x1b8/0x2a8n mv88e6xxx_probe+0xc4c/0xf60n mdio_probe+0x78/0xb8n really_probe+0x2b8/0x5a8n __driver_probe_device+0x164/0x298n driver_probe_device+0x78/0x258n __device_attach_driver+0x274/0x350nnFreed by task 42:n __kasan_slab_free+0x48/0x68n kfree+0x138/0x418n dsa_register_switch+0x2694/0x2ae0n mv88e6xxx_register_switch+0x1b8/0x2a8n mv88e6xxx_probe+0xc4c/0xf60n mdio_probe+0x78/0xb8n really_probe+0x2b8/0x5a8n __driver_probe_device+0x164/0x298n driver_probe_device+0x78/0x258n __device_attach_driver+0x274/0x350nnThe simplest way to fix the bug is to delete the routing table in itsnentirety. dsa_tree_setup_routing_table() has no problem in regeneratingnit even if we deleted links between ports other than those of switch Nnbecause dsa_link_touch() first checks whether the port pair alreadynexists in dst->rtable allocating if not.nnThe deletion of the routing table in its entirety already exists inndsa_tree_teardown() so refactor that into a function that can also bencalled from the tree setup error path.nnIn my analysis of the commit to blame it is the one which addedndsa_link elements to dst->rtable. Prior to that each switch had its ownnds->rtable which is freed when the switch fails to probe. But the treenis potentially persistent memory.,CVE-2025-37786,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nncxgb4: fix memory leak in cxgb4_init_ethtool_filters() error pathnnIn the for loop used to allocate the loc_array and bmap for each port anmemory leak is possible when the allocation for loc_array succeedsnbut the allocation for bmap fails. This is because when the control flowngoes to the label free_eth_finfo only the allocations starting fromn(i-1)th iteration are freed.nnFix that by freeing the loc_array in the bmap allocation error path.,CVE-2025-37788,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet: openvswitch: fix nested key length validation in the set() actionnnIt's not safe to access nla_len(ovs_key) if the data is smaller thannthe netlink header. Check that the attribute is OK first.,CVE-2025-37789,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnBluetooth: btrtl: Prevent potential NULL dereferencennThe btrtl_initialize() function checks that rtl_load_file() eithernhad an error or it loaded a zero length file. However if it loadedna zero length file then the error code is not set correctly. Itnresults in an error pointer vs NULL bug followed by a NULL pointerndereference. This was detected by Smatch:nndrivers/bluetooth/btrtl.c:592 btrtl_initialize() warn: passing zero to 'ERR_PTR',CVE-2025-37792,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnwifi: mac80211: Purge vif txq in ieee80211_do_stop()nnAfter ieee80211_do_stop() SKB from vif's txq could still be processed.nIndeed another concurrent vif schedule_and_wake_txq call could causenthose packets to be dequeued (see ieee80211_handle_wake_tx_queue())nwithout checking the sdata current state.nnBecause vif.drv_priv is now cleared in this function this could lead tondriver crash.nnFor example in ath12k ahvif is store in vif.drv_priv. Thus ifnath12k_mac_op_tx() is called after ieee80211_do_stop() ahvif->ah can benNULL leading the ath12k_warn(ahvif->ah...) call in this function tontrigger the NULL deref below.nn Unable to handle kernel paging request at virtual address dfffffc000000001n KASAN: null-ptr-deref in range [0x0000000000000008-0x000000000000000f]n batman_adv: bat0: Interface deactivated: brbh1337n Mem abort info:n ESR = 0x0000000096000004n EC = 0x25: DABT (current EL) IL = 32 bitsn SET = 0 FnV = 0n EA = 0 S1PTW = 0n FSC = 0x04: level 0 translation faultn Data abort info:n ISV = 0 ISS = 0x00000004 ISS2 = 0x00000000n CM = 0 WnR = 0 TnD = 0 TagAccess = 0n GCS = 0 Overlay = 0 DirtyBit = 0 Xs = 0n [dfffffc000000001] address between user and kernel address rangesn Internal error: Oops: 0000000096000004 [#1] SMPn CPU: 1 UID: 0 PID: 978 Comm: lbd Not tainted 6.13.0-g633f875b8f1e #114n Hardware name: HW (DT)n pstate: 10000005 (nzcV daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)n pc : ath12k_mac_op_tx+0x6cc/0x29b8 [ath12k]n lr : ath12k_mac_op_tx+0x174/0x29b8 [ath12k]n sp : ffffffc086ace450n x29: ffffffc086ace450 x28: 0000000000000000 x27: 1ffffff810d59ca4n x26: ffffff801d05f7c0 x25: 0000000000000000 x24: 000000004000001en x23: ffffff8009ce4926 x22: ffffff801f9c0800 x21: ffffff801d05f7f0n x20: ffffff8034a19f40 x19: 0000000000000000 x18: ffffff801f9c0958n x17: ffffff800bc0a504 x16: dfffffc000000000 x15: ffffffc086ace4f8n x14: ffffff801d05f83c x13: 0000000000000000 x12: ffffffb003a0bf03n x11: 0000000000000000 x10: ffffffb003a0bf02 x9 : ffffff8034a19f40n x8 : ffffff801d05f818 x7 : 1ffffff0069433dc x6 : ffffff8034a19ee0n x5 : ffffff801d05f7f0 x4 : 0000000000000000 x3 : 0000000000000001n x2 : 0000000000000000 x1 : dfffffc000000000 x0 : 0000000000000008n Call trace:n ath12k_mac_op_tx+0x6cc/0x29b8 [ath12k] (P)n ieee80211_handle_wake_tx_queue+0x16c/0x260n ieee80211_queue_skb+0xeec/0x1d20n ieee80211_tx+0x200/0x2c8n ieee80211_xmit+0x22c/0x338n __ieee80211_subif_start_xmit+0x7e8/0xc60n ieee80211_subif_start_xmit+0xc4/0xee0n __ieee80211_subif_start_xmit_8023.isra.0+0x854/0x17a0n ieee80211_subif_start_xmit_8023+0x124/0x488n dev_hard_start_xmit+0x160/0x5a8n __dev_queue_xmit+0x6f8/0x3120n br_dev_queue_push_xmit+0x120/0x4a8n __br_forward+0xe4/0x2b0n deliver_clone+0x5c/0xd0n br_flood+0x398/0x580n br_dev_xmit+0x454/0x9f8n dev_hard_start_xmit+0x160/0x5a8n __dev_queue_xmit+0x6f8/0x3120n ip6_finish_output2+0xc28/0x1b60n __ip6_finish_output+0x38c/0x638n ip6_output+0x1b4/0x338n ip6_local_out+0x7c/0xa8n ip6_send_skb+0x7c/0x1b0n ip6_push_pending_frames+0x94/0xd0n rawv6_sendmsg+0x1a98/0x2898n inet_sendmsg+0x94/0xe0n __sys_sendto+0x1e4/0x308n __arm64_sys_sendto+0xc4/0x140n do_el0_svc+0x110/0x280n el0_svc+0x20/0x60n el0t_64_sync_handler+0x104/0x138n el0t_64_sync+0x154/0x158nnTo avoid that empty vif's txq at ieee80211_do_stop() so no packet couldnbe dequeued after ieee80211_do_stop() (new packets cannot be queuednbecause SDATA_STATE_RUNNING is cleared at this point).,CVE-2025-37794,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnwifi: at76c50x: fix use after free access in at76_disconnectnnThe memory pointed to by priv is freed at the end of at76_delete_devicenfunction (using ieee80211_free_hw). But the code then accesses the udevnfield of the freed object to put the USB device. This may also lead to anmemory leak of the usb device. Fix this by using udev from interface.,CVE-2025-37796,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet_sched: hfsc: Fix a UAF vulnerability in class handlingnnThis patch fixes a Use-After-Free vulnerability in the HFSC qdisc classnhandling. The issue occurs due to a time-of-check/time-of-use conditionnin hfsc_change_class() when working with certain child qdiscs like netemnor codel.nnThe vulnerability works as follows:n1. hfsc_change_class() checks if a class has packets (q.qlen != 0)n2. It then calls qdisc_peek_len() which for certain qdiscs (e.g.n codel netem) might drop packets and empty the queuen3. The code continues assuming the queue is still non-empty addingn the class to vttreen4. This breaks HFSC scheduler assumptions that only non-empty classesn are in vttreen5. Later when the class is destroyed this can lead to a Use-After-FreennThe fix adds a second queue length check after qdisc_peek_len() to verifynthe queue wasn't emptied.,CVE-2025-37797,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nncodel: remove sch->q.qlen check before qdisc_tree_reduce_backlog()nnAfter making all ->qlen_notify() callbacks idempotent now it is safe tonremove the check of qlen!=0 from both fq_codel_dequeue() andncodel_qdisc_dequeue().,CVE-2025-37798,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnvmxnet3: Fix malformed packet sizing in vmxnet3_process_xdpnnvmxnet3 driver's XDP handling is buggy for packet sizes using ring0 (thatnis packet sizes between 128 - 3k bytes).nnWe noticed MTU-related connectivity issues with Cilium's service load-nbalancing in case of vmxnet3 as NIC underneath. A simple curl to a HTTPnbackend service where the XDP LB was doing IPIP encap led to overly largenpacket sizes but only for *some* of the packets (e.g. HTTP GET request)nwhile others (e.g. the prior TCP 3WHS) looked completely fine on the wire.nnIn fact the pcap recording on the backend node actually revealed that thennode with the XDP LB was leaking uninitialized kernel data onto the wirenfor the affected packets for example while the packets should have beenn152 bytes their actual size was 1482 bytes so the remainder after 152 bytesnwas padded with whatever other data was in that page at the time (e.g. wensaw user/payload data from prior processed packets).nnWe only noticed this through an MTU issue e.g. when the XDP LB node andnthe backend node both had the same MTU (e.g. 1500) then the curl requestngot dropped on the backend node's NIC given the packet was too large evennthough the IPIP-encapped packet normally would never even come close tonthe MTU limit. Lowering the MTU on the XDP LB (e.g. 1480) allowed to letnthe curl request succeed (which also indicates that the kernel ignored thenpadding and thus the issue wasn't very user-visible).nnCommit e127ce7699c1 (vmxnet3: Fix missing reserved tailroom) was too eagernto also switch xdp_prepare_buff() from rcd->len to rbi->len. It really needsnto stick to rcd->len which is the actual packet length from the descriptor.nThe latter we also feed into vmxnet3_process_xdp_small() by the way andnit indicates the correct length needed to initialize the xdp->{datadata_end}nparts. For e127ce7699c1 (vmxnet3: Fix missing reserved tailroom) thenrelevant part was adapting xdp_init_buff() to address the warning given thenxdp_data_hard_end() depends on xdp->frame_sz. With that fixed traffic onnthe wire looks good again.,CVE-2025-37799,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndriver core: fix potential NULL pointer dereference in dev_uevent()nnIf userspace reads uevent device attribute at the same time as anothernthreads unbinds the device from its driver change to dev->driver from anvalid pointer to NULL may result in crash. Fix this by using READ_ONCE()nwhen fetching the pointer and take bus' drivers klist lock to make surendriver instance will not disappear while we access it.nnUse WRITE_ONCE() when setting the driver pointer to ensure there is nontearing.,CVE-2025-37800,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnspi: spi-imx: Add check for spi_imx_setupxfer()nnAdd check for the return value of spi_imx_setupxfer().nspi_imx->rx and spi_imx->tx function pointer can be NULL whennspi_imx_setupxfer() return error and make NULL pointer dereference.nn Unable to handle kernel NULL pointer dereference at virtual address 0000000000000000n Call trace:n 0x0n spi_imx_pio_transfer+0x50/0xd8n spi_imx_transfer_one+0x18c/0x858n spi_transfer_one_message+0x43c/0x790n __spi_pump_transfer_message+0x238/0x5d4n __spi_sync+0x2b0/0x454n spi_write_then_read+0x11c/0x200,CVE-2025-37801,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnksmbd: fix WARNING do not call blocking ops when !TASK_RUNNINGnnwait_event_timeout() will set the state of the currentntask to TASK_UNINTERRUPTIBLE before doing the condition check. Thisnmeans that ksmbd_durable_scavenger_alive() will try to acquire the mutexnwhile already in a sleeping state. The scheduler warns us by givingnthe following warning:nndo not call blocking ops when !TASK_RUNNING; state=2 set atn [<0000000061515a6f>] prepare_to_wait_event+0x9f/0x6c0nWARNING: CPU: 2 PID: 4147 at kernel/sched/core.c:10099 __might_sleep+0x12f/0x160nnmutex lock is not needed in ksmbd_durable_scavenger_alive().,CVE-2025-37802,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnudmabuf: fix a buf size overflow issue during udmabuf creationnnby casting size_limit_mb to u64 when calculate pglimit.,CVE-2025-37803,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnio_uring: always do atomic put from iowqnnio_uring always switches requests to atomic refcounting for iowqnexecution before there is any parallilism by setting REQ_F_REFCOUNTnand the flag is not cleared until the request completes. That should benfine as long as the compiler doesn't make up a non existing value fornthe flags however KCSAN still complains when the request owner changesnoter flag bits:nnBUG: KCSAN: data-race in io_req_task_cancel / io_wq_free_workn...nread to 0xffff888117207448 of 8 bytes by task 3871 on cpu 0:n req_ref_put_and_test io_uring/refs.h:22 [inline]nnSkip REQ_F_REFCOUNT checks for iowq we know it's set.,CVE-2025-37804,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnsound/virtio: Fix cancel_sync warnings on uninitialized work_structsnnBetty reported hitting the following warning:nn[ 8.709131][ T221] WARNING: CPU: 2 PID: 221 at kernel/workqueue.c:4182n...n[ 8.713282][ T221] Call trace:n[ 8.713365][ T221] __flush_work+0x8d0/0x914n[ 8.713468][ T221] __cancel_work_sync+0xac/0xfcn[ 8.713570][ T221] cancel_work_sync+0x24/0x34n[ 8.713667][ T221] virtsnd_remove+0xa8/0xf8 [virtio_snd ab15f34d0dd772f6d11327e08a81d46dc9c36276]n[ 8.713868][ T221] virtsnd_probe+0x48c/0x664 [virtio_snd ab15f34d0dd772f6d11327e08a81d46dc9c36276]n[ 8.714035][ T221] virtio_dev_probe+0x28c/0x390n[ 8.714139][ T221] really_probe+0x1bc/0x4c8n...nnIt seems we're hitting the error path in virtsnd_probe() whichntriggers a virtsnd_remove() which iterates over the substreamsncalling cancel_work_sync() on the elapsed_period work_struct.nnLooking at the code from earlier in:nvirtsnd_probe()->virtsnd_build_devs()->virtsnd_pcm_parse_cfg()nnWe set snd->nsubstreams allocate the snd->substreams and ifnwe then hit an error on the info allocation or something innvirtsnd_ctl_query_info() fails we will exit without havingninitialized the elapsed_period work_struct.nnWhen that error path unwinds we then call virtsnd_remove()nwhich as long as the substreams array is allocated will iteratenthrough calling cancel_work_sync() on the uninitialized worknstruct hitting this warning.nnTakashi Iwai suggested this fix which initializes the substreamsnstructure right after allocation so that if we hit the errornpaths we avoid trying to cleanup uninitialized data.nnNote: I have not yet managed to reproduce the issue myself sonthis patch has had limited testing.nnFeedback or thoughts would be appreciated!,CVE-2025-37805,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnfs/ntfs3: Keep write operations atomicnnsyzbot reported a NULL pointer dereference in __generic_file_write_iter. [1]nnBefore the write operation is completed the user executes ioctl[2] to clearnthe compress flag of the file which causes the is_compressed() judgment tonreturn 0 further causing the program to enter the wrong process and call thenwrong ops ntfs_aops_cmpr which triggers the null pointer dereference ofnwrite_begin.nnUse inode lock to synchronize ioctl and write to avoid this case.nn[1]nUnable to handle kernel NULL pointer dereference at virtual address 0000000000000000nMem abort info:n ESR = 0x0000000086000006n EC = 0x21: IABT (current EL) IL = 32 bitsn SET = 0 FnV = 0n EA = 0 S1PTW = 0n FSC = 0x06: level 2 translation faultnuser pgtable: 4k pages 48-bit VAs pgdp=000000011896d000n[0000000000000000] pgd=0800000118b44403 p4d=0800000118b44403 pud=0800000117517403 pmd=0000000000000000nInternal error: Oops: 0000000086000006 [#1] PREEMPT SMPnModules linked in:nCPU: 0 UID: 0 PID: 6427 Comm: syz-executor347 Not tainted 6.13.0-rc3-syzkaller-g573067a5a685 #0nHardware name: Google Google Compute Engine/Google Compute Engine BIOS Google 09/13/2024npstate: 80400005 (Nzcv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)npc : 0x0nlr : generic_perform_write+0x29c/0x868 mm/filemap.c:4055nsp : ffff80009d4978a0nx29: ffff80009d4979c0 x28: dfff800000000000 x27: ffff80009d497bc8nx26: 0000000000000000 x25: ffff80009d497960 x24: ffff80008ba71c68nx23: 0000000000000000 x22: ffff0000c655dac0 x21: 0000000000001000nx20: 000000000000000c x19: 1ffff00013a92f2c x18: ffff0000e183aa1cnx17: 0004060000000014 x16: ffff800083275834 x15: 0000000000000001nx14: 0000000000000000 x13: 0000000000000001 x12: ffff0000c655dac0nx11: 0000000000ff0100 x10: 0000000000ff0100 x9 : 0000000000000000nx8 : 0000000000000000 x7 : 0000000000000000 x6 : 0000000000000000nx5 : ffff80009d497980 x4 : ffff80009d497960 x3 : 0000000000001000nx2 : 0000000000000000 x1 : ffff0000e183a928 x0 : ffff0000d60b0fc0nCall trace:n 0x0 (P)n __generic_file_write_iter+0xfc/0x204 mm/filemap.c:4156n ntfs_file_write_iter+0x54c/0x630 fs/ntfs3/file.c:1267n new_sync_write fs/read_write.c:586 [inline]n vfs_write+0x920/0xcf4 fs/read_write.c:679n ksys_write+0x15c/0x26c fs/read_write.c:731n __do_sys_write fs/read_write.c:742 [inline]n __se_sys_write fs/read_write.c:739 [inline]n __arm64_sys_write+0x7c/0x90 fs/read_write.c:739n __invoke_syscall arch/arm64/kernel/syscall.c:35 [inline]n invoke_syscall+0x98/0x2b8 arch/arm64/kernel/syscall.c:49n el0_svc_common+0x130/0x23c arch/arm64/kernel/syscall.c:132n do_el0_svc+0x48/0x58 arch/arm64/kernel/syscall.c:151n el0_svc+0x54/0x168 arch/arm64/kernel/entry-common.c:744n el0t_64_sync_handler+0x84/0x108 arch/arm64/kernel/entry-common.c:762nn[2]nioctl$FS_IOC_SETFLAGS(r0 0x40086602 &(0x7f00000000c0)=0x20),CVE-2025-37806,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbpf: Fix kmemleak warning for percpu hashmapnnVlad Poenaru reported the following kmemleak issue:nn unreferenced object 0x606fd7c44ac8 (size 32):n backtrace (crc 0):n pcpu_alloc_noprof+0x730/0xeb0n bpf_map_alloc_percpu+0x69/0xc0n prealloc_init+0x9d/0x1b0n htab_map_alloc+0x363/0x510n map_create+0x215/0x3a0n __sys_bpf+0x16b/0x3e0n __x64_sys_bpf+0x18/0x20n do_syscall_64+0x7b/0x150n entry_SYSCALL_64_after_hwframe+0x4b/0x53nnFurther investigation shows the reason is due to not 8-byte alignednstore of percpu pointer in htab_elem_set_ptr():n *(void __percpu **)(l->key + key_size) = pptr;nnNote that the whole htab_elem alignment is 8 (for x86_64). If the key_sizenis 4 that means pptr is stored in a location which is 4 byte aligned butnnot 8 byte aligned. In mm/kmemleak.c scan_block() scans the memory basednon 8 byte stride so it won't detect above pptr hence reporting the memorynleak.nnIn htab_map_alloc() we already havenn htab->elem_size = sizeof(struct htab_elem) +n round_up(htab->map.key_size 8);n if (percpu)n htab->elem_size += sizeof(void *);n elsen htab->elem_size += round_up(htab->map.value_size 8);nnSo storing pptr with 8-byte alignment won't cause any problem and can fixnkmemleak too.nnThe issue can be reproduced with bpf selftest as well:n 1. Enable CONFIG_DEBUG_KMEMLEAK confign 2. Add a getchar() before skel destroy in test_hash_map() in prog_tests/for_each.c.n The purpose is to keep map available so kmemleak can be detected.n 3. run './test_progs -t for_each/hash_map &' and a kmemleak should be reported.,CVE-2025-37807,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nncrypto: null - Use spin lock instead of mutexnnAs the null algorithm may be freed in softirq context throughnaf_alg use spin locks instead of mutexes to protect the defaultnnull algorithm.,CVE-2025-37808,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnusb: dwc3: gadget: check that event count does not exceed event buffer lengthnnThe event count is read from register DWC3_GEVNTCOUNT.nThere is a check for the count being zero but not for exceeding thenevent buffer length.nCheck that event count does not exceed event buffer lengthnavoiding an out-of-bounds access when memcpy'ing the event.nCrash log:nUnable to handle kernel paging request at virtual address ffffffc0129be000npc : __memcpy+0x114/0x180nlr : dwc3_check_event_buf+0xec/0x348nx3 : 0000000000000030 x2 : 000000000000dfc4nx1 : ffffffc0129be000 x0 : ffffff87aad60080nCall trace:n__memcpy+0x114/0x180ndwc3_interrupt+0x24/0x34,CVE-2025-37810,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnusb: cdns3: Fix deadlock when using NCM gadgetnnThe cdns3 driver has the same NCM deadlock as fixed in cdnsp by commitn58f2fcb3a845 (usb: cdnsp: Fix deadlock issue during using NCM gadget).nnUnder PREEMPT_RT the deadlock can be readily triggered by heavy networkntraffic for example using iperf --bidir over NCM ethernet link.nnThe deadlock occurs because the threaded interrupt handler getsnpreempted by a softirq but both are protected by the same spinlock.nPrevent deadlock by disabling softirq during threaded irq handler.,CVE-2025-37812,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnmcb: fix a double free bug in chameleon_parse_gdd()nnIn chameleon_parse_gdd() if mcb_device_register() fails 'mdev'nwould be released in mcb_device_register() via put_device().nThus goto 'err' label and free 'mdev' again causes a double free.nJust return if mcb_device_register() fails.,CVE-2025-37817,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnLoongArch: Return NULL from huge_pte_offset() for invalid PMDnnLoongArch's huge_pte_offset() currently returns a pointer to a PMD slotneven if the underlying entry points to invalid_pte_table (indicating nonmapping). Callers like smaps_hugetlb_range() fetch this invalid entrynvalue (the address of invalid_pte_table) via this pointer.nnThe generic is_swap_pte() check then incorrectly identifies this addressnas a swap entry on LoongArch because it satisfies the !pte_present()n&& !pte_none() conditions. This misinterpretation combined with ancoincidental match by is_migration_entry() on the address bits leads tonkernel crashes in pfn_swap_entry_to_page().nnFix this at the architecture level by modifying huge_pte_offset() toncheck the PMD entry's content using pmd_none() before returning. If thenentry is invalid (i.e. it points to invalid_pte_table) return NULLninstead of the pointer to the slot.,CVE-2025-37818,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnirqchip/gic-v2m: Prevent use after free of gicv2m_get_fwnode()nnWith ACPI in place gicv2m_get_fwnode() is registered with the pcinsubsystem as pci_msi_get_fwnode_cb() which may get invoked at runtimenduring a PCI host bridge probe. But the call back is wrongly marked asn__init causing it to be freed while being registered with the PCInsubsystem and could trigger:nn Unable to handle kernel paging request at virtual address ffff8000816c0400n gicv2m_get_fwnode+0x0/0x58 (P)n pci_set_bus_msi_domain+0x74/0x88n pci_register_host_bridge+0x194/0x548nnThis is easily reproducible on a Juno board with ACPI boot.nnRetain the function for later use.,CVE-2025-37819,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnxen-netfront: handle NULL returned by xdp_convert_buff_to_frame()nnThe function xdp_convert_buff_to_frame() may return NULL if it failsnto correctly convert the XDP buffer into an XDP frame due to memorynconstraints internal errors or invalid data. Failing to check for NULLnmay lead to a NULL pointer dereference if the result is used later innprocessing potentially causing crashes data corruption or undefinednbehavior.nnOn XDP redirect failure the associated page must be released explicitlynif it was previously retained via get_page(). Failing to do so may resultnin a memory leak as the pages reference count is not decremented.,CVE-2025-37820,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet_sched: hfsc: Fix a potential UAF in hfsc_dequeue() toonnSimilarly to the previous patch we need to safe guard hfsc_dequeue()ntoo. But for this one we don't have a reliable reproducer.,CVE-2025-37823,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nntipc: fix NULL pointer dereference in tipc_mon_reinit_self()nnsyzbot reported:nntipc: Node number set to 1055423674nOops: general protection fault probably for non-canonical address 0xdffffc0000000000: 0000 [#1] SMP KASAN NOPTInKASAN: null-ptr-deref in range [0x0000000000000000-0x0000000000000007]nCPU: 3 UID: 0 PID: 6017 Comm: kworker/3:5 Not tainted 6.15.0-rc1-syzkaller-00246-g900241a5cc15 #0 PREEMPT(full)nHardware name: QEMU Standard PC (Q35 + ICH9 2009) BIOS 1.16.3-debian-1.16.3-2~bpo12+1 04/01/2014nWorkqueue: events tipc_net_finalize_worknRIP: 0010:tipc_mon_reinit_self+0x11c/0x210 net/tipc/monitor.c:719n...nRSP: 0018:ffffc9000356fb68 EFLAGS: 00010246nRAX: 0000000000000000 RBX: 0000000000000000 RCX: 000000003ee87cbanRDX: 0000000000000000 RSI: ffffffff8dbc56a7 RDI: ffff88804c2cc010nRBP: dffffc0000000000 R08: 0000000000000001 R09: 0000000000000000nR10: 0000000000000001 R11: 0000000000000000 R12: 0000000000000007nR13: fffffbfff2111097 R14: ffff88804ead8000 R15: ffff88804ead9010nFS: 0000000000000000(0000) GS:ffff888097ab9000(0000) knlGS:0000000000000000nCS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033nCR2: 00000000f720eb00 CR3: 000000000e182000 CR4: 0000000000352ef0nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400nCall Trace:n <TASK>n tipc_net_finalize+0x10b/0x180 net/tipc/net.c:140n process_one_work+0x9cc/0x1b70 kernel/workqueue.c:3238n process_scheduled_works kernel/workqueue.c:3319 [inline]n worker_thread+0x6c8/0xf10 kernel/workqueue.c:3400n kthread+0x3c2/0x780 kernel/kthread.c:464n ret_from_fork+0x45/0x80 arch/x86/kernel/process.c:153n ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:245n </TASK>n...nRIP: 0010:tipc_mon_reinit_self+0x11c/0x210 net/tipc/monitor.c:719n...nRSP: 0018:ffffc9000356fb68 EFLAGS: 00010246nRAX: 0000000000000000 RBX: 0000000000000000 RCX: 000000003ee87cbanRDX: 0000000000000000 RSI: ffffffff8dbc56a7 RDI: ffff88804c2cc010nRBP: dffffc0000000000 R08: 0000000000000001 R09: 0000000000000000nR10: 0000000000000001 R11: 0000000000000000 R12: 0000000000000007nR13: fffffbfff2111097 R14: ffff88804ead8000 R15: ffff88804ead9010nFS: 0000000000000000(0000) GS:ffff888097ab9000(0000) knlGS:0000000000000000nCS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033nCR2: 00000000f720eb00 CR3: 000000000e182000 CR4: 0000000000352ef0nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400nnThere is a racing condition between workqueue created when enablingnbearer and another thread created when disabling bearer right afternthat as follow:nnenabling_bearer | disabling_bearern--------------- | ----------------ntipc_disc_timeout() |n{ | bearer_disable()n ... | {n schedule_work(&tn->work); | tipc_mon_delete()n ... | {n} | ...n | write_lock_bh(&mon->lock);n | mon->self = NULL;n | write_unlock_bh(&mon->lock);n | ...n | }ntipc_net_finalize_work() | }n{ |n ... |n tipc_net_finalize() |n { |n ... |n tipc_mon_reinit_self() |n { |n ... |n write_lock_bh(&mon->lock); |n mon->self->addr = tipc_own_addr(net); |n write_unlock_bh(&mon->lock); |n ... n---truncated---,CVE-2025-37824,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nncpufreq: scpi: Fix null-ptr-deref in scpi_cpufreq_get_rate()nncpufreq_cpu_get_raw() can return NULL when the target CPU is not presentnin the policy->cpus mask. scpi_cpufreq_get_rate() does not check fornthis case which results in a NULL pointer dereference.,CVE-2025-37829,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nncpufreq: scmi: Fix null-ptr-deref in scmi_cpufreq_get_rate()nncpufreq_cpu_get_raw() can return NULL when the target CPU is not presentnin the policy->cpus mask. scmi_cpufreq_get_rate() does not check fornthis case which results in a NULL pointer dereference.nnAdd NULL check after cpufreq_cpu_get_raw() to prevent this issue.,CVE-2025-37830,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet/niu: Niu requires MSIX ENTRY_DATA fields touch before entry readsnnFix niu_try_msix() to not cause a fatal trap on sparc systems.nnSet PCI_DEV_FLAGS_MSIX_TOUCH_ENTRY_DATA_FIRST on the struct pci_dev tonwork around a bug in the hardware or firmware.nnFor each vector entry in the msix table niu chips will cause a fatalntrap if any registers in that entry are read before that entries'nENTRY_DATA register is written to. Testing indicates writes to othernregisters are not sufficient to prevent the fatal trap however the valuendoes not appear to matter. This only needs to happen once after power upnso simply rebooting into a kernel lacking this fix will NOT cause thentrap.nnNON-RESUMABLE ERROR: Reporting on cpu 64nNON-RESUMABLE ERROR: TPC [0x00000000005f6900] <msix_prepare_msi_desc+0x90/0xa0>nNON-RESUMABLE ERROR: RAW [4010000000000016:00000e37f93e32ff:0000000202000080:ffffffffffffffffnNON-RESUMABLE ERROR: 0000000800000000:0000000000000000:0000000000000000:0000000000000000]nNON-RESUMABLE ERROR: handle [0x4010000000000016] stick [0x00000e37f93e32ff]nNON-RESUMABLE ERROR: type [precise nonresumable]nNON-RESUMABLE ERROR: attrs [0x02000080] < ASI sp-faulted priv >nNON-RESUMABLE ERROR: raddr [0xffffffffffffffff]nNON-RESUMABLE ERROR: insn effective address [0x000000c50020000c]nNON-RESUMABLE ERROR: size [0x8]nNON-RESUMABLE ERROR: asi [0x00]nCPU: 64 UID: 0 PID: 745 Comm: kworker/64:1 Not tainted 6.11.5 #63nWorkqueue: events work_for_cpu_fnnTSTATE: 0000000011001602 TPC: 00000000005f6900 TNPC: 00000000005f6904 Y: 00000000 Not taintednTPC: <msix_prepare_msi_desc+0x90/0xa0>ng0: 00000000000002e9 g1: 000000000000000c g2: 000000c50020000c g3: 0000000000000100ng4: ffff8000470307c0 g5: ffff800fec5be000 g6: ffff800047a08000 g7: 0000000000000000no0: ffff800014feb000 o1: ffff800047a0b620 o2: 0000000000000011 o3: ffff800047a0b620no4: 0000000000000080 o5: 0000000000000011 sp: ffff800047a0ad51 ret_pc: 00000000005f7128nRPC: <__pci_enable_msix_range+0x3cc/0x460>nl0: 000000000000000d l1: 000000000000c01f l2: ffff800014feb0a8 l3: 0000000000000020nl4: 000000000000c000 l5: 0000000000000001 l6: 0000000020000000 l7: ffff800047a0b734ni0: ffff800014feb000 i1: ffff800047a0b730 i2: 0000000000000001 i3: 000000000000000dni4: 0000000000000000 i5: 0000000000000000 i6: ffff800047a0ae81 i7: 00000000101888b0nI7: <niu_try_msix.constprop.0+0xc0/0x130 [niu]>nCall Trace:n[<00000000101888b0>] niu_try_msix.constprop.0+0xc0/0x130 [niu]n[<000000001018f840>] niu_get_invariants+0x183c/0x207c [niu]n[<00000000101902fc>] niu_pci_init_one+0x27c/0x2fc [niu]n[<00000000005ef3e4>] local_pci_probe+0x28/0x74n[<0000000000469240>] work_for_cpu_fn+0x8/0x1cn[<000000000046b008>] process_scheduled_works+0x144/0x210n[<000000000046b518>] worker_thread+0x13c/0x1c0n[<00000000004710e0>] kthread+0xb8/0xc8n[<00000000004060c8>] ret_from_fork+0x1c/0x2cn[<0000000000000000>] 0x0nKernel panic - not syncing: Non-resumable error.,CVE-2025-37833,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnmm/vmscan: don't try to reclaim hwpoison folionnSyzkaller reports a bug as follows:nnInjecting memory failure for pfn 0x18b00e at process virtual address 0x20ffd000nMemory failure: 0x18b00e: dirty swapcache page still referenced by 2 usersnMemory failure: 0x18b00e: recovery action for dirty swapcache page: Failednpage: refcount:2 mapcount:0 mapping:0000000000000000 index:0x20ffd pfn:0x18b00enmemcg:ffff0000dd6d9000nanon flags: 0x5ffffe00482011(locked|dirty|arch_1|swapbacked|hwpoison|node=0|zone=2|lastcpupid=0xfffff)nraw: 005ffffe00482011 dead000000000100 dead000000000122 ffff0000e232a7c9nraw: 0000000000020ffd 0000000000000000 00000002ffffffff ffff0000dd6d9000npage dumped because: VM_BUG_ON_FOLIO(!folio_test_uptodate(folio))n------------[ cut here ]------------nkernel BUG at mm/swap_state.c:184!nInternal error: Oops - BUG: 00000000f2000800 [#1] SMPnModules linked in:nCPU: 0 PID: 60 Comm: kswapd0 Not tainted 6.6.0-gcb097e7de84e #3nHardware name: linuxdummy-virt (DT)npstate: 80400005 (Nzcv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)npc : add_to_swap+0xbc/0x158nlr : add_to_swap+0xbc/0x158nsp : ffff800087f37340nx29: ffff800087f37340 x28: fffffc00052c0380 x27: ffff800087f37780nx26: ffff800087f37490 x25: ffff800087f37c78 x24: ffff800087f377a0nx23: ffff800087f37c50 x22: 0000000000000000 x21: fffffc00052c03b4nx20: 0000000000000000 x19: fffffc00052c0380 x18: 0000000000000000nx17: 296f696c6f662865 x16: 7461646f7470755f x15: 747365745f6f696cnx14: 6f6621284f494c4f x13: 0000000000000001 x12: ffff600036d8b97bnx11: 1fffe00036d8b97a x10: ffff600036d8b97a x9 : dfff800000000000nx8 : 00009fffc9274686 x7 : ffff0001b6c5cbd3 x6 : 0000000000000001nx5 : ffff0000c25896c0 x4 : 0000000000000000 x3 : 0000000000000000nx2 : 0000000000000000 x1 : ffff0000c25896c0 x0 : 0000000000000000nCall trace:n add_to_swap+0xbc/0x158n shrink_folio_list+0x12ac/0x2648n shrink_inactive_list+0x318/0x948n shrink_lruvec+0x450/0x720n shrink_node_memcgs+0x280/0x4a8n shrink_node+0x128/0x978n balance_pgdat+0x4f0/0xb20n kswapd+0x228/0x438n kthread+0x214/0x230n ret_from_fork+0x10/0x20nnI can reproduce this issue with the following steps:nn1) When a dirty swapcache page is isolated by reclaim process and then page isn't locked inject memory failure for the page. n me_swapcache_dirty() clears uptodate flag and tries to delete from lrun but fails. Reclaim process will put the hwpoisoned page back to lru.nn2) The process that maps the hwpoisoned page exits the page is deletedn the page will never be freed and will be in the lru forever.nn3) If we trigger a reclaim again and tries to reclaim the pagen add_to_swap() will trigger VM_BUG_ON_FOLIO due to the uptodate flag isn cleared.nnTo fix it skip the hwpoisoned page in shrink_folio_list(). Besides thenhwpoison folio may not be unmapped by hwpoison_user_mappings() yet unmapnit in shrink_folio_list() otherwise the folio will fail to be unmaped bynhwpoison_user_mappings() since the folio isn't in lru list.,CVE-2025-37834,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnPCI: Fix reference leak in pci_register_host_bridge()nnIf device_register() fails call put_device() to give up the reference tonavoid a memory leak per the comment at device_register().nnFound by code review.nn[bhelgaas: squash Dan Carpenter's double free fix fromnhttps://lore.kernel.org/r/db806a6c-a91b-4e5a-a84b-6b7e01bdac85@stanley.mountain],CVE-2025-37836,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnHSI: ssi_protocol: Fix use after free vulnerability in ssi_protocol Driver Due to Race ConditionnnIn the ssi_protocol_probe() function &ssi->work is bound withnssip_xmit_work() In ssip_pn_setup() the ssip_pn_xmit() functionnwithin the ssip_pn_ops structure is capable of starting thenwork.nnIf we remove the module which will call ssi_protocol_remove()nto make a cleanup it will free ssi through kfree(ssi)nwhile the work mentioned above will be used. The sequencenof operations that may lead to a UAF bug is as follows:nnCPU0 CPU1nn | ssip_xmit_worknssi_protocol_remove |nkfree(ssi); |n | struct hsi_client *cl = ssi->cl;n | // use ssinnFix it by ensuring that the work is canceled before proceedingnwith the cleanup in ssi_protocol_remove().,CVE-2025-37838,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnjbd2: remove wrong sb->s_sequence checknnJournal emptiness is not determined by sb->s_sequence == 0 but rather bynsb->s_start == 0 (which is set a few lines above). Furthermore 0 is anvalid transaction ID so the check can spuriously trigger. Remove theninvalid WARN_ON.,CVE-2025-37839,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnmtd: rawnand: brcmnand: fix PM resume warningnnFixed warning on PM resume as shown below caused due to uninitializednstruct nand_operation that checks chip select field :nWARN_ON(op->cs >= nanddev_ntargets(&chip->base)nn[ 14.588522] ------------[ cut here ]------------n[ 14.588529] WARNING: CPU: 0 PID: 1392 at drivers/mtd/nand/raw/internals.h:139 nand_reset_op+0x1e0/0x1f8n[ 14.588553] Modules linked in: bdc udc_coren[ 14.588579] CPU: 0 UID: 0 PID: 1392 Comm: rtcwake Tainted: G W 6.14.0-rc4-g5394eea10651 #16n[ 14.588590] Tainted: [W]=WARNn[ 14.588593] Hardware name: Broadcom STB (Flattened Device Tree)n[ 14.588598] Call trace:n[ 14.588604] dump_backtrace from show_stack+0x18/0x1cn[ 14.588622] r7:00000009 r6:0000008b r5:60000153 r4:c0fa558cn[ 14.588625] show_stack from dump_stack_lvl+0x70/0x7cn[ 14.588639] dump_stack_lvl from dump_stack+0x18/0x1cn[ 14.588653] r5:c08d40b0 r4:c1003cb0n[ 14.588656] dump_stack from __warn+0x84/0xe4n[ 14.588668] __warn from warn_slowpath_fmt+0x18c/0x194n[ 14.588678] r7:c08d40b0 r6:c1003cb0 r5:00000000 r4:00000000n[ 14.588681] warn_slowpath_fmt from nand_reset_op+0x1e0/0x1f8n[ 14.588695] r8:70c40dff r7:89705f41 r6:36b4a597 r5:c26c9444 r4:c26b0048n[ 14.588697] nand_reset_op from brcmnand_resume+0x13c/0x150n[ 14.588714] r9:00000000 r8:00000000 r7:c24f8010 r6:c228a3f8 r5:c26c94bc r4:c26b0040n[ 14.588717] brcmnand_resume from platform_pm_resume+0x34/0x54n[ 14.588735] r5:00000010 r4:c0840a50n[ 14.588738] platform_pm_resume from dpm_run_callback+0x5c/0x14cn[ 14.588757] dpm_run_callback from device_resume+0xc0/0x324n[ 14.588776] r9:c24f8054 r8:c24f80a0 r7:00000000 r6:00000000 r5:00000010 r4:c24f8010n[ 14.588779] device_resume from dpm_resume+0x130/0x160n[ 14.588799] r9:c22539e4 r8:00000010 r7:c22bebb0 r6:c24f8010 r5:c22539dc r4:c22539b0n[ 14.588802] dpm_resume from dpm_resume_end+0x14/0x20n[ 14.588822] r10:c2204e40 r9:00000000 r8:c228a3fc r7:00000000 r6:00000003 r5:c228a414n[ 14.588826] r4:00000010n[ 14.588828] dpm_resume_end from suspend_devices_and_enter+0x274/0x6f8n[ 14.588848] r5:c228a414 r4:00000000n[ 14.588851] suspend_devices_and_enter from pm_suspend+0x228/0x2bcn[ 14.588868] r10:c3502910 r9:c3501f40 r8:00000004 r7:c228a438 r6:c0f95e18 r5:00000000n[ 14.588871] r4:00000003n[ 14.588874] pm_suspend from state_store+0x74/0xd0n[ 14.588889] r7:c228a438 r6:c0f934c8 r5:00000003 r4:00000003n[ 14.588892] state_store from kobj_attr_store+0x1c/0x28n[ 14.588913] r9:00000000 r8:00000000 r7:f09f9f08 r6:00000004 r5:c3502900 r4:c0283250n[ 14.588916] kobj_attr_store from sysfs_kf_write+0x40/0x4cn[ 14.588936] r5:c3502900 r4:c0d92a48n[ 14.588939] sysfs_kf_write from kernfs_fop_write_iter+0x104/0x1f0n[ 14.588956] r5:c3502900 r4:c3501f40n[ 14.588960] kernfs_fop_write_iter from vfs_write+0x250/0x420n[ 14.588980] r10:c0e14b48 r9:00000000 r8:c25f5780 r7:00443398 r6:f09f9f68 r5:c34f7f00n[ 14.588983] r4:c042a88cn[ 14.588987] vfs_write from ksys_write+0x74/0xe4n[ 14.589005] r10:00000004 r9:c25f5780 r8:c02002fA0 r7:00000000 r6:00000000 r5:c34f7f00n[ 14.589008] r4:c34f7f00n[ 14.589011] ksys_write from sys_write+0x10/0x14n[ 14.589029] r7:00000004 r6:004421c0 r5:00443398 r4:00000004n[ 14.589032] sys_write from ret_fast_syscall+0x0/0x5cn[ 14.589044] Exception stack(0xf09f9fa8 to 0xf09f9ff0)n[ 14.589050] 9fa0: 00000004 00443398 00000004 00443398 00000004 00000001n[ 14.589056] 9fc0: 00000004 00443398 004421c0 00000004 b6ecbd58 00000008 bebfbc38 0043eb78n[ 14.589062] 9fe0: 00440eb0 bebfbaf8 b6de18a0 b6e579e8n[ 14.589065] ---[ end trace 0000000000000000 ]---nnThe fix uses the higher level nand_reset(chip chipnr); where chipnr = 0 whenndoing PM resume operation in compliance with the controller support for singlendie nand chip. Switching from nand_reset_op() to nann---truncated---,CVE-2025-37840,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnpm: cpupower: bench: Prevent NULL dereference on malloc failurennIf malloc returns NULL due to low memory 'config' pointer can be NULL.nAdd a check to prevent NULL dereference.,CVE-2025-37841,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnspi: fsl-qspi: use devm function instead of driver removennDriver use devm APIs to manage clk/irq/resources and register the spincontroller but the legacy remove function will be called first duringndevice detach and trigger kernel panic. Drop the remove function and usendevm_add_action_or_reset() for driver cleanup to ensure the releasensequence.nnTrigger kernel panic on i.MX8MQ bynecho 30bb0000.spi >/sys/bus/platform/drivers/fsl-quadspi/unbind,CVE-2025-37842,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nncifs: avoid NULL pointer dereference in dbg callnncifs_server_dbg() implies server to be non-NULL sonmove call under condition to avoid NULL pointer dereference.nnFound by Linux Verification Center (linuxtesting.org) with SVACE.,CVE-2025-37844,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnKVM: arm64: Tear down vGIC on failed vCPU creationnnIf kvm_arch_vcpu_create() fails to share the vCPU page with thenhypervisor we propagate the error back to the ioctl but leave thenvGIC vCPU data initialised. Note only does this leak the correspondingnmemory when the vCPU is destroyed but it can also lead to use-after-freenif the redistributor device handling tries to walk into the vCPU.nnAdd the missing cleanup to kvm_arch_vcpu_create() ensuring that thenvGIC vCPU structures are destroyed on error.,CVE-2025-37849,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnpwm: mediatek: Prevent divide-by-zero in pwm_mediatek_config()nnWith CONFIG_COMPILE_TEST && !CONFIG_HAVE_CLK pwm_mediatek_config() has andivide-by-zero in the following line:nntdo_div(resolution clk_get_rate(pc->clk_pwms[pwm->hwpwm]));nndue to the fact that the !CONFIG_HAVE_CLK version of clk_get_rate()nreturns zero.nnThis is presumably just a theoretical problem: COMPILE_TEST overridesnthe dependency on RALINK which would select COMMON_CLK. Regardless it'sna good idea to check for the error explicitly to avoid divide-by-zero.nnFixes the following warning:nn drivers/pwm/pwm-mediatek.o: warning: objtool: .text: unexpected end of sectionnn[ukleinek: s/CONFIG_CLK/CONFIG_HAVE_CLK/],CVE-2025-37850,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnfbdev: omapfb: Add 'plane' value checknnFunction dispc_ovl_setup is not intended to work with the value OMAP_DSS_WBnof the enum parameter plane.nnThe value of this parameter is initialized in dss_init_overlays and in thencurrent state of the code it cannot take this value so it's not a realnproblem.nnFor the purposes of defensive coding it wouldn't be superfluous to checknthe parameter value because some functions down the call stack processnthis value correctly and some not.nnFor example in dispc_ovl_setup_global_alpha it may lead to buffernoverflow.nnAdd check for this value.nnFound by Linux Verification Center (linuxtesting.org) with SVACE staticnanalysis tool.,CVE-2025-37851,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amdgpu: handle amdgpu_cgs_create_device() errors in amd_powerplay_create()nnAdd error handling to propagate amdgpu_cgs_create_device() failuresnto the caller. When amdgpu_cgs_create_device() fails release hwmgrnand return -ENOMEM to prevent null pointer dereference.nn[v1]->[v2]: Change error code from -EINVAL to -ENOMEM. Free hwmgr.,CVE-2025-37852,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amdkfd: debugfs hang_hws skip GPU with MESnndebugfs hang_hws is used by GPU reset test with HWS for MES this crashnthe kernel with NULL pointer access because dqm->packet_mgr is not setupnfor MES path.nnSkip GPU with MES for now MES hang_hws debugfs interface will bensupported later.,CVE-2025-37853,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amdkfd: Fix mode1 reset crash issuennIf HW scheduler hangs and mode1 reset is used to recover GPU KFD signalnuser space to abort the processes. After process abort exit user queuesnstill use the GPU to access system memory before h/w is reset while KFDncleanup worker free system memory and free VRAM.nnThere is use-after-free race bug that KFD allocate and reuse the freednsystem memory and user queue write to the same system memory to corruptnthe data structure and cause driver crash.nnTo fix this race KFD cleanup worker terminate user queues then flushnreset_domain wq to wait for any GPU ongoing reset complete and thennfree outstanding BOs.,CVE-2025-37854,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: Guard Possible Null Pointer Dereferencenn[WHY]nIn some situations dc->res_pool may be null.nn[HOW]nCheck if pointer is null before dereference.,CVE-2025-37855,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbtrfs: harden block_group::bg_list against list_del() racesnnAs far as I can tell these calls of list_del_init() on bg_list cannotnrun concurrently with btrfs_mark_bg_unused() or btrfs_mark_bg_to_reclaim()nas they are in transaction error paths and situations where the blockngroup is readonly.nnHowever if there is any chance at all of racing with mark_bg_unused()nor a different future user of bg_list better to be safe than sorry.nnOtherwise we risk the following interleaving (bg_list refcount in parens)nnT1 (some random op) T2 (btrfs_mark_bg_unused)n !list_empty(&bg->bg_list); (1)nlist_del_init(&bg->bg_list); (1)n list_move_tail (1)nbtrfs_put_block_group (0)n btrfs_delete_unused_bgsn bg = list_first_entryn list_del_init(&bg->bg_list);n btrfs_put_block_group(bg); (-1)nnUltimately this results in a broken ref count that hits zero one derefnearly and the real final deref underflows the refcount resulting in a WARNING.,CVE-2025-37856,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnscsi: st: Fix array overflow in st_setup()nnChange the array size to follow parms size instead of a fixed value.,CVE-2025-37857,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnfs/jfs: Prevent integer overflow in AG size calculationnnThe JFS filesystem calculates allocation group (AG) size using 1 <<nl2agsize in dbExtendFS(). When l2agsize exceeds 31 (possible with >2TBnaggregates on 32-bit systems) this 32-bit shift operation causes undefinednbehavior and improper AG sizing.nnOn 32-bit architectures:n- Left-shifting 1 by 32+ bits results in 0 due to integer overflown- This creates invalid AG sizes (0 or garbage values) innsbi->bmap->db_agsizen- Subsequent block allocations would reference invalid AG structuresn- Could lead to:n - Filesystem corruption during extend operationsn - Kernel crashes due to invalid memory accessesn - Security vulnerabilities via malformed on-disk structuresnnFix by casting to s64 before shifting:nbmp->db_agsize = (s64)1 << l2agsize;nnThis ensures 64-bit arithmetic even on 32-bit architectures. The castnmatches the data type of db_agsize (s64) and follows similar patterns innJFS block calculation code.nnFound by Linux Verification Center (linuxtesting.org) with SVACE.,CVE-2025-37858,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnpage_pool: avoid infinite loop to schedule delayed workernnWe noticed the kworker in page_pool_release_retry() was wakennup repeatedly and infinitely in production because of thenbuggy driver causing the inflight less than 0 and warningnus in page_pool_inflight()[1].nnSince the inflight value goes negative it means we shouldnnot expect the whole page_pool to get back to work normally.nnThis patch mitigates the adverse effect by not reschedulingnthe kworker when detecting the inflight negative innpage_pool_release_retry().nn[1]n[Mon Feb 10 20:36:11 2025] ------------[ cut here ]------------n[Mon Feb 10 20:36:11 2025] Negative(-51446) inflight packet-pagesn...n[Mon Feb 10 20:36:11 2025] Call Trace:n[Mon Feb 10 20:36:11 2025] page_pool_release_retry+0x23/0x70n[Mon Feb 10 20:36:11 2025] process_one_work+0x1b1/0x370n[Mon Feb 10 20:36:11 2025] worker_thread+0x37/0x3a0n[Mon Feb 10 20:36:11 2025] kthread+0x11a/0x140n[Mon Feb 10 20:36:11 2025] ? process_one_work+0x370/0x370n[Mon Feb 10 20:36:11 2025] ? __kthread_cancel_work+0x40/0x40n[Mon Feb 10 20:36:11 2025] ret_from_fork+0x35/0x40n[Mon Feb 10 20:36:11 2025] ---[ end trace ebffe800f33e7e34 ]---nNote: before this patch the above calltrace would flood thendmesg due to repeated reschedule of release_dw kworker.,CVE-2025-37859,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnscsi: mpi3mr: Synchronous access b/w reset and tm thread for reply queuennWhen the task management thread processes reply queues while the resetnthread resets them the task management thread accesses an invalid queue IDn(0xFFFF) set by the reset thread which points to unallocated memoryncausing a crash.nnAdd flag 'io_admin_reset_sync' to synchronize access between the resetnI/O and admin threads. Before a reset the reset handler sets this flag tonblock I/O and admin processing threads. If any thread bypasses the initialncheck the reset thread waits up to 10 seconds for processing to finish. Ifnthe wait exceeds 10 seconds the controller is marked as unrecoverable.,CVE-2025-37861,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnHID: pidff: Fix null pointer dereference in pidff_find_fieldsnnThis function triggered a null pointer dereference if used to search forna report that isn't implemented on the device. This happened both fornoptional and required reports alike.nnThe same logic was applied to pidff_find_special_field and althoughnpidff_init_fields should return an error earlier if one of the requirednreports is missing future modifications could change this logic andnresurface this possible null pointer dereference again.nnLKML bug report:nhttps://lore.kernel.org/all/CAL-gK7f5=R0nrrQdPtaZZr1fd-cdAMbDMuZ_NLA8vM0SX+nGSw@mail.gmail.com,CVE-2025-37862,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnRDMA/core: Silence oversized kvmalloc() warningnnsyzkaller triggered an oversized kvmalloc() warning.nSilence it by adding __GFP_NOWARN.nnsyzkaller log:n WARNING: CPU: 7 PID: 518 at mm/util.c:665 __kvmalloc_node_noprof+0x175/0x180n CPU: 7 UID: 0 PID: 518 Comm: c_repro Not tainted 6.11.0-rc6+ #6n Hardware name: QEMU Standard PC (i440FX + PIIX 1996) BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014n RIP: 0010:__kvmalloc_node_noprof+0x175/0x180n RSP: 0018:ffffc90001e67c10 EFLAGS: 00010246n RAX: 0000000000000100 RBX: 0000000000000400 RCX: ffffffff8149d46bn RDX: 0000000000000000 RSI: ffff8881030fae80 RDI: 0000000000000002n RBP: 000000712c800000 R08: 0000000000000100 R09: 0000000000000000n R10: ffffc90001e67c10 R11: 0030ae0601000000 R12: 0000000000000000n R13: 0000000000000000 R14: 00000000ffffffff R15: 0000000000000000n FS: 00007fde79159740(0000) GS:ffff88813bdc0000(0000) knlGS:0000000000000000n CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033n CR2: 0000000020000180 CR3: 0000000105eb4005 CR4: 00000000003706b0n DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000n DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400n Call Trace:n <TASK>n ib_umem_odp_get+0x1f6/0x390n mlx5_ib_reg_user_mr+0x1e8/0x450n ib_uverbs_reg_mr+0x28b/0x440n ib_uverbs_write+0x7d3/0xa30n vfs_write+0x1ac/0x6c0n ksys_write+0x134/0x170n ? __sanitizer_cov_trace_pc+0x1c/0x50n do_syscall_64+0x50/0x110n entry_SYSCALL_64_after_hwframe+0x76/0x7e,CVE-2025-37867,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nndrm/amd/display: prevent hang on link training failnn[Why]nWhen link training fails the phy clock will be disabled. However innenable_streams it is assumed that link training succeeded and thenmux selects the phy clock causing a hang when a register write is made.nn[How]nWhen enable_stream is hit check if link training failed. If it did fallnback to the ref clock to avoid a hang and keep the system in a recoverablenstate.,CVE-2025-37870,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnfsd: decrease sc_count directly if fail to queue dl_recallnnA deadlock warning occurred when invoking nfs4_put_stid following a failedndl_recall queue operation:n T1 T2n nfs4_laundromatn nfs4_get_client_reaplistn nfs4_anylock_blockersn__break_leasen spin_lock // ctx->flc_lockn spin_lock // clp->cl_lockn nfs4_lockowner_has_blockersn locks_owner_has_blockersn spin_lock // flctx->flc_lockn nfsd_break_deleg_cbn nfsd_break_one_delegn nfs4_put_stidn refcount_dec_and_lockn spin_lock // clp->cl_locknnWhen a file is opened an nfs4_delegation is allocated with sc_countninitialized to 1 and the file_lease holds a reference to the delegation.nThe file_lease is then associated with the file through kernel_setlease.nnThe disassociation is performed in nfsd4_delegreturn via the followingncall chain:nnfsd4_delegreturn --> destroy_delegation --> destroy_unhashed_deleg -->nnfs4_unlock_deleg_lease --> kernel_setlease --> generic_delete_leasenThe corresponding sc_count reference will be released after thisndisassociation.nnSince nfsd_break_one_deleg executes while holding the flc_lock thendisassociation process becomes blocked when attempting to acquire flc_locknin generic_delete_lease. This means:n1) sc_count in nfsd_break_one_deleg will not be decremented to 0;n2) The nfs4_put_stid called by nfsd_break_one_deleg will not attempt tonacquire cl_lock;n3) Consequently no deadlock condition is created.nnGiven that sc_count in nfsd_break_one_deleg remains non-zero we cannsafely perform refcount_dec on sc_count directly. This approachneffectively avoids triggering deadlock warnings.,CVE-2025-37871,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnetfs: Only create /proc/fs/netfs with CONFIG_PROC_FSnnWhen testing a special config:nnCONFIG_NETFS_SUPPORTS=ynCONFIG_PROC_FS=nnnThe system crashes with something like:nn[ 3.766197] ------------[ cut here ]------------n[ 3.766484] kernel BUG at mm/mempool.c:560!n[ 3.766789] Oops: invalid opcode: 0000 [#1] SMP NOPTIn[ 3.767123] CPU: 0 UID: 0 PID: 1 Comm: swapper/0 Tainted: G Wn[ 3.767777] Tainted: [W]=WARNn[ 3.767968] Hardware name: QEMU Standard PC (i440FX + PIIX 1996)n[ 3.768523] RIP: 0010:mempool_alloc_slab.cold+0x17/0x19n[ 3.768847] Code: 50 fe ff 58 5b 5d 41 5c 41 5d 41 5e 41 5f e9 93 95 13 00n[ 3.769977] RSP: 0018:ffffc90000013998 EFLAGS: 00010286n[ 3.770315] RAX: 000000000000002f RBX: ffff888100ba8640 RCX: 0000000000000000n[ 3.770749] RDX: 0000000000000000 RSI: 0000000000000003 RDI: 00000000ffffffffn[ 3.771217] RBP: 0000000000092880 R08: 0000000000000000 R09: ffffc90000013828n[ 3.771664] R10: 0000000000000001 R11: 00000000ffffffea R12: 0000000000092cc0n[ 3.772117] R13: 0000000000000400 R14: ffff8881004b1620 R15: ffffea0004ef7e40n[ 3.772554] FS: 0000000000000000(0000) GS:ffff8881b5f3c000(0000) knlGS:0000000000000000n[ 3.773061] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033n[ 3.773443] CR2: ffffffff830901b4 CR3: 0000000004296001 CR4: 0000000000770ef0n[ 3.773884] PKRU: 55555554n[ 3.774058] Call Trace:n[ 3.774232] <TASK>n[ 3.774371] mempool_alloc_noprof+0x6a/0x190n[ 3.774649] ? _printk+0x57/0x80n[ 3.774862] netfs_alloc_request+0x85/0x2cen[ 3.775147] netfs_readahead+0x28/0x170n[ 3.775395] read_pages+0x6c/0x350n[ 3.775623] ? srso_alias_return_thunk+0x5/0xfbef5n[ 3.775928] page_cache_ra_unbounded+0x1bd/0x2a0n[ 3.776247] filemap_get_pages+0x139/0x970n[ 3.776510] ? srso_alias_return_thunk+0x5/0xfbef5n[ 3.776820] filemap_read+0xf9/0x580n[ 3.777054] ? srso_alias_return_thunk+0x5/0xfbef5n[ 3.777368] ? srso_alias_return_thunk+0x5/0xfbef5n[ 3.777674] ? find_held_lock+0x32/0x90n[ 3.777929] ? netfs_start_io_read+0x19/0x70n[ 3.778221] ? netfs_start_io_read+0x19/0x70n[ 3.778489] ? srso_alias_return_thunk+0x5/0xfbef5n[ 3.778800] ? lock_acquired+0x1e6/0x450n[ 3.779054] ? srso_alias_return_thunk+0x5/0xfbef5n[ 3.779379] netfs_buffered_read_iter+0x57/0x80n[ 3.779670] __kernel_read+0x158/0x2c0n[ 3.779927] bprm_execve+0x300/0x7a0n[ 3.780185] kernel_execve+0x10c/0x140n[ 3.780423] ? __pfx_kernel_init+0x10/0x10n[ 3.780690] kernel_init+0xd5/0x150n[ 3.780910] ret_from_fork+0x2d/0x50n[ 3.781156] ? __pfx_kernel_init+0x10/0x10n[ 3.781414] ret_from_fork_asm+0x1a/0x30n[ 3.781677] </TASK>n[ 3.781823] Modules linked in:n[ 3.782065] ---[ end trace 0000000000000000 ]---nnThis is caused by the following error path in netfs_init():nn if (!proc_mkdir(fs/netfs NULL))n goto error_proc;nnFix this by adding ifdef in netfs_main() so that /proc/fs/netfs is onlyncreated with CONFIG_PROC_FS.,CVE-2025-37876,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nniommu: Clear iommu-dma ops on cleanupnnIf iommu_device_register() encounters an error it can end up tearingndown already-configured groups and default domains however thisncurrently still leaves devices hooked up to iommu-dma (and evennhistorically the behaviour in this area was at best inconsistent acrossnarchitectures/drivers...) Although in the case that an IOMMU is presentnwhose driver has failed to probe users cannot necessarily expect DMA tonwork anyway it's still arguable that we should do our best to putnthings back as if the IOMMU driver was never there at all and certainlynthe potential for crashing in iommu-dma itself is undesirable. Make surenwe clean up the dev->dma_iommu flag along with everything else.,CVE-2025-37877,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnperf/core: Fix WARN_ON(!ctx) in __free_event() for partial initnnMove the get_ctx(child_ctx) call and the child_event->ctx assignment tonoccur immediately after the child event is allocated. Ensure thatnchild_event->ctx is non-NULL before any subsequent error path withinninherit_event calls free_event() satisfying the assumptions of thencleanup code.nnDetails:nnThere's no clear Fixes tag because this bug is a side-effect ofnmultiple interacting commits over time (up to 15 years old) notna single regression.nnThe code initially incremented refcount then assigned contextnimmediately after the child_event was created. Later an earlynvalidity check for child_event was added before thenrefcount/assignment. Even later a WARN_ON_ONCE() cleanup check wasnadded assuming event->ctx is valid if the pmu_ctx is valid.nThe problem is that the WARN_ON_ONCE() could trigger after the initialncheck passed but before child_event->ctx was assigned violating itsnprecondition. The solution is to assign child_event->ctx right afternits initial validation. This ensures the context exists for anynsubsequent checks or cleanup routines resolving the WARN_ON_ONCE().nnTo resolve it defer the refcount update and child_event->ctx assignmentndirectly after child_event->pmu_ctx is set but before checking if thenparent event is orphaned. The cleanup routine depends onnevent->pmu_ctx being non-NULL before it verifies event->ctx isnnon-NULL. This also maintains the author's original intent of passingnin child_ctx to find_get_pmu_context before its refcount/assignment.nn[ mingo: Expanded the changelog from another email by Gabriel Shahrouzi. ],CVE-2025-37878,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nn9p/net: fix improper handling of bogus negative read/write repliesnnIn p9_client_write() and p9_client_read_once() if the servernincorrectly replies with success but a negative write/read count then wenwould consider written (negative) <= rsize (positive) because bothnvariables were signed.nnMake variables unsigned to avoid this problem.nnThe reproducer linked below now fails with the following error insteadnof a null pointer deref:n9pnet: bogus RWRITE count (4294967295 > 3),CVE-2025-37879,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnum: work around sched_yield not yielding in time-travel modennsched_yield by a userspace may not actually cause scheduling inntime-travel mode as no time has passed. In the case seen it appears tonbe a badly implemented userspace spinlock in ASAN. Unfortunately withntime-travel it causes an extreme slowdown or even deadlock depending onnthe kernel configuration (CONFIG_UML_MAX_USERSPACE_ITERATIONS).nnWork around it by accounting time to the process whenever it executes ansched_yield syscall.,CVE-2025-37880,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnusb: gadget: aspeed: Add NULL pointer check in ast_vhub_init_dev()nnThe variable d->name returned by devm_kasprintf() could be NULL.nA pointer check is added to prevent potential NULL pointer dereference.nThis is similar to the fix in commit 3027e7b15b02n(ice: Fix some null pointer dereference issues in ice_ptp.c).nnThis issue is found by our static analysis tool,CVE-2025-37881,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnusb: xhci: Fix isochronous Ring Underrun/Overrun event handlingnnThe TRB pointer of these events points at enqueue at the time of errornoccurrence on xHCI 1.1+ HCs or it's NULL on older ones. By the time wenare handling the event a new TD may be queued at this ring position.nnI can trigger this race by rising interrupt moderation to increase IRQnhandling delay. Similar delay may occur naturally due to system load.nnIf this ever happens after a Missed Service Error missed TDs will benskipped and the new TD processed as if it matched the event. It couldnbe given back prematurely risking data loss or buffer UAF by the xHC.nnDon't complete TDs on xrun events and don't warn if queued TDs don'tnmatch the event's TRB pointer which can be NULL or a link/no-op TRB.nDon't warn if there are no queued TDs at all.nnNow that it's safe also handle xrun events if the skip flag is clear.nThis ensures completion of any TD stuck in 'error mid TD' state rightnbefore the xrun event which could happen if a driver submits a finitennumber of URBs to a buggy HC and then an error occurs on the last TD.,CVE-2025-37882,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nns390/sclp: Add check for get_zeroed_page()nnAdd check for the return value of get_zeroed_page() innsclp_console_init() to prevent null pointer dereference.nFurthermore to solve the memory leak caused by the loopnallocation add a free helper to do the free job.,CVE-2025-37883,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnbpf: Fix deadlock between rcu_tasks_trace and event_mutex.nnFix the following deadlock:nCPU An_free_event()n perf_kprobe_destroy()n mutex_lock(&event_mutex)n perf_trace_event_unreg()n synchronize_rcu_tasks_trace()nnThere are several paths where _free_event() grabs event_mutexnand calls sync_rcu_tasks_trace. Above is one such case.nnCPU Bnbpf_prog_test_run_syscall()n rcu_read_lock_trace()n bpf_prog_run_pin_on_cpu()n bpf_prog_load()n bpf_tracing_func_proto()n trace_set_clr_event()n mutex_lock(&event_mutex)nnDelegate trace_set_clr_event() to workqueue to avoidnsuch lock dependency.,CVE-2025-37884,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnKVM: x86: Reset IRTE to host control if *new* route isn't postablennRestore an IRTE back to host control (remapped or posted MSI mode) if then*new* GSI route prevents posting the IRQ directly to a vCPU regardless ofnthe GSI routing type. Updating the IRTE if and only if the new GSI is annMSI results in KVM leaving an IRTE posting to a vCPU.nnThe dangling IRTE can result in interrupts being incorrectly delivered tonthe guest and in the worst case scenario can result in use-after-freene.g. if the VM is torn down but the underlying host IRQ isn't freed.,CVE-2025-37885,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnjfs: reject on-disk inodes of an unsupported typennSyzbot has reported the following BUG:nnkernel BUG at fs/inode.c:668!nOops: invalid opcode: 0000 [#1] PREEMPT SMP KASAN PTInCPU: 3 UID: 0 PID: 139 Comm: jfsCommit Not tainted 6.12.0-rc4-syzkaller-00085-g4e46774408d9 #0nHardware name: QEMU Standard PC (i440FX + PIIX 1996) BIOS 1.16.3-3.fc41 04/01/2014nRIP: 0010:clear_inode+0x168/0x190nCode: 4c 89 f7 e8 ba fe e5 ff e9 61 ff ff ff 44 89 f1 80 e1 07 80 c1 03 38 c1 7c c1 4c 89 f7 e8 90 ff e5 ff eb b7n 0b e8 01 5d 7f ff 90 0f 0b e8 f9 5c 7f ff 90 0f 0b e8 f1 5c 7fnRSP: 0018:ffffc900027dfae8 EFLAGS: 00010093nRAX: ffffffff82157a87 RBX: 0000000000000001 RCX: ffff888104d4b980nRDX: 0000000000000000 RSI: 0000000000000001 RDI: 0000000000000000nRBP: ffffc900027dfc90 R08: ffffffff82157977 R09: fffff520004fbf38nR10: dffffc0000000000 R11: fffff520004fbf38 R12: dffffc0000000000nR13: ffff88811315bc00 R14: ffff88811315bda8 R15: ffff88811315bb80nFS: 0000000000000000(0000) GS:ffff888135f00000(0000) knlGS:0000000000000000nCS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033nCR2: 00005565222e0578 CR3: 0000000026ef0000 CR4: 00000000000006f0nCall Trace:n <TASK>n ? __die_body+0x5f/0xb0n ? die+0x9e/0xc0n ? do_trap+0x15a/0x3a0n ? clear_inode+0x168/0x190n ? do_error_trap+0x1dc/0x2c0n ? clear_inode+0x168/0x190n ? __pfx_do_error_trap+0x10/0x10n ? report_bug+0x3cd/0x500n ? handle_invalid_op+0x34/0x40n ? clear_inode+0x168/0x190n ? exc_invalid_op+0x38/0x50n ? asm_exc_invalid_op+0x1a/0x20n ? clear_inode+0x57/0x190n ? clear_inode+0x167/0x190n ? clear_inode+0x168/0x190n ? clear_inode+0x167/0x190n jfs_evict_inode+0xb5/0x440n ? __pfx_jfs_evict_inode+0x10/0x10n evict+0x4ea/0x9b0n ? __pfx_evict+0x10/0x10n ? iput+0x713/0xa50n txUpdateMap+0x931/0xb10n ? __pfx_txUpdateMap+0x10/0x10n jfs_lazycommit+0x49a/0xb80n ? _raw_spin_unlock_irqrestore+0x8f/0x140n ? lockdep_hardirqs_on+0x99/0x150n ? __pfx_jfs_lazycommit+0x10/0x10n ? __pfx_default_wake_function+0x10/0x10n ? __kthread_parkme+0x169/0x1d0n ? __pfx_jfs_lazycommit+0x10/0x10n kthread+0x2f2/0x390n ? __pfx_jfs_lazycommit+0x10/0x10n ? __pfx_kthread+0x10/0x10n ret_from_fork+0x4d/0x80n ? __pfx_kthread+0x10/0x10n ret_from_fork_asm+0x1a/0x30n </TASK>nnThis happens when 'clear_inode()' makes an attempt to finalize an underlyingnJFS inode of unknown type. According to JFS layout description fromnhttps://jfs.sourceforge.net/project/pub/jfslayout.pdf inode types from 5 ton15 are reserved for future extensions and should not be encountered on a validnfilesystem. So add an extra check for valid inode type in 'copy_from_dinode()'.,CVE-2025-37925,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnnet_sched: skbprio: Remove overly strict queue assertionsnnIn the current implementation skbprio enqueue/dequeue contains an assertionnthat fails under certain conditions when SKBPRIO is used as a child qdisc undernTBF with specific parameters. The failure occurs because TBF sometimes peeks atnpackets in the child qdisc without actually dequeuing them when tokens arenunavailable.nnThis peek operation creates a discrepancy between the parent and child qdiscnqueue length counters. When TBF later receives a high-priority packetnSKBPRIO's queue length may show a different value than what's reflected in itsninternal priority queue tracking triggering the assertion.nnThe fix removes this overly strict assertions in SKBPRIO they are notnnecessary at all.,CVE-2025-38637,tykio/tyk-plugin-compiler
linux-libc-dev,MEDIUM,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnclk: samsung: Fix UBSAN panic in samsung_clk_init()nnWith UBSAN_ARRAY_BOUNDS=y I'm hitting the below panic due tondereferencing `ctx->clk_data.hws` before settingn`ctx->clk_data.num = nr_clks`. Move that up to fix the crash.nn UBSAN: array index out of bounds: 00000000f2005512 [#1] PREEMPT SMPn <snip>n Call trace:n samsung_clk_init+0x110/0x124 (P)n samsung_clk_init+0x48/0x124 (L)n samsung_cmu_register_one+0x3c/0xa0n exynos_arm64_register_cmu+0x54/0x64n __gs101_cmu_top_of_clk_init_declare+0x28/0x60n ...,CVE-2025-39728,tykio/tyk-plugin-compiler
linux-libc-dev,HIGH,5.10.234-1,,In the Linux kernel the following vulnerability has been resolved:nnjfs: fix slab-out-of-bounds read in ea_get()nnDuring the size_check label in ea_get() the code checks if the extendednattribute list (xattr) size matches ea_size. If not it logsnea_get: invalid extended attribute and calls print_hex_dump().nnHere EALIST_SIZE(ea_buf->xattr) returns 4110417968 which exceedsnINT_MAX (2147483647). Then ea_size is clamped:nntint size = clamp_t(int ea_size 0 EALIST_SIZE(ea_buf->xattr));nnAlthough clamp_t aims to bound ea_size between 0 and 4110417968 the uppernlimit is treated as an int causing an overflow above 2^31 - 1. This leadsnsize to wrap around and become negative (-184549328).nnThe size is then passed to print_hex_dump() (called len innprint_hex_dump()) it is passed as type size_t (an unsignedntype) this is then stored inside a variable callednint remaining which is then assigned to int linelen whichnis then passed to hex_dump_to_buffer(). In print_hex_dump()nthe for loop iterates through 0 to len-1 where len isn18446744073525002176 calling hex_dump_to_buffer()non each iteration:nntfor (i = 0; i < len; i += rowsize) {nttlinelen = min(remaining rowsize);nttremaining -= rowsize;nntthex_dump_to_buffer(ptr + i linelen rowsize groupsizentttt linebuf sizeof(linebuf) ascii);nntt...nt}nnThe expected stopping condition (i < len) is effectively brokennsince len is corrupted and very large. This eventually leads tonthe ptr+i being passed to hex_dump_to_buffer() to get closernto the end of the actual bounds of ptr eventually an out ofnbounds access is done in hex_dump_to_buffer() in the followingnfor loop:nntfor (j = 0; j < len; j++) {ntttif (linebuflen < lx + 2)nttttgoto overflow2;ntttch = ptr[j];ntt...nt}nnTo fix this we should validate EALIST_SIZE(ea_buf->xattr)nbefore it is utilised.,CVE-2025-39735,tykio/tyk-plugin-compiler
linux-libc-dev,LOW,5.10.234-1,,null,TEMP-0000000-F7A20F,tykio/tyk-plugin-compiler
login,LOW,1:4.8.1-1+deb11u1,,initscripts in rPath Linux 1 sets insecure permissions for the /var/log/btmp file which allows local users to obtain sensitive information regarding authentication attempts. NOTE: because sshd detects the insecure permissions and does not log certain events this also prevents sshd from logging failed authentication attempts by remote attackers.,CVE-2007-5686,tykio/gromit & tykio/tyk-plugin-compiler
login,LOW,1:4.8.1-1+deb11u1,,shadow: TOCTOU (time-of-check time-of-use) race condition when copying and removing directory trees,CVE-2013-4235,tykio/tyk-plugin-compiler
login,LOW,1:4.13+dfsg1-1+b1,,In Shadow 4.13 it is possible to inject control characters into fields provided to the SUID program chfn (change finger). Although it is not possible to exploit this directly (e.g. adding a new user fails because n is in the block list) it is possible to misrepresent the /etc/passwd file when viewed. Use of r manipulations and Unicode characters to work around blocking of the : character make it possible to give the impression that a new user has been added. In other words an adversary may be able to convince a system administrator to take the system offline (an indirect social-engineered denial of service) by demonstrating that cat /etc/passwd shows a rogue user account.,CVE-2023-29383,tykio/gromit
login,MEDIUM,1:4.13+dfsg1-1+b1,,A flaw was found in shadow-utils. When asking for a new password shadow-utils asks the password twice. If the password fails on the second attempt shadow-utils fails in cleaning the buffer used to store the first entry. This may allow an attacker with enough access to retrieve the password from the memory.,CVE-2023-4641,tykio/gromit
login,LOW,1:4.8.1-1+deb11u1,,shadow-utils (aka shadow) 4.4 through 4.17.0 establishes a default /etc/subuid behavior (e.g. uid 100000 through 165535 for the first user account) that can realistically conflict with the uids of users defined on locally administered networks potentially leading to account takeover e.g. by leveraging newuidmap for access to an NFS home directory (or same-host resources in the case of remote logins by these local network users). NOTE: it may also be argued that system administrators should not have assigned uids within local networks that are within the range that can occur in /etc/subuid.,CVE-2024-56433,tykio/gromit & tykio/tyk-plugin-compiler
login,LOW,1:4.8.1-1+deb11u1,,null,TEMP-0628843-DBAD28,tykio/gromit & tykio/tyk-plugin-compiler
m4,LOW,1.4.18-5,,The (1) maketemp and (2) mkstemp builtin functions in GNU m4 before 1.4.11 do not quote their output when a file is created which might allow context-dependent attackers to trigger a macro expansion leading to unspecified use of an incorrect filename.,CVE-2008-1687,tykio/tyk-plugin-compiler
m4,LOW,1.4.18-5,,Unspecified vulnerability in GNU m4 before 1.4.11 might allow context-dependent attackers to execute arbitrary code related to improper handling of filenames specified with the -F option. NOTE: it is not clear when this issue crosses privilege boundaries.,CVE-2008-1688,tykio/tyk-plugin-compiler
mount,LOW,2.36.1-8+deb11u2,,A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an INPUTRC environment variable to get a path to the library config file. When the library cannot parse the specified file it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.,CVE-2022-0563,tykio/gromit & tykio/tyk-plugin-compiler
ncurses-base,MEDIUM,6.2+20201114-2+deb11u2,,NCurse v6.4-20230418 was discovered to contain a segmentation fault via the component _nc_wrap_entry().,CVE-2023-50495,tykio/gromit & tykio/tyk-plugin-compiler
ncurses-bin,MEDIUM,6.2+20201114-2+deb11u2,,NCurse v6.4-20230418 was discovered to contain a segmentation fault via the component _nc_wrap_entry().,CVE-2023-50495,tykio/gromit & tykio/tyk-plugin-compiler
openssh-client,LOW,1:8.4p1-5+deb11u4,,OpenSSH 4.6 and earlier when ChallengeResponseAuthentication is enabled allows remote attackers to determine the existence of user accounts by attempting to authenticate via S/KEY which displays a different response if the user account exists a similar issue to CVE-2001-1483.,CVE-2007-2243,tykio/gromit & tykio/tyk-plugin-compiler
openssh-client,LOW,1:8.4p1-5+deb11u4,,OpenSSH when using OPIE (One-Time Passwords in Everything) for PAM allows remote attackers to determine the existence of certain user accounts which displays a different response if the user account exists and is configured to use one-time passwords (OTP) a similar issue to CVE-2007-2243.,CVE-2007-2768,tykio/gromit & tykio/tyk-plugin-compiler
openssh-client,LOW,1:8.4p1-5+deb11u4,,sshd in OpenSSH 4 on Debian GNU/Linux and the 20070303 OpenSSH snapshot allows remote authenticated users to obtain access to arbitrary SELinux roles by appending a :/ (colon slash) sequence followed by the role name to the username.,CVE-2008-3234,tykio/gromit & tykio/tyk-plugin-compiler
openssh-client,LOW,1:8.4p1-5+deb11u4,,OpenSSH through 8.7 allows remote attackers who have a suspicion that a certain combination of username and public key is known to an SSH server to test whether this suspicion is correct. This occurs because a challenge is sent only when that combination could be valid for a login session. NOTE: the vendor does not recognize user enumeration as a vulnerability for this product,CVE-2016-20012,tykio/gromit & tykio/tyk-plugin-compiler
openssh-client,LOW,1:8.4p1-5+deb11u4,,Remotely observable behaviour in auth-gss2.c in OpenSSH through 7.8 could be used by remote attackers to detect existence of users on a target system when GSS2 is in use. NOTE: the discoverer states 'We understand that the OpenSSH developers do not want to treat such a username enumeration (or oracle) as a vulnerability.',CVE-2018-15919,tykio/gromit & tykio/tyk-plugin-compiler
openssh-client,LOW,1:8.4p1-5+deb11u4,,In OpenSSH 7.9 due to accepting and displaying arbitrary stderr output from the server a malicious server (or Man-in-The-Middle attacker) can manipulate the client output for example to use ANSI control codes to hide additional files being transferred.,CVE-2019-6110,tykio/gromit & tykio/tyk-plugin-compiler
openssh-client,LOW,1:8.4p1-5+deb11u4,,The client side in OpenSSH 5.7 through 8.4 has an Observable Discrepancy leading to an information leak in the algorithm negotiation. This allows man-in-the-middle attackers to target initial connection attempts (where no host key for the server has been cached by the client). NOTE: some reports state that 8.5 and 8.6 are also affected.,CVE-2020-14145,tykio/gromit & tykio/tyk-plugin-compiler
openssh-client,LOW,1:8.4p1-5+deb11u4,,scp in OpenSSH through 8.3p1 allows command injection in the scp.c toremote function as demonstrated by backtick characters in the destination argument. NOTE: the vendor reportedly has stated that they intentionally omit validation of anomalous argument transfers because that could stand a great chance of breaking existing workflows.,CVE-2020-15778,tykio/gromit & tykio/tyk-plugin-compiler
openssh-client,LOW,1:8.4p1-5+deb11u4,,An issue was discovered in OpenSSH before 8.9. If a client is using public-key authentication with agent forwarding but without -oLogLevel=verbose and an attacker has silently modified the server to support the None authentication option then the user cannot determine whether FIDO authentication is going to confirm that the user wishes to connect to that server or that the user wishes to allow that server to connect to a different server on the user's behalf. NOTE: the vendor's position is this is not an authentication bypass since nothing is being bypassed.,CVE-2021-36368,tykio/tyk-plugin-compiler
openssh-client,LOW,1:8.4p1-5+deb11u4,,OpenSSH through 9.6 when common types of DRAM are used might allow row hammer attacks (for authentication bypass) because the integer value of authenticated in mm_answer_authpassword does not resist flips of a single bit. NOTE: this is applicable to a certain threat model of attacker-victim co-location in which the attacker has user privileges.,CVE-2023-51767,tykio/gromit & tykio/tyk-plugin-compiler
openssh-client,MEDIUM,1:9.2p1-2+deb12u3,1:9.2p1-2+deb12u5,A vulnerability was found in OpenSSH when the VerifyHostKeyDNS option is enabled. A machine-in-the-middle attack can be performed by a malicious machine impersonating a legit server. This issue occurs due to how OpenSSH mishandles error codes in specific conditions when verifying the host key. For an attack to be considered successful the attacker needs to manage to exhaust the client's memory resource first turning the attack complexity high.,CVE-2025-26465,tykio/gromit
openssh-client,MEDIUM,1:8.4p1-5+deb11u4,1:8.4p1-5+deb11u5,In sshd in OpenSSH before 10.0 the DisableForwarding directive does not adhere to the documentation stating that it disables X11 and agent forwarding.,CVE-2025-32728,tykio/gromit & tykio/tyk-plugin-compiler
openssl,MEDIUM,1.1.1w-0+deb11u2,,Issue summary: A timing side-channel which could potentially allow recoveringnthe private key exists in the ECDSA signature computation.nnImpact summary: A timing side-channel in ECDSA signature computationsncould allow recovering the private key by an attacker. However measuringnthe timing would require either local access to the signing application orna very fast network connection with low latency.nnThere is a timing signal of around 300 nanoseconds when the top word ofnthe inverted ECDSA nonce value is zero. This can happen with significantnprobability only for some of the supported elliptic curves. In particularnthe NIST P-521 curve is affected. To be able to measure this leak the attackernprocess must either be located in the same physical computer or mustnhave a very fast network connection with low latency. For that reasonnthe severity of this vulnerability is Low.nnThe FIPS modules in 3.4 3.3 3.2 3.1 and 3.0 are affected by this issue.,CVE-2024-13176,tykio/gromit & tykio/tyk-plugin-compiler
passwd,LOW,1:4.8.1-1+deb11u1,,initscripts in rPath Linux 1 sets insecure permissions for the /var/log/btmp file which allows local users to obtain sensitive information regarding authentication attempts. NOTE: because sshd detects the insecure permissions and does not log certain events this also prevents sshd from logging failed authentication attempts by remote attackers.,CVE-2007-5686,tykio/gromit & tykio/tyk-plugin-compiler
passwd,LOW,1:4.8.1-1+deb11u1,,shadow: TOCTOU (time-of-check time-of-use) race condition when copying and removing directory trees,CVE-2013-4235,tykio/tyk-plugin-compiler
passwd,LOW,1:4.13+dfsg1-1+b1,,In Shadow 4.13 it is possible to inject control characters into fields provided to the SUID program chfn (change finger). Although it is not possible to exploit this directly (e.g. adding a new user fails because n is in the block list) it is possible to misrepresent the /etc/passwd file when viewed. Use of r manipulations and Unicode characters to work around blocking of the : character make it possible to give the impression that a new user has been added. In other words an adversary may be able to convince a system administrator to take the system offline (an indirect social-engineered denial of service) by demonstrating that cat /etc/passwd shows a rogue user account.,CVE-2023-29383,tykio/gromit
passwd,MEDIUM,1:4.13+dfsg1-1+b1,,A flaw was found in shadow-utils. When asking for a new password shadow-utils asks the password twice. If the password fails on the second attempt shadow-utils fails in cleaning the buffer used to store the first entry. This may allow an attacker with enough access to retrieve the password from the memory.,CVE-2023-4641,tykio/gromit
passwd,LOW,1:4.8.1-1+deb11u1,,shadow-utils (aka shadow) 4.4 through 4.17.0 establishes a default /etc/subuid behavior (e.g. uid 100000 through 165535 for the first user account) that can realistically conflict with the uids of users defined on locally administered networks potentially leading to account takeover e.g. by leveraging newuidmap for access to an NFS home directory (or same-host resources in the case of remote logins by these local network users). NOTE: it may also be argued that system administrators should not have assigned uids within local networks that are within the range that can occur in /etc/subuid.,CVE-2024-56433,tykio/gromit & tykio/tyk-plugin-compiler
passwd,LOW,1:4.8.1-1+deb11u1,,null,TEMP-0628843-DBAD28,tykio/gromit & tykio/tyk-plugin-compiler
patch,LOW,2.7.6-7,,Directory traversal vulnerability in util.c in GNU patch 2.6.1 and earlier allows user-assisted remote attackers to create or overwrite arbitrary files via a filename that is specified with a .. (dot dot) or full pathname a related issue to CVE-2010-1679.,CVE-2010-4651,tykio/gromit & tykio/tyk-plugin-compiler
patch,LOW,2.7.6-7,,An issue was discovered in GNU patch through 2.7.6. There is a segmentation fault associated with a NULL pointer dereference leading to a denial of service in the intuit_diff_type function in pch.c aka a mangled rename issue.,CVE-2018-6951,tykio/gromit & tykio/tyk-plugin-compiler
patch,LOW,2.7.6-7,,A double free exists in the another_hunk function in pch.c in GNU patch through 2.7.6.,CVE-2018-6952,tykio/gromit & tykio/tyk-plugin-compiler
patch,LOW,2.7.6-7,,An Invalid Pointer vulnerability exists in GNU patch 2.7 via the another_hunk function which causes a Denial of Service.,CVE-2021-45261,tykio/gromit & tykio/tyk-plugin-compiler
perl,LOW,5.32.1-4+deb11u4,,_is_safe in the File::Temp module for Perl does not properly handle symlinks.,CVE-2011-4116,tykio/gromit & tykio/tyk-plugin-compiler
perl,HIGH,5.36.0-7+deb12u1,,CPAN.pm before 2.35 does not verify TLS certificates when downloading distributions over HTTPS.,CVE-2023-31484,tykio/gromit
perl,LOW,5.32.1-4+deb11u4,,HTTP::Tiny before 0.083 a Perl core module since 5.13.9 and available standalone on CPAN has an insecure default TLS configuration where users must opt in to verify certificates.,CVE-2023-31486,tykio/gromit & tykio/tyk-plugin-compiler
perl,HIGH,5.36.0-7+deb12u1,5.36.0-7+deb12u2,A heap buffer overflow vulnerability was discovered in Perl. nnRelease branches 5.34 5.36 5.38 and 5.40 are affected including development versions from 5.33.1 through 5.41.10.nnWhen there are non-ASCII bytes in the left-hand-side of the `tr` operator `S_do_trans_invmap` can overflow the destination pointer `d`.nn $ perl -e '$_ = x{FF} x 1000000; tr/xFF/x{100}/;' n Segmentation fault (core dumped)nnIt is believed that this vulnerability can enable Denial of Service and possibly Code Execution attacks on platforms that lack sufficient defenses.,CVE-2024-56406,tykio/gromit
perl-base,LOW,5.32.1-4+deb11u4,,_is_safe in the File::Temp module for Perl does not properly handle symlinks.,CVE-2011-4116,tykio/gromit & tykio/tyk-plugin-compiler
perl-base,HIGH,5.36.0-7+deb12u1,,CPAN.pm before 2.35 does not verify TLS certificates when downloading distributions over HTTPS.,CVE-2023-31484,tykio/gromit
perl-base,LOW,5.32.1-4+deb11u4,,HTTP::Tiny before 0.083 a Perl core module since 5.13.9 and available standalone on CPAN has an insecure default TLS configuration where users must opt in to verify certificates.,CVE-2023-31486,tykio/gromit & tykio/tyk-plugin-compiler
perl-base,HIGH,5.36.0-7+deb12u1,5.36.0-7+deb12u2,A heap buffer overflow vulnerability was discovered in Perl. nnRelease branches 5.34 5.36 5.38 and 5.40 are affected including development versions from 5.33.1 through 5.41.10.nnWhen there are non-ASCII bytes in the left-hand-side of the `tr` operator `S_do_trans_invmap` can overflow the destination pointer `d`.nn $ perl -e '$_ = x{FF} x 1000000; tr/xFF/x{100}/;' n Segmentation fault (core dumped)nnIt is believed that this vulnerability can enable Denial of Service and possibly Code Execution attacks on platforms that lack sufficient defenses.,CVE-2024-56406,tykio/gromit
perl-modules-5.32,LOW,5.32.1-4+deb11u4,,_is_safe in the File::Temp module for Perl does not properly handle symlinks.,CVE-2011-4116,tykio/tyk-plugin-compiler
perl-modules-5.32,LOW,5.32.1-4+deb11u4,,HTTP::Tiny before 0.083 a Perl core module since 5.13.9 and available standalone on CPAN has an insecure default TLS configuration where users must opt in to verify certificates.,CVE-2023-31486,tykio/tyk-plugin-compiler
perl-modules-5.36,LOW,5.36.0-7+deb12u1,,_is_safe in the File::Temp module for Perl does not properly handle symlinks.,CVE-2011-4116,tykio/gromit
perl-modules-5.36,HIGH,5.36.0-7+deb12u1,,CPAN.pm before 2.35 does not verify TLS certificates when downloading distributions over HTTPS.,CVE-2023-31484,tykio/gromit
perl-modules-5.36,LOW,5.36.0-7+deb12u1,,HTTP::Tiny before 0.083 a Perl core module since 5.13.9 and available standalone on CPAN has an insecure default TLS configuration where users must opt in to verify certificates.,CVE-2023-31486,tykio/gromit
perl-modules-5.36,HIGH,5.36.0-7+deb12u1,5.36.0-7+deb12u2,A heap buffer overflow vulnerability was discovered in Perl. nnRelease branches 5.34 5.36 5.38 and 5.40 are affected including development versions from 5.33.1 through 5.41.10.nnWhen there are non-ASCII bytes in the left-hand-side of the `tr` operator `S_do_trans_invmap` can overflow the destination pointer `d`.nn $ perl -e '$_ = x{FF} x 1000000; tr/xFF/x{100}/;' n Segmentation fault (core dumped)nnIt is believed that this vulnerability can enable Denial of Service and possibly Code Execution attacks on platforms that lack sufficient defenses.,CVE-2024-56406,tykio/gromit
procps,LOW,2:3.3.17-5,,Under some circumstances this weakness allows a user who has access to run the ps utility on a machine the ability to write almost unlimited amounts of unfiltered data into the process heap.,CVE-2023-4016,tykio/tyk-plugin-compiler
stdlib,MEDIUM,v1.23.3,1.22.11, 1.23.5, 1.24.0-rc.2,The HTTP client drops sensitive headers after following a cross-domain redirect. For example a request to a.com/ containing an Authorization header which is redirected to b.com/ will not send that header to b.com. In the event that the client received a subsequent same-domain redirect however the sensitive headers would be restored. For example a chain of redirects from a.com/ to b.com/1 and finally to b.com/2 would incorrectly send the Authorization header to b.com/2.,CVE-2024-45336,tykio/gromit
stdlib,MEDIUM,v1.23.3,1.22.11, 1.23.5, 1.24.0-rc.2,A certificate with a URI which has a IPv6 address with a zone ID may incorrectly satisfy a URI name constraint that applies to the certificate chain. Certificates containing URIs are not permitted in the web PKI so this only affects users of private PKIs which make use of URIs.,CVE-2024-45341,tykio/gromit
stdlib,MEDIUM,v1.23.3,1.22.12, 1.23.6, 1.24.0-rc.3,Due to the usage of a variable time instruction in the assembly implementation of an internal function a small number of bits of secret scalars are leaked on the ppc64le architecture. Due to the way this function is used we do not believe this leakage is enough to allow recovery of the private key when P-256 is used in any well known protocols.,CVE-2025-22866,tykio/gromit
stdlib,MEDIUM,v1.23.3,1.23.8, 1.24.2,The net/http package improperly accepts a bare LF as a line terminator in chunked data chunk-size lines. This can permit request smuggling if a net/http server is used in conjunction with a server that incorrectly accepts a bare LF as part of a chunk-ext.,CVE-2025-22871,tykio/gromit
sudo,LOW,1.9.5p2-3+deb11u1,,Sudo VISudo 1.6.8 and earlier allows local users to corrupt arbitrary files via a symlink attack on temporary files.,CVE-2005-1119,tykio/tyk-plugin-compiler
sudo,LOW,1.9.5p2-3+deb11u1,,Sudo 1.8.0 through 1.9.12 with the crypt() password backend contains a plugins/sudoers/auth/passwd.c array-out-of-bounds error that can result in a heap-based buffer over-read. This can be triggered by arbitrary local users with access to Sudo by entering a password of seven characters or fewer. The impact could vary depending on the system libraries compiler and processor architecture.,CVE-2022-43995,tykio/tyk-plugin-compiler
sudo,MEDIUM,1.9.5p2-3+deb11u1,,Sudo before 1.9.13 does not escape control characters in log messages.,CVE-2023-28486,tykio/tyk-plugin-compiler
sudo,MEDIUM,1.9.5p2-3+deb11u1,,Sudo before 1.9.13 does not escape control characters in sudoreplay output.,CVE-2023-28487,tykio/tyk-plugin-compiler
sudo,HIGH,1.9.5p2-3+deb11u1,,Sudo before 1.9.15 might allow row hammer attacks (for authentication bypass or privilege escalation) because application logic sometimes is based on not equaling an error value (instead of equaling a success value) and because the values do not resist flips of a single bit.,CVE-2023-42465,tykio/tyk-plugin-compiler
sysvinit-utils,LOW,2.96-7+deb11u1,,null,TEMP-0517018-A83CE6,tykio/gromit & tykio/tyk-plugin-compiler
tar,LOW,1.34+dfsg-1+deb11u1,,Tar 1.15.1 does not properly warn the user when extracting setuid or setgid files which may allow local users or remote attackers to gain privileges.,CVE-2005-2541,tykio/gromit & tykio/tyk-plugin-compiler
tar,LOW,1.34+dfsg-1+deb11u1,,null,TEMP-0290435-0B57B5,tykio/gromit & tykio/tyk-plugin-compiler
unzip,LOW,6.0-26+deb11u1,,A flaw was found in unzip. The vulnerability occurs due to improper handling of Unicode strings which can lead to a null pointer dereference. This flaw allows an attacker to input a specially crafted zip file leading to a crash or code execution.,CVE-2021-4217,tykio/tyk-plugin-compiler
util-linux,LOW,2.36.1-8+deb11u2,,A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an INPUTRC environment variable to get a path to the library config file. When the library cannot parse the specified file it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.,CVE-2022-0563,tykio/gromit & tykio/tyk-plugin-compiler
util-linux-extra,LOW,2.38.1-5+deb12u2,,A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an INPUTRC environment variable to get a path to the library config file. When the library cannot parse the specified file it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.,CVE-2022-0563,tykio/gromit
zlib1g,CRITICAL,1:1.2.11.dfsg-2+deb11u2,,MiniZip in zlib through 1.3 has an integer overflow and resultant heap-based buffer overflow in zipOpenNewFileInZip4_64 via a long filename comment or extra field. NOTE: MiniZip is not a supported part of the zlib product. NOTE: pyminizip through 0.2.6 is also vulnerable because it bundles an affected zlib version and exposes the applicable MiniZip code through its compress API.,CVE-2023-45853,tykio/gromit & tykio/tyk-plugin-compiler
zlib1g-dev,CRITICAL,1:1.2.11.dfsg-2+deb11u2,,MiniZip in zlib through 1.3 has an integer overflow and resultant heap-based buffer overflow in zipOpenNewFileInZip4_64 via a long filename comment or extra field. NOTE: MiniZip is not a supported part of the zlib product. NOTE: pyminizip through 0.2.6 is also vulnerable because it bundles an affected zlib version and exposes the applicable MiniZip code through its compress API.,CVE-2023-45853,tykio/tyk-plugin-compiler
